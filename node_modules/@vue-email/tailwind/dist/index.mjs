import { defineComponent as _6, h as _v } from "vue";
import { renderToString as S6 } from "vue/server-renderer";
const l2 = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((t) => t.charCodeAt(0))
), u2 = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((t) => t.charCodeAt(0))
);
var eh;
const w6 = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), m0 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (eh = String.fromCodePoint) !== null && eh !== void 0 ? eh : function(t) {
    let e = "";
    return t > 65535 && (t -= 65536, e += String.fromCharCode(t >>> 10 & 1023 | 55296), t = 56320 | t & 1023), e += String.fromCharCode(t), e;
  }
);
function x6(t) {
  var e;
  return t >= 55296 && t <= 57343 || t > 1114111 ? 65533 : (e = w6.get(t)) !== null && e !== void 0 ? e : t;
}
var Ln;
(function(t) {
  t[t.NUM = 35] = "NUM", t[t.SEMI = 59] = "SEMI", t[t.EQUALS = 61] = "EQUALS", t[t.ZERO = 48] = "ZERO", t[t.NINE = 57] = "NINE", t[t.LOWER_A = 97] = "LOWER_A", t[t.LOWER_F = 102] = "LOWER_F", t[t.LOWER_X = 120] = "LOWER_X", t[t.LOWER_Z = 122] = "LOWER_Z", t[t.UPPER_A = 65] = "UPPER_A", t[t.UPPER_F = 70] = "UPPER_F", t[t.UPPER_Z = 90] = "UPPER_Z";
})(Ln || (Ln = {}));
const T6 = 32;
var ba;
(function(t) {
  t[t.VALUE_LENGTH = 49152] = "VALUE_LENGTH", t[t.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", t[t.JUMP_TABLE = 127] = "JUMP_TABLE";
})(ba || (ba = {}));
function y0(t) {
  return t >= Ln.ZERO && t <= Ln.NINE;
}
function A6(t) {
  return t >= Ln.UPPER_A && t <= Ln.UPPER_F || t >= Ln.LOWER_A && t <= Ln.LOWER_F;
}
function P6(t) {
  return t >= Ln.UPPER_A && t <= Ln.UPPER_Z || t >= Ln.LOWER_A && t <= Ln.LOWER_Z || y0(t);
}
function C6(t) {
  return t === Ln.EQUALS || P6(t);
}
var Nn;
(function(t) {
  t[t.EntityStart = 0] = "EntityStart", t[t.NumericStart = 1] = "NumericStart", t[t.NumericDecimal = 2] = "NumericDecimal", t[t.NumericHex = 3] = "NumericHex", t[t.NamedEntity = 4] = "NamedEntity";
})(Nn || (Nn = {}));
var Ss;
(function(t) {
  t[t.Legacy = 0] = "Legacy", t[t.Strict = 1] = "Strict", t[t.Attribute = 2] = "Attribute";
})(Ss || (Ss = {}));
class c2 {
  constructor(e, r, a) {
    this.decodeTree = e, this.emitCodePoint = r, this.errors = a, this.state = Nn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Ss.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(e) {
    this.decodeMode = e, this.state = Nn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(e, r) {
    switch (this.state) {
      case Nn.EntityStart:
        return e.charCodeAt(r) === Ln.NUM ? (this.state = Nn.NumericStart, this.consumed += 1, this.stateNumericStart(e, r + 1)) : (this.state = Nn.NamedEntity, this.stateNamedEntity(e, r));
      case Nn.NumericStart:
        return this.stateNumericStart(e, r);
      case Nn.NumericDecimal:
        return this.stateNumericDecimal(e, r);
      case Nn.NumericHex:
        return this.stateNumericHex(e, r);
      case Nn.NamedEntity:
        return this.stateNamedEntity(e, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(e, r) {
    return r >= e.length ? -1 : (e.charCodeAt(r) | T6) === Ln.LOWER_X ? (this.state = Nn.NumericHex, this.consumed += 1, this.stateNumericHex(e, r + 1)) : (this.state = Nn.NumericDecimal, this.stateNumericDecimal(e, r));
  }
  addToNumericResult(e, r, a, l) {
    if (r !== a) {
      const d = a - r;
      this.result = this.result * Math.pow(l, d) + parseInt(e.substr(r, d), l), this.consumed += d;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(e, r) {
    const a = r;
    for (; r < e.length; ) {
      const l = e.charCodeAt(r);
      if (y0(l) || A6(l))
        r += 1;
      else
        return this.addToNumericResult(e, a, r, 16), this.emitNumericEntity(l, 3);
    }
    return this.addToNumericResult(e, a, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(e, r) {
    const a = r;
    for (; r < e.length; ) {
      const l = e.charCodeAt(r);
      if (y0(l))
        r += 1;
      else
        return this.addToNumericResult(e, a, r, 10), this.emitNumericEntity(l, 2);
    }
    return this.addToNumericResult(e, a, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(e, r) {
    var a;
    if (this.consumed <= r)
      return (a = this.errors) === null || a === void 0 || a.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (e === Ln.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Ss.Strict)
      return 0;
    return this.emitCodePoint(x6(this.result), this.consumed), this.errors && (e !== Ln.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(e, r) {
    const { decodeTree: a } = this;
    let l = a[this.treeIndex], d = (l & ba.VALUE_LENGTH) >> 14;
    for (; r < e.length; r++, this.excess++) {
      const h = e.charCodeAt(r);
      if (this.treeIndex = I6(a, l, this.treeIndex + Math.max(1, d), h), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Ss.Attribute && // We shouldn't have consumed any characters after the entity,
        (d === 0 || // And there should be no invalid characters.
        C6(h)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (l = a[this.treeIndex], d = (l & ba.VALUE_LENGTH) >> 14, d !== 0) {
        if (h === Ln.SEMI)
          return this.emitNamedEntityData(this.treeIndex, d, this.consumed + this.excess);
        this.decodeMode !== Ss.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var e;
    const { result: r, decodeTree: a } = this, l = (a[r] & ba.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, l, this.consumed), (e = this.errors) === null || e === void 0 || e.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(e, r, a) {
    const { decodeTree: l } = this;
    return this.emitCodePoint(r === 1 ? l[e] & ~ba.VALUE_LENGTH : l[e + 1], a), r === 3 && this.emitCodePoint(l[e + 2], a), a;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var e;
    switch (this.state) {
      case Nn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Ss.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case Nn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case Nn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case Nn.NumericStart:
        return (e = this.errors) === null || e === void 0 || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case Nn.EntityStart:
        return 0;
    }
  }
}
function f2(t) {
  let e = "";
  const r = new c2(t, (a) => e += m0(a));
  return function(l, d) {
    let h = 0, n = 0;
    for (; (n = l.indexOf("&", n)) >= 0; ) {
      e += l.slice(h, n), r.startEntity(d);
      const i = r.write(
        l,
        // Skip the "&"
        n + 1
      );
      if (i < 0) {
        h = n + r.end();
        break;
      }
      h = n + i, n = i === 0 ? h + 1 : h;
    }
    const u = e + l.slice(h);
    return e = "", u;
  };
}
function I6(t, e, r, a) {
  const l = (e & ba.BRANCH_LENGTH) >> 7, d = e & ba.JUMP_TABLE;
  if (l === 0)
    return d !== 0 && a === d ? r : -1;
  if (d) {
    const u = a - d;
    return u < 0 || u >= l ? -1 : t[r + u] - 1;
  }
  let h = r, n = h + l - 1;
  for (; h <= n; ) {
    const u = h + n >>> 1, i = t[u];
    if (i < a)
      h = u + 1;
    else if (i > a)
      n = u - 1;
    else
      return t[u + l];
  }
  return -1;
}
f2(l2);
f2(u2);
var Yt;
(function(t) {
  t[t.Tab = 9] = "Tab", t[t.NewLine = 10] = "NewLine", t[t.FormFeed = 12] = "FormFeed", t[t.CarriageReturn = 13] = "CarriageReturn", t[t.Space = 32] = "Space", t[t.ExclamationMark = 33] = "ExclamationMark", t[t.Number = 35] = "Number", t[t.Amp = 38] = "Amp", t[t.SingleQuote = 39] = "SingleQuote", t[t.DoubleQuote = 34] = "DoubleQuote", t[t.Dash = 45] = "Dash", t[t.Slash = 47] = "Slash", t[t.Zero = 48] = "Zero", t[t.Nine = 57] = "Nine", t[t.Semi = 59] = "Semi", t[t.Lt = 60] = "Lt", t[t.Eq = 61] = "Eq", t[t.Gt = 62] = "Gt", t[t.Questionmark = 63] = "Questionmark", t[t.UpperA = 65] = "UpperA", t[t.LowerA = 97] = "LowerA", t[t.UpperF = 70] = "UpperF", t[t.LowerF = 102] = "LowerF", t[t.UpperZ = 90] = "UpperZ", t[t.LowerZ = 122] = "LowerZ", t[t.LowerX = 120] = "LowerX", t[t.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(Yt || (Yt = {}));
var vt;
(function(t) {
  t[t.Text = 1] = "Text", t[t.BeforeTagName = 2] = "BeforeTagName", t[t.InTagName = 3] = "InTagName", t[t.InSelfClosingTag = 4] = "InSelfClosingTag", t[t.BeforeClosingTagName = 5] = "BeforeClosingTagName", t[t.InClosingTagName = 6] = "InClosingTagName", t[t.AfterClosingTagName = 7] = "AfterClosingTagName", t[t.BeforeAttributeName = 8] = "BeforeAttributeName", t[t.InAttributeName = 9] = "InAttributeName", t[t.AfterAttributeName = 10] = "AfterAttributeName", t[t.BeforeAttributeValue = 11] = "BeforeAttributeValue", t[t.InAttributeValueDq = 12] = "InAttributeValueDq", t[t.InAttributeValueSq = 13] = "InAttributeValueSq", t[t.InAttributeValueNq = 14] = "InAttributeValueNq", t[t.BeforeDeclaration = 15] = "BeforeDeclaration", t[t.InDeclaration = 16] = "InDeclaration", t[t.InProcessingInstruction = 17] = "InProcessingInstruction", t[t.BeforeComment = 18] = "BeforeComment", t[t.CDATASequence = 19] = "CDATASequence", t[t.InSpecialComment = 20] = "InSpecialComment", t[t.InCommentLike = 21] = "InCommentLike", t[t.BeforeSpecialS = 22] = "BeforeSpecialS", t[t.BeforeSpecialT = 23] = "BeforeSpecialT", t[t.SpecialStartSequence = 24] = "SpecialStartSequence", t[t.InSpecialTag = 25] = "InSpecialTag", t[t.InEntity = 26] = "InEntity";
})(vt || (vt = {}));
function Ys(t) {
  return t === Yt.Space || t === Yt.NewLine || t === Yt.Tab || t === Yt.FormFeed || t === Yt.CarriageReturn;
}
function Ic(t) {
  return t === Yt.Slash || t === Yt.Gt || Ys(t);
}
function O6(t) {
  return t >= Yt.LowerA && t <= Yt.LowerZ || t >= Yt.UpperA && t <= Yt.UpperZ;
}
var ws;
(function(t) {
  t[t.NoValue = 0] = "NoValue", t[t.Unquoted = 1] = "Unquoted", t[t.Single = 2] = "Single", t[t.Double = 3] = "Double";
})(ws || (ws = {}));
const Hn = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea`
};
class k6 {
  constructor({ xmlMode: e = !1, decodeEntities: r = !0 }, a) {
    this.cbs = a, this.state = vt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = vt.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = e, this.decodeEntities = r, this.entityDecoder = new c2(e ? u2 : l2, (l, d) => this.emitCodePoint(l, d));
  }
  reset() {
    this.state = vt.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = vt.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
  }
  write(e) {
    this.offset += this.buffer.length, this.buffer = e, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = !1;
  }
  resume() {
    this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(e) {
    e === Yt.Lt || !this.decodeEntities && this.fastForwardTo(Yt.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = vt.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && e === Yt.Amp && this.startEntity();
  }
  stateSpecialStartSequence(e) {
    const r = this.sequenceIndex === this.currentSequence.length;
    if (!(r ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Ic(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = !1;
    else if (!r) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = vt.InTagName, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === Yt.Gt || Ys(e)) {
        const r = this.index - this.currentSequence.length;
        if (this.sectionStart < r) {
          const a = this.index;
          this.index = r, this.cbs.ontext(this.sectionStart, r), this.index = a;
        }
        this.isSpecial = !1, this.sectionStart = r + 2, this.stateInClosingTagName(e);
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === Hn.TitleEnd ? this.decodeEntities && e === Yt.Amp && this.startEntity() : this.fastForwardTo(Yt.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === Yt.Lt);
  }
  stateCDATASequence(e) {
    e === Hn.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === Hn.Cdata.length && (this.state = vt.InCommentLike, this.currentSequence = Hn.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = vt.InDeclaration, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === e)
        return !0;
    return this.index = this.buffer.length + this.offset - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === Hn.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = vt.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(e) {
    return this.xmlMode ? !Ic(e) : O6(e);
  }
  startSpecial(e, r) {
    this.isSpecial = !0, this.currentSequence = e, this.sequenceIndex = r, this.state = vt.SpecialStartSequence;
  }
  stateBeforeTagName(e) {
    if (e === Yt.ExclamationMark)
      this.state = vt.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (e === Yt.Questionmark)
      this.state = vt.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(e)) {
      const r = e | 32;
      this.sectionStart = this.index, this.xmlMode ? this.state = vt.InTagName : r === Hn.ScriptEnd[2] ? this.state = vt.BeforeSpecialS : r === Hn.TitleEnd[2] ? this.state = vt.BeforeSpecialT : this.state = vt.InTagName;
    } else e === Yt.Slash ? this.state = vt.BeforeClosingTagName : (this.state = vt.Text, this.stateText(e));
  }
  stateInTagName(e) {
    Ic(e) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = vt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateBeforeClosingTagName(e) {
    Ys(e) || (e === Yt.Gt ? this.state = vt.Text : (this.state = this.isTagStartChar(e) ? vt.InClosingTagName : vt.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === Yt.Gt || Ys(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = vt.AfterClosingTagName, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    (e === Yt.Gt || this.fastForwardTo(Yt.Gt)) && (this.state = vt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(e) {
    e === Yt.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = vt.InSpecialTag, this.sequenceIndex = 0) : this.state = vt.Text, this.sectionStart = this.index + 1) : e === Yt.Slash ? this.state = vt.InSelfClosingTag : Ys(e) || (this.state = vt.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === Yt.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = vt.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : Ys(e) || (this.state = vt.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateInAttributeName(e) {
    (e === Yt.Eq || Ic(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = vt.AfterAttributeName, this.stateAfterAttributeName(e));
  }
  stateAfterAttributeName(e) {
    e === Yt.Eq ? this.state = vt.BeforeAttributeValue : e === Yt.Slash || e === Yt.Gt ? (this.cbs.onattribend(ws.NoValue, this.sectionStart), this.sectionStart = -1, this.state = vt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : Ys(e) || (this.cbs.onattribend(ws.NoValue, this.sectionStart), this.state = vt.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(e) {
    e === Yt.DoubleQuote ? (this.state = vt.InAttributeValueDq, this.sectionStart = this.index + 1) : e === Yt.SingleQuote ? (this.state = vt.InAttributeValueSq, this.sectionStart = this.index + 1) : Ys(e) || (this.sectionStart = this.index, this.state = vt.InAttributeValueNq, this.stateInAttributeValueNoQuotes(e));
  }
  handleInAttributeValue(e, r) {
    e === r || !this.decodeEntities && this.fastForwardTo(r) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(r === Yt.DoubleQuote ? ws.Double : ws.Single, this.index + 1), this.state = vt.BeforeAttributeName) : this.decodeEntities && e === Yt.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(e) {
    this.handleInAttributeValue(e, Yt.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(e) {
    this.handleInAttributeValue(e, Yt.SingleQuote);
  }
  stateInAttributeValueNoQuotes(e) {
    Ys(e) || e === Yt.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(ws.Unquoted, this.index), this.state = vt.BeforeAttributeName, this.stateBeforeAttributeName(e)) : this.decodeEntities && e === Yt.Amp && this.startEntity();
  }
  stateBeforeDeclaration(e) {
    e === Yt.OpeningSquareBracket ? (this.state = vt.CDATASequence, this.sequenceIndex = 0) : this.state = e === Yt.Dash ? vt.BeforeComment : vt.InDeclaration;
  }
  stateInDeclaration(e) {
    (e === Yt.Gt || this.fastForwardTo(Yt.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = vt.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === Yt.Gt || this.fastForwardTo(Yt.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = vt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === Yt.Dash ? (this.state = vt.InCommentLike, this.currentSequence = Hn.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = vt.InDeclaration;
  }
  stateInSpecialComment(e) {
    (e === Yt.Gt || this.fastForwardTo(Yt.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = vt.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    const r = e | 32;
    r === Hn.ScriptEnd[3] ? this.startSpecial(Hn.ScriptEnd, 4) : r === Hn.StyleEnd[3] ? this.startSpecial(Hn.StyleEnd, 4) : (this.state = vt.InTagName, this.stateInTagName(e));
  }
  stateBeforeSpecialT(e) {
    const r = e | 32;
    r === Hn.TitleEnd[3] ? this.startSpecial(Hn.TitleEnd, 4) : r === Hn.TextareaEnd[3] ? this.startSpecial(Hn.TextareaEnd, 4) : (this.state = vt.InTagName, this.stateInTagName(e));
  }
  startEntity() {
    this.baseState = this.state, this.state = vt.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? Ss.Strict : this.baseState === vt.Text || this.baseState === vt.InSpecialTag ? Ss.Legacy : Ss.Attribute);
  }
  stateInEntity() {
    const e = this.entityDecoder.write(this.buffer, this.index - this.offset);
    e >= 0 ? (this.state = this.baseState, e === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === vt.Text || this.state === vt.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === vt.InAttributeValueDq || this.state === vt.InAttributeValueSq || this.state === vt.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const e = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case vt.Text: {
          this.stateText(e);
          break;
        }
        case vt.SpecialStartSequence: {
          this.stateSpecialStartSequence(e);
          break;
        }
        case vt.InSpecialTag: {
          this.stateInSpecialTag(e);
          break;
        }
        case vt.CDATASequence: {
          this.stateCDATASequence(e);
          break;
        }
        case vt.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(e);
          break;
        }
        case vt.InAttributeName: {
          this.stateInAttributeName(e);
          break;
        }
        case vt.InCommentLike: {
          this.stateInCommentLike(e);
          break;
        }
        case vt.InSpecialComment: {
          this.stateInSpecialComment(e);
          break;
        }
        case vt.BeforeAttributeName: {
          this.stateBeforeAttributeName(e);
          break;
        }
        case vt.InTagName: {
          this.stateInTagName(e);
          break;
        }
        case vt.InClosingTagName: {
          this.stateInClosingTagName(e);
          break;
        }
        case vt.BeforeTagName: {
          this.stateBeforeTagName(e);
          break;
        }
        case vt.AfterAttributeName: {
          this.stateAfterAttributeName(e);
          break;
        }
        case vt.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(e);
          break;
        }
        case vt.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(e);
          break;
        }
        case vt.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(e);
          break;
        }
        case vt.AfterClosingTagName: {
          this.stateAfterClosingTagName(e);
          break;
        }
        case vt.BeforeSpecialS: {
          this.stateBeforeSpecialS(e);
          break;
        }
        case vt.BeforeSpecialT: {
          this.stateBeforeSpecialT(e);
          break;
        }
        case vt.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(e);
          break;
        }
        case vt.InSelfClosingTag: {
          this.stateInSelfClosingTag(e);
          break;
        }
        case vt.InDeclaration: {
          this.stateInDeclaration(e);
          break;
        }
        case vt.BeforeDeclaration: {
          this.stateBeforeDeclaration(e);
          break;
        }
        case vt.BeforeComment: {
          this.stateBeforeComment(e);
          break;
        }
        case vt.InProcessingInstruction: {
          this.stateInProcessingInstruction(e);
          break;
        }
        case vt.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === vt.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length + this.offset;
    this.sectionStart >= e || (this.state === vt.InCommentLike ? this.currentSequence === Hn.CdataEnd ? this.cbs.oncdata(this.sectionStart, e, 0) : this.cbs.oncomment(this.sectionStart, e, 0) : this.state === vt.InTagName || this.state === vt.BeforeAttributeName || this.state === vt.BeforeAttributeValue || this.state === vt.AfterAttributeName || this.state === vt.InAttributeName || this.state === vt.InAttributeValueSq || this.state === vt.InAttributeValueDq || this.state === vt.InAttributeValueNq || this.state === vt.InClosingTagName || this.cbs.ontext(this.sectionStart, e));
  }
  emitCodePoint(e, r) {
    this.baseState !== vt.Text && this.baseState !== vt.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.onattribentity(e)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + r, this.index = this.sectionStart - 1, this.cbs.ontextentity(e, this.sectionStart));
  }
}
const Io = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), Nr = /* @__PURE__ */ new Set(["p"]), Sv = /* @__PURE__ */ new Set(["thead", "tbody"]), wv = /* @__PURE__ */ new Set(["dd", "dt"]), xv = /* @__PURE__ */ new Set(["rt", "rp"]), D6 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", Nr],
  ["h1", Nr],
  ["h2", Nr],
  ["h3", Nr],
  ["h4", Nr],
  ["h5", Nr],
  ["h6", Nr],
  ["select", Io],
  ["input", Io],
  ["output", Io],
  ["button", Io],
  ["datalist", Io],
  ["textarea", Io],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", wv],
  ["dt", wv],
  ["address", Nr],
  ["article", Nr],
  ["aside", Nr],
  ["blockquote", Nr],
  ["details", Nr],
  ["div", Nr],
  ["dl", Nr],
  ["fieldset", Nr],
  ["figcaption", Nr],
  ["figure", Nr],
  ["footer", Nr],
  ["form", Nr],
  ["header", Nr],
  ["hr", Nr],
  ["main", Nr],
  ["nav", Nr],
  ["ol", Nr],
  ["pre", Nr],
  ["section", Nr],
  ["table", Nr],
  ["ul", Nr],
  ["rt", xv],
  ["rp", xv],
  ["tbody", Sv],
  ["tfoot", Sv]
]), N6 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), Tv = /* @__PURE__ */ new Set(["math", "svg"]), Av = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), R6 = /\s|\//;
let M6 = class {
  constructor(e, r = {}) {
    var a, l, d, h, n, u;
    this.options = r, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = e ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (a = r.lowerCaseTags) !== null && a !== void 0 ? a : this.htmlMode, this.lowerCaseAttributeNames = (l = r.lowerCaseAttributeNames) !== null && l !== void 0 ? l : this.htmlMode, this.recognizeSelfClosing = (d = r.recognizeSelfClosing) !== null && d !== void 0 ? d : !this.htmlMode, this.tokenizer = new ((h = r.Tokenizer) !== null && h !== void 0 ? h : k6)(this.options, this), this.foreignContext = [!this.htmlMode], (u = (n = this.cbs).onparserinit) === null || u === void 0 || u.call(n, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(e, r) {
    var a, l;
    const d = this.getSlice(e, r);
    this.endIndex = r - 1, (l = (a = this.cbs).ontext) === null || l === void 0 || l.call(a, d), this.startIndex = r;
  }
  /** @internal */
  ontextentity(e, r) {
    var a, l;
    this.endIndex = r - 1, (l = (a = this.cbs).ontext) === null || l === void 0 || l.call(a, m0(e)), this.startIndex = r;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(e) {
    return this.htmlMode && N6.has(e);
  }
  /** @internal */
  onopentagname(e, r) {
    this.endIndex = r;
    let a = this.getSlice(e, r);
    this.lowerCaseTagNames && (a = a.toLowerCase()), this.emitOpenTag(a);
  }
  emitOpenTag(e) {
    var r, a, l, d;
    this.openTagStart = this.startIndex, this.tagname = e;
    const h = this.htmlMode && D6.get(e);
    if (h)
      for (; this.stack.length > 0 && h.has(this.stack[0]); ) {
        const n = this.stack.shift();
        (a = (r = this.cbs).onclosetag) === null || a === void 0 || a.call(r, n, !0);
      }
    this.isVoidElement(e) || (this.stack.unshift(e), this.htmlMode && (Tv.has(e) ? this.foreignContext.unshift(!0) : Av.has(e) && this.foreignContext.unshift(!1))), (d = (l = this.cbs).onopentagname) === null || d === void 0 || d.call(l, e), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(e) {
    var r, a;
    this.startIndex = this.openTagStart, this.attribs && ((a = (r = this.cbs).onopentag) === null || a === void 0 || a.call(r, this.tagname, this.attribs, e), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
  }
  /** @internal */
  onopentagend(e) {
    this.endIndex = e, this.endOpenTag(!1), this.startIndex = e + 1;
  }
  /** @internal */
  onclosetag(e, r) {
    var a, l, d, h, n, u, i, c;
    this.endIndex = r;
    let f = this.getSlice(e, r);
    if (this.lowerCaseTagNames && (f = f.toLowerCase()), this.htmlMode && (Tv.has(f) || Av.has(f)) && this.foreignContext.shift(), this.isVoidElement(f))
      this.htmlMode && f === "br" && ((h = (d = this.cbs).onopentagname) === null || h === void 0 || h.call(d, "br"), (u = (n = this.cbs).onopentag) === null || u === void 0 || u.call(n, "br", {}, !0), (c = (i = this.cbs).onclosetag) === null || c === void 0 || c.call(i, "br", !1));
    else {
      const s = this.stack.indexOf(f);
      if (s !== -1)
        for (let o = 0; o <= s; o++) {
          const y = this.stack.shift();
          (l = (a = this.cbs).onclosetag) === null || l === void 0 || l.call(a, y, o !== s);
        }
      else this.htmlMode && f === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
    }
    this.startIndex = r + 1;
  }
  /** @internal */
  onselfclosingtag(e) {
    this.endIndex = e, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(!1), this.startIndex = e + 1) : this.onopentagend(e);
  }
  closeCurrentTag(e) {
    var r, a;
    const l = this.tagname;
    this.endOpenTag(e), this.stack[0] === l && ((a = (r = this.cbs).onclosetag) === null || a === void 0 || a.call(r, l, !e), this.stack.shift());
  }
  /** @internal */
  onattribname(e, r) {
    this.startIndex = e;
    const a = this.getSlice(e, r);
    this.attribname = this.lowerCaseAttributeNames ? a.toLowerCase() : a;
  }
  /** @internal */
  onattribdata(e, r) {
    this.attribvalue += this.getSlice(e, r);
  }
  /** @internal */
  onattribentity(e) {
    this.attribvalue += m0(e);
  }
  /** @internal */
  onattribend(e, r) {
    var a, l;
    this.endIndex = r, (l = (a = this.cbs).onattribute) === null || l === void 0 || l.call(a, this.attribname, this.attribvalue, e === ws.Double ? '"' : e === ws.Single ? "'" : e === ws.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(e) {
    const r = e.search(R6);
    let a = r < 0 ? e : e.substr(0, r);
    return this.lowerCaseTagNames && (a = a.toLowerCase()), a;
  }
  /** @internal */
  ondeclaration(e, r) {
    this.endIndex = r;
    const a = this.getSlice(e, r);
    if (this.cbs.onprocessinginstruction) {
      const l = this.getInstructionName(a);
      this.cbs.onprocessinginstruction(`!${l}`, `!${a}`);
    }
    this.startIndex = r + 1;
  }
  /** @internal */
  onprocessinginstruction(e, r) {
    this.endIndex = r;
    const a = this.getSlice(e, r);
    if (this.cbs.onprocessinginstruction) {
      const l = this.getInstructionName(a);
      this.cbs.onprocessinginstruction(`?${l}`, `?${a}`);
    }
    this.startIndex = r + 1;
  }
  /** @internal */
  oncomment(e, r, a) {
    var l, d, h, n;
    this.endIndex = r, (d = (l = this.cbs).oncomment) === null || d === void 0 || d.call(l, this.getSlice(e, r - a)), (n = (h = this.cbs).oncommentend) === null || n === void 0 || n.call(h), this.startIndex = r + 1;
  }
  /** @internal */
  oncdata(e, r, a) {
    var l, d, h, n, u, i, c, f, s, o;
    this.endIndex = r;
    const y = this.getSlice(e, r - a);
    !this.htmlMode || this.options.recognizeCDATA ? ((d = (l = this.cbs).oncdatastart) === null || d === void 0 || d.call(l), (n = (h = this.cbs).ontext) === null || n === void 0 || n.call(h, y), (i = (u = this.cbs).oncdataend) === null || i === void 0 || i.call(u)) : ((f = (c = this.cbs).oncomment) === null || f === void 0 || f.call(c, `[CDATA[${y}]]`), (o = (s = this.cbs).oncommentend) === null || o === void 0 || o.call(s)), this.startIndex = r + 1;
  }
  /** @internal */
  onend() {
    var e, r;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let a = 0; a < this.stack.length; a++)
        this.cbs.onclosetag(this.stack[a], !0);
    }
    (r = (e = this.cbs).onend) === null || r === void 0 || r.call(e);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var e, r, a, l;
    (r = (e = this.cbs).onreset) === null || r === void 0 || r.call(e), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (l = (a = this.cbs).onparserinit) === null || l === void 0 || l.call(a, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(e) {
    this.reset(), this.end(e);
  }
  getSlice(e, r) {
    for (; e - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let a = this.buffers[0].slice(e - this.bufferOffset, r - this.bufferOffset);
    for (; r - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), a += this.buffers[0].slice(0, r - this.bufferOffset);
    return a;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(e) {
    var r, a;
    if (this.ended) {
      (a = (r = this.cbs).onerror) === null || a === void 0 || a.call(r, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(e), this.tokenizer.running && (this.tokenizer.write(e), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(e) {
    var r, a;
    if (this.ended) {
      (a = (r = this.cbs).onerror) === null || a === void 0 || a.call(r, new Error(".end() after done!"));
      return;
    }
    e && this.write(e), this.ended = !0, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(e) {
    this.write(e);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(e) {
    this.end(e);
  }
};
var Pr;
(function(t) {
  t.Root = "root", t.Text = "text", t.Directive = "directive", t.Comment = "comment", t.Script = "script", t.Style = "style", t.Tag = "tag", t.CDATA = "cdata", t.Doctype = "doctype";
})(Pr || (Pr = {}));
function L6(t) {
  return t.type === Pr.Tag || t.type === Pr.Script || t.type === Pr.Style;
}
const j6 = Pr.Root, F6 = Pr.Text, B6 = Pr.Directive, $6 = Pr.Comment, U6 = Pr.Script, V6 = Pr.Style, W6 = Pr.Tag, q6 = Pr.CDATA, H6 = Pr.Doctype;
let d2 = class {
  constructor() {
    this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(e) {
    this.parent = e;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(e) {
    this.prev = e;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(e) {
    this.next = e;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(e = !1) {
    return b2(this, e);
  }
};
class yy extends d2 {
  /**
   * @param data The content of the data node
   */
  constructor(e) {
    super(), this.data = e;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(e) {
    this.data = e;
  }
}
class b0 extends yy {
  constructor() {
    super(...arguments), this.type = Pr.Text;
  }
  get nodeType() {
    return 3;
  }
}
let p2 = class extends yy {
  constructor() {
    super(...arguments), this.type = Pr.Comment;
  }
  get nodeType() {
    return 8;
  }
};
class h2 extends yy {
  constructor(e, r) {
    super(r), this.name = e, this.type = Pr.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class by extends d2 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(e) {
    super(), this.children = e;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var e;
    return (e = this.children[0]) !== null && e !== void 0 ? e : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(e) {
    this.children = e;
  }
}
class m2 extends by {
  constructor() {
    super(...arguments), this.type = Pr.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
let g0 = class extends by {
  constructor() {
    super(...arguments), this.type = Pr.Root;
  }
  get nodeType() {
    return 9;
  }
};
class y2 extends by {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(e, r, a = [], l = e === "script" ? Pr.Script : e === "style" ? Pr.Style : Pr.Tag) {
    super(a), this.name = e, this.attribs = r, this.type = l;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(e) {
    this.name = e;
  }
  get attributes() {
    return Object.keys(this.attribs).map((e) => {
      var r, a;
      return {
        name: e,
        value: this.attribs[e],
        namespace: (r = this["x-attribsNamespace"]) === null || r === void 0 ? void 0 : r[e],
        prefix: (a = this["x-attribsPrefix"]) === null || a === void 0 ? void 0 : a[e]
      };
    });
  }
}
function gy(t) {
  return L6(t);
}
function G6(t) {
  return t.type === Pr.CDATA;
}
function z6(t) {
  return t.type === Pr.Text;
}
function K6(t) {
  return t.type === Pr.Comment;
}
function Y6(t) {
  return t.type === Pr.Directive;
}
function X6(t) {
  return t.type === Pr.Root;
}
function b2(t, e = !1) {
  let r;
  if (z6(t))
    r = new b0(t.data);
  else if (K6(t))
    r = new p2(t.data);
  else if (gy(t)) {
    const a = e ? th(t.children) : [], l = new y2(t.name, { ...t.attribs }, a);
    a.forEach((d) => d.parent = l), t.namespace != null && (l.namespace = t.namespace), t["x-attribsNamespace"] && (l["x-attribsNamespace"] = { ...t["x-attribsNamespace"] }), t["x-attribsPrefix"] && (l["x-attribsPrefix"] = { ...t["x-attribsPrefix"] }), r = l;
  } else if (G6(t)) {
    const a = e ? th(t.children) : [], l = new m2(a);
    a.forEach((d) => d.parent = l), r = l;
  } else if (X6(t)) {
    const a = e ? th(t.children) : [], l = new g0(a);
    a.forEach((d) => d.parent = l), t["x-mode"] && (l["x-mode"] = t["x-mode"]), r = l;
  } else if (Y6(t)) {
    const a = new h2(t.name, t.data);
    t["x-name"] != null && (a["x-name"] = t["x-name"], a["x-publicId"] = t["x-publicId"], a["x-systemId"] = t["x-systemId"]), r = a;
  } else
    throw new Error(`Not implemented yet: ${t.type}`);
  return r.startIndex = t.startIndex, r.endIndex = t.endIndex, t.sourceCodeLocation != null && (r.sourceCodeLocation = t.sourceCodeLocation), r;
}
function th(t) {
  const e = t.map((r) => b2(r, !0));
  for (let r = 1; r < e.length; r++)
    e[r].prev = e[r - 1], e[r - 1].next = e[r];
  return e;
}
const Pv = {
  withStartIndices: !1,
  withEndIndices: !1,
  xmlMode: !1
};
class J6 {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(e, r, a) {
    this.dom = [], this.root = new g0(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof r == "function" && (a = r, r = Pv), typeof e == "object" && (r = e, e = void 0), this.callback = e ?? null, this.options = r ?? Pv, this.elementCB = a ?? null;
  }
  onparserinit(e) {
    this.parser = e;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [], this.root = new g0(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
  }
  onerror(e) {
    this.handleCallback(e);
  }
  onclosetag() {
    this.lastNode = null;
    const e = this.tagStack.pop();
    this.options.withEndIndices && (e.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(e);
  }
  onopentag(e, r) {
    const a = this.options.xmlMode ? Pr.Tag : void 0, l = new y2(e, r, void 0, a);
    this.addNode(l), this.tagStack.push(l);
  }
  ontext(e) {
    const { lastNode: r } = this;
    if (r && r.type === Pr.Text)
      r.data += e, this.options.withEndIndices && (r.endIndex = this.parser.endIndex);
    else {
      const a = new b0(e);
      this.addNode(a), this.lastNode = a;
    }
  }
  oncomment(e) {
    if (this.lastNode && this.lastNode.type === Pr.Comment) {
      this.lastNode.data += e;
      return;
    }
    const r = new p2(e);
    this.addNode(r), this.lastNode = r;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const e = new b0(""), r = new m2([e]);
    this.addNode(r), e.parent = r, this.lastNode = e;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(e, r) {
    const a = new h2(e, r);
    this.addNode(a);
  }
  handleCallback(e) {
    if (typeof this.callback == "function")
      this.callback(e, this.dom);
    else if (e)
      throw e;
  }
  addNode(e) {
    const r = this.tagStack[this.tagStack.length - 1], a = r.children[r.children.length - 1];
    this.options.withStartIndices && (e.startIndex = this.parser.startIndex), this.options.withEndIndices && (e.endIndex = this.parser.endIndex), r.children.push(e), a && (e.prev = a, a.next = e), e.parent = r, this.lastNode = null;
  }
}
const Cv = /["&'<>$\x80-\uFFFF]/g, Q6 = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]), Z6 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (t, e) => t.codePointAt(e) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (t, e) => (t.charCodeAt(e) & 64512) === 55296 ? (t.charCodeAt(e) - 55296) * 1024 + t.charCodeAt(e + 1) - 56320 + 65536 : t.charCodeAt(e)
  )
);
function g2(t) {
  let e = "", r = 0, a;
  for (; (a = Cv.exec(t)) !== null; ) {
    const l = a.index, d = t.charCodeAt(l), h = Q6.get(d);
    h !== void 0 ? (e += t.substring(r, l) + h, r = l + 1) : (e += `${t.substring(r, l)}&#x${Z6(t, l).toString(16)};`, r = Cv.lastIndex += +((d & 64512) === 55296));
  }
  return e + t.substr(r);
}
function v2(t, e) {
  return function(a) {
    let l, d = 0, h = "";
    for (; l = t.exec(a); )
      d !== l.index && (h += a.substring(d, l.index)), h += e.get(l[0].charCodeAt(0)), d = l.index + 1;
    return h + a.substring(d);
  };
}
const e7 = v2(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
])), t7 = v2(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
])), r7 = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((t) => [t.toLowerCase(), t])), n7 = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((t) => [t.toLowerCase(), t])), i7 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function s7(t) {
  return t.replace(/"/g, "&quot;");
}
function a7(t, e) {
  var r;
  if (!t)
    return;
  const a = ((r = e.encodeEntities) !== null && r !== void 0 ? r : e.decodeEntities) === !1 ? s7 : e.xmlMode || e.encodeEntities !== "utf8" ? g2 : e7;
  return Object.keys(t).map((l) => {
    var d, h;
    const n = (d = t[l]) !== null && d !== void 0 ? d : "";
    return e.xmlMode === "foreign" && (l = (h = n7.get(l)) !== null && h !== void 0 ? h : l), !e.emptyAttrs && !e.xmlMode && n === "" ? l : `${l}="${a(n)}"`;
  }).join(" ");
}
const Iv = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function vy(t, e = {}) {
  const r = "length" in t ? t : [t];
  let a = "";
  for (let l = 0; l < r.length; l++)
    a += o7(r[l], e);
  return a;
}
function o7(t, e) {
  switch (t.type) {
    case j6:
      return vy(t.children, e);
    case H6:
    case B6:
      return f7(t);
    case $6:
      return h7(t);
    case q6:
      return p7(t);
    case U6:
    case V6:
    case W6:
      return c7(t, e);
    case F6:
      return d7(t, e);
  }
}
const l7 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]), u7 = /* @__PURE__ */ new Set(["svg", "math"]);
function c7(t, e) {
  var r;
  e.xmlMode === "foreign" && (t.name = (r = r7.get(t.name)) !== null && r !== void 0 ? r : t.name, t.parent && l7.has(t.parent.name) && (e = { ...e, xmlMode: !1 })), !e.xmlMode && u7.has(t.name) && (e = { ...e, xmlMode: "foreign" });
  let a = `<${t.name}`;
  const l = a7(t.attribs, e);
  return l && (a += ` ${l}`), t.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== !1
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && Iv.has(t.name)
  )) ? (e.xmlMode || (a += " "), a += "/>") : (a += ">", t.children.length > 0 && (a += vy(t.children, e)), (e.xmlMode || !Iv.has(t.name)) && (a += `</${t.name}>`)), a;
}
function f7(t) {
  return `<${t.data}>`;
}
function d7(t, e) {
  var r;
  let a = t.data || "";
  return ((r = e.encodeEntities) !== null && r !== void 0 ? r : e.decodeEntities) !== !1 && !(!e.xmlMode && t.parent && i7.has(t.parent.name)) && (a = e.xmlMode || e.encodeEntities !== "utf8" ? g2(a) : t7(a)), a;
}
function p7(t) {
  return `<![CDATA[${t.children[0].data}]]>`;
}
function h7(t) {
  return `<!--${t.data}-->`;
}
function m7(t) {
  if (t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.parent) {
    const e = t.parent.children, r = e.lastIndexOf(t);
    r >= 0 && e.splice(r, 1);
  }
  t.next = null, t.prev = null, t.parent = null;
}
function y7(t, e) {
  if (m7(e), e.next = null, e.parent = t, t.children.push(e) > 1) {
    const r = t.children[t.children.length - 2];
    r.next = e, e.prev = r;
  } else
    e.prev = null;
}
function E2(t, e, r = !0) {
  let a = null;
  for (let l = 0; l < e.length && !a; l++) {
    const d = e[l];
    if (gy(d))
      t(d) ? a = d : r && d.children.length > 0 && (a = E2(t, d.children, !0));
    else continue;
  }
  return a;
}
function b7(t, e) {
  const r = [], a = [e], l = [0];
  for (; ; ) {
    if (l[0] >= a[0].length) {
      if (a.length === 1)
        return r;
      a.shift(), l.shift();
      continue;
    }
    const d = a[0][l[0]++];
    gy(d) && (t(d) && r.push(d), d.children.length > 0 && (l.unshift(0), a.unshift(d.children)));
  }
}
function g7(t) {
  return t.replace(/\/\*[\s\S]*?\*\//g, "").replace(/;\s+/g, ";").replace(/:\s+/g, ":").replace(/\)\s*\{/g, "){").replace(/\s+\(/g, "(").replace(/\{\s+/g, "{").replace(/\}\s+/g, "}").replace(/\s*\{/g, "{").replace(/;?\s*\}/g, "}");
}
function v7(t) {
  const e = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/g;
  return t.replaceAll(e, (r, a, l, d, h) => {
    const n = h === "1" || typeof h > "u" ? "" : `,${h}`;
    return `rgb(${a},${l},${d}${n})`;
  });
}
const E7 = globalThis || void 0 || self;
var jt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function vd(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function a() {
      return this instanceof a ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(a) {
    var l = Object.getOwnPropertyDescriptor(t, a);
    Object.defineProperty(r, a, l.get ? l : {
      enumerable: !0,
      get: function() {
        return t[a];
      }
    });
  }), r;
}
var _2 = {}, Ed = {};
Ed.byteLength = w7;
Ed.toByteArray = T7;
Ed.fromByteArray = C7;
var xs = [], Oi = [], _7 = typeof Uint8Array < "u" ? Uint8Array : Array, rh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Oo = 0, S7 = rh.length; Oo < S7; ++Oo)
  xs[Oo] = rh[Oo], Oi[rh.charCodeAt(Oo)] = Oo;
Oi[45] = 62;
Oi[95] = 63;
function S2(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var a = r === e ? 0 : 4 - r % 4;
  return [r, a];
}
function w7(t) {
  var e = S2(t), r = e[0], a = e[1];
  return (r + a) * 3 / 4 - a;
}
function x7(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function T7(t) {
  var e, r = S2(t), a = r[0], l = r[1], d = new _7(x7(t, a, l)), h = 0, n = l > 0 ? a - 4 : a, u;
  for (u = 0; u < n; u += 4)
    e = Oi[t.charCodeAt(u)] << 18 | Oi[t.charCodeAt(u + 1)] << 12 | Oi[t.charCodeAt(u + 2)] << 6 | Oi[t.charCodeAt(u + 3)], d[h++] = e >> 16 & 255, d[h++] = e >> 8 & 255, d[h++] = e & 255;
  return l === 2 && (e = Oi[t.charCodeAt(u)] << 2 | Oi[t.charCodeAt(u + 1)] >> 4, d[h++] = e & 255), l === 1 && (e = Oi[t.charCodeAt(u)] << 10 | Oi[t.charCodeAt(u + 1)] << 4 | Oi[t.charCodeAt(u + 2)] >> 2, d[h++] = e >> 8 & 255, d[h++] = e & 255), d;
}
function A7(t) {
  return xs[t >> 18 & 63] + xs[t >> 12 & 63] + xs[t >> 6 & 63] + xs[t & 63];
}
function P7(t, e, r) {
  for (var a, l = [], d = e; d < r; d += 3)
    a = (t[d] << 16 & 16711680) + (t[d + 1] << 8 & 65280) + (t[d + 2] & 255), l.push(A7(a));
  return l.join("");
}
function C7(t) {
  for (var e, r = t.length, a = r % 3, l = [], d = 16383, h = 0, n = r - a; h < n; h += d)
    l.push(P7(t, h, h + d > n ? n : h + d));
  return a === 1 ? (e = t[r - 1], l.push(
    xs[e >> 2] + xs[e << 4 & 63] + "=="
  )) : a === 2 && (e = (t[r - 2] << 8) + t[r - 1], l.push(
    xs[e >> 10] + xs[e >> 4 & 63] + xs[e << 2 & 63] + "="
  )), l.join("");
}
var Ey = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Ey.read = function(t, e, r, a, l) {
  var d, h, n = l * 8 - a - 1, u = (1 << n) - 1, i = u >> 1, c = -7, f = r ? l - 1 : 0, s = r ? -1 : 1, o = t[e + f];
  for (f += s, d = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; d = d * 256 + t[e + f], f += s, c -= 8)
    ;
  for (h = d & (1 << -c) - 1, d >>= -c, c += a; c > 0; h = h * 256 + t[e + f], f += s, c -= 8)
    ;
  if (d === 0)
    d = 1 - i;
  else {
    if (d === u)
      return h ? NaN : (o ? -1 : 1) * (1 / 0);
    h = h + Math.pow(2, a), d = d - i;
  }
  return (o ? -1 : 1) * h * Math.pow(2, d - a);
};
Ey.write = function(t, e, r, a, l, d) {
  var h, n, u, i = d * 8 - l - 1, c = (1 << i) - 1, f = c >> 1, s = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, o = a ? 0 : d - 1, y = a ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (n = isNaN(e) ? 1 : 0, h = c) : (h = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -h)) < 1 && (h--, u *= 2), h + f >= 1 ? e += s / u : e += s * Math.pow(2, 1 - f), e * u >= 2 && (h++, u /= 2), h + f >= c ? (n = 0, h = c) : h + f >= 1 ? (n = (e * u - 1) * Math.pow(2, l), h = h + f) : (n = e * Math.pow(2, f - 1) * Math.pow(2, l), h = 0)); l >= 8; t[r + o] = n & 255, o += y, n /= 256, l -= 8)
    ;
  for (h = h << l | n, i += l; i > 0; t[r + o] = h & 255, o += y, h /= 256, i -= 8)
    ;
  t[r + o - y] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = Ed, r = Ey, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = c, t.SlowBuffer = O, t.INSPECT_MAX_BYTES = 50;
  const l = 2147483647;
  t.kMaxLength = l;
  const { Uint8Array: d, ArrayBuffer: h, SharedArrayBuffer: n } = globalThis;
  c.TYPED_ARRAY_SUPPORT = u(), !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function u() {
    try {
      const ue = new d(1), te = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(te, d.prototype), Object.setPrototypeOf(ue, te), ue.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(c.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (c.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(c.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (c.isBuffer(this))
        return this.byteOffset;
    }
  });
  function i(ue) {
    if (ue > l)
      throw new RangeError('The value "' + ue + '" is invalid for option "size"');
    const te = new d(ue);
    return Object.setPrototypeOf(te, c.prototype), te;
  }
  function c(ue, te, Y) {
    if (typeof ue == "number") {
      if (typeof te == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return y(ue);
    }
    return f(ue, te, Y);
  }
  c.poolSize = 8192;
  function f(ue, te, Y) {
    if (typeof ue == "string")
      return m(ue, te);
    if (h.isView(ue))
      return b(ue);
    if (ue == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ue
      );
    if (be(ue, h) || ue && be(ue.buffer, h) || typeof n < "u" && (be(ue, n) || ue && be(ue.buffer, n)))
      return v(ue, te, Y);
    if (typeof ue == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const le = ue.valueOf && ue.valueOf();
    if (le != null && le !== ue)
      return c.from(le, te, Y);
    const Ee = T(ue);
    if (Ee) return Ee;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ue[Symbol.toPrimitive] == "function")
      return c.from(ue[Symbol.toPrimitive]("string"), te, Y);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ue
    );
  }
  c.from = function(ue, te, Y) {
    return f(ue, te, Y);
  }, Object.setPrototypeOf(c.prototype, d.prototype), Object.setPrototypeOf(c, d);
  function s(ue) {
    if (typeof ue != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ue < 0)
      throw new RangeError('The value "' + ue + '" is invalid for option "size"');
  }
  function o(ue, te, Y) {
    return s(ue), ue <= 0 ? i(ue) : te !== void 0 ? typeof Y == "string" ? i(ue).fill(te, Y) : i(ue).fill(te) : i(ue);
  }
  c.alloc = function(ue, te, Y) {
    return o(ue, te, Y);
  };
  function y(ue) {
    return s(ue), i(ue < 0 ? 0 : E(ue) | 0);
  }
  c.allocUnsafe = function(ue) {
    return y(ue);
  }, c.allocUnsafeSlow = function(ue) {
    return y(ue);
  };
  function m(ue, te) {
    if ((typeof te != "string" || te === "") && (te = "utf8"), !c.isEncoding(te))
      throw new TypeError("Unknown encoding: " + te);
    const Y = D(ue, te) | 0;
    let le = i(Y);
    const Ee = le.write(ue, te);
    return Ee !== Y && (le = le.slice(0, Ee)), le;
  }
  function g(ue) {
    const te = ue.length < 0 ? 0 : E(ue.length) | 0, Y = i(te);
    for (let le = 0; le < te; le += 1)
      Y[le] = ue[le] & 255;
    return Y;
  }
  function b(ue) {
    if (be(ue, d)) {
      const te = new d(ue);
      return v(te.buffer, te.byteOffset, te.byteLength);
    }
    return g(ue);
  }
  function v(ue, te, Y) {
    if (te < 0 || ue.byteLength < te)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ue.byteLength < te + (Y || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let le;
    return te === void 0 && Y === void 0 ? le = new d(ue) : Y === void 0 ? le = new d(ue, te) : le = new d(ue, te, Y), Object.setPrototypeOf(le, c.prototype), le;
  }
  function T(ue) {
    if (c.isBuffer(ue)) {
      const te = E(ue.length) | 0, Y = i(te);
      return Y.length === 0 || ue.copy(Y, 0, 0, te), Y;
    }
    if (ue.length !== void 0)
      return typeof ue.length != "number" || Ie(ue.length) ? i(0) : g(ue);
    if (ue.type === "Buffer" && Array.isArray(ue.data))
      return g(ue.data);
  }
  function E(ue) {
    if (ue >= l)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l.toString(16) + " bytes");
    return ue | 0;
  }
  function O(ue) {
    return +ue != ue && (ue = 0), c.alloc(+ue);
  }
  c.isBuffer = function(te) {
    return te != null && te._isBuffer === !0 && te !== c.prototype;
  }, c.compare = function(te, Y) {
    if (be(te, d) && (te = c.from(te, te.offset, te.byteLength)), be(Y, d) && (Y = c.from(Y, Y.offset, Y.byteLength)), !c.isBuffer(te) || !c.isBuffer(Y))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (te === Y) return 0;
    let le = te.length, Ee = Y.length;
    for (let Se = 0, Pe = Math.min(le, Ee); Se < Pe; ++Se)
      if (te[Se] !== Y[Se]) {
        le = te[Se], Ee = Y[Se];
        break;
      }
    return le < Ee ? -1 : Ee < le ? 1 : 0;
  }, c.isEncoding = function(te) {
    switch (String(te).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, c.concat = function(te, Y) {
    if (!Array.isArray(te))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (te.length === 0)
      return c.alloc(0);
    let le;
    if (Y === void 0)
      for (Y = 0, le = 0; le < te.length; ++le)
        Y += te[le].length;
    const Ee = c.allocUnsafe(Y);
    let Se = 0;
    for (le = 0; le < te.length; ++le) {
      let Pe = te[le];
      if (be(Pe, d))
        Se + Pe.length > Ee.length ? (c.isBuffer(Pe) || (Pe = c.from(Pe)), Pe.copy(Ee, Se)) : d.prototype.set.call(
          Ee,
          Pe,
          Se
        );
      else if (c.isBuffer(Pe))
        Pe.copy(Ee, Se);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Se += Pe.length;
    }
    return Ee;
  };
  function D(ue, te) {
    if (c.isBuffer(ue))
      return ue.length;
    if (h.isView(ue) || be(ue, h))
      return ue.byteLength;
    if (typeof ue != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ue
      );
    const Y = ue.length, le = arguments.length > 2 && arguments[2] === !0;
    if (!le && Y === 0) return 0;
    let Ee = !1;
    for (; ; )
      switch (te) {
        case "ascii":
        case "latin1":
        case "binary":
          return Y;
        case "utf8":
        case "utf-8":
          return me(ue).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Y * 2;
        case "hex":
          return Y >>> 1;
        case "base64":
          return ge(ue).length;
        default:
          if (Ee)
            return le ? -1 : me(ue).length;
          te = ("" + te).toLowerCase(), Ee = !0;
      }
  }
  c.byteLength = D;
  function $(ue, te, Y) {
    let le = !1;
    if ((te === void 0 || te < 0) && (te = 0), te > this.length || ((Y === void 0 || Y > this.length) && (Y = this.length), Y <= 0) || (Y >>>= 0, te >>>= 0, Y <= te))
      return "";
    for (ue || (ue = "utf8"); ; )
      switch (ue) {
        case "hex":
          return B(this, te, Y);
        case "utf8":
        case "utf-8":
          return H(this, te, Y);
        case "ascii":
          return P(this, te, Y);
        case "latin1":
        case "binary":
          return W(this, te, Y);
        case "base64":
          return R(this, te, Y);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Q(this, te, Y);
        default:
          if (le) throw new TypeError("Unknown encoding: " + ue);
          ue = (ue + "").toLowerCase(), le = !0;
      }
  }
  c.prototype._isBuffer = !0;
  function I(ue, te, Y) {
    const le = ue[te];
    ue[te] = ue[Y], ue[Y] = le;
  }
  c.prototype.swap16 = function() {
    const te = this.length;
    if (te % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Y = 0; Y < te; Y += 2)
      I(this, Y, Y + 1);
    return this;
  }, c.prototype.swap32 = function() {
    const te = this.length;
    if (te % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Y = 0; Y < te; Y += 4)
      I(this, Y, Y + 3), I(this, Y + 1, Y + 2);
    return this;
  }, c.prototype.swap64 = function() {
    const te = this.length;
    if (te % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Y = 0; Y < te; Y += 8)
      I(this, Y, Y + 7), I(this, Y + 1, Y + 6), I(this, Y + 2, Y + 5), I(this, Y + 3, Y + 4);
    return this;
  }, c.prototype.toString = function() {
    const te = this.length;
    return te === 0 ? "" : arguments.length === 0 ? H(this, 0, te) : $.apply(this, arguments);
  }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(te) {
    if (!c.isBuffer(te)) throw new TypeError("Argument must be a Buffer");
    return this === te ? !0 : c.compare(this, te) === 0;
  }, c.prototype.inspect = function() {
    let te = "";
    const Y = t.INSPECT_MAX_BYTES;
    return te = this.toString("hex", 0, Y).replace(/(.{2})/g, "$1 ").trim(), this.length > Y && (te += " ... "), "<Buffer " + te + ">";
  }, a && (c.prototype[a] = c.prototype.inspect), c.prototype.compare = function(te, Y, le, Ee, Se) {
    if (be(te, d) && (te = c.from(te, te.offset, te.byteLength)), !c.isBuffer(te))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof te
      );
    if (Y === void 0 && (Y = 0), le === void 0 && (le = te ? te.length : 0), Ee === void 0 && (Ee = 0), Se === void 0 && (Se = this.length), Y < 0 || le > te.length || Ee < 0 || Se > this.length)
      throw new RangeError("out of range index");
    if (Ee >= Se && Y >= le)
      return 0;
    if (Ee >= Se)
      return -1;
    if (Y >= le)
      return 1;
    if (Y >>>= 0, le >>>= 0, Ee >>>= 0, Se >>>= 0, this === te) return 0;
    let Pe = Se - Ee, Ve = le - Y;
    const Xe = Math.min(Pe, Ve), Ye = this.slice(Ee, Se), We = te.slice(Y, le);
    for (let et = 0; et < Xe; ++et)
      if (Ye[et] !== We[et]) {
        Pe = Ye[et], Ve = We[et];
        break;
      }
    return Pe < Ve ? -1 : Ve < Pe ? 1 : 0;
  };
  function k(ue, te, Y, le, Ee) {
    if (ue.length === 0) return -1;
    if (typeof Y == "string" ? (le = Y, Y = 0) : Y > 2147483647 ? Y = 2147483647 : Y < -2147483648 && (Y = -2147483648), Y = +Y, Ie(Y) && (Y = Ee ? 0 : ue.length - 1), Y < 0 && (Y = ue.length + Y), Y >= ue.length) {
      if (Ee) return -1;
      Y = ue.length - 1;
    } else if (Y < 0)
      if (Ee) Y = 0;
      else return -1;
    if (typeof te == "string" && (te = c.from(te, le)), c.isBuffer(te))
      return te.length === 0 ? -1 : L(ue, te, Y, le, Ee);
    if (typeof te == "number")
      return te = te & 255, typeof d.prototype.indexOf == "function" ? Ee ? d.prototype.indexOf.call(ue, te, Y) : d.prototype.lastIndexOf.call(ue, te, Y) : L(ue, [te], Y, le, Ee);
    throw new TypeError("val must be string, number or Buffer");
  }
  function L(ue, te, Y, le, Ee) {
    let Se = 1, Pe = ue.length, Ve = te.length;
    if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
      if (ue.length < 2 || te.length < 2)
        return -1;
      Se = 2, Pe /= 2, Ve /= 2, Y /= 2;
    }
    function Xe(We, et) {
      return Se === 1 ? We[et] : We.readUInt16BE(et * Se);
    }
    let Ye;
    if (Ee) {
      let We = -1;
      for (Ye = Y; Ye < Pe; Ye++)
        if (Xe(ue, Ye) === Xe(te, We === -1 ? 0 : Ye - We)) {
          if (We === -1 && (We = Ye), Ye - We + 1 === Ve) return We * Se;
        } else
          We !== -1 && (Ye -= Ye - We), We = -1;
    } else
      for (Y + Ve > Pe && (Y = Pe - Ve), Ye = Y; Ye >= 0; Ye--) {
        let We = !0;
        for (let et = 0; et < Ve; et++)
          if (Xe(ue, Ye + et) !== Xe(te, et)) {
            We = !1;
            break;
          }
        if (We) return Ye;
      }
    return -1;
  }
  c.prototype.includes = function(te, Y, le) {
    return this.indexOf(te, Y, le) !== -1;
  }, c.prototype.indexOf = function(te, Y, le) {
    return k(this, te, Y, le, !0);
  }, c.prototype.lastIndexOf = function(te, Y, le) {
    return k(this, te, Y, le, !1);
  };
  function M(ue, te, Y, le) {
    Y = Number(Y) || 0;
    const Ee = ue.length - Y;
    le ? (le = Number(le), le > Ee && (le = Ee)) : le = Ee;
    const Se = te.length;
    le > Se / 2 && (le = Se / 2);
    let Pe;
    for (Pe = 0; Pe < le; ++Pe) {
      const Ve = parseInt(te.substr(Pe * 2, 2), 16);
      if (Ie(Ve)) return Pe;
      ue[Y + Pe] = Ve;
    }
    return Pe;
  }
  function x(ue, te, Y, le) {
    return se(me(te, ue.length - Y), ue, Y, le);
  }
  function _(ue, te, Y, le) {
    return se(ye(te), ue, Y, le);
  }
  function S(ue, te, Y, le) {
    return se(ge(te), ue, Y, le);
  }
  function C(ue, te, Y, le) {
    return se(we(te, ue.length - Y), ue, Y, le);
  }
  c.prototype.write = function(te, Y, le, Ee) {
    if (Y === void 0)
      Ee = "utf8", le = this.length, Y = 0;
    else if (le === void 0 && typeof Y == "string")
      Ee = Y, le = this.length, Y = 0;
    else if (isFinite(Y))
      Y = Y >>> 0, isFinite(le) ? (le = le >>> 0, Ee === void 0 && (Ee = "utf8")) : (Ee = le, le = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Se = this.length - Y;
    if ((le === void 0 || le > Se) && (le = Se), te.length > 0 && (le < 0 || Y < 0) || Y > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ee || (Ee = "utf8");
    let Pe = !1;
    for (; ; )
      switch (Ee) {
        case "hex":
          return M(this, te, Y, le);
        case "utf8":
        case "utf-8":
          return x(this, te, Y, le);
        case "ascii":
        case "latin1":
        case "binary":
          return _(this, te, Y, le);
        case "base64":
          return S(this, te, Y, le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return C(this, te, Y, le);
        default:
          if (Pe) throw new TypeError("Unknown encoding: " + Ee);
          Ee = ("" + Ee).toLowerCase(), Pe = !0;
      }
  }, c.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function R(ue, te, Y) {
    return te === 0 && Y === ue.length ? e.fromByteArray(ue) : e.fromByteArray(ue.slice(te, Y));
  }
  function H(ue, te, Y) {
    Y = Math.min(ue.length, Y);
    const le = [];
    let Ee = te;
    for (; Ee < Y; ) {
      const Se = ue[Ee];
      let Pe = null, Ve = Se > 239 ? 4 : Se > 223 ? 3 : Se > 191 ? 2 : 1;
      if (Ee + Ve <= Y) {
        let Xe, Ye, We, et;
        switch (Ve) {
          case 1:
            Se < 128 && (Pe = Se);
            break;
          case 2:
            Xe = ue[Ee + 1], (Xe & 192) === 128 && (et = (Se & 31) << 6 | Xe & 63, et > 127 && (Pe = et));
            break;
          case 3:
            Xe = ue[Ee + 1], Ye = ue[Ee + 2], (Xe & 192) === 128 && (Ye & 192) === 128 && (et = (Se & 15) << 12 | (Xe & 63) << 6 | Ye & 63, et > 2047 && (et < 55296 || et > 57343) && (Pe = et));
            break;
          case 4:
            Xe = ue[Ee + 1], Ye = ue[Ee + 2], We = ue[Ee + 3], (Xe & 192) === 128 && (Ye & 192) === 128 && (We & 192) === 128 && (et = (Se & 15) << 18 | (Xe & 63) << 12 | (Ye & 63) << 6 | We & 63, et > 65535 && et < 1114112 && (Pe = et));
        }
      }
      Pe === null ? (Pe = 65533, Ve = 1) : Pe > 65535 && (Pe -= 65536, le.push(Pe >>> 10 & 1023 | 55296), Pe = 56320 | Pe & 1023), le.push(Pe), Ee += Ve;
    }
    return U(le);
  }
  const z = 4096;
  function U(ue) {
    const te = ue.length;
    if (te <= z)
      return String.fromCharCode.apply(String, ue);
    let Y = "", le = 0;
    for (; le < te; )
      Y += String.fromCharCode.apply(
        String,
        ue.slice(le, le += z)
      );
    return Y;
  }
  function P(ue, te, Y) {
    let le = "";
    Y = Math.min(ue.length, Y);
    for (let Ee = te; Ee < Y; ++Ee)
      le += String.fromCharCode(ue[Ee] & 127);
    return le;
  }
  function W(ue, te, Y) {
    let le = "";
    Y = Math.min(ue.length, Y);
    for (let Ee = te; Ee < Y; ++Ee)
      le += String.fromCharCode(ue[Ee]);
    return le;
  }
  function B(ue, te, Y) {
    const le = ue.length;
    (!te || te < 0) && (te = 0), (!Y || Y < 0 || Y > le) && (Y = le);
    let Ee = "";
    for (let Se = te; Se < Y; ++Se)
      Ee += Oe[ue[Se]];
    return Ee;
  }
  function Q(ue, te, Y) {
    const le = ue.slice(te, Y);
    let Ee = "";
    for (let Se = 0; Se < le.length - 1; Se += 2)
      Ee += String.fromCharCode(le[Se] + le[Se + 1] * 256);
    return Ee;
  }
  c.prototype.slice = function(te, Y) {
    const le = this.length;
    te = ~~te, Y = Y === void 0 ? le : ~~Y, te < 0 ? (te += le, te < 0 && (te = 0)) : te > le && (te = le), Y < 0 ? (Y += le, Y < 0 && (Y = 0)) : Y > le && (Y = le), Y < te && (Y = te);
    const Ee = this.subarray(te, Y);
    return Object.setPrototypeOf(Ee, c.prototype), Ee;
  };
  function J(ue, te, Y) {
    if (ue % 1 !== 0 || ue < 0) throw new RangeError("offset is not uint");
    if (ue + te > Y) throw new RangeError("Trying to access beyond buffer length");
  }
  c.prototype.readUintLE = c.prototype.readUIntLE = function(te, Y, le) {
    te = te >>> 0, Y = Y >>> 0, le || J(te, Y, this.length);
    let Ee = this[te], Se = 1, Pe = 0;
    for (; ++Pe < Y && (Se *= 256); )
      Ee += this[te + Pe] * Se;
    return Ee;
  }, c.prototype.readUintBE = c.prototype.readUIntBE = function(te, Y, le) {
    te = te >>> 0, Y = Y >>> 0, le || J(te, Y, this.length);
    let Ee = this[te + --Y], Se = 1;
    for (; Y > 0 && (Se *= 256); )
      Ee += this[te + --Y] * Se;
    return Ee;
  }, c.prototype.readUint8 = c.prototype.readUInt8 = function(te, Y) {
    return te = te >>> 0, Y || J(te, 1, this.length), this[te];
  }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 2, this.length), this[te] | this[te + 1] << 8;
  }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 2, this.length), this[te] << 8 | this[te + 1];
  }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 4, this.length), (this[te] | this[te + 1] << 8 | this[te + 2] << 16) + this[te + 3] * 16777216;
  }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 4, this.length), this[te] * 16777216 + (this[te + 1] << 16 | this[te + 2] << 8 | this[te + 3]);
  }, c.prototype.readBigUInt64LE = Be(function(te) {
    te = te >>> 0, ce(te, "offset");
    const Y = this[te], le = this[te + 7];
    (Y === void 0 || le === void 0) && ee(te, this.length - 8);
    const Ee = Y + this[++te] * 2 ** 8 + this[++te] * 2 ** 16 + this[++te] * 2 ** 24, Se = this[++te] + this[++te] * 2 ** 8 + this[++te] * 2 ** 16 + le * 2 ** 24;
    return BigInt(Ee) + (BigInt(Se) << BigInt(32));
  }), c.prototype.readBigUInt64BE = Be(function(te) {
    te = te >>> 0, ce(te, "offset");
    const Y = this[te], le = this[te + 7];
    (Y === void 0 || le === void 0) && ee(te, this.length - 8);
    const Ee = Y * 2 ** 24 + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + this[++te], Se = this[++te] * 2 ** 24 + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + le;
    return (BigInt(Ee) << BigInt(32)) + BigInt(Se);
  }), c.prototype.readIntLE = function(te, Y, le) {
    te = te >>> 0, Y = Y >>> 0, le || J(te, Y, this.length);
    let Ee = this[te], Se = 1, Pe = 0;
    for (; ++Pe < Y && (Se *= 256); )
      Ee += this[te + Pe] * Se;
    return Se *= 128, Ee >= Se && (Ee -= Math.pow(2, 8 * Y)), Ee;
  }, c.prototype.readIntBE = function(te, Y, le) {
    te = te >>> 0, Y = Y >>> 0, le || J(te, Y, this.length);
    let Ee = Y, Se = 1, Pe = this[te + --Ee];
    for (; Ee > 0 && (Se *= 256); )
      Pe += this[te + --Ee] * Se;
    return Se *= 128, Pe >= Se && (Pe -= Math.pow(2, 8 * Y)), Pe;
  }, c.prototype.readInt8 = function(te, Y) {
    return te = te >>> 0, Y || J(te, 1, this.length), this[te] & 128 ? (255 - this[te] + 1) * -1 : this[te];
  }, c.prototype.readInt16LE = function(te, Y) {
    te = te >>> 0, Y || J(te, 2, this.length);
    const le = this[te] | this[te + 1] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, c.prototype.readInt16BE = function(te, Y) {
    te = te >>> 0, Y || J(te, 2, this.length);
    const le = this[te + 1] | this[te] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, c.prototype.readInt32LE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 4, this.length), this[te] | this[te + 1] << 8 | this[te + 2] << 16 | this[te + 3] << 24;
  }, c.prototype.readInt32BE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 4, this.length), this[te] << 24 | this[te + 1] << 16 | this[te + 2] << 8 | this[te + 3];
  }, c.prototype.readBigInt64LE = Be(function(te) {
    te = te >>> 0, ce(te, "offset");
    const Y = this[te], le = this[te + 7];
    (Y === void 0 || le === void 0) && ee(te, this.length - 8);
    const Ee = this[te + 4] + this[te + 5] * 2 ** 8 + this[te + 6] * 2 ** 16 + (le << 24);
    return (BigInt(Ee) << BigInt(32)) + BigInt(Y + this[++te] * 2 ** 8 + this[++te] * 2 ** 16 + this[++te] * 2 ** 24);
  }), c.prototype.readBigInt64BE = Be(function(te) {
    te = te >>> 0, ce(te, "offset");
    const Y = this[te], le = this[te + 7];
    (Y === void 0 || le === void 0) && ee(te, this.length - 8);
    const Ee = (Y << 24) + // Overflow
    this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + this[++te];
    return (BigInt(Ee) << BigInt(32)) + BigInt(this[++te] * 2 ** 24 + this[++te] * 2 ** 16 + this[++te] * 2 ** 8 + le);
  }), c.prototype.readFloatLE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 4, this.length), r.read(this, te, !0, 23, 4);
  }, c.prototype.readFloatBE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 4, this.length), r.read(this, te, !1, 23, 4);
  }, c.prototype.readDoubleLE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 8, this.length), r.read(this, te, !0, 52, 8);
  }, c.prototype.readDoubleBE = function(te, Y) {
    return te = te >>> 0, Y || J(te, 8, this.length), r.read(this, te, !1, 52, 8);
  };
  function re(ue, te, Y, le, Ee, Se) {
    if (!c.isBuffer(ue)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (te > Ee || te < Se) throw new RangeError('"value" argument is out of bounds');
    if (Y + le > ue.length) throw new RangeError("Index out of range");
  }
  c.prototype.writeUintLE = c.prototype.writeUIntLE = function(te, Y, le, Ee) {
    if (te = +te, Y = Y >>> 0, le = le >>> 0, !Ee) {
      const Ve = Math.pow(2, 8 * le) - 1;
      re(this, te, Y, le, Ve, 0);
    }
    let Se = 1, Pe = 0;
    for (this[Y] = te & 255; ++Pe < le && (Se *= 256); )
      this[Y + Pe] = te / Se & 255;
    return Y + le;
  }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function(te, Y, le, Ee) {
    if (te = +te, Y = Y >>> 0, le = le >>> 0, !Ee) {
      const Ve = Math.pow(2, 8 * le) - 1;
      re(this, te, Y, le, Ve, 0);
    }
    let Se = le - 1, Pe = 1;
    for (this[Y + Se] = te & 255; --Se >= 0 && (Pe *= 256); )
      this[Y + Se] = te / Pe & 255;
    return Y + le;
  }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 1, 255, 0), this[Y] = te & 255, Y + 1;
  }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 2, 65535, 0), this[Y] = te & 255, this[Y + 1] = te >>> 8, Y + 2;
  }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 2, 65535, 0), this[Y] = te >>> 8, this[Y + 1] = te & 255, Y + 2;
  }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 4, 4294967295, 0), this[Y + 3] = te >>> 24, this[Y + 2] = te >>> 16, this[Y + 1] = te >>> 8, this[Y] = te & 255, Y + 4;
  }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 4, 4294967295, 0), this[Y] = te >>> 24, this[Y + 1] = te >>> 16, this[Y + 2] = te >>> 8, this[Y + 3] = te & 255, Y + 4;
  };
  function G(ue, te, Y, le, Ee) {
    Ae(te, le, Ee, ue, Y, 7);
    let Se = Number(te & BigInt(4294967295));
    ue[Y++] = Se, Se = Se >> 8, ue[Y++] = Se, Se = Se >> 8, ue[Y++] = Se, Se = Se >> 8, ue[Y++] = Se;
    let Pe = Number(te >> BigInt(32) & BigInt(4294967295));
    return ue[Y++] = Pe, Pe = Pe >> 8, ue[Y++] = Pe, Pe = Pe >> 8, ue[Y++] = Pe, Pe = Pe >> 8, ue[Y++] = Pe, Y;
  }
  function N(ue, te, Y, le, Ee) {
    Ae(te, le, Ee, ue, Y, 7);
    let Se = Number(te & BigInt(4294967295));
    ue[Y + 7] = Se, Se = Se >> 8, ue[Y + 6] = Se, Se = Se >> 8, ue[Y + 5] = Se, Se = Se >> 8, ue[Y + 4] = Se;
    let Pe = Number(te >> BigInt(32) & BigInt(4294967295));
    return ue[Y + 3] = Pe, Pe = Pe >> 8, ue[Y + 2] = Pe, Pe = Pe >> 8, ue[Y + 1] = Pe, Pe = Pe >> 8, ue[Y] = Pe, Y + 8;
  }
  c.prototype.writeBigUInt64LE = Be(function(te, Y = 0) {
    return G(this, te, Y, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeBigUInt64BE = Be(function(te, Y = 0) {
    return N(this, te, Y, BigInt(0), BigInt("0xffffffffffffffff"));
  }), c.prototype.writeIntLE = function(te, Y, le, Ee) {
    if (te = +te, Y = Y >>> 0, !Ee) {
      const Xe = Math.pow(2, 8 * le - 1);
      re(this, te, Y, le, Xe - 1, -Xe);
    }
    let Se = 0, Pe = 1, Ve = 0;
    for (this[Y] = te & 255; ++Se < le && (Pe *= 256); )
      te < 0 && Ve === 0 && this[Y + Se - 1] !== 0 && (Ve = 1), this[Y + Se] = (te / Pe >> 0) - Ve & 255;
    return Y + le;
  }, c.prototype.writeIntBE = function(te, Y, le, Ee) {
    if (te = +te, Y = Y >>> 0, !Ee) {
      const Xe = Math.pow(2, 8 * le - 1);
      re(this, te, Y, le, Xe - 1, -Xe);
    }
    let Se = le - 1, Pe = 1, Ve = 0;
    for (this[Y + Se] = te & 255; --Se >= 0 && (Pe *= 256); )
      te < 0 && Ve === 0 && this[Y + Se + 1] !== 0 && (Ve = 1), this[Y + Se] = (te / Pe >> 0) - Ve & 255;
    return Y + le;
  }, c.prototype.writeInt8 = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 1, 127, -128), te < 0 && (te = 255 + te + 1), this[Y] = te & 255, Y + 1;
  }, c.prototype.writeInt16LE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 2, 32767, -32768), this[Y] = te & 255, this[Y + 1] = te >>> 8, Y + 2;
  }, c.prototype.writeInt16BE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 2, 32767, -32768), this[Y] = te >>> 8, this[Y + 1] = te & 255, Y + 2;
  }, c.prototype.writeInt32LE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 4, 2147483647, -2147483648), this[Y] = te & 255, this[Y + 1] = te >>> 8, this[Y + 2] = te >>> 16, this[Y + 3] = te >>> 24, Y + 4;
  }, c.prototype.writeInt32BE = function(te, Y, le) {
    return te = +te, Y = Y >>> 0, le || re(this, te, Y, 4, 2147483647, -2147483648), te < 0 && (te = 4294967295 + te + 1), this[Y] = te >>> 24, this[Y + 1] = te >>> 16, this[Y + 2] = te >>> 8, this[Y + 3] = te & 255, Y + 4;
  }, c.prototype.writeBigInt64LE = Be(function(te, Y = 0) {
    return G(this, te, Y, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), c.prototype.writeBigInt64BE = Be(function(te, Y = 0) {
    return N(this, te, Y, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function V(ue, te, Y, le, Ee, Se) {
    if (Y + le > ue.length) throw new RangeError("Index out of range");
    if (Y < 0) throw new RangeError("Index out of range");
  }
  function F(ue, te, Y, le, Ee) {
    return te = +te, Y = Y >>> 0, Ee || V(ue, te, Y, 4), r.write(ue, te, Y, le, 23, 4), Y + 4;
  }
  c.prototype.writeFloatLE = function(te, Y, le) {
    return F(this, te, Y, !0, le);
  }, c.prototype.writeFloatBE = function(te, Y, le) {
    return F(this, te, Y, !1, le);
  };
  function X(ue, te, Y, le, Ee) {
    return te = +te, Y = Y >>> 0, Ee || V(ue, te, Y, 8), r.write(ue, te, Y, le, 52, 8), Y + 8;
  }
  c.prototype.writeDoubleLE = function(te, Y, le) {
    return X(this, te, Y, !0, le);
  }, c.prototype.writeDoubleBE = function(te, Y, le) {
    return X(this, te, Y, !1, le);
  }, c.prototype.copy = function(te, Y, le, Ee) {
    if (!c.isBuffer(te)) throw new TypeError("argument should be a Buffer");
    if (le || (le = 0), !Ee && Ee !== 0 && (Ee = this.length), Y >= te.length && (Y = te.length), Y || (Y = 0), Ee > 0 && Ee < le && (Ee = le), Ee === le || te.length === 0 || this.length === 0) return 0;
    if (Y < 0)
      throw new RangeError("targetStart out of bounds");
    if (le < 0 || le >= this.length) throw new RangeError("Index out of range");
    if (Ee < 0) throw new RangeError("sourceEnd out of bounds");
    Ee > this.length && (Ee = this.length), te.length - Y < Ee - le && (Ee = te.length - Y + le);
    const Se = Ee - le;
    return this === te && typeof d.prototype.copyWithin == "function" ? this.copyWithin(Y, le, Ee) : d.prototype.set.call(
      te,
      this.subarray(le, Ee),
      Y
    ), Se;
  }, c.prototype.fill = function(te, Y, le, Ee) {
    if (typeof te == "string") {
      if (typeof Y == "string" ? (Ee = Y, Y = 0, le = this.length) : typeof le == "string" && (Ee = le, le = this.length), Ee !== void 0 && typeof Ee != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ee == "string" && !c.isEncoding(Ee))
        throw new TypeError("Unknown encoding: " + Ee);
      if (te.length === 1) {
        const Pe = te.charCodeAt(0);
        (Ee === "utf8" && Pe < 128 || Ee === "latin1") && (te = Pe);
      }
    } else typeof te == "number" ? te = te & 255 : typeof te == "boolean" && (te = Number(te));
    if (Y < 0 || this.length < Y || this.length < le)
      throw new RangeError("Out of range index");
    if (le <= Y)
      return this;
    Y = Y >>> 0, le = le === void 0 ? this.length : le >>> 0, te || (te = 0);
    let Se;
    if (typeof te == "number")
      for (Se = Y; Se < le; ++Se)
        this[Se] = te;
    else {
      const Pe = c.isBuffer(te) ? te : c.from(te, Ee), Ve = Pe.length;
      if (Ve === 0)
        throw new TypeError('The value "' + te + '" is invalid for argument "value"');
      for (Se = 0; Se < le - Y; ++Se)
        this[Se + Y] = Pe[Se % Ve];
    }
    return this;
  };
  const K = {};
  function ie(ue, te, Y) {
    K[ue] = class extends Y {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: te.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ue}]`, this.stack, delete this.name;
      }
      get code() {
        return ue;
      }
      set code(Ee) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ee,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ue}]: ${this.message}`;
      }
    };
  }
  ie(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ue) {
      return ue ? `${ue} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ie(
    "ERR_INVALID_ARG_TYPE",
    function(ue, te) {
      return `The "${ue}" argument must be of type number. Received type ${typeof te}`;
    },
    TypeError
  ), ie(
    "ERR_OUT_OF_RANGE",
    function(ue, te, Y) {
      let le = `The value of "${ue}" is out of range.`, Ee = Y;
      return Number.isInteger(Y) && Math.abs(Y) > 2 ** 32 ? Ee = fe(String(Y)) : typeof Y == "bigint" && (Ee = String(Y), (Y > BigInt(2) ** BigInt(32) || Y < -(BigInt(2) ** BigInt(32))) && (Ee = fe(Ee)), Ee += "n"), le += ` It must be ${te}. Received ${Ee}`, le;
    },
    RangeError
  );
  function fe(ue) {
    let te = "", Y = ue.length;
    const le = ue[0] === "-" ? 1 : 0;
    for (; Y >= le + 4; Y -= 3)
      te = `_${ue.slice(Y - 3, Y)}${te}`;
    return `${ue.slice(0, Y)}${te}`;
  }
  function _e(ue, te, Y) {
    ce(te, "offset"), (ue[te] === void 0 || ue[te + Y] === void 0) && ee(te, ue.length - (Y + 1));
  }
  function Ae(ue, te, Y, le, Ee, Se) {
    if (ue > Y || ue < te) {
      const Pe = typeof te == "bigint" ? "n" : "";
      let Ve;
      throw te === 0 || te === BigInt(0) ? Ve = `>= 0${Pe} and < 2${Pe} ** ${(Se + 1) * 8}${Pe}` : Ve = `>= -(2${Pe} ** ${(Se + 1) * 8 - 1}${Pe}) and < 2 ** ${(Se + 1) * 8 - 1}${Pe}`, new K.ERR_OUT_OF_RANGE("value", Ve, ue);
    }
    _e(le, Ee, Se);
  }
  function ce(ue, te) {
    if (typeof ue != "number")
      throw new K.ERR_INVALID_ARG_TYPE(te, "number", ue);
  }
  function ee(ue, te, Y) {
    throw Math.floor(ue) !== ue ? (ce(ue, Y), new K.ERR_OUT_OF_RANGE("offset", "an integer", ue)) : te < 0 ? new K.ERR_BUFFER_OUT_OF_BOUNDS() : new K.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${te}`,
      ue
    );
  }
  const ae = /[^+/0-9A-Za-z-_]/g;
  function oe(ue) {
    if (ue = ue.split("=")[0], ue = ue.trim().replace(ae, ""), ue.length < 2) return "";
    for (; ue.length % 4 !== 0; )
      ue = ue + "=";
    return ue;
  }
  function me(ue, te) {
    te = te || 1 / 0;
    let Y;
    const le = ue.length;
    let Ee = null;
    const Se = [];
    for (let Pe = 0; Pe < le; ++Pe) {
      if (Y = ue.charCodeAt(Pe), Y > 55295 && Y < 57344) {
        if (!Ee) {
          if (Y > 56319) {
            (te -= 3) > -1 && Se.push(239, 191, 189);
            continue;
          } else if (Pe + 1 === le) {
            (te -= 3) > -1 && Se.push(239, 191, 189);
            continue;
          }
          Ee = Y;
          continue;
        }
        if (Y < 56320) {
          (te -= 3) > -1 && Se.push(239, 191, 189), Ee = Y;
          continue;
        }
        Y = (Ee - 55296 << 10 | Y - 56320) + 65536;
      } else Ee && (te -= 3) > -1 && Se.push(239, 191, 189);
      if (Ee = null, Y < 128) {
        if ((te -= 1) < 0) break;
        Se.push(Y);
      } else if (Y < 2048) {
        if ((te -= 2) < 0) break;
        Se.push(
          Y >> 6 | 192,
          Y & 63 | 128
        );
      } else if (Y < 65536) {
        if ((te -= 3) < 0) break;
        Se.push(
          Y >> 12 | 224,
          Y >> 6 & 63 | 128,
          Y & 63 | 128
        );
      } else if (Y < 1114112) {
        if ((te -= 4) < 0) break;
        Se.push(
          Y >> 18 | 240,
          Y >> 12 & 63 | 128,
          Y >> 6 & 63 | 128,
          Y & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Se;
  }
  function ye(ue) {
    const te = [];
    for (let Y = 0; Y < ue.length; ++Y)
      te.push(ue.charCodeAt(Y) & 255);
    return te;
  }
  function we(ue, te) {
    let Y, le, Ee;
    const Se = [];
    for (let Pe = 0; Pe < ue.length && !((te -= 2) < 0); ++Pe)
      Y = ue.charCodeAt(Pe), le = Y >> 8, Ee = Y % 256, Se.push(Ee), Se.push(le);
    return Se;
  }
  function ge(ue) {
    return e.toByteArray(oe(ue));
  }
  function se(ue, te, Y, le) {
    let Ee;
    for (Ee = 0; Ee < le && !(Ee + Y >= te.length || Ee >= ue.length); ++Ee)
      te[Ee + Y] = ue[Ee];
    return Ee;
  }
  function be(ue, te) {
    return ue instanceof te || ue != null && ue.constructor != null && ue.constructor.name != null && ue.constructor.name === te.name;
  }
  function Ie(ue) {
    return ue !== ue;
  }
  const Oe = function() {
    const ue = "0123456789abcdef", te = new Array(256);
    for (let Y = 0; Y < 16; ++Y) {
      const le = Y * 16;
      for (let Ee = 0; Ee < 16; ++Ee)
        te[le + Ee] = ue[Y] + ue[Ee];
    }
    return te;
  }();
  function Be(ue) {
    return typeof BigInt > "u" ? Fe : ue;
  }
  function Fe() {
    throw new Error("BigInt not supported");
  }
})(_2);
const Gt = _2.Buffer;
function I7(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var w2 = { exports: {} }, fn = w2.exports = {}, gs, vs;
function v0() {
  throw new Error("setTimeout has not been defined");
}
function E0() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? gs = setTimeout : gs = v0;
  } catch {
    gs = v0;
  }
  try {
    typeof clearTimeout == "function" ? vs = clearTimeout : vs = E0;
  } catch {
    vs = E0;
  }
})();
function x2(t) {
  if (gs === setTimeout)
    return setTimeout(t, 0);
  if ((gs === v0 || !gs) && setTimeout)
    return gs = setTimeout, setTimeout(t, 0);
  try {
    return gs(t, 0);
  } catch {
    try {
      return gs.call(null, t, 0);
    } catch {
      return gs.call(this, t, 0);
    }
  }
}
function O7(t) {
  if (vs === clearTimeout)
    return clearTimeout(t);
  if ((vs === E0 || !vs) && clearTimeout)
    return vs = clearTimeout, clearTimeout(t);
  try {
    return vs(t);
  } catch {
    try {
      return vs.call(null, t);
    } catch {
      return vs.call(this, t);
    }
  }
}
var Qs = [], Ko = !1, Xa, df = -1;
function k7() {
  !Ko || !Xa || (Ko = !1, Xa.length ? Qs = Xa.concat(Qs) : df = -1, Qs.length && T2());
}
function T2() {
  if (!Ko) {
    var t = x2(k7);
    Ko = !0;
    for (var e = Qs.length; e; ) {
      for (Xa = Qs, Qs = []; ++df < e; )
        Xa && Xa[df].run();
      df = -1, e = Qs.length;
    }
    Xa = null, Ko = !1, O7(t);
  }
}
fn.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
  Qs.push(new A2(t, e)), Qs.length === 1 && !Ko && x2(T2);
};
function A2(t, e) {
  this.fun = t, this.array = e;
}
A2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
fn.title = "browser";
fn.browser = !0;
fn.env = {};
fn.argv = [];
fn.version = "";
fn.versions = {};
function la() {
}
fn.on = la;
fn.addListener = la;
fn.once = la;
fn.off = la;
fn.removeListener = la;
fn.removeAllListeners = la;
fn.emit = la;
fn.prependListener = la;
fn.prependOnceListener = la;
fn.listeners = function(t) {
  return [];
};
fn.binding = function(t) {
  throw new Error("process.binding is not supported");
};
fn.cwd = function() {
  return "/";
};
fn.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
fn.umask = function() {
  return 0;
};
var D7 = w2.exports;
const Ze = /* @__PURE__ */ I7(D7), N7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ze,
  process: Ze
}, Symbol.toStringTag, { value: "Module" }));
var _d = { exports: {} }, P2 = {}, _0 = { exports: {} }, fo = {}, Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.constants = void 0;
Us.constants = {
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_SYMLINK: 2097152,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  UV_FS_COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_EXCL: 1,
  COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE_FORCE: 4
};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.Stats = void 0;
const R7 = Us, { S_IFMT: M7, S_IFDIR: L7, S_IFREG: j7, S_IFBLK: F7, S_IFCHR: B7, S_IFLNK: $7, S_IFIFO: U7, S_IFSOCK: V7 } = R7.constants;
class Sd {
  static build(e, r = !1) {
    const a = new Sd(), { uid: l, gid: d, atime: h, mtime: n, ctime: u } = e, i = r ? (f) => BigInt(f) : (f) => f;
    a.uid = i(l), a.gid = i(d), a.rdev = i(0), a.blksize = i(4096), a.ino = i(e.ino), a.size = i(e.getSize()), a.blocks = i(1), a.atime = h, a.mtime = n, a.ctime = u, a.birthtime = u, a.atimeMs = i(h.getTime()), a.mtimeMs = i(n.getTime());
    const c = i(u.getTime());
    if (a.ctimeMs = c, a.birthtimeMs = c, r) {
      a.atimeNs = BigInt(h.getTime()) * BigInt(1e6), a.mtimeNs = BigInt(n.getTime()) * BigInt(1e6);
      const f = BigInt(u.getTime()) * BigInt(1e6);
      a.ctimeNs = f, a.birthtimeNs = f;
    }
    return a.dev = i(0), a.mode = i(e.mode), a.nlink = i(e.nlink), a;
  }
  _checkModeProperty(e) {
    return (Number(this.mode) & M7) === e;
  }
  isDirectory() {
    return this._checkModeProperty(L7);
  }
  isFile() {
    return this._checkModeProperty(j7);
  }
  isBlockDevice() {
    return this._checkModeProperty(F7);
  }
  isCharacterDevice() {
    return this._checkModeProperty(B7);
  }
  isSymbolicLink() {
    return this._checkModeProperty($7);
  }
  isFIFO() {
    return this._checkModeProperty(U7);
  }
  isSocket() {
    return this._checkModeProperty(V7);
  }
}
fo.Stats = Sd;
fo.default = Sd;
var Sl = {}, $u = {}, rl = {}, Ui = {}, wd = {};
wd.byteLength = H7;
wd.toByteArray = z7;
wd.fromByteArray = X7;
var Ts = [], ki = [], W7 = typeof Uint8Array < "u" ? Uint8Array : Array, nh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ko = 0, q7 = nh.length; ko < q7; ++ko)
  Ts[ko] = nh[ko], ki[nh.charCodeAt(ko)] = ko;
ki[45] = 62;
ki[95] = 63;
function C2(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var a = r === e ? 0 : 4 - r % 4;
  return [r, a];
}
function H7(t) {
  var e = C2(t), r = e[0], a = e[1];
  return (r + a) * 3 / 4 - a;
}
function G7(t, e, r) {
  return (e + r) * 3 / 4 - r;
}
function z7(t) {
  var e, r = C2(t), a = r[0], l = r[1], d = new W7(G7(t, a, l)), h = 0, n = l > 0 ? a - 4 : a, u;
  for (u = 0; u < n; u += 4)
    e = ki[t.charCodeAt(u)] << 18 | ki[t.charCodeAt(u + 1)] << 12 | ki[t.charCodeAt(u + 2)] << 6 | ki[t.charCodeAt(u + 3)], d[h++] = e >> 16 & 255, d[h++] = e >> 8 & 255, d[h++] = e & 255;
  return l === 2 && (e = ki[t.charCodeAt(u)] << 2 | ki[t.charCodeAt(u + 1)] >> 4, d[h++] = e & 255), l === 1 && (e = ki[t.charCodeAt(u)] << 10 | ki[t.charCodeAt(u + 1)] << 4 | ki[t.charCodeAt(u + 2)] >> 2, d[h++] = e >> 8 & 255, d[h++] = e & 255), d;
}
function K7(t) {
  return Ts[t >> 18 & 63] + Ts[t >> 12 & 63] + Ts[t >> 6 & 63] + Ts[t & 63];
}
function Y7(t, e, r) {
  for (var a, l = [], d = e; d < r; d += 3)
    a = (t[d] << 16 & 16711680) + (t[d + 1] << 8 & 65280) + (t[d + 2] & 255), l.push(K7(a));
  return l.join("");
}
function X7(t) {
  for (var e, r = t.length, a = r % 3, l = [], d = 16383, h = 0, n = r - a; h < n; h += d)
    l.push(Y7(t, h, h + d > n ? n : h + d));
  return a === 1 ? (e = t[r - 1], l.push(
    Ts[e >> 2] + Ts[e << 4 & 63] + "=="
  )) : a === 2 && (e = (t[r - 2] << 8) + t[r - 1], l.push(
    Ts[e >> 10] + Ts[e >> 4 & 63] + Ts[e << 2 & 63] + "="
  )), l.join("");
}
var _y = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
_y.read = function(t, e, r, a, l) {
  var d, h, n = l * 8 - a - 1, u = (1 << n) - 1, i = u >> 1, c = -7, f = r ? l - 1 : 0, s = r ? -1 : 1, o = t[e + f];
  for (f += s, d = o & (1 << -c) - 1, o >>= -c, c += n; c > 0; d = d * 256 + t[e + f], f += s, c -= 8)
    ;
  for (h = d & (1 << -c) - 1, d >>= -c, c += a; c > 0; h = h * 256 + t[e + f], f += s, c -= 8)
    ;
  if (d === 0)
    d = 1 - i;
  else {
    if (d === u)
      return h ? NaN : (o ? -1 : 1) * (1 / 0);
    h = h + Math.pow(2, a), d = d - i;
  }
  return (o ? -1 : 1) * h * Math.pow(2, d - a);
};
_y.write = function(t, e, r, a, l, d) {
  var h, n, u, i = d * 8 - l - 1, c = (1 << i) - 1, f = c >> 1, s = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, o = a ? 0 : d - 1, y = a ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (n = isNaN(e) ? 1 : 0, h = c) : (h = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -h)) < 1 && (h--, u *= 2), h + f >= 1 ? e += s / u : e += s * Math.pow(2, 1 - f), e * u >= 2 && (h++, u /= 2), h + f >= c ? (n = 0, h = c) : h + f >= 1 ? (n = (e * u - 1) * Math.pow(2, l), h = h + f) : (n = e * Math.pow(2, f - 1) * Math.pow(2, l), h = 0)); l >= 8; t[r + o] = n & 255, o += y, n /= 256, l -= 8)
    ;
  for (h = h << l | n, i += l; i > 0; t[r + o] = h & 255, o += y, h /= 256, i -= 8)
    ;
  t[r + o - y] |= m * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  var e = wd, r = _y, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = n, t.SlowBuffer = v, t.INSPECT_MAX_BYTES = 50;
  var l = 2147483647;
  t.kMaxLength = l, n.TYPED_ARRAY_SUPPORT = d(), !n.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      var ce = new Uint8Array(1), ee = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ee, Uint8Array.prototype), Object.setPrototypeOf(ce, ee), ce.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(n.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (n.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(n.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (n.isBuffer(this))
        return this.byteOffset;
    }
  });
  function h(ce) {
    if (ce > l)
      throw new RangeError('The value "' + ce + '" is invalid for option "size"');
    var ee = new Uint8Array(ce);
    return Object.setPrototypeOf(ee, n.prototype), ee;
  }
  function n(ce, ee, ae) {
    if (typeof ce == "number") {
      if (typeof ee == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return f(ce);
    }
    return u(ce, ee, ae);
  }
  n.poolSize = 8192;
  function u(ce, ee, ae) {
    if (typeof ce == "string")
      return s(ce, ee);
    if (ArrayBuffer.isView(ce))
      return y(ce);
    if (ce == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ce
      );
    if (fe(ce, ArrayBuffer) || ce && fe(ce.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (fe(ce, SharedArrayBuffer) || ce && fe(ce.buffer, SharedArrayBuffer)))
      return m(ce, ee, ae);
    if (typeof ce == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var oe = ce.valueOf && ce.valueOf();
    if (oe != null && oe !== ce)
      return n.from(oe, ee, ae);
    var me = g(ce);
    if (me) return me;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ce[Symbol.toPrimitive] == "function")
      return n.from(
        ce[Symbol.toPrimitive]("string"),
        ee,
        ae
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ce
    );
  }
  n.from = function(ce, ee, ae) {
    return u(ce, ee, ae);
  }, Object.setPrototypeOf(n.prototype, Uint8Array.prototype), Object.setPrototypeOf(n, Uint8Array);
  function i(ce) {
    if (typeof ce != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ce < 0)
      throw new RangeError('The value "' + ce + '" is invalid for option "size"');
  }
  function c(ce, ee, ae) {
    return i(ce), ce <= 0 ? h(ce) : ee !== void 0 ? typeof ae == "string" ? h(ce).fill(ee, ae) : h(ce).fill(ee) : h(ce);
  }
  n.alloc = function(ce, ee, ae) {
    return c(ce, ee, ae);
  };
  function f(ce) {
    return i(ce), h(ce < 0 ? 0 : b(ce) | 0);
  }
  n.allocUnsafe = function(ce) {
    return f(ce);
  }, n.allocUnsafeSlow = function(ce) {
    return f(ce);
  };
  function s(ce, ee) {
    if ((typeof ee != "string" || ee === "") && (ee = "utf8"), !n.isEncoding(ee))
      throw new TypeError("Unknown encoding: " + ee);
    var ae = T(ce, ee) | 0, oe = h(ae), me = oe.write(ce, ee);
    return me !== ae && (oe = oe.slice(0, me)), oe;
  }
  function o(ce) {
    for (var ee = ce.length < 0 ? 0 : b(ce.length) | 0, ae = h(ee), oe = 0; oe < ee; oe += 1)
      ae[oe] = ce[oe] & 255;
    return ae;
  }
  function y(ce) {
    if (fe(ce, Uint8Array)) {
      var ee = new Uint8Array(ce);
      return m(ee.buffer, ee.byteOffset, ee.byteLength);
    }
    return o(ce);
  }
  function m(ce, ee, ae) {
    if (ee < 0 || ce.byteLength < ee)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ce.byteLength < ee + (ae || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var oe;
    return ee === void 0 && ae === void 0 ? oe = new Uint8Array(ce) : ae === void 0 ? oe = new Uint8Array(ce, ee) : oe = new Uint8Array(ce, ee, ae), Object.setPrototypeOf(oe, n.prototype), oe;
  }
  function g(ce) {
    if (n.isBuffer(ce)) {
      var ee = b(ce.length) | 0, ae = h(ee);
      return ae.length === 0 || ce.copy(ae, 0, 0, ee), ae;
    }
    if (ce.length !== void 0)
      return typeof ce.length != "number" || _e(ce.length) ? h(0) : o(ce);
    if (ce.type === "Buffer" && Array.isArray(ce.data))
      return o(ce.data);
  }
  function b(ce) {
    if (ce >= l)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l.toString(16) + " bytes");
    return ce | 0;
  }
  function v(ce) {
    return +ce != ce && (ce = 0), n.alloc(+ce);
  }
  n.isBuffer = function(ee) {
    return ee != null && ee._isBuffer === !0 && ee !== n.prototype;
  }, n.compare = function(ee, ae) {
    if (fe(ee, Uint8Array) && (ee = n.from(ee, ee.offset, ee.byteLength)), fe(ae, Uint8Array) && (ae = n.from(ae, ae.offset, ae.byteLength)), !n.isBuffer(ee) || !n.isBuffer(ae))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ee === ae) return 0;
    for (var oe = ee.length, me = ae.length, ye = 0, we = Math.min(oe, me); ye < we; ++ye)
      if (ee[ye] !== ae[ye]) {
        oe = ee[ye], me = ae[ye];
        break;
      }
    return oe < me ? -1 : me < oe ? 1 : 0;
  }, n.isEncoding = function(ee) {
    switch (String(ee).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, n.concat = function(ee, ae) {
    if (!Array.isArray(ee))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ee.length === 0)
      return n.alloc(0);
    var oe;
    if (ae === void 0)
      for (ae = 0, oe = 0; oe < ee.length; ++oe)
        ae += ee[oe].length;
    var me = n.allocUnsafe(ae), ye = 0;
    for (oe = 0; oe < ee.length; ++oe) {
      var we = ee[oe];
      if (fe(we, Uint8Array))
        ye + we.length > me.length ? n.from(we).copy(me, ye) : Uint8Array.prototype.set.call(
          me,
          we,
          ye
        );
      else if (n.isBuffer(we))
        we.copy(me, ye);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ye += we.length;
    }
    return me;
  };
  function T(ce, ee) {
    if (n.isBuffer(ce))
      return ce.length;
    if (ArrayBuffer.isView(ce) || fe(ce, ArrayBuffer))
      return ce.byteLength;
    if (typeof ce != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ce
      );
    var ae = ce.length, oe = arguments.length > 2 && arguments[2] === !0;
    if (!oe && ae === 0) return 0;
    for (var me = !1; ; )
      switch (ee) {
        case "ascii":
        case "latin1":
        case "binary":
          return ae;
        case "utf8":
        case "utf-8":
          return V(ce).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ae * 2;
        case "hex":
          return ae >>> 1;
        case "base64":
          return K(ce).length;
        default:
          if (me)
            return oe ? -1 : V(ce).length;
          ee = ("" + ee).toLowerCase(), me = !0;
      }
  }
  n.byteLength = T;
  function E(ce, ee, ae) {
    var oe = !1;
    if ((ee === void 0 || ee < 0) && (ee = 0), ee > this.length || ((ae === void 0 || ae > this.length) && (ae = this.length), ae <= 0) || (ae >>>= 0, ee >>>= 0, ae <= ee))
      return "";
    for (ce || (ce = "utf8"); ; )
      switch (ce) {
        case "hex":
          return U(this, ee, ae);
        case "utf8":
        case "utf-8":
          return S(this, ee, ae);
        case "ascii":
          return H(this, ee, ae);
        case "latin1":
        case "binary":
          return z(this, ee, ae);
        case "base64":
          return _(this, ee, ae);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return P(this, ee, ae);
        default:
          if (oe) throw new TypeError("Unknown encoding: " + ce);
          ce = (ce + "").toLowerCase(), oe = !0;
      }
  }
  n.prototype._isBuffer = !0;
  function O(ce, ee, ae) {
    var oe = ce[ee];
    ce[ee] = ce[ae], ce[ae] = oe;
  }
  n.prototype.swap16 = function() {
    var ee = this.length;
    if (ee % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var ae = 0; ae < ee; ae += 2)
      O(this, ae, ae + 1);
    return this;
  }, n.prototype.swap32 = function() {
    var ee = this.length;
    if (ee % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var ae = 0; ae < ee; ae += 4)
      O(this, ae, ae + 3), O(this, ae + 1, ae + 2);
    return this;
  }, n.prototype.swap64 = function() {
    var ee = this.length;
    if (ee % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var ae = 0; ae < ee; ae += 8)
      O(this, ae, ae + 7), O(this, ae + 1, ae + 6), O(this, ae + 2, ae + 5), O(this, ae + 3, ae + 4);
    return this;
  }, n.prototype.toString = function() {
    var ee = this.length;
    return ee === 0 ? "" : arguments.length === 0 ? S(this, 0, ee) : E.apply(this, arguments);
  }, n.prototype.toLocaleString = n.prototype.toString, n.prototype.equals = function(ee) {
    if (!n.isBuffer(ee)) throw new TypeError("Argument must be a Buffer");
    return this === ee ? !0 : n.compare(this, ee) === 0;
  }, n.prototype.inspect = function() {
    var ee = "", ae = t.INSPECT_MAX_BYTES;
    return ee = this.toString("hex", 0, ae).replace(/(.{2})/g, "$1 ").trim(), this.length > ae && (ee += " ... "), "<Buffer " + ee + ">";
  }, a && (n.prototype[a] = n.prototype.inspect), n.prototype.compare = function(ee, ae, oe, me, ye) {
    if (fe(ee, Uint8Array) && (ee = n.from(ee, ee.offset, ee.byteLength)), !n.isBuffer(ee))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ee
      );
    if (ae === void 0 && (ae = 0), oe === void 0 && (oe = ee ? ee.length : 0), me === void 0 && (me = 0), ye === void 0 && (ye = this.length), ae < 0 || oe > ee.length || me < 0 || ye > this.length)
      throw new RangeError("out of range index");
    if (me >= ye && ae >= oe)
      return 0;
    if (me >= ye)
      return -1;
    if (ae >= oe)
      return 1;
    if (ae >>>= 0, oe >>>= 0, me >>>= 0, ye >>>= 0, this === ee) return 0;
    for (var we = ye - me, ge = oe - ae, se = Math.min(we, ge), be = this.slice(me, ye), Ie = ee.slice(ae, oe), Oe = 0; Oe < se; ++Oe)
      if (be[Oe] !== Ie[Oe]) {
        we = be[Oe], ge = Ie[Oe];
        break;
      }
    return we < ge ? -1 : ge < we ? 1 : 0;
  };
  function D(ce, ee, ae, oe, me) {
    if (ce.length === 0) return -1;
    if (typeof ae == "string" ? (oe = ae, ae = 0) : ae > 2147483647 ? ae = 2147483647 : ae < -2147483648 && (ae = -2147483648), ae = +ae, _e(ae) && (ae = me ? 0 : ce.length - 1), ae < 0 && (ae = ce.length + ae), ae >= ce.length) {
      if (me) return -1;
      ae = ce.length - 1;
    } else if (ae < 0)
      if (me) ae = 0;
      else return -1;
    if (typeof ee == "string" && (ee = n.from(ee, oe)), n.isBuffer(ee))
      return ee.length === 0 ? -1 : $(ce, ee, ae, oe, me);
    if (typeof ee == "number")
      return ee = ee & 255, typeof Uint8Array.prototype.indexOf == "function" ? me ? Uint8Array.prototype.indexOf.call(ce, ee, ae) : Uint8Array.prototype.lastIndexOf.call(ce, ee, ae) : $(ce, [ee], ae, oe, me);
    throw new TypeError("val must be string, number or Buffer");
  }
  function $(ce, ee, ae, oe, me) {
    var ye = 1, we = ce.length, ge = ee.length;
    if (oe !== void 0 && (oe = String(oe).toLowerCase(), oe === "ucs2" || oe === "ucs-2" || oe === "utf16le" || oe === "utf-16le")) {
      if (ce.length < 2 || ee.length < 2)
        return -1;
      ye = 2, we /= 2, ge /= 2, ae /= 2;
    }
    function se(Fe, ue) {
      return ye === 1 ? Fe[ue] : Fe.readUInt16BE(ue * ye);
    }
    var be;
    if (me) {
      var Ie = -1;
      for (be = ae; be < we; be++)
        if (se(ce, be) === se(ee, Ie === -1 ? 0 : be - Ie)) {
          if (Ie === -1 && (Ie = be), be - Ie + 1 === ge) return Ie * ye;
        } else
          Ie !== -1 && (be -= be - Ie), Ie = -1;
    } else
      for (ae + ge > we && (ae = we - ge), be = ae; be >= 0; be--) {
        for (var Oe = !0, Be = 0; Be < ge; Be++)
          if (se(ce, be + Be) !== se(ee, Be)) {
            Oe = !1;
            break;
          }
        if (Oe) return be;
      }
    return -1;
  }
  n.prototype.includes = function(ee, ae, oe) {
    return this.indexOf(ee, ae, oe) !== -1;
  }, n.prototype.indexOf = function(ee, ae, oe) {
    return D(this, ee, ae, oe, !0);
  }, n.prototype.lastIndexOf = function(ee, ae, oe) {
    return D(this, ee, ae, oe, !1);
  };
  function I(ce, ee, ae, oe) {
    ae = Number(ae) || 0;
    var me = ce.length - ae;
    oe ? (oe = Number(oe), oe > me && (oe = me)) : oe = me;
    var ye = ee.length;
    oe > ye / 2 && (oe = ye / 2);
    for (var we = 0; we < oe; ++we) {
      var ge = parseInt(ee.substr(we * 2, 2), 16);
      if (_e(ge)) return we;
      ce[ae + we] = ge;
    }
    return we;
  }
  function k(ce, ee, ae, oe) {
    return ie(V(ee, ce.length - ae), ce, ae, oe);
  }
  function L(ce, ee, ae, oe) {
    return ie(F(ee), ce, ae, oe);
  }
  function M(ce, ee, ae, oe) {
    return ie(K(ee), ce, ae, oe);
  }
  function x(ce, ee, ae, oe) {
    return ie(X(ee, ce.length - ae), ce, ae, oe);
  }
  n.prototype.write = function(ee, ae, oe, me) {
    if (ae === void 0)
      me = "utf8", oe = this.length, ae = 0;
    else if (oe === void 0 && typeof ae == "string")
      me = ae, oe = this.length, ae = 0;
    else if (isFinite(ae))
      ae = ae >>> 0, isFinite(oe) ? (oe = oe >>> 0, me === void 0 && (me = "utf8")) : (me = oe, oe = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var ye = this.length - ae;
    if ((oe === void 0 || oe > ye) && (oe = ye), ee.length > 0 && (oe < 0 || ae < 0) || ae > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    me || (me = "utf8");
    for (var we = !1; ; )
      switch (me) {
        case "hex":
          return I(this, ee, ae, oe);
        case "utf8":
        case "utf-8":
          return k(this, ee, ae, oe);
        case "ascii":
        case "latin1":
        case "binary":
          return L(this, ee, ae, oe);
        case "base64":
          return M(this, ee, ae, oe);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return x(this, ee, ae, oe);
        default:
          if (we) throw new TypeError("Unknown encoding: " + me);
          me = ("" + me).toLowerCase(), we = !0;
      }
  }, n.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function _(ce, ee, ae) {
    return ee === 0 && ae === ce.length ? e.fromByteArray(ce) : e.fromByteArray(ce.slice(ee, ae));
  }
  function S(ce, ee, ae) {
    ae = Math.min(ce.length, ae);
    for (var oe = [], me = ee; me < ae; ) {
      var ye = ce[me], we = null, ge = ye > 239 ? 4 : ye > 223 ? 3 : ye > 191 ? 2 : 1;
      if (me + ge <= ae) {
        var se, be, Ie, Oe;
        switch (ge) {
          case 1:
            ye < 128 && (we = ye);
            break;
          case 2:
            se = ce[me + 1], (se & 192) === 128 && (Oe = (ye & 31) << 6 | se & 63, Oe > 127 && (we = Oe));
            break;
          case 3:
            se = ce[me + 1], be = ce[me + 2], (se & 192) === 128 && (be & 192) === 128 && (Oe = (ye & 15) << 12 | (se & 63) << 6 | be & 63, Oe > 2047 && (Oe < 55296 || Oe > 57343) && (we = Oe));
            break;
          case 4:
            se = ce[me + 1], be = ce[me + 2], Ie = ce[me + 3], (se & 192) === 128 && (be & 192) === 128 && (Ie & 192) === 128 && (Oe = (ye & 15) << 18 | (se & 63) << 12 | (be & 63) << 6 | Ie & 63, Oe > 65535 && Oe < 1114112 && (we = Oe));
        }
      }
      we === null ? (we = 65533, ge = 1) : we > 65535 && (we -= 65536, oe.push(we >>> 10 & 1023 | 55296), we = 56320 | we & 1023), oe.push(we), me += ge;
    }
    return R(oe);
  }
  var C = 4096;
  function R(ce) {
    var ee = ce.length;
    if (ee <= C)
      return String.fromCharCode.apply(String, ce);
    for (var ae = "", oe = 0; oe < ee; )
      ae += String.fromCharCode.apply(
        String,
        ce.slice(oe, oe += C)
      );
    return ae;
  }
  function H(ce, ee, ae) {
    var oe = "";
    ae = Math.min(ce.length, ae);
    for (var me = ee; me < ae; ++me)
      oe += String.fromCharCode(ce[me] & 127);
    return oe;
  }
  function z(ce, ee, ae) {
    var oe = "";
    ae = Math.min(ce.length, ae);
    for (var me = ee; me < ae; ++me)
      oe += String.fromCharCode(ce[me]);
    return oe;
  }
  function U(ce, ee, ae) {
    var oe = ce.length;
    (!ee || ee < 0) && (ee = 0), (!ae || ae < 0 || ae > oe) && (ae = oe);
    for (var me = "", ye = ee; ye < ae; ++ye)
      me += Ae[ce[ye]];
    return me;
  }
  function P(ce, ee, ae) {
    for (var oe = ce.slice(ee, ae), me = "", ye = 0; ye < oe.length - 1; ye += 2)
      me += String.fromCharCode(oe[ye] + oe[ye + 1] * 256);
    return me;
  }
  n.prototype.slice = function(ee, ae) {
    var oe = this.length;
    ee = ~~ee, ae = ae === void 0 ? oe : ~~ae, ee < 0 ? (ee += oe, ee < 0 && (ee = 0)) : ee > oe && (ee = oe), ae < 0 ? (ae += oe, ae < 0 && (ae = 0)) : ae > oe && (ae = oe), ae < ee && (ae = ee);
    var me = this.subarray(ee, ae);
    return Object.setPrototypeOf(me, n.prototype), me;
  };
  function W(ce, ee, ae) {
    if (ce % 1 !== 0 || ce < 0) throw new RangeError("offset is not uint");
    if (ce + ee > ae) throw new RangeError("Trying to access beyond buffer length");
  }
  n.prototype.readUintLE = n.prototype.readUIntLE = function(ee, ae, oe) {
    ee = ee >>> 0, ae = ae >>> 0, oe || W(ee, ae, this.length);
    for (var me = this[ee], ye = 1, we = 0; ++we < ae && (ye *= 256); )
      me += this[ee + we] * ye;
    return me;
  }, n.prototype.readUintBE = n.prototype.readUIntBE = function(ee, ae, oe) {
    ee = ee >>> 0, ae = ae >>> 0, oe || W(ee, ae, this.length);
    for (var me = this[ee + --ae], ye = 1; ae > 0 && (ye *= 256); )
      me += this[ee + --ae] * ye;
    return me;
  }, n.prototype.readUint8 = n.prototype.readUInt8 = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 1, this.length), this[ee];
  }, n.prototype.readUint16LE = n.prototype.readUInt16LE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 2, this.length), this[ee] | this[ee + 1] << 8;
  }, n.prototype.readUint16BE = n.prototype.readUInt16BE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 2, this.length), this[ee] << 8 | this[ee + 1];
  }, n.prototype.readUint32LE = n.prototype.readUInt32LE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 4, this.length), (this[ee] | this[ee + 1] << 8 | this[ee + 2] << 16) + this[ee + 3] * 16777216;
  }, n.prototype.readUint32BE = n.prototype.readUInt32BE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 4, this.length), this[ee] * 16777216 + (this[ee + 1] << 16 | this[ee + 2] << 8 | this[ee + 3]);
  }, n.prototype.readIntLE = function(ee, ae, oe) {
    ee = ee >>> 0, ae = ae >>> 0, oe || W(ee, ae, this.length);
    for (var me = this[ee], ye = 1, we = 0; ++we < ae && (ye *= 256); )
      me += this[ee + we] * ye;
    return ye *= 128, me >= ye && (me -= Math.pow(2, 8 * ae)), me;
  }, n.prototype.readIntBE = function(ee, ae, oe) {
    ee = ee >>> 0, ae = ae >>> 0, oe || W(ee, ae, this.length);
    for (var me = ae, ye = 1, we = this[ee + --me]; me > 0 && (ye *= 256); )
      we += this[ee + --me] * ye;
    return ye *= 128, we >= ye && (we -= Math.pow(2, 8 * ae)), we;
  }, n.prototype.readInt8 = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 1, this.length), this[ee] & 128 ? (255 - this[ee] + 1) * -1 : this[ee];
  }, n.prototype.readInt16LE = function(ee, ae) {
    ee = ee >>> 0, ae || W(ee, 2, this.length);
    var oe = this[ee] | this[ee + 1] << 8;
    return oe & 32768 ? oe | 4294901760 : oe;
  }, n.prototype.readInt16BE = function(ee, ae) {
    ee = ee >>> 0, ae || W(ee, 2, this.length);
    var oe = this[ee + 1] | this[ee] << 8;
    return oe & 32768 ? oe | 4294901760 : oe;
  }, n.prototype.readInt32LE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 4, this.length), this[ee] | this[ee + 1] << 8 | this[ee + 2] << 16 | this[ee + 3] << 24;
  }, n.prototype.readInt32BE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 4, this.length), this[ee] << 24 | this[ee + 1] << 16 | this[ee + 2] << 8 | this[ee + 3];
  }, n.prototype.readFloatLE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 4, this.length), r.read(this, ee, !0, 23, 4);
  }, n.prototype.readFloatBE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 4, this.length), r.read(this, ee, !1, 23, 4);
  }, n.prototype.readDoubleLE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 8, this.length), r.read(this, ee, !0, 52, 8);
  }, n.prototype.readDoubleBE = function(ee, ae) {
    return ee = ee >>> 0, ae || W(ee, 8, this.length), r.read(this, ee, !1, 52, 8);
  };
  function B(ce, ee, ae, oe, me, ye) {
    if (!n.isBuffer(ce)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ee > me || ee < ye) throw new RangeError('"value" argument is out of bounds');
    if (ae + oe > ce.length) throw new RangeError("Index out of range");
  }
  n.prototype.writeUintLE = n.prototype.writeUIntLE = function(ee, ae, oe, me) {
    if (ee = +ee, ae = ae >>> 0, oe = oe >>> 0, !me) {
      var ye = Math.pow(2, 8 * oe) - 1;
      B(this, ee, ae, oe, ye, 0);
    }
    var we = 1, ge = 0;
    for (this[ae] = ee & 255; ++ge < oe && (we *= 256); )
      this[ae + ge] = ee / we & 255;
    return ae + oe;
  }, n.prototype.writeUintBE = n.prototype.writeUIntBE = function(ee, ae, oe, me) {
    if (ee = +ee, ae = ae >>> 0, oe = oe >>> 0, !me) {
      var ye = Math.pow(2, 8 * oe) - 1;
      B(this, ee, ae, oe, ye, 0);
    }
    var we = oe - 1, ge = 1;
    for (this[ae + we] = ee & 255; --we >= 0 && (ge *= 256); )
      this[ae + we] = ee / ge & 255;
    return ae + oe;
  }, n.prototype.writeUint8 = n.prototype.writeUInt8 = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 1, 255, 0), this[ae] = ee & 255, ae + 1;
  }, n.prototype.writeUint16LE = n.prototype.writeUInt16LE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 2, 65535, 0), this[ae] = ee & 255, this[ae + 1] = ee >>> 8, ae + 2;
  }, n.prototype.writeUint16BE = n.prototype.writeUInt16BE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 2, 65535, 0), this[ae] = ee >>> 8, this[ae + 1] = ee & 255, ae + 2;
  }, n.prototype.writeUint32LE = n.prototype.writeUInt32LE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 4, 4294967295, 0), this[ae + 3] = ee >>> 24, this[ae + 2] = ee >>> 16, this[ae + 1] = ee >>> 8, this[ae] = ee & 255, ae + 4;
  }, n.prototype.writeUint32BE = n.prototype.writeUInt32BE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 4, 4294967295, 0), this[ae] = ee >>> 24, this[ae + 1] = ee >>> 16, this[ae + 2] = ee >>> 8, this[ae + 3] = ee & 255, ae + 4;
  }, n.prototype.writeIntLE = function(ee, ae, oe, me) {
    if (ee = +ee, ae = ae >>> 0, !me) {
      var ye = Math.pow(2, 8 * oe - 1);
      B(this, ee, ae, oe, ye - 1, -ye);
    }
    var we = 0, ge = 1, se = 0;
    for (this[ae] = ee & 255; ++we < oe && (ge *= 256); )
      ee < 0 && se === 0 && this[ae + we - 1] !== 0 && (se = 1), this[ae + we] = (ee / ge >> 0) - se & 255;
    return ae + oe;
  }, n.prototype.writeIntBE = function(ee, ae, oe, me) {
    if (ee = +ee, ae = ae >>> 0, !me) {
      var ye = Math.pow(2, 8 * oe - 1);
      B(this, ee, ae, oe, ye - 1, -ye);
    }
    var we = oe - 1, ge = 1, se = 0;
    for (this[ae + we] = ee & 255; --we >= 0 && (ge *= 256); )
      ee < 0 && se === 0 && this[ae + we + 1] !== 0 && (se = 1), this[ae + we] = (ee / ge >> 0) - se & 255;
    return ae + oe;
  }, n.prototype.writeInt8 = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 1, 127, -128), ee < 0 && (ee = 255 + ee + 1), this[ae] = ee & 255, ae + 1;
  }, n.prototype.writeInt16LE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 2, 32767, -32768), this[ae] = ee & 255, this[ae + 1] = ee >>> 8, ae + 2;
  }, n.prototype.writeInt16BE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 2, 32767, -32768), this[ae] = ee >>> 8, this[ae + 1] = ee & 255, ae + 2;
  }, n.prototype.writeInt32LE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 4, 2147483647, -2147483648), this[ae] = ee & 255, this[ae + 1] = ee >>> 8, this[ae + 2] = ee >>> 16, this[ae + 3] = ee >>> 24, ae + 4;
  }, n.prototype.writeInt32BE = function(ee, ae, oe) {
    return ee = +ee, ae = ae >>> 0, oe || B(this, ee, ae, 4, 2147483647, -2147483648), ee < 0 && (ee = 4294967295 + ee + 1), this[ae] = ee >>> 24, this[ae + 1] = ee >>> 16, this[ae + 2] = ee >>> 8, this[ae + 3] = ee & 255, ae + 4;
  };
  function Q(ce, ee, ae, oe, me, ye) {
    if (ae + oe > ce.length) throw new RangeError("Index out of range");
    if (ae < 0) throw new RangeError("Index out of range");
  }
  function J(ce, ee, ae, oe, me) {
    return ee = +ee, ae = ae >>> 0, me || Q(ce, ee, ae, 4), r.write(ce, ee, ae, oe, 23, 4), ae + 4;
  }
  n.prototype.writeFloatLE = function(ee, ae, oe) {
    return J(this, ee, ae, !0, oe);
  }, n.prototype.writeFloatBE = function(ee, ae, oe) {
    return J(this, ee, ae, !1, oe);
  };
  function re(ce, ee, ae, oe, me) {
    return ee = +ee, ae = ae >>> 0, me || Q(ce, ee, ae, 8), r.write(ce, ee, ae, oe, 52, 8), ae + 8;
  }
  n.prototype.writeDoubleLE = function(ee, ae, oe) {
    return re(this, ee, ae, !0, oe);
  }, n.prototype.writeDoubleBE = function(ee, ae, oe) {
    return re(this, ee, ae, !1, oe);
  }, n.prototype.copy = function(ee, ae, oe, me) {
    if (!n.isBuffer(ee)) throw new TypeError("argument should be a Buffer");
    if (oe || (oe = 0), !me && me !== 0 && (me = this.length), ae >= ee.length && (ae = ee.length), ae || (ae = 0), me > 0 && me < oe && (me = oe), me === oe || ee.length === 0 || this.length === 0) return 0;
    if (ae < 0)
      throw new RangeError("targetStart out of bounds");
    if (oe < 0 || oe >= this.length) throw new RangeError("Index out of range");
    if (me < 0) throw new RangeError("sourceEnd out of bounds");
    me > this.length && (me = this.length), ee.length - ae < me - oe && (me = ee.length - ae + oe);
    var ye = me - oe;
    return this === ee && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(ae, oe, me) : Uint8Array.prototype.set.call(
      ee,
      this.subarray(oe, me),
      ae
    ), ye;
  }, n.prototype.fill = function(ee, ae, oe, me) {
    if (typeof ee == "string") {
      if (typeof ae == "string" ? (me = ae, ae = 0, oe = this.length) : typeof oe == "string" && (me = oe, oe = this.length), me !== void 0 && typeof me != "string")
        throw new TypeError("encoding must be a string");
      if (typeof me == "string" && !n.isEncoding(me))
        throw new TypeError("Unknown encoding: " + me);
      if (ee.length === 1) {
        var ye = ee.charCodeAt(0);
        (me === "utf8" && ye < 128 || me === "latin1") && (ee = ye);
      }
    } else typeof ee == "number" ? ee = ee & 255 : typeof ee == "boolean" && (ee = Number(ee));
    if (ae < 0 || this.length < ae || this.length < oe)
      throw new RangeError("Out of range index");
    if (oe <= ae)
      return this;
    ae = ae >>> 0, oe = oe === void 0 ? this.length : oe >>> 0, ee || (ee = 0);
    var we;
    if (typeof ee == "number")
      for (we = ae; we < oe; ++we)
        this[we] = ee;
    else {
      var ge = n.isBuffer(ee) ? ee : n.from(ee, me), se = ge.length;
      if (se === 0)
        throw new TypeError('The value "' + ee + '" is invalid for argument "value"');
      for (we = 0; we < oe - ae; ++we)
        this[we + ae] = ge[we % se];
    }
    return this;
  };
  var G = /[^+/0-9A-Za-z-_]/g;
  function N(ce) {
    if (ce = ce.split("=")[0], ce = ce.trim().replace(G, ""), ce.length < 2) return "";
    for (; ce.length % 4 !== 0; )
      ce = ce + "=";
    return ce;
  }
  function V(ce, ee) {
    ee = ee || 1 / 0;
    for (var ae, oe = ce.length, me = null, ye = [], we = 0; we < oe; ++we) {
      if (ae = ce.charCodeAt(we), ae > 55295 && ae < 57344) {
        if (!me) {
          if (ae > 56319) {
            (ee -= 3) > -1 && ye.push(239, 191, 189);
            continue;
          } else if (we + 1 === oe) {
            (ee -= 3) > -1 && ye.push(239, 191, 189);
            continue;
          }
          me = ae;
          continue;
        }
        if (ae < 56320) {
          (ee -= 3) > -1 && ye.push(239, 191, 189), me = ae;
          continue;
        }
        ae = (me - 55296 << 10 | ae - 56320) + 65536;
      } else me && (ee -= 3) > -1 && ye.push(239, 191, 189);
      if (me = null, ae < 128) {
        if ((ee -= 1) < 0) break;
        ye.push(ae);
      } else if (ae < 2048) {
        if ((ee -= 2) < 0) break;
        ye.push(
          ae >> 6 | 192,
          ae & 63 | 128
        );
      } else if (ae < 65536) {
        if ((ee -= 3) < 0) break;
        ye.push(
          ae >> 12 | 224,
          ae >> 6 & 63 | 128,
          ae & 63 | 128
        );
      } else if (ae < 1114112) {
        if ((ee -= 4) < 0) break;
        ye.push(
          ae >> 18 | 240,
          ae >> 12 & 63 | 128,
          ae >> 6 & 63 | 128,
          ae & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ye;
  }
  function F(ce) {
    for (var ee = [], ae = 0; ae < ce.length; ++ae)
      ee.push(ce.charCodeAt(ae) & 255);
    return ee;
  }
  function X(ce, ee) {
    for (var ae, oe, me, ye = [], we = 0; we < ce.length && !((ee -= 2) < 0); ++we)
      ae = ce.charCodeAt(we), oe = ae >> 8, me = ae % 256, ye.push(me), ye.push(oe);
    return ye;
  }
  function K(ce) {
    return e.toByteArray(N(ce));
  }
  function ie(ce, ee, ae, oe) {
    for (var me = 0; me < oe && !(me + ae >= ee.length || me >= ce.length); ++me)
      ee[me + ae] = ce[me];
    return me;
  }
  function fe(ce, ee) {
    return ce instanceof ee || ce != null && ce.constructor != null && ce.constructor.name != null && ce.constructor.name === ee.name;
  }
  function _e(ce) {
    return ce !== ce;
  }
  var Ae = function() {
    for (var ce = "0123456789abcdef", ee = new Array(256), ae = 0; ae < 16; ++ae)
      for (var oe = ae * 16, me = 0; me < 16; ++me)
        ee[oe + me] = ce[ae] + ce[me];
    return ee;
  }();
})(Ui);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.bufferFrom = t.bufferAllocUnsafe = t.Buffer = void 0;
  const e = Ui;
  Object.defineProperty(t, "Buffer", { enumerable: !0, get: function() {
    return e.Buffer;
  } });
  function r(d, ...h) {
    return new e.Buffer(d, ...h);
  }
  const a = e.Buffer.allocUnsafe || r;
  t.bufferAllocUnsafe = a;
  const l = e.Buffer.from || r;
  t.bufferFrom = l;
})(rl);
var Sy = {}, ih = { exports: {} }, sh = {}, Fi = {}, I2 = {}, wy = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, r = Symbol("test"), a = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
    return !1;
  var l = 42;
  e[r] = l;
  for (r in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var d = Object.getOwnPropertySymbols(e);
  if (d.length !== 1 || d[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var h = Object.getOwnPropertyDescriptor(e, r);
    if (h.value !== l || h.enumerable !== !0)
      return !1;
  }
  return !0;
}, J7 = wy, xy = function() {
  return J7() && !!Symbol.toStringTag;
}, Q7 = Error, Z7 = EvalError, eO = RangeError, tO = ReferenceError, O2 = SyntaxError, Uu = TypeError, rO = URIError, Ov = typeof Symbol < "u" && Symbol, nO = wy, iO = function() {
  return typeof Ov != "function" || typeof Symbol != "function" || typeof Ov("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : nO();
}, ah = {
  __proto__: null,
  foo: {}
}, sO = Object, aO = function() {
  return { __proto__: ah }.foo === ah.foo && !(ah instanceof sO);
}, oO = "Function.prototype.bind called on incompatible ", lO = Object.prototype.toString, uO = Math.max, cO = "[object Function]", kv = function(e, r) {
  for (var a = [], l = 0; l < e.length; l += 1)
    a[l] = e[l];
  for (var d = 0; d < r.length; d += 1)
    a[d + e.length] = r[d];
  return a;
}, fO = function(e, r) {
  for (var a = [], l = r, d = 0; l < e.length; l += 1, d += 1)
    a[d] = e[l];
  return a;
}, dO = function(t, e) {
  for (var r = "", a = 0; a < t.length; a += 1)
    r += t[a], a + 1 < t.length && (r += e);
  return r;
}, pO = function(e) {
  var r = this;
  if (typeof r != "function" || lO.apply(r) !== cO)
    throw new TypeError(oO + r);
  for (var a = fO(arguments, 1), l, d = function() {
    if (this instanceof l) {
      var c = r.apply(
        this,
        kv(a, arguments)
      );
      return Object(c) === c ? c : this;
    }
    return r.apply(
      e,
      kv(a, arguments)
    );
  }, h = uO(0, r.length - a.length), n = [], u = 0; u < h; u++)
    n[u] = "$" + u;
  if (l = Function("binder", "return function (" + dO(n, ",") + "){ return binder.apply(this,arguments); }")(d), r.prototype) {
    var i = function() {
    };
    i.prototype = r.prototype, l.prototype = new i(), i.prototype = null;
  }
  return l;
}, hO = pO, Ty = Function.prototype.bind || hO, mO = Function.prototype.call, yO = Object.prototype.hasOwnProperty, bO = Ty, gO = bO.call(mO, yO), mr, vO = Q7, EO = Z7, _O = eO, SO = tO, nl = O2, Yo = Uu, wO = rO, k2 = Function, oh = function(t) {
  try {
    return k2('"use strict"; return (' + t + ").constructor;")();
  } catch {
  }
}, eo = Object.getOwnPropertyDescriptor;
if (eo)
  try {
    eo({}, "");
  } catch {
    eo = null;
  }
var lh = function() {
  throw new Yo();
}, xO = eo ? function() {
  try {
    return arguments.callee, lh;
  } catch {
    try {
      return eo(arguments, "callee").get;
    } catch {
      return lh;
    }
  }
}() : lh, Do = iO(), TO = aO(), Rn = Object.getPrototypeOf || (TO ? function(t) {
  return t.__proto__;
} : null), qo = {}, AO = typeof Uint8Array > "u" || !Rn ? mr : Rn(Uint8Array), to = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? mr : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? mr : ArrayBuffer,
  "%ArrayIteratorPrototype%": Do && Rn ? Rn([][Symbol.iterator]()) : mr,
  "%AsyncFromSyncIteratorPrototype%": mr,
  "%AsyncFunction%": qo,
  "%AsyncGenerator%": qo,
  "%AsyncGeneratorFunction%": qo,
  "%AsyncIteratorPrototype%": qo,
  "%Atomics%": typeof Atomics > "u" ? mr : Atomics,
  "%BigInt%": typeof BigInt > "u" ? mr : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? mr : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? mr : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? mr : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": vO,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EO,
  "%Float32Array%": typeof Float32Array > "u" ? mr : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? mr : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? mr : FinalizationRegistry,
  "%Function%": k2,
  "%GeneratorFunction%": qo,
  "%Int8Array%": typeof Int8Array > "u" ? mr : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? mr : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? mr : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Do && Rn ? Rn(Rn([][Symbol.iterator]())) : mr,
  "%JSON%": typeof JSON == "object" ? JSON : mr,
  "%Map%": typeof Map > "u" ? mr : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Do || !Rn ? mr : Rn((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? mr : Promise,
  "%Proxy%": typeof Proxy > "u" ? mr : Proxy,
  "%RangeError%": _O,
  "%ReferenceError%": SO,
  "%Reflect%": typeof Reflect > "u" ? mr : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? mr : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Do || !Rn ? mr : Rn((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? mr : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Do && Rn ? Rn(""[Symbol.iterator]()) : mr,
  "%Symbol%": Do ? Symbol : mr,
  "%SyntaxError%": nl,
  "%ThrowTypeError%": xO,
  "%TypedArray%": AO,
  "%TypeError%": Yo,
  "%Uint8Array%": typeof Uint8Array > "u" ? mr : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? mr : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? mr : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? mr : Uint32Array,
  "%URIError%": wO,
  "%WeakMap%": typeof WeakMap > "u" ? mr : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? mr : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? mr : WeakSet
};
if (Rn)
  try {
    null.error;
  } catch (t) {
    var PO = Rn(Rn(t));
    to["%Error.prototype%"] = PO;
  }
var CO = function t(e) {
  var r;
  if (e === "%AsyncFunction%")
    r = oh("async function () {}");
  else if (e === "%GeneratorFunction%")
    r = oh("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    r = oh("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var a = t("%AsyncGeneratorFunction%");
    a && (r = a.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var l = t("%AsyncGenerator%");
    l && Rn && (r = Rn(l.prototype));
  }
  return to[e] = r, r;
}, Dv = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Vu = Ty, Rf = gO, IO = Vu.call(Function.call, Array.prototype.concat), OO = Vu.call(Function.apply, Array.prototype.splice), Nv = Vu.call(Function.call, String.prototype.replace), Mf = Vu.call(Function.call, String.prototype.slice), kO = Vu.call(Function.call, RegExp.prototype.exec), DO = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, NO = /\\(\\)?/g, RO = function(e) {
  var r = Mf(e, 0, 1), a = Mf(e, -1);
  if (r === "%" && a !== "%")
    throw new nl("invalid intrinsic syntax, expected closing `%`");
  if (a === "%" && r !== "%")
    throw new nl("invalid intrinsic syntax, expected opening `%`");
  var l = [];
  return Nv(e, DO, function(d, h, n, u) {
    l[l.length] = n ? Nv(u, NO, "$1") : h || d;
  }), l;
}, MO = function(e, r) {
  var a = e, l;
  if (Rf(Dv, a) && (l = Dv[a], a = "%" + l[0] + "%"), Rf(to, a)) {
    var d = to[a];
    if (d === qo && (d = CO(a)), typeof d > "u" && !r)
      throw new Yo("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: l,
      name: a,
      value: d
    };
  }
  throw new nl("intrinsic " + e + " does not exist!");
}, wl = function(e, r) {
  if (typeof e != "string" || e.length === 0)
    throw new Yo("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new Yo('"allowMissing" argument must be a boolean');
  if (kO(/^%?[^%]*%?$/, e) === null)
    throw new nl("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var a = RO(e), l = a.length > 0 ? a[0] : "", d = MO("%" + l + "%", r), h = d.name, n = d.value, u = !1, i = d.alias;
  i && (l = i[0], OO(a, IO([0, 1], i)));
  for (var c = 1, f = !0; c < a.length; c += 1) {
    var s = a[c], o = Mf(s, 0, 1), y = Mf(s, -1);
    if ((o === '"' || o === "'" || o === "`" || y === '"' || y === "'" || y === "`") && o !== y)
      throw new nl("property names with quotes must have matching quotes");
    if ((s === "constructor" || !f) && (u = !0), l += "." + s, h = "%" + l + "%", Rf(to, h))
      n = to[h];
    else if (n != null) {
      if (!(s in n)) {
        if (!r)
          throw new Yo("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (eo && c + 1 >= a.length) {
        var m = eo(n, s);
        f = !!m, f && "get" in m && !("originalValue" in m.get) ? n = m.get : n = n[s];
      } else
        f = Rf(n, s), n = n[s];
      f && !u && (to[h] = n);
    }
  }
  return n;
}, D2 = { exports: {} }, uh, Rv;
function Ay() {
  if (Rv) return uh;
  Rv = 1;
  var t = wl, e = t("%Object.defineProperty%", !0) || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return uh = e, uh;
}
var LO = wl, pf = LO("%Object.getOwnPropertyDescriptor%", !0);
if (pf)
  try {
    pf([], "length");
  } catch {
    pf = null;
  }
var Py = pf, Mv = Ay(), jO = O2, No = Uu, Lv = Py, N2 = function(e, r, a) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new No("`obj` must be an object or a function`");
  if (typeof r != "string" && typeof r != "symbol")
    throw new No("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new No("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new No("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new No("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new No("`loose`, if provided, must be a boolean");
  var l = arguments.length > 3 ? arguments[3] : null, d = arguments.length > 4 ? arguments[4] : null, h = arguments.length > 5 ? arguments[5] : null, n = arguments.length > 6 ? arguments[6] : !1, u = !!Lv && Lv(e, r);
  if (Mv)
    Mv(e, r, {
      configurable: h === null && u ? u.configurable : !h,
      enumerable: l === null && u ? u.enumerable : !l,
      value: a,
      writable: d === null && u ? u.writable : !d
    });
  else if (n || !l && !d && !h)
    e[r] = a;
  else
    throw new jO("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, S0 = Ay(), R2 = function() {
  return !!S0;
};
R2.hasArrayLengthDefineBug = function() {
  if (!S0)
    return null;
  try {
    return S0([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var M2 = R2, FO = wl, jv = N2, BO = M2(), Fv = Py, Bv = Uu, $O = FO("%Math.floor%"), UO = function(e, r) {
  if (typeof e != "function")
    throw new Bv("`fn` is not a function");
  if (typeof r != "number" || r < 0 || r > 4294967295 || $O(r) !== r)
    throw new Bv("`length` must be a positive 32-bit integer");
  var a = arguments.length > 2 && !!arguments[2], l = !0, d = !0;
  if ("length" in e && Fv) {
    var h = Fv(e, "length");
    h && !h.configurable && (l = !1), h && !h.writable && (d = !1);
  }
  return (l || d || !a) && (BO ? jv(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    r,
    !0,
    !0
  ) : jv(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    r
  )), e;
};
(function(t) {
  var e = Ty, r = wl, a = UO, l = Uu, d = r("%Function.prototype.apply%"), h = r("%Function.prototype.call%"), n = r("%Reflect.apply%", !0) || e.call(h, d), u = Ay(), i = r("%Math.max%");
  t.exports = function(s) {
    if (typeof s != "function")
      throw new l("a function is required");
    var o = n(e, h, arguments);
    return a(
      o,
      1 + i(0, s.length - (arguments.length - 1)),
      !0
    );
  };
  var c = function() {
    return n(e, d, arguments);
  };
  u ? u(t.exports, "apply", { value: c }) : t.exports.apply = c;
})(D2);
var xd = D2.exports, L2 = wl, j2 = xd, VO = j2(L2("String.prototype.indexOf")), Wu = function(e, r) {
  var a = L2(e, !!r);
  return typeof a == "function" && VO(e, ".prototype.") > -1 ? j2(a) : a;
}, WO = xy(), qO = Wu, w0 = qO("Object.prototype.toString"), Td = function(e) {
  return WO && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : w0(e) === "[object Arguments]";
}, F2 = function(e) {
  return Td(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && w0(e) !== "[object Array]" && w0(e.callee) === "[object Function]";
}, HO = function() {
  return Td(arguments);
}();
Td.isLegacyArguments = F2;
var GO = HO ? Td : F2, zO = Object.prototype.toString, KO = Function.prototype.toString, YO = /^\s*(?:function)?\*/, B2 = xy(), ch = Object.getPrototypeOf, XO = function() {
  if (!B2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, fh, JO = function(e) {
  if (typeof e != "function")
    return !1;
  if (YO.test(KO.call(e)))
    return !0;
  if (!B2) {
    var r = zO.call(e);
    return r === "[object GeneratorFunction]";
  }
  if (!ch)
    return !1;
  if (typeof fh > "u") {
    var a = XO();
    fh = a ? ch(a) : !1;
  }
  return ch(e) === fh;
}, $2 = Function.prototype.toString, Ho = typeof Reflect == "object" && Reflect !== null && Reflect.apply, x0, hf;
if (typeof Ho == "function" && typeof Object.defineProperty == "function")
  try {
    x0 = Object.defineProperty({}, "length", {
      get: function() {
        throw hf;
      }
    }), hf = {}, Ho(function() {
      throw 42;
    }, null, x0);
  } catch (t) {
    t !== hf && (Ho = null);
  }
else
  Ho = null;
var QO = /^\s*class\b/, T0 = function(e) {
  try {
    var r = $2.call(e);
    return QO.test(r);
  } catch {
    return !1;
  }
}, dh = function(e) {
  try {
    return T0(e) ? !1 : ($2.call(e), !0);
  } catch {
    return !1;
  }
}, mf = Object.prototype.toString, ZO = "[object Object]", ek = "[object Function]", tk = "[object GeneratorFunction]", rk = "[object HTMLAllCollection]", nk = "[object HTML document.all class]", ik = "[object HTMLCollection]", sk = typeof Symbol == "function" && !!Symbol.toStringTag, ak = !(0 in [,]), A0 = function() {
  return !1;
};
if (typeof document == "object") {
  var ok = document.all;
  mf.call(ok) === mf.call(document.all) && (A0 = function(e) {
    if ((ak || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var r = mf.call(e);
        return (r === rk || r === nk || r === ik || r === ZO) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var lk = Ho ? function(e) {
  if (A0(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    Ho(e, null, x0);
  } catch (r) {
    if (r !== hf)
      return !1;
  }
  return !T0(e) && dh(e);
} : function(e) {
  if (A0(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (sk)
    return dh(e);
  if (T0(e))
    return !1;
  var r = mf.call(e);
  return r !== ek && r !== tk && !/^\[object HTML/.test(r) ? !1 : dh(e);
}, uk = lk, ck = Object.prototype.toString, U2 = Object.prototype.hasOwnProperty, fk = function(e, r, a) {
  for (var l = 0, d = e.length; l < d; l++)
    U2.call(e, l) && (a == null ? r(e[l], l, e) : r.call(a, e[l], l, e));
}, dk = function(e, r, a) {
  for (var l = 0, d = e.length; l < d; l++)
    a == null ? r(e.charAt(l), l, e) : r.call(a, e.charAt(l), l, e);
}, pk = function(e, r, a) {
  for (var l in e)
    U2.call(e, l) && (a == null ? r(e[l], l, e) : r.call(a, e[l], l, e));
}, hk = function(e, r, a) {
  if (!uk(r))
    throw new TypeError("iterator must be a function");
  var l;
  arguments.length >= 3 && (l = a), ck.call(e) === "[object Array]" ? fk(e, r, l) : typeof e == "string" ? dk(e, r, l) : pk(e, r, l);
}, mk = hk, yk = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], ph = yk, bk = typeof globalThis > "u" ? jt : globalThis, gk = function() {
  for (var e = [], r = 0; r < ph.length; r++)
    typeof bk[ph[r]] == "function" && (e[e.length] = ph[r]);
  return e;
}, Lf = mk, vk = gk, $v = xd, Cy = Wu, yf = Py, Ek = Cy("Object.prototype.toString"), V2 = xy(), Uv = typeof globalThis > "u" ? jt : globalThis, P0 = vk(), Iy = Cy("String.prototype.slice"), hh = Object.getPrototypeOf, _k = Cy("Array.prototype.indexOf", !0) || function(e, r) {
  for (var a = 0; a < e.length; a += 1)
    if (e[a] === r)
      return a;
  return -1;
}, jf = { __proto__: null };
V2 && yf && hh ? Lf(P0, function(t) {
  var e = new Uv[t]();
  if (Symbol.toStringTag in e) {
    var r = hh(e), a = yf(r, Symbol.toStringTag);
    if (!a) {
      var l = hh(r);
      a = yf(l, Symbol.toStringTag);
    }
    jf["$" + t] = $v(a.get);
  }
}) : Lf(P0, function(t) {
  var e = new Uv[t](), r = e.slice || e.set;
  r && (jf["$" + t] = $v(r));
});
var Sk = function(e) {
  var r = !1;
  return Lf(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    jf,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(a, l) {
      if (!r)
        try {
          "$" + a(e) === l && (r = Iy(l, 1));
        } catch {
        }
    }
  ), r;
}, wk = function(e) {
  var r = !1;
  return Lf(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    jf,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(a, l) {
      if (!r)
        try {
          a(e), r = Iy(l, 1);
        } catch {
        }
    }
  ), r;
}, W2 = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!V2) {
    var r = Iy(Ek(e), 8, -1);
    return _k(P0, r) > -1 ? r : r !== "Object" ? !1 : wk(e);
  }
  return yf ? Sk(e) : null;
}, xk = W2, Tk = function(e) {
  return !!xk(e);
};
(function(t) {
  var e = GO, r = JO, a = W2, l = Tk;
  function d(oe) {
    return oe.call.bind(oe);
  }
  var h = typeof BigInt < "u", n = typeof Symbol < "u", u = d(Object.prototype.toString), i = d(Number.prototype.valueOf), c = d(String.prototype.valueOf), f = d(Boolean.prototype.valueOf);
  if (h)
    var s = d(BigInt.prototype.valueOf);
  if (n)
    var o = d(Symbol.prototype.valueOf);
  function y(oe, me) {
    if (typeof oe != "object")
      return !1;
    try {
      return me(oe), !0;
    } catch {
      return !1;
    }
  }
  t.isArgumentsObject = e, t.isGeneratorFunction = r, t.isTypedArray = l;
  function m(oe) {
    return typeof Promise < "u" && oe instanceof Promise || oe !== null && typeof oe == "object" && typeof oe.then == "function" && typeof oe.catch == "function";
  }
  t.isPromise = m;
  function g(oe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(oe) : l(oe) || Q(oe);
  }
  t.isArrayBufferView = g;
  function b(oe) {
    return a(oe) === "Uint8Array";
  }
  t.isUint8Array = b;
  function v(oe) {
    return a(oe) === "Uint8ClampedArray";
  }
  t.isUint8ClampedArray = v;
  function T(oe) {
    return a(oe) === "Uint16Array";
  }
  t.isUint16Array = T;
  function E(oe) {
    return a(oe) === "Uint32Array";
  }
  t.isUint32Array = E;
  function O(oe) {
    return a(oe) === "Int8Array";
  }
  t.isInt8Array = O;
  function D(oe) {
    return a(oe) === "Int16Array";
  }
  t.isInt16Array = D;
  function $(oe) {
    return a(oe) === "Int32Array";
  }
  t.isInt32Array = $;
  function I(oe) {
    return a(oe) === "Float32Array";
  }
  t.isFloat32Array = I;
  function k(oe) {
    return a(oe) === "Float64Array";
  }
  t.isFloat64Array = k;
  function L(oe) {
    return a(oe) === "BigInt64Array";
  }
  t.isBigInt64Array = L;
  function M(oe) {
    return a(oe) === "BigUint64Array";
  }
  t.isBigUint64Array = M;
  function x(oe) {
    return u(oe) === "[object Map]";
  }
  x.working = typeof Map < "u" && x(/* @__PURE__ */ new Map());
  function _(oe) {
    return typeof Map > "u" ? !1 : x.working ? x(oe) : oe instanceof Map;
  }
  t.isMap = _;
  function S(oe) {
    return u(oe) === "[object Set]";
  }
  S.working = typeof Set < "u" && S(/* @__PURE__ */ new Set());
  function C(oe) {
    return typeof Set > "u" ? !1 : S.working ? S(oe) : oe instanceof Set;
  }
  t.isSet = C;
  function R(oe) {
    return u(oe) === "[object WeakMap]";
  }
  R.working = typeof WeakMap < "u" && R(/* @__PURE__ */ new WeakMap());
  function H(oe) {
    return typeof WeakMap > "u" ? !1 : R.working ? R(oe) : oe instanceof WeakMap;
  }
  t.isWeakMap = H;
  function z(oe) {
    return u(oe) === "[object WeakSet]";
  }
  z.working = typeof WeakSet < "u" && z(/* @__PURE__ */ new WeakSet());
  function U(oe) {
    return z(oe);
  }
  t.isWeakSet = U;
  function P(oe) {
    return u(oe) === "[object ArrayBuffer]";
  }
  P.working = typeof ArrayBuffer < "u" && P(new ArrayBuffer());
  function W(oe) {
    return typeof ArrayBuffer > "u" ? !1 : P.working ? P(oe) : oe instanceof ArrayBuffer;
  }
  t.isArrayBuffer = W;
  function B(oe) {
    return u(oe) === "[object DataView]";
  }
  B.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && B(new DataView(new ArrayBuffer(1), 0, 1));
  function Q(oe) {
    return typeof DataView > "u" ? !1 : B.working ? B(oe) : oe instanceof DataView;
  }
  t.isDataView = Q;
  var J = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function re(oe) {
    return u(oe) === "[object SharedArrayBuffer]";
  }
  function G(oe) {
    return typeof J > "u" ? !1 : (typeof re.working > "u" && (re.working = re(new J())), re.working ? re(oe) : oe instanceof J);
  }
  t.isSharedArrayBuffer = G;
  function N(oe) {
    return u(oe) === "[object AsyncFunction]";
  }
  t.isAsyncFunction = N;
  function V(oe) {
    return u(oe) === "[object Map Iterator]";
  }
  t.isMapIterator = V;
  function F(oe) {
    return u(oe) === "[object Set Iterator]";
  }
  t.isSetIterator = F;
  function X(oe) {
    return u(oe) === "[object Generator]";
  }
  t.isGeneratorObject = X;
  function K(oe) {
    return u(oe) === "[object WebAssembly.Module]";
  }
  t.isWebAssemblyCompiledModule = K;
  function ie(oe) {
    return y(oe, i);
  }
  t.isNumberObject = ie;
  function fe(oe) {
    return y(oe, c);
  }
  t.isStringObject = fe;
  function _e(oe) {
    return y(oe, f);
  }
  t.isBooleanObject = _e;
  function Ae(oe) {
    return h && y(oe, s);
  }
  t.isBigIntObject = Ae;
  function ce(oe) {
    return n && y(oe, o);
  }
  t.isSymbolObject = ce;
  function ee(oe) {
    return ie(oe) || fe(oe) || _e(oe) || Ae(oe) || ce(oe);
  }
  t.isBoxedPrimitive = ee;
  function ae(oe) {
    return typeof Uint8Array < "u" && (W(oe) || G(oe));
  }
  t.isAnyArrayBuffer = ae, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(oe) {
    Object.defineProperty(t, oe, {
      enumerable: !1,
      value: function() {
        throw new Error(oe + " is not supported in userland");
      }
    });
  });
})(I2);
var Ak = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
}, C0 = { exports: {} };
typeof Object.create == "function" ? C0.exports = function(e, r) {
  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : C0.exports = function(e, r) {
  if (r) {
    e.super_ = r;
    var a = function() {
    };
    a.prototype = r.prototype, e.prototype = new a(), e.prototype.constructor = e;
  }
};
var ir = C0.exports;
(function(t) {
  var e = Object.getOwnPropertyDescriptors || function(Q) {
    for (var J = Object.keys(Q), re = {}, G = 0; G < J.length; G++)
      re[J[G]] = Object.getOwnPropertyDescriptor(Q, J[G]);
    return re;
  }, r = /%[sdj%]/g;
  t.format = function(B) {
    if (!O(B)) {
      for (var Q = [], J = 0; J < arguments.length; J++)
        Q.push(h(arguments[J]));
      return Q.join(" ");
    }
    for (var J = 1, re = arguments, G = re.length, N = String(B).replace(r, function(F) {
      if (F === "%%") return "%";
      if (J >= G) return F;
      switch (F) {
        case "%s":
          return String(re[J++]);
        case "%d":
          return Number(re[J++]);
        case "%j":
          try {
            return JSON.stringify(re[J++]);
          } catch {
            return "[Circular]";
          }
        default:
          return F;
      }
    }), V = re[J]; J < G; V = re[++J])
      v(V) || !k(V) ? N += " " + V : N += " " + h(V);
    return N;
  }, t.deprecate = function(B, Q) {
    if (typeof Ze < "u" && Ze.noDeprecation === !0)
      return B;
    if (typeof Ze > "u")
      return function() {
        return t.deprecate(B, Q).apply(this, arguments);
      };
    var J = !1;
    function re() {
      if (!J) {
        if (Ze.throwDeprecation)
          throw new Error(Q);
        Ze.traceDeprecation ? console.trace(Q) : console.error(Q), J = !0;
      }
      return B.apply(this, arguments);
    }
    return re;
  };
  var a = {}, l = /^$/;
  if (Ze.env.NODE_DEBUG) {
    var d = Ze.env.NODE_DEBUG;
    d = d.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), l = new RegExp("^" + d + "$", "i");
  }
  t.debuglog = function(B) {
    if (B = B.toUpperCase(), !a[B])
      if (l.test(B)) {
        var Q = Ze.pid;
        a[B] = function() {
          var J = t.format.apply(t, arguments);
          console.error("%s %d: %s", B, Q, J);
        };
      } else
        a[B] = function() {
        };
    return a[B];
  };
  function h(B, Q) {
    var J = {
      seen: [],
      stylize: u
    };
    return arguments.length >= 3 && (J.depth = arguments[2]), arguments.length >= 4 && (J.colors = arguments[3]), b(Q) ? J.showHidden = Q : Q && t._extend(J, Q), $(J.showHidden) && (J.showHidden = !1), $(J.depth) && (J.depth = 2), $(J.colors) && (J.colors = !1), $(J.customInspect) && (J.customInspect = !0), J.colors && (J.stylize = n), c(J, B, J.depth);
  }
  t.inspect = h, h.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, h.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function n(B, Q) {
    var J = h.styles[Q];
    return J ? "\x1B[" + h.colors[J][0] + "m" + B + "\x1B[" + h.colors[J][1] + "m" : B;
  }
  function u(B, Q) {
    return B;
  }
  function i(B) {
    var Q = {};
    return B.forEach(function(J, re) {
      Q[J] = !0;
    }), Q;
  }
  function c(B, Q, J) {
    if (B.customInspect && Q && x(Q.inspect) && // Filter out the util module, it's inspect function is special
    Q.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
    !(Q.constructor && Q.constructor.prototype === Q)) {
      var re = Q.inspect(J, B);
      return O(re) || (re = c(B, re, J)), re;
    }
    var G = f(B, Q);
    if (G)
      return G;
    var N = Object.keys(Q), V = i(N);
    if (B.showHidden && (N = Object.getOwnPropertyNames(Q)), M(Q) && (N.indexOf("message") >= 0 || N.indexOf("description") >= 0))
      return s(Q);
    if (N.length === 0) {
      if (x(Q)) {
        var F = Q.name ? ": " + Q.name : "";
        return B.stylize("[Function" + F + "]", "special");
      }
      if (I(Q))
        return B.stylize(RegExp.prototype.toString.call(Q), "regexp");
      if (L(Q))
        return B.stylize(Date.prototype.toString.call(Q), "date");
      if (M(Q))
        return s(Q);
    }
    var X = "", K = !1, ie = ["{", "}"];
    if (g(Q) && (K = !0, ie = ["[", "]"]), x(Q)) {
      var fe = Q.name ? ": " + Q.name : "";
      X = " [Function" + fe + "]";
    }
    if (I(Q) && (X = " " + RegExp.prototype.toString.call(Q)), L(Q) && (X = " " + Date.prototype.toUTCString.call(Q)), M(Q) && (X = " " + s(Q)), N.length === 0 && (!K || Q.length == 0))
      return ie[0] + X + ie[1];
    if (J < 0)
      return I(Q) ? B.stylize(RegExp.prototype.toString.call(Q), "regexp") : B.stylize("[Object]", "special");
    B.seen.push(Q);
    var _e;
    return K ? _e = o(B, Q, J, V, N) : _e = N.map(function(Ae) {
      return y(B, Q, J, V, Ae, K);
    }), B.seen.pop(), m(_e, X, ie);
  }
  function f(B, Q) {
    if ($(Q))
      return B.stylize("undefined", "undefined");
    if (O(Q)) {
      var J = "'" + JSON.stringify(Q).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return B.stylize(J, "string");
    }
    if (E(Q))
      return B.stylize("" + Q, "number");
    if (b(Q))
      return B.stylize("" + Q, "boolean");
    if (v(Q))
      return B.stylize("null", "null");
  }
  function s(B) {
    return "[" + Error.prototype.toString.call(B) + "]";
  }
  function o(B, Q, J, re, G) {
    for (var N = [], V = 0, F = Q.length; V < F; ++V)
      z(Q, String(V)) ? N.push(y(
        B,
        Q,
        J,
        re,
        String(V),
        !0
      )) : N.push("");
    return G.forEach(function(X) {
      X.match(/^\d+$/) || N.push(y(
        B,
        Q,
        J,
        re,
        X,
        !0
      ));
    }), N;
  }
  function y(B, Q, J, re, G, N) {
    var V, F, X;
    if (X = Object.getOwnPropertyDescriptor(Q, G) || { value: Q[G] }, X.get ? X.set ? F = B.stylize("[Getter/Setter]", "special") : F = B.stylize("[Getter]", "special") : X.set && (F = B.stylize("[Setter]", "special")), z(re, G) || (V = "[" + G + "]"), F || (B.seen.indexOf(X.value) < 0 ? (v(J) ? F = c(B, X.value, null) : F = c(B, X.value, J - 1), F.indexOf(`
`) > -1 && (N ? F = F.split(`
`).map(function(K) {
      return "  " + K;
    }).join(`
`).slice(2) : F = `
` + F.split(`
`).map(function(K) {
      return "   " + K;
    }).join(`
`))) : F = B.stylize("[Circular]", "special")), $(V)) {
      if (N && G.match(/^\d+$/))
        return F;
      V = JSON.stringify("" + G), V.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (V = V.slice(1, -1), V = B.stylize(V, "name")) : (V = V.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), V = B.stylize(V, "string"));
    }
    return V + ": " + F;
  }
  function m(B, Q, J) {
    var re = B.reduce(function(G, N) {
      return N.indexOf(`
`) >= 0, G + N.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return re > 60 ? J[0] + (Q === "" ? "" : Q + `
 `) + " " + B.join(`,
  `) + " " + J[1] : J[0] + Q + " " + B.join(", ") + " " + J[1];
  }
  t.types = I2;
  function g(B) {
    return Array.isArray(B);
  }
  t.isArray = g;
  function b(B) {
    return typeof B == "boolean";
  }
  t.isBoolean = b;
  function v(B) {
    return B === null;
  }
  t.isNull = v;
  function T(B) {
    return B == null;
  }
  t.isNullOrUndefined = T;
  function E(B) {
    return typeof B == "number";
  }
  t.isNumber = E;
  function O(B) {
    return typeof B == "string";
  }
  t.isString = O;
  function D(B) {
    return typeof B == "symbol";
  }
  t.isSymbol = D;
  function $(B) {
    return B === void 0;
  }
  t.isUndefined = $;
  function I(B) {
    return k(B) && S(B) === "[object RegExp]";
  }
  t.isRegExp = I, t.types.isRegExp = I;
  function k(B) {
    return typeof B == "object" && B !== null;
  }
  t.isObject = k;
  function L(B) {
    return k(B) && S(B) === "[object Date]";
  }
  t.isDate = L, t.types.isDate = L;
  function M(B) {
    return k(B) && (S(B) === "[object Error]" || B instanceof Error);
  }
  t.isError = M, t.types.isNativeError = M;
  function x(B) {
    return typeof B == "function";
  }
  t.isFunction = x;
  function _(B) {
    return B === null || typeof B == "boolean" || typeof B == "number" || typeof B == "string" || typeof B == "symbol" || // ES6 symbol
    typeof B > "u";
  }
  t.isPrimitive = _, t.isBuffer = Ak;
  function S(B) {
    return Object.prototype.toString.call(B);
  }
  function C(B) {
    return B < 10 ? "0" + B.toString(10) : B.toString(10);
  }
  var R = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function H() {
    var B = /* @__PURE__ */ new Date(), Q = [
      C(B.getHours()),
      C(B.getMinutes()),
      C(B.getSeconds())
    ].join(":");
    return [B.getDate(), R[B.getMonth()], Q].join(" ");
  }
  t.log = function() {
    console.log("%s - %s", H(), t.format.apply(t, arguments));
  }, t.inherits = ir, t._extend = function(B, Q) {
    if (!Q || !k(Q)) return B;
    for (var J = Object.keys(Q), re = J.length; re--; )
      B[J[re]] = Q[J[re]];
    return B;
  };
  function z(B, Q) {
    return Object.prototype.hasOwnProperty.call(B, Q);
  }
  var U = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  t.promisify = function(Q) {
    if (typeof Q != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (U && Q[U]) {
      var J = Q[U];
      if (typeof J != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(J, U, {
        value: J,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), J;
    }
    function J() {
      for (var re, G, N = new Promise(function(X, K) {
        re = X, G = K;
      }), V = [], F = 0; F < arguments.length; F++)
        V.push(arguments[F]);
      V.push(function(X, K) {
        X ? G(X) : re(K);
      });
      try {
        Q.apply(this, V);
      } catch (X) {
        G(X);
      }
      return N;
    }
    return Object.setPrototypeOf(J, Object.getPrototypeOf(Q)), U && Object.defineProperty(J, U, {
      value: J,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      J,
      e(Q)
    );
  }, t.promisify.custom = U;
  function P(B, Q) {
    if (!B) {
      var J = new Error("Promise was rejected with a falsy value");
      J.reason = B, B = J;
    }
    return Q(B);
  }
  function W(B) {
    if (typeof B != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Q() {
      for (var J = [], re = 0; re < arguments.length; re++)
        J.push(arguments[re]);
      var G = J.pop();
      if (typeof G != "function")
        throw new TypeError("The last argument must be of type Function");
      var N = this, V = function() {
        return G.apply(N, arguments);
      };
      B.apply(this, J).then(
        function(F) {
          Ze.nextTick(V.bind(null, null, F));
        },
        function(F) {
          Ze.nextTick(P.bind(null, F, V));
        }
      );
    }
    return Object.setPrototypeOf(Q, Object.getPrototypeOf(B)), Object.defineProperties(
      Q,
      e(B)
    ), Q;
  }
  t.callbackify = W;
})(Fi);
var Vv;
function q2() {
  if (Vv) return sh;
  Vv = 1;
  function t(v) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(T) {
      return typeof T;
    } : function(T) {
      return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
    }, t(v);
  }
  function e(v, T, E) {
    return Object.defineProperty(v, "prototype", { writable: !1 }), v;
  }
  function r(v, T) {
    if (!(v instanceof T))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(v, T) {
    if (typeof T != "function" && T !== null)
      throw new TypeError("Super expression must either be null or a function");
    v.prototype = Object.create(T && T.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), Object.defineProperty(v, "prototype", { writable: !1 }), T && l(v, T);
  }
  function l(v, T) {
    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(O, D) {
      return O.__proto__ = D, O;
    }, l(v, T);
  }
  function d(v) {
    var T = u();
    return function() {
      var O = i(v), D;
      if (T) {
        var $ = i(this).constructor;
        D = Reflect.construct(O, arguments, $);
      } else
        D = O.apply(this, arguments);
      return h(this, D);
    };
  }
  function h(v, T) {
    if (T && (t(T) === "object" || typeof T == "function"))
      return T;
    if (T !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return n(v);
  }
  function n(v) {
    if (v === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return v;
  }
  function u() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function i(v) {
    return i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(E) {
      return E.__proto__ || Object.getPrototypeOf(E);
    }, i(v);
  }
  var c = {}, f, s;
  function o(v, T, E) {
    E || (E = Error);
    function O($, I, k) {
      return typeof T == "string" ? T : T($, I, k);
    }
    var D = /* @__PURE__ */ function($) {
      a(k, $);
      var I = d(k);
      function k(L, M, x) {
        var _;
        return r(this, k), _ = I.call(this, O(L, M, x)), _.code = v, _;
      }
      return e(k);
    }(E);
    c[v] = D;
  }
  function y(v, T) {
    if (Array.isArray(v)) {
      var E = v.length;
      return v = v.map(function(O) {
        return String(O);
      }), E > 2 ? "one of ".concat(T, " ").concat(v.slice(0, E - 1).join(", "), ", or ") + v[E - 1] : E === 2 ? "one of ".concat(T, " ").concat(v[0], " or ").concat(v[1]) : "of ".concat(T, " ").concat(v[0]);
    } else
      return "of ".concat(T, " ").concat(String(v));
  }
  function m(v, T, E) {
    return v.substr(0, T.length) === T;
  }
  function g(v, T, E) {
    return (E === void 0 || E > v.length) && (E = v.length), v.substring(E - T.length, E) === T;
  }
  function b(v, T, E) {
    return typeof E != "number" && (E = 0), E + T.length > v.length ? !1 : v.indexOf(T, E) !== -1;
  }
  return o("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), o("ERR_INVALID_ARG_TYPE", function(v, T, E) {
    f === void 0 && (f = Su()), f(typeof v == "string", "'name' must be a string");
    var O;
    typeof T == "string" && m(T, "not ") ? (O = "must not be", T = T.replace(/^not /, "")) : O = "must be";
    var D;
    if (g(v, " argument"))
      D = "The ".concat(v, " ").concat(O, " ").concat(y(T, "type"));
    else {
      var $ = b(v, ".") ? "property" : "argument";
      D = 'The "'.concat(v, '" ').concat($, " ").concat(O, " ").concat(y(T, "type"));
    }
    return D += ". Received type ".concat(t(E)), D;
  }, TypeError), o("ERR_INVALID_ARG_VALUE", function(v, T) {
    var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    s === void 0 && (s = Fi);
    var O = s.inspect(T);
    return O.length > 128 && (O = "".concat(O.slice(0, 128), "...")), "The argument '".concat(v, "' ").concat(E, ". Received ").concat(O);
  }, TypeError), o("ERR_INVALID_RETURN_VALUE", function(v, T, E) {
    var O;
    return E && E.constructor && E.constructor.name ? O = "instance of ".concat(E.constructor.name) : O = "type ".concat(t(E)), "Expected ".concat(v, ' to be returned from the "').concat(T, '"') + " function but got ".concat(O, ".");
  }, TypeError), o("ERR_MISSING_ARGS", function() {
    for (var v = arguments.length, T = new Array(v), E = 0; E < v; E++)
      T[E] = arguments[E];
    f === void 0 && (f = Su()), f(T.length > 0, "At least one arg needs to be specified");
    var O = "The ", D = T.length;
    switch (T = T.map(function($) {
      return '"'.concat($, '"');
    }), D) {
      case 1:
        O += "".concat(T[0], " argument");
        break;
      case 2:
        O += "".concat(T[0], " and ").concat(T[1], " arguments");
        break;
      default:
        O += T.slice(0, D - 1).join(", "), O += ", and ".concat(T[D - 1], " arguments");
        break;
    }
    return "".concat(O, " must be specified");
  }, TypeError), sh.codes = c, sh;
}
var mh, Wv;
function Pk() {
  if (Wv) return mh;
  Wv = 1;
  function t(U, P) {
    var W = Object.keys(U);
    if (Object.getOwnPropertySymbols) {
      var B = Object.getOwnPropertySymbols(U);
      P && (B = B.filter(function(Q) {
        return Object.getOwnPropertyDescriptor(U, Q).enumerable;
      })), W.push.apply(W, B);
    }
    return W;
  }
  function e(U) {
    for (var P = 1; P < arguments.length; P++) {
      var W = arguments[P] != null ? arguments[P] : {};
      P % 2 ? t(Object(W), !0).forEach(function(B) {
        r(U, B, W[B]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(U, Object.getOwnPropertyDescriptors(W)) : t(Object(W)).forEach(function(B) {
        Object.defineProperty(U, B, Object.getOwnPropertyDescriptor(W, B));
      });
    }
    return U;
  }
  function r(U, P, W) {
    return P = h(P), P in U ? Object.defineProperty(U, P, { value: W, enumerable: !0, configurable: !0, writable: !0 }) : U[P] = W, U;
  }
  function a(U, P) {
    if (!(U instanceof P))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(U, P) {
    for (var W = 0; W < P.length; W++) {
      var B = P[W];
      B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(U, h(B.key), B);
    }
  }
  function d(U, P, W) {
    return P && l(U.prototype, P), Object.defineProperty(U, "prototype", { writable: !1 }), U;
  }
  function h(U) {
    var P = n(U, "string");
    return v(P) === "symbol" ? P : String(P);
  }
  function n(U, P) {
    if (v(U) !== "object" || U === null) return U;
    var W = U[Symbol.toPrimitive];
    if (W !== void 0) {
      var B = W.call(U, P || "default");
      if (v(B) !== "object") return B;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (P === "string" ? String : Number)(U);
  }
  function u(U, P) {
    if (typeof P != "function" && P !== null)
      throw new TypeError("Super expression must either be null or a function");
    U.prototype = Object.create(P && P.prototype, { constructor: { value: U, writable: !0, configurable: !0 } }), Object.defineProperty(U, "prototype", { writable: !1 }), P && g(U, P);
  }
  function i(U) {
    var P = y();
    return function() {
      var B = b(U), Q;
      if (P) {
        var J = b(this).constructor;
        Q = Reflect.construct(B, arguments, J);
      } else
        Q = B.apply(this, arguments);
      return c(this, Q);
    };
  }
  function c(U, P) {
    if (P && (v(P) === "object" || typeof P == "function"))
      return P;
    if (P !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return f(U);
  }
  function f(U) {
    if (U === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U;
  }
  function s(U) {
    var P = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return s = function(B) {
      if (B === null || !m(B)) return B;
      if (typeof B != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof P < "u") {
        if (P.has(B)) return P.get(B);
        P.set(B, Q);
      }
      function Q() {
        return o(B, arguments, b(this).constructor);
      }
      return Q.prototype = Object.create(B.prototype, { constructor: { value: Q, enumerable: !1, writable: !0, configurable: !0 } }), g(Q, B);
    }, s(U);
  }
  function o(U, P, W) {
    return y() ? o = Reflect.construct.bind() : o = function(Q, J, re) {
      var G = [null];
      G.push.apply(G, J);
      var N = Function.bind.apply(Q, G), V = new N();
      return re && g(V, re.prototype), V;
    }, o.apply(null, arguments);
  }
  function y() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function m(U) {
    return Function.toString.call(U).indexOf("[native code]") !== -1;
  }
  function g(U, P) {
    return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(B, Q) {
      return B.__proto__ = Q, B;
    }, g(U, P);
  }
  function b(U) {
    return b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(W) {
      return W.__proto__ || Object.getPrototypeOf(W);
    }, b(U);
  }
  function v(U) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(P) {
      return typeof P;
    } : function(P) {
      return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
    }, v(U);
  }
  var T = Fi, E = T.inspect, O = q2(), D = O.codes.ERR_INVALID_ARG_TYPE;
  function $(U, P, W) {
    return (W === void 0 || W > U.length) && (W = U.length), U.substring(W - P.length, W) === P;
  }
  function I(U, P) {
    if (P = Math.floor(P), U.length == 0 || P == 0) return "";
    var W = U.length * P;
    for (P = Math.floor(Math.log(P) / Math.log(2)); P; )
      U += U, P--;
    return U += U.substring(0, W - U.length), U;
  }
  var k = "", L = "", M = "", x = "", _ = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, S = 10;
  function C(U) {
    var P = Object.keys(U), W = Object.create(Object.getPrototypeOf(U));
    return P.forEach(function(B) {
      W[B] = U[B];
    }), Object.defineProperty(W, "message", {
      value: U.message
    }), W;
  }
  function R(U) {
    return E(U, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function H(U, P, W) {
    var B = "", Q = "", J = 0, re = "", G = !1, N = R(U), V = N.split(`
`), F = R(P).split(`
`), X = 0, K = "";
    if (W === "strictEqual" && v(U) === "object" && v(P) === "object" && U !== null && P !== null && (W = "strictEqualObject"), V.length === 1 && F.length === 1 && V[0] !== F[0]) {
      var ie = V[0].length + F[0].length;
      if (ie <= S) {
        if ((v(U) !== "object" || U === null) && (v(P) !== "object" || P === null) && (U !== 0 || P !== 0))
          return "".concat(_[W], `

`) + "".concat(V[0], " !== ").concat(F[0], `
`);
      } else if (W !== "strictEqualObject") {
        var fe = Ze.stderr && Ze.stderr.isTTY ? Ze.stderr.columns : 80;
        if (ie < fe) {
          for (; V[0][X] === F[0][X]; )
            X++;
          X > 2 && (K = `
  `.concat(I(" ", X), "^"), X = 0);
        }
      }
    }
    for (var _e = V[V.length - 1], Ae = F[F.length - 1]; _e === Ae && (X++ < 2 ? re = `
  `.concat(_e).concat(re) : B = _e, V.pop(), F.pop(), !(V.length === 0 || F.length === 0)); )
      _e = V[V.length - 1], Ae = F[F.length - 1];
    var ce = Math.max(V.length, F.length);
    if (ce === 0) {
      var ee = N.split(`
`);
      if (ee.length > 30)
        for (ee[26] = "".concat(k, "...").concat(x); ee.length > 27; )
          ee.pop();
      return "".concat(_.notIdentical, `

`).concat(ee.join(`
`), `
`);
    }
    X > 3 && (re = `
`.concat(k, "...").concat(x).concat(re), G = !0), B !== "" && (re = `
  `.concat(B).concat(re), B = "");
    var ae = 0, oe = _[W] + `
`.concat(L, "+ actual").concat(x, " ").concat(M, "- expected").concat(x), me = " ".concat(k, "...").concat(x, " Lines skipped");
    for (X = 0; X < ce; X++) {
      var ye = X - J;
      if (V.length < X + 1)
        ye > 1 && X > 2 && (ye > 4 ? (Q += `
`.concat(k, "...").concat(x), G = !0) : ye > 3 && (Q += `
  `.concat(F[X - 2]), ae++), Q += `
  `.concat(F[X - 1]), ae++), J = X, B += `
`.concat(M, "-").concat(x, " ").concat(F[X]), ae++;
      else if (F.length < X + 1)
        ye > 1 && X > 2 && (ye > 4 ? (Q += `
`.concat(k, "...").concat(x), G = !0) : ye > 3 && (Q += `
  `.concat(V[X - 2]), ae++), Q += `
  `.concat(V[X - 1]), ae++), J = X, Q += `
`.concat(L, "+").concat(x, " ").concat(V[X]), ae++;
      else {
        var we = F[X], ge = V[X], se = ge !== we && (!$(ge, ",") || ge.slice(0, -1) !== we);
        se && $(we, ",") && we.slice(0, -1) === ge && (se = !1, ge += ","), se ? (ye > 1 && X > 2 && (ye > 4 ? (Q += `
`.concat(k, "...").concat(x), G = !0) : ye > 3 && (Q += `
  `.concat(V[X - 2]), ae++), Q += `
  `.concat(V[X - 1]), ae++), J = X, Q += `
`.concat(L, "+").concat(x, " ").concat(ge), B += `
`.concat(M, "-").concat(x, " ").concat(we), ae += 2) : (Q += B, B = "", (ye === 1 || X === 0) && (Q += `
  `.concat(ge), ae++));
      }
      if (ae > 20 && X < ce - 2)
        return "".concat(oe).concat(me, `
`).concat(Q, `
`).concat(k, "...").concat(x).concat(B, `
`) + "".concat(k, "...").concat(x);
    }
    return "".concat(oe).concat(G ? me : "", `
`).concat(Q).concat(B).concat(re).concat(K);
  }
  var z = /* @__PURE__ */ function(U, P) {
    u(B, U);
    var W = i(B);
    function B(Q) {
      var J;
      if (a(this, B), v(Q) !== "object" || Q === null)
        throw new D("options", "Object", Q);
      var re = Q.message, G = Q.operator, N = Q.stackStartFn, V = Q.actual, F = Q.expected, X = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, re != null)
        J = W.call(this, String(re));
      else if (Ze.stderr && Ze.stderr.isTTY && (Ze.stderr && Ze.stderr.getColorDepth && Ze.stderr.getColorDepth() !== 1 ? (k = "\x1B[34m", L = "\x1B[32m", x = "\x1B[39m", M = "\x1B[31m") : (k = "", L = "", x = "", M = "")), v(V) === "object" && V !== null && v(F) === "object" && F !== null && "stack" in V && V instanceof Error && "stack" in F && F instanceof Error && (V = C(V), F = C(F)), G === "deepStrictEqual" || G === "strictEqual")
        J = W.call(this, H(V, F, G));
      else if (G === "notDeepStrictEqual" || G === "notStrictEqual") {
        var K = _[G], ie = R(V).split(`
`);
        if (G === "notStrictEqual" && v(V) === "object" && V !== null && (K = _.notStrictEqualObject), ie.length > 30)
          for (ie[26] = "".concat(k, "...").concat(x); ie.length > 27; )
            ie.pop();
        ie.length === 1 ? J = W.call(this, "".concat(K, " ").concat(ie[0])) : J = W.call(this, "".concat(K, `

`).concat(ie.join(`
`), `
`));
      } else {
        var fe = R(V), _e = "", Ae = _[G];
        G === "notDeepEqual" || G === "notEqual" ? (fe = "".concat(_[G], `

`).concat(fe), fe.length > 1024 && (fe = "".concat(fe.slice(0, 1021), "..."))) : (_e = "".concat(R(F)), fe.length > 512 && (fe = "".concat(fe.slice(0, 509), "...")), _e.length > 512 && (_e = "".concat(_e.slice(0, 509), "...")), G === "deepEqual" || G === "equal" ? fe = "".concat(Ae, `

`).concat(fe, `

should equal

`) : _e = " ".concat(G, " ").concat(_e)), J = W.call(this, "".concat(fe).concat(_e));
      }
      return Error.stackTraceLimit = X, J.generatedMessage = !re, Object.defineProperty(f(J), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), J.code = "ERR_ASSERTION", J.actual = V, J.expected = F, J.operator = G, Error.captureStackTrace && Error.captureStackTrace(f(J), N), J.stack, J.name = "AssertionError", c(J);
    }
    return d(B, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: P,
      value: function(J, re) {
        return E(this, e(e({}, re), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), B;
  }(/* @__PURE__ */ s(Error), E.custom);
  return mh = z, mh;
}
var yh, qv;
function H2() {
  if (qv) return yh;
  qv = 1;
  var t = Object.prototype.toString;
  return yh = function(r) {
    var a = t.call(r), l = a === "[object Arguments]";
    return l || (l = a !== "[object Array]" && r !== null && typeof r == "object" && typeof r.length == "number" && r.length >= 0 && t.call(r.callee) === "[object Function]"), l;
  }, yh;
}
var bh, Hv;
function Ck() {
  if (Hv) return bh;
  Hv = 1;
  var t;
  if (!Object.keys) {
    var e = Object.prototype.hasOwnProperty, r = Object.prototype.toString, a = H2(), l = Object.prototype.propertyIsEnumerable, d = !l.call({ toString: null }, "toString"), h = l.call(function() {
    }, "prototype"), n = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], u = function(s) {
      var o = s.constructor;
      return o && o.prototype === s;
    }, i = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, c = function() {
      if (typeof window > "u")
        return !1;
      for (var s in window)
        try {
          if (!i["$" + s] && e.call(window, s) && window[s] !== null && typeof window[s] == "object")
            try {
              u(window[s]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), f = function(s) {
      if (typeof window > "u" || !c)
        return u(s);
      try {
        return u(s);
      } catch {
        return !1;
      }
    };
    t = function(o) {
      var y = o !== null && typeof o == "object", m = r.call(o) === "[object Function]", g = a(o), b = y && r.call(o) === "[object String]", v = [];
      if (!y && !m && !g)
        throw new TypeError("Object.keys called on a non-object");
      var T = h && m;
      if (b && o.length > 0 && !e.call(o, 0))
        for (var E = 0; E < o.length; ++E)
          v.push(String(E));
      if (g && o.length > 0)
        for (var O = 0; O < o.length; ++O)
          v.push(String(O));
      else
        for (var D in o)
          !(T && D === "prototype") && e.call(o, D) && v.push(String(D));
      if (d)
        for (var $ = f(o), I = 0; I < n.length; ++I)
          !($ && n[I] === "constructor") && e.call(o, n[I]) && v.push(n[I]);
      return v;
    };
  }
  return bh = t, bh;
}
var gh, Gv;
function G2() {
  if (Gv) return gh;
  Gv = 1;
  var t = Array.prototype.slice, e = H2(), r = Object.keys, a = r ? function(h) {
    return r(h);
  } : Ck(), l = Object.keys;
  return a.shim = function() {
    if (Object.keys) {
      var h = function() {
        var n = Object.keys(arguments);
        return n && n.length === arguments.length;
      }(1, 2);
      h || (Object.keys = function(u) {
        return e(u) ? l(t.call(u)) : l(u);
      });
    } else
      Object.keys = a;
    return Object.keys || a;
  }, gh = a, gh;
}
var vh, zv;
function Ik() {
  if (zv) return vh;
  zv = 1;
  var t = G2(), e = wy(), r = Wu, a = Object, l = r("Array.prototype.push"), d = r("Object.prototype.propertyIsEnumerable"), h = e ? Object.getOwnPropertySymbols : null;
  return vh = function(u, i) {
    if (u == null)
      throw new TypeError("target must be an object");
    var c = a(u);
    if (arguments.length === 1)
      return c;
    for (var f = 1; f < arguments.length; ++f) {
      var s = a(arguments[f]), o = t(s), y = e && (Object.getOwnPropertySymbols || h);
      if (y)
        for (var m = y(s), g = 0; g < m.length; ++g) {
          var b = m[g];
          d(s, b) && l(o, b);
        }
      for (var v = 0; v < o.length; ++v) {
        var T = o[v];
        if (d(s, T)) {
          var E = s[T];
          c[T] = E;
        }
      }
    }
    return c;
  }, vh;
}
var Eh, Kv;
function Ok() {
  if (Kv) return Eh;
  Kv = 1;
  var t = Ik(), e = function() {
    if (!Object.assign)
      return !1;
    for (var a = "abcdefghijklmnopqrst", l = a.split(""), d = {}, h = 0; h < l.length; ++h)
      d[l[h]] = l[h];
    var n = Object.assign({}, d), u = "";
    for (var i in n)
      u += i;
    return a !== u;
  }, r = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var a = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(a, "xy");
    } catch {
      return a[1] === "y";
    }
    return !1;
  };
  return Eh = function() {
    return !Object.assign || e() || r() ? t : Object.assign;
  }, Eh;
}
var _h, Yv;
function z2() {
  if (Yv) return _h;
  Yv = 1;
  var t = function(e) {
    return e !== e;
  };
  return _h = function(r, a) {
    return r === 0 && a === 0 ? 1 / r === 1 / a : !!(r === a || t(r) && t(a));
  }, _h;
}
var Sh, Xv;
function Oy() {
  if (Xv) return Sh;
  Xv = 1;
  var t = z2();
  return Sh = function() {
    return typeof Object.is == "function" ? Object.is : t;
  }, Sh;
}
var wh, Jv;
function Ad() {
  if (Jv) return wh;
  Jv = 1;
  var t = G2(), e = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", r = Object.prototype.toString, a = Array.prototype.concat, l = N2, d = function(i) {
    return typeof i == "function" && r.call(i) === "[object Function]";
  }, h = M2(), n = function(i, c, f, s) {
    if (c in i) {
      if (s === !0) {
        if (i[c] === f)
          return;
      } else if (!d(s) || !s())
        return;
    }
    h ? l(i, c, f, !0) : l(i, c, f);
  }, u = function(i, c) {
    var f = arguments.length > 2 ? arguments[2] : {}, s = t(c);
    e && (s = a.call(s, Object.getOwnPropertySymbols(c)));
    for (var o = 0; o < s.length; o += 1)
      n(i, s[o], c[s[o]], f[s[o]]);
  };
  return u.supportsDescriptors = !!h, wh = u, wh;
}
var xh, Qv;
function kk() {
  if (Qv) return xh;
  Qv = 1;
  var t = Oy(), e = Ad();
  return xh = function() {
    var a = t();
    return e(Object, { is: a }, {
      is: function() {
        return Object.is !== a;
      }
    }), a;
  }, xh;
}
var Th, Zv;
function Dk() {
  if (Zv) return Th;
  Zv = 1;
  var t = Ad(), e = xd, r = z2(), a = Oy(), l = kk(), d = e(a(), Object);
  return t(d, {
    getPolyfill: a,
    implementation: r,
    shim: l
  }), Th = d, Th;
}
var Ah, eE;
function K2() {
  return eE || (eE = 1, Ah = function(e) {
    return e !== e;
  }), Ah;
}
var Ph, tE;
function Y2() {
  if (tE) return Ph;
  tE = 1;
  var t = K2();
  return Ph = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : t;
  }, Ph;
}
var Ch, rE;
function Nk() {
  if (rE) return Ch;
  rE = 1;
  var t = Ad(), e = Y2();
  return Ch = function() {
    var a = e();
    return t(Number, { isNaN: a }, {
      isNaN: function() {
        return Number.isNaN !== a;
      }
    }), a;
  }, Ch;
}
var Ih, nE;
function Rk() {
  if (nE) return Ih;
  nE = 1;
  var t = xd, e = Ad(), r = K2(), a = Y2(), l = Nk(), d = t(a(), Number);
  return e(d, {
    getPolyfill: a,
    implementation: r,
    shim: l
  }), Ih = d, Ih;
}
var Oh, iE;
function Mk() {
  if (iE) return Oh;
  iE = 1;
  function t(se, be) {
    return d(se) || l(se, be) || r(se, be) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function r(se, be) {
    if (se) {
      if (typeof se == "string") return a(se, be);
      var Ie = Object.prototype.toString.call(se).slice(8, -1);
      if (Ie === "Object" && se.constructor && (Ie = se.constructor.name), Ie === "Map" || Ie === "Set") return Array.from(se);
      if (Ie === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Ie)) return a(se, be);
    }
  }
  function a(se, be) {
    (be == null || be > se.length) && (be = se.length);
    for (var Ie = 0, Oe = new Array(be); Ie < be; Ie++) Oe[Ie] = se[Ie];
    return Oe;
  }
  function l(se, be) {
    var Ie = se == null ? null : typeof Symbol < "u" && se[Symbol.iterator] || se["@@iterator"];
    if (Ie != null) {
      var Oe, Be, Fe, ue, te = [], Y = !0, le = !1;
      try {
        if (Fe = (Ie = Ie.call(se)).next, be !== 0) for (; !(Y = (Oe = Fe.call(Ie)).done) && (te.push(Oe.value), te.length !== be); Y = !0) ;
      } catch (Ee) {
        le = !0, Be = Ee;
      } finally {
        try {
          if (!Y && Ie.return != null && (ue = Ie.return(), Object(ue) !== ue)) return;
        } finally {
          if (le) throw Be;
        }
      }
      return te;
    }
  }
  function d(se) {
    if (Array.isArray(se)) return se;
  }
  function h(se) {
    "@babel/helpers - typeof";
    return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(be) {
      return typeof be;
    } : function(be) {
      return be && typeof Symbol == "function" && be.constructor === Symbol && be !== Symbol.prototype ? "symbol" : typeof be;
    }, h(se);
  }
  var n = /a/g.flags !== void 0, u = function(be) {
    var Ie = [];
    return be.forEach(function(Oe) {
      return Ie.push(Oe);
    }), Ie;
  }, i = function(be) {
    var Ie = [];
    return be.forEach(function(Oe, Be) {
      return Ie.push([Be, Oe]);
    }), Ie;
  }, c = Object.is ? Object.is : Dk(), f = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, s = Number.isNaN ? Number.isNaN : Rk();
  function o(se) {
    return se.call.bind(se);
  }
  var y = o(Object.prototype.hasOwnProperty), m = o(Object.prototype.propertyIsEnumerable), g = o(Object.prototype.toString), b = Fi.types, v = b.isAnyArrayBuffer, T = b.isArrayBufferView, E = b.isDate, O = b.isMap, D = b.isRegExp, $ = b.isSet, I = b.isNativeError, k = b.isBoxedPrimitive, L = b.isNumberObject, M = b.isStringObject, x = b.isBooleanObject, _ = b.isBigIntObject, S = b.isSymbolObject, C = b.isFloat32Array, R = b.isFloat64Array;
  function H(se) {
    if (se.length === 0 || se.length > 10) return !0;
    for (var be = 0; be < se.length; be++) {
      var Ie = se.charCodeAt(be);
      if (Ie < 48 || Ie > 57) return !0;
    }
    return se.length === 10 && se >= Math.pow(2, 32);
  }
  function z(se) {
    return Object.keys(se).filter(H).concat(f(se).filter(Object.prototype.propertyIsEnumerable.bind(se)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function U(se, be) {
    if (se === be)
      return 0;
    for (var Ie = se.length, Oe = be.length, Be = 0, Fe = Math.min(Ie, Oe); Be < Fe; ++Be)
      if (se[Be] !== be[Be]) {
        Ie = se[Be], Oe = be[Be];
        break;
      }
    return Ie < Oe ? -1 : Oe < Ie ? 1 : 0;
  }
  var P = !0, W = !1, B = 0, Q = 1, J = 2, re = 3;
  function G(se, be) {
    return n ? se.source === be.source && se.flags === be.flags : RegExp.prototype.toString.call(se) === RegExp.prototype.toString.call(be);
  }
  function N(se, be) {
    if (se.byteLength !== be.byteLength)
      return !1;
    for (var Ie = 0; Ie < se.byteLength; Ie++)
      if (se[Ie] !== be[Ie])
        return !1;
    return !0;
  }
  function V(se, be) {
    return se.byteLength !== be.byteLength ? !1 : U(new Uint8Array(se.buffer, se.byteOffset, se.byteLength), new Uint8Array(be.buffer, be.byteOffset, be.byteLength)) === 0;
  }
  function F(se, be) {
    return se.byteLength === be.byteLength && U(new Uint8Array(se), new Uint8Array(be)) === 0;
  }
  function X(se, be) {
    return L(se) ? L(be) && c(Number.prototype.valueOf.call(se), Number.prototype.valueOf.call(be)) : M(se) ? M(be) && String.prototype.valueOf.call(se) === String.prototype.valueOf.call(be) : x(se) ? x(be) && Boolean.prototype.valueOf.call(se) === Boolean.prototype.valueOf.call(be) : _(se) ? _(be) && BigInt.prototype.valueOf.call(se) === BigInt.prototype.valueOf.call(be) : S(be) && Symbol.prototype.valueOf.call(se) === Symbol.prototype.valueOf.call(be);
  }
  function K(se, be, Ie, Oe) {
    if (se === be)
      return se !== 0 ? !0 : Ie ? c(se, be) : !0;
    if (Ie) {
      if (h(se) !== "object")
        return typeof se == "number" && s(se) && s(be);
      if (h(be) !== "object" || se === null || be === null || Object.getPrototypeOf(se) !== Object.getPrototypeOf(be))
        return !1;
    } else {
      if (se === null || h(se) !== "object")
        return be === null || h(be) !== "object" ? se == be : !1;
      if (be === null || h(be) !== "object")
        return !1;
    }
    var Be = g(se), Fe = g(be);
    if (Be !== Fe)
      return !1;
    if (Array.isArray(se)) {
      if (se.length !== be.length)
        return !1;
      var ue = z(se), te = z(be);
      return ue.length !== te.length ? !1 : fe(se, be, Ie, Oe, Q, ue);
    }
    if (Be === "[object Object]" && (!O(se) && O(be) || !$(se) && $(be)))
      return !1;
    if (E(se)) {
      if (!E(be) || Date.prototype.getTime.call(se) !== Date.prototype.getTime.call(be))
        return !1;
    } else if (D(se)) {
      if (!D(be) || !G(se, be))
        return !1;
    } else if (I(se) || se instanceof Error) {
      if (se.message !== be.message || se.name !== be.name)
        return !1;
    } else if (T(se)) {
      if (!Ie && (C(se) || R(se))) {
        if (!N(se, be))
          return !1;
      } else if (!V(se, be))
        return !1;
      var Y = z(se), le = z(be);
      return Y.length !== le.length ? !1 : fe(se, be, Ie, Oe, B, Y);
    } else {
      if ($(se))
        return !$(be) || se.size !== be.size ? !1 : fe(se, be, Ie, Oe, J);
      if (O(se))
        return !O(be) || se.size !== be.size ? !1 : fe(se, be, Ie, Oe, re);
      if (v(se)) {
        if (!F(se, be))
          return !1;
      } else if (k(se) && !X(se, be))
        return !1;
    }
    return fe(se, be, Ie, Oe, B);
  }
  function ie(se, be) {
    return be.filter(function(Ie) {
      return m(se, Ie);
    });
  }
  function fe(se, be, Ie, Oe, Be, Fe) {
    if (arguments.length === 5) {
      Fe = Object.keys(se);
      var ue = Object.keys(be);
      if (Fe.length !== ue.length)
        return !1;
    }
    for (var te = 0; te < Fe.length; te++)
      if (!y(be, Fe[te]))
        return !1;
    if (Ie && arguments.length === 5) {
      var Y = f(se);
      if (Y.length !== 0) {
        var le = 0;
        for (te = 0; te < Y.length; te++) {
          var Ee = Y[te];
          if (m(se, Ee)) {
            if (!m(be, Ee))
              return !1;
            Fe.push(Ee), le++;
          } else if (m(be, Ee))
            return !1;
        }
        var Se = f(be);
        if (Y.length !== Se.length && ie(be, Se).length !== le)
          return !1;
      } else {
        var Pe = f(be);
        if (Pe.length !== 0 && ie(be, Pe).length !== 0)
          return !1;
      }
    }
    if (Fe.length === 0 && (Be === B || Be === Q && se.length === 0 || se.size === 0))
      return !0;
    if (Oe === void 0)
      Oe = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Ve = Oe.val1.get(se);
      if (Ve !== void 0) {
        var Xe = Oe.val2.get(be);
        if (Xe !== void 0)
          return Ve === Xe;
      }
      Oe.position++;
    }
    Oe.val1.set(se, Oe.position), Oe.val2.set(be, Oe.position);
    var Ye = ye(se, be, Ie, Fe, Oe, Be);
    return Oe.val1.delete(se), Oe.val2.delete(be), Ye;
  }
  function _e(se, be, Ie, Oe) {
    for (var Be = u(se), Fe = 0; Fe < Be.length; Fe++) {
      var ue = Be[Fe];
      if (K(be, ue, Ie, Oe))
        return se.delete(ue), !0;
    }
    return !1;
  }
  function Ae(se) {
    switch (h(se)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        se = +se;
      case "number":
        if (s(se))
          return !1;
    }
    return !0;
  }
  function ce(se, be, Ie) {
    var Oe = Ae(Ie);
    return Oe ?? (be.has(Oe) && !se.has(Oe));
  }
  function ee(se, be, Ie, Oe, Be) {
    var Fe = Ae(Ie);
    if (Fe != null)
      return Fe;
    var ue = be.get(Fe);
    return ue === void 0 && !be.has(Fe) || !K(Oe, ue, !1, Be) ? !1 : !se.has(Fe) && K(Oe, ue, !1, Be);
  }
  function ae(se, be, Ie, Oe) {
    for (var Be = null, Fe = u(se), ue = 0; ue < Fe.length; ue++) {
      var te = Fe[ue];
      if (h(te) === "object" && te !== null)
        Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(te);
      else if (!be.has(te)) {
        if (Ie || !ce(se, be, te))
          return !1;
        Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(te);
      }
    }
    if (Be !== null) {
      for (var Y = u(be), le = 0; le < Y.length; le++) {
        var Ee = Y[le];
        if (h(Ee) === "object" && Ee !== null) {
          if (!_e(Be, Ee, Ie, Oe)) return !1;
        } else if (!Ie && !se.has(Ee) && !_e(Be, Ee, Ie, Oe))
          return !1;
      }
      return Be.size === 0;
    }
    return !0;
  }
  function oe(se, be, Ie, Oe, Be, Fe) {
    for (var ue = u(se), te = 0; te < ue.length; te++) {
      var Y = ue[te];
      if (K(Ie, Y, Be, Fe) && K(Oe, be.get(Y), Be, Fe))
        return se.delete(Y), !0;
    }
    return !1;
  }
  function me(se, be, Ie, Oe) {
    for (var Be = null, Fe = i(se), ue = 0; ue < Fe.length; ue++) {
      var te = t(Fe[ue], 2), Y = te[0], le = te[1];
      if (h(Y) === "object" && Y !== null)
        Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(Y);
      else {
        var Ee = be.get(Y);
        if (Ee === void 0 && !be.has(Y) || !K(le, Ee, Ie, Oe)) {
          if (Ie || !ee(se, be, Y, le, Oe)) return !1;
          Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(Y);
        }
      }
    }
    if (Be !== null) {
      for (var Se = i(be), Pe = 0; Pe < Se.length; Pe++) {
        var Ve = t(Se[Pe], 2), Xe = Ve[0], Ye = Ve[1];
        if (h(Xe) === "object" && Xe !== null) {
          if (!oe(Be, se, Xe, Ye, Ie, Oe)) return !1;
        } else if (!Ie && (!se.has(Xe) || !K(se.get(Xe), Ye, !1, Oe)) && !oe(Be, se, Xe, Ye, !1, Oe))
          return !1;
      }
      return Be.size === 0;
    }
    return !0;
  }
  function ye(se, be, Ie, Oe, Be, Fe) {
    var ue = 0;
    if (Fe === J) {
      if (!ae(se, be, Ie, Be))
        return !1;
    } else if (Fe === re) {
      if (!me(se, be, Ie, Be))
        return !1;
    } else if (Fe === Q)
      for (; ue < se.length; ue++)
        if (y(se, ue)) {
          if (!y(be, ue) || !K(se[ue], be[ue], Ie, Be))
            return !1;
        } else {
          if (y(be, ue))
            return !1;
          for (var te = Object.keys(se); ue < te.length; ue++) {
            var Y = te[ue];
            if (!y(be, Y) || !K(se[Y], be[Y], Ie, Be))
              return !1;
          }
          return te.length === Object.keys(be).length;
        }
    for (ue = 0; ue < Oe.length; ue++) {
      var le = Oe[ue];
      if (!K(se[le], be[le], Ie, Be))
        return !1;
    }
    return !0;
  }
  function we(se, be) {
    return K(se, be, W);
  }
  function ge(se, be) {
    return K(se, be, P);
  }
  return Oh = {
    isDeepEqual: we,
    isDeepStrictEqual: ge
  }, Oh;
}
var sE;
function Su() {
  if (sE) return ih.exports;
  sE = 1;
  function t(J) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(re) {
      return typeof re;
    } : function(re) {
      return re && typeof Symbol == "function" && re.constructor === Symbol && re !== Symbol.prototype ? "symbol" : typeof re;
    }, t(J);
  }
  function e(J, re, G) {
    return Object.defineProperty(J, "prototype", { writable: !1 }), J;
  }
  function r(J, re) {
    if (!(J instanceof re))
      throw new TypeError("Cannot call a class as a function");
  }
  var a = q2(), l = a.codes, d = l.ERR_AMBIGUOUS_ARGUMENT, h = l.ERR_INVALID_ARG_TYPE, n = l.ERR_INVALID_ARG_VALUE, u = l.ERR_INVALID_RETURN_VALUE, i = l.ERR_MISSING_ARGS, c = Pk(), f = Fi, s = f.inspect, o = Fi.types, y = o.isPromise, m = o.isRegExp, g = Ok()(), b = Oy()(), v = Wu("RegExp.prototype.test"), T, E;
  function O() {
    var J = Mk();
    T = J.isDeepEqual, E = J.isDeepStrictEqual;
  }
  var D = !1, $ = ih.exports = x, I = {};
  function k(J) {
    throw J.message instanceof Error ? J.message : new c(J);
  }
  function L(J, re, G, N, V) {
    var F = arguments.length, X;
    if (F === 0)
      X = "Failed";
    else if (F === 1)
      G = J, J = void 0;
    else {
      if (D === !1) {
        D = !0;
        var K = Ze.emitWarning ? Ze.emitWarning : console.warn.bind(console);
        K("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      F === 2 && (N = "!=");
    }
    if (G instanceof Error) throw G;
    var ie = {
      actual: J,
      expected: re,
      operator: N === void 0 ? "fail" : N,
      stackStartFn: V || L
    };
    G !== void 0 && (ie.message = G);
    var fe = new c(ie);
    throw X && (fe.message = X, fe.generatedMessage = !0), fe;
  }
  $.fail = L, $.AssertionError = c;
  function M(J, re, G, N) {
    if (!G) {
      var V = !1;
      if (re === 0)
        V = !0, N = "No value argument passed to `assert.ok()`";
      else if (N instanceof Error)
        throw N;
      var F = new c({
        actual: G,
        expected: !0,
        message: N,
        operator: "==",
        stackStartFn: J
      });
      throw F.generatedMessage = V, F;
    }
  }
  function x() {
    for (var J = arguments.length, re = new Array(J), G = 0; G < J; G++)
      re[G] = arguments[G];
    M.apply(void 0, [x, re.length].concat(re));
  }
  $.ok = x, $.equal = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    re != G && k({
      actual: re,
      expected: G,
      message: N,
      operator: "==",
      stackStartFn: J
    });
  }, $.notEqual = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    re == G && k({
      actual: re,
      expected: G,
      message: N,
      operator: "!=",
      stackStartFn: J
    });
  }, $.deepEqual = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    T === void 0 && O(), T(re, G) || k({
      actual: re,
      expected: G,
      message: N,
      operator: "deepEqual",
      stackStartFn: J
    });
  }, $.notDeepEqual = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    T === void 0 && O(), T(re, G) && k({
      actual: re,
      expected: G,
      message: N,
      operator: "notDeepEqual",
      stackStartFn: J
    });
  }, $.deepStrictEqual = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    T === void 0 && O(), E(re, G) || k({
      actual: re,
      expected: G,
      message: N,
      operator: "deepStrictEqual",
      stackStartFn: J
    });
  }, $.notDeepStrictEqual = _;
  function _(J, re, G) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    T === void 0 && O(), E(J, re) && k({
      actual: J,
      expected: re,
      message: G,
      operator: "notDeepStrictEqual",
      stackStartFn: _
    });
  }
  $.strictEqual = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    b(re, G) || k({
      actual: re,
      expected: G,
      message: N,
      operator: "strictEqual",
      stackStartFn: J
    });
  }, $.notStrictEqual = function J(re, G, N) {
    if (arguments.length < 2)
      throw new i("actual", "expected");
    b(re, G) && k({
      actual: re,
      expected: G,
      message: N,
      operator: "notStrictEqual",
      stackStartFn: J
    });
  };
  var S = /* @__PURE__ */ e(function J(re, G, N) {
    var V = this;
    r(this, J), G.forEach(function(F) {
      F in re && (N !== void 0 && typeof N[F] == "string" && m(re[F]) && v(re[F], N[F]) ? V[F] = N[F] : V[F] = re[F]);
    });
  });
  function C(J, re, G, N, V, F) {
    if (!(G in J) || !E(J[G], re[G])) {
      if (!N) {
        var X = new S(J, V), K = new S(re, V, J), ie = new c({
          actual: X,
          expected: K,
          operator: "deepStrictEqual",
          stackStartFn: F
        });
        throw ie.actual = J, ie.expected = re, ie.operator = F.name, ie;
      }
      k({
        actual: J,
        expected: re,
        message: N,
        operator: F.name,
        stackStartFn: F
      });
    }
  }
  function R(J, re, G, N) {
    if (typeof re != "function") {
      if (m(re)) return v(re, J);
      if (arguments.length === 2)
        throw new h("expected", ["Function", "RegExp"], re);
      if (t(J) !== "object" || J === null) {
        var V = new c({
          actual: J,
          expected: re,
          message: G,
          operator: "deepStrictEqual",
          stackStartFn: N
        });
        throw V.operator = N.name, V;
      }
      var F = Object.keys(re);
      if (re instanceof Error)
        F.push("name", "message");
      else if (F.length === 0)
        throw new n("error", re, "may not be an empty object");
      return T === void 0 && O(), F.forEach(function(X) {
        typeof J[X] == "string" && m(re[X]) && v(re[X], J[X]) || C(J, re, X, G, F, N);
      }), !0;
    }
    return re.prototype !== void 0 && J instanceof re ? !0 : Error.isPrototypeOf(re) ? !1 : re.call({}, J) === !0;
  }
  function H(J) {
    if (typeof J != "function")
      throw new h("fn", "Function", J);
    try {
      J();
    } catch (re) {
      return re;
    }
    return I;
  }
  function z(J) {
    return y(J) || J !== null && t(J) === "object" && typeof J.then == "function" && typeof J.catch == "function";
  }
  function U(J) {
    return Promise.resolve().then(function() {
      var re;
      if (typeof J == "function") {
        if (re = J(), !z(re))
          throw new u("instance of Promise", "promiseFn", re);
      } else if (z(J))
        re = J;
      else
        throw new h("promiseFn", ["Function", "Promise"], J);
      return Promise.resolve().then(function() {
        return re;
      }).then(function() {
        return I;
      }).catch(function(G) {
        return G;
      });
    });
  }
  function P(J, re, G, N) {
    if (typeof G == "string") {
      if (arguments.length === 4)
        throw new h("error", ["Object", "Error", "Function", "RegExp"], G);
      if (t(re) === "object" && re !== null) {
        if (re.message === G)
          throw new d("error/message", 'The error message "'.concat(re.message, '" is identical to the message.'));
      } else if (re === G)
        throw new d("error/message", 'The error "'.concat(re, '" is identical to the message.'));
      N = G, G = void 0;
    } else if (G != null && t(G) !== "object" && typeof G != "function")
      throw new h("error", ["Object", "Error", "Function", "RegExp"], G);
    if (re === I) {
      var V = "";
      G && G.name && (V += " (".concat(G.name, ")")), V += N ? ": ".concat(N) : ".";
      var F = J.name === "rejects" ? "rejection" : "exception";
      k({
        actual: void 0,
        expected: G,
        operator: J.name,
        message: "Missing expected ".concat(F).concat(V),
        stackStartFn: J
      });
    }
    if (G && !R(re, G, N, J))
      throw re;
  }
  function W(J, re, G, N) {
    if (re !== I) {
      if (typeof G == "string" && (N = G, G = void 0), !G || R(re, G)) {
        var V = N ? ": ".concat(N) : ".", F = J.name === "doesNotReject" ? "rejection" : "exception";
        k({
          actual: re,
          expected: G,
          operator: J.name,
          message: "Got unwanted ".concat(F).concat(V, `
`) + 'Actual message: "'.concat(re && re.message, '"'),
          stackStartFn: J
        });
      }
      throw re;
    }
  }
  $.throws = function J(re) {
    for (var G = arguments.length, N = new Array(G > 1 ? G - 1 : 0), V = 1; V < G; V++)
      N[V - 1] = arguments[V];
    P.apply(void 0, [J, H(re)].concat(N));
  }, $.rejects = function J(re) {
    for (var G = arguments.length, N = new Array(G > 1 ? G - 1 : 0), V = 1; V < G; V++)
      N[V - 1] = arguments[V];
    return U(re).then(function(F) {
      return P.apply(void 0, [J, F].concat(N));
    });
  }, $.doesNotThrow = function J(re) {
    for (var G = arguments.length, N = new Array(G > 1 ? G - 1 : 0), V = 1; V < G; V++)
      N[V - 1] = arguments[V];
    W.apply(void 0, [J, H(re)].concat(N));
  }, $.doesNotReject = function J(re) {
    for (var G = arguments.length, N = new Array(G > 1 ? G - 1 : 0), V = 1; V < G; V++)
      N[V - 1] = arguments[V];
    return U(re).then(function(F) {
      return W.apply(void 0, [J, F].concat(N));
    });
  }, $.ifError = function J(re) {
    if (re != null) {
      var G = "ifError got unwanted exception: ";
      t(re) === "object" && typeof re.message == "string" ? re.message.length === 0 && re.constructor ? G += re.constructor.name : G += re.message : G += s(re);
      var N = new c({
        actual: re,
        expected: null,
        operator: "ifError",
        message: G,
        stackStartFn: J
      }), V = re.stack;
      if (typeof V == "string") {
        var F = V.split(`
`);
        F.shift();
        for (var X = N.stack.split(`
`), K = 0; K < F.length; K++) {
          var ie = X.indexOf(F[K]);
          if (ie !== -1) {
            X = X.slice(0, ie);
            break;
          }
        }
        N.stack = "".concat(X.join(`
`), `
`).concat(F.join(`
`));
      }
      throw N;
    }
  };
  function B(J, re, G, N, V) {
    if (!m(re))
      throw new h("regexp", "RegExp", re);
    var F = V === "match";
    if (typeof J != "string" || v(re, J) !== F) {
      if (G instanceof Error)
        throw G;
      var X = !G;
      G = G || (typeof J != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(t(J), " (").concat(s(J), ")") : (F ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(s(re), `. Input:

`).concat(s(J), `
`));
      var K = new c({
        actual: J,
        expected: re,
        message: G,
        operator: V,
        stackStartFn: N
      });
      throw K.generatedMessage = X, K;
    }
  }
  $.match = function J(re, G, N) {
    B(re, G, N, J, "match");
  }, $.doesNotMatch = function J(re, G, N) {
    B(re, G, N, J, "doesNotMatch");
  };
  function Q() {
    for (var J = arguments.length, re = new Array(J), G = 0; G < J; G++)
      re[G] = arguments[G];
    M.apply(void 0, [Q, re.length].concat(re));
  }
  return $.strict = g(Q, $, {
    equal: $.strictEqual,
    deepEqual: $.deepStrictEqual,
    notEqual: $.notStrictEqual,
    notDeepEqual: $.notDeepStrictEqual
  }), $.strict.strict = $.strict, ih.exports;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.E = t.AssertionError = t.message = t.RangeError = t.TypeError = t.Error = void 0;
  const e = Su(), r = Fi, a = typeof Symbol > "u" ? "_kCode" : Symbol("code"), l = {};
  function d(y) {
    return class extends y {
      constructor(g, ...b) {
        super(u(g, b)), this.code = g, this[a] = g, this.name = `${super.name} [${this[a]}]`;
      }
    };
  }
  const h = typeof globalThis < "u" ? globalThis : jt;
  class n extends h.Error {
    constructor(m) {
      if (typeof m != "object" || m === null)
        throw new t.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
      m.message ? super(m.message) : super(`${r.inspect(m.actual).slice(0, 128)} ${m.operator} ${r.inspect(m.expected).slice(0, 128)}`), this.generatedMessage = !m.message, this.name = "AssertionError [ERR_ASSERTION]", this.code = "ERR_ASSERTION", this.actual = m.actual, this.expected = m.expected, this.operator = m.operator, t.Error.captureStackTrace(this, m.stackStartFunction);
    }
  }
  t.AssertionError = n;
  function u(y, m) {
    e.strictEqual(typeof y, "string");
    const g = l[y];
    e(g, `An invalid error message key was used: ${y}.`);
    let b;
    if (typeof g == "function")
      b = g;
    else {
      if (b = r.format, m === void 0 || m.length === 0)
        return g;
      m.unshift(g);
    }
    return String(b.apply(null, m));
  }
  t.message = u;
  function i(y, m) {
    l[y] = typeof m == "function" ? m : String(m);
  }
  t.E = i, t.Error = d(h.Error), t.TypeError = d(h.TypeError), t.RangeError = d(h.RangeError), i("ERR_ARG_NOT_ITERABLE", "%s must be iterable"), i("ERR_ASSERTION", "%s"), i("ERR_BUFFER_OUT_OF_BOUNDS", o), i("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received"), i("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s"), i("ERR_CPU_USAGE", "Unable to obtain cpu usage %s"), i("ERR_DNS_SET_SERVERS_FAILED", (y, m) => `c-ares failed to set servers: "${y}" [${m}]`), i("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value"), i("ERR_ENCODING_NOT_SUPPORTED", (y) => `The "${y}" encoding is not supported`), i("ERR_ENCODING_INVALID_ENCODED_DATA", (y) => `The encoded data was not valid for encoding ${y}`), i("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client"), i("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s"), i("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding"), i("ERR_INDEX_OUT_OF_RANGE", "Index out of range"), i("ERR_INVALID_ARG_TYPE", c), i("ERR_INVALID_ARRAY_LENGTH", (y, m, g) => (e.strictEqual(typeof g, "number"), `The array "${y}" (length ${g}) must be of length ${m}.`)), i("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s"), i("ERR_INVALID_CALLBACK", "Callback must be a function"), i("ERR_INVALID_CHAR", "Invalid character in %s"), i("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column"), i("ERR_INVALID_FD", '"fd" must be a positive integer: %s'), i("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s'), i("ERR_INVALID_FILE_URL_PATH", "File URL path %s"), i("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent"), i("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s"), i("ERR_INVALID_OPT_VALUE", (y, m) => `The value "${String(m)}" is invalid for option "${y}"`), i("ERR_INVALID_OPT_VALUE_ENCODING", (y) => `The value "${String(y)}" is invalid for option "encoding"`), i("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'), i("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s"), i("ERR_INVALID_THIS", 'Value of "this" must be of type %s'), i("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple"), i("ERR_INVALID_URL", "Invalid URL: %s"), i("ERR_INVALID_URL_SCHEME", (y) => `The URL must be ${s(y, "scheme")}`), i("ERR_IPC_CHANNEL_CLOSED", "Channel closed"), i("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected"), i("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe"), i("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks"), i("ERR_MISSING_ARGS", f), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function"), i("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object"), i("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support"), i("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported"), i("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s"), i("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound"), i("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536"), i("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6"), i("ERR_SOCKET_CANNOT_SEND", "Unable to send data"), i("ERR_SOCKET_CLOSED", "Socket is closed"), i("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running"), i("ERR_STDERR_CLOSE", "process.stderr cannot be closed"), i("ERR_STDOUT_CLOSE", "process.stdout cannot be closed"), i("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode"), i("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s"), i("ERR_TLS_DH_PARAM_SIZE", (y) => `DH parameter size ${y} is less than 2048`), i("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout"), i("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate"), i("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext'), i("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected"), i("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming"), i("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0"), i("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s"), i("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s"), i("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type"), i("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type"), i("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function c(y, m, g) {
    e(y, "name is required");
    let b;
    m.includes("not ") ? (b = "must not be", m = m.split("not ")[1]) : b = "must be";
    let v;
    if (Array.isArray(y))
      v = `The ${y.map((E) => `"${E}"`).join(", ")} arguments ${b} ${s(m, "type")}`;
    else if (y.includes(" argument"))
      v = `The ${y} ${b} ${s(m, "type")}`;
    else {
      const T = y.includes(".") ? "property" : "argument";
      v = `The "${y}" ${T} ${b} ${s(m, "type")}`;
    }
    return arguments.length >= 3 && (v += `. Received type ${g !== null ? typeof g : "null"}`), v;
  }
  function f(...y) {
    e(y.length > 0, "At least one arg needs to be specified");
    let m = "The ";
    const g = y.length;
    switch (y = y.map((b) => `"${b}"`), g) {
      case 1:
        m += `${y[0]} argument`;
        break;
      case 2:
        m += `${y[0]} and ${y[1]} arguments`;
        break;
      default:
        m += y.slice(0, g - 1).join(", "), m += `, and ${y[g - 1]} arguments`;
        break;
    }
    return `${m} must be specified`;
  }
  function s(y, m) {
    if (e(y, "expected is required"), e(typeof m == "string", "thing is required"), Array.isArray(y)) {
      const g = y.length;
      return e(g > 0, "At least one expected value needs to be specified"), y = y.map((b) => String(b)), g > 2 ? `one of ${m} ${y.slice(0, g - 1).join(", ")}, or ` + y[g - 1] : g === 2 ? `one of ${m} ${y[0]} or ${y[1]}` : `of ${m} ${y[0]}`;
    } else
      return `of ${m} ${String(y)}`;
  }
  function o(y, m) {
    return m ? "Attempt to write outside buffer bounds" : `"${y}" is outside of buffer bounds`;
  }
})(Sy);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.strToEncoding = t.assertEncoding = t.ENCODING_UTF8 = void 0;
  const e = rl, r = Sy;
  t.ENCODING_UTF8 = "utf8";
  function a(d) {
    if (d && !e.Buffer.isEncoding(d))
      throw new r.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", d);
  }
  t.assertEncoding = a;
  function l(d, h) {
    return !h || h === t.ENCODING_UTF8 ? d : h === "buffer" ? new e.Buffer(d) : new e.Buffer(d).toString(h);
  }
  t.strToEncoding = l;
})($u);
Object.defineProperty(Sl, "__esModule", { value: !0 });
Sl.Dirent = void 0;
const Lk = Us, jk = $u, { S_IFMT: Fk, S_IFDIR: Bk, S_IFREG: $k, S_IFBLK: Uk, S_IFCHR: Vk, S_IFLNK: Wk, S_IFIFO: qk, S_IFSOCK: Hk } = Lk.constants;
class Pd {
  constructor() {
    this.name = "", this.path = "", this.mode = 0;
  }
  static build(e, r) {
    const a = new Pd(), { mode: l } = e.getNode();
    return a.name = (0, jk.strToEncoding)(e.getName(), r), a.mode = l, a.path = e.getParentPath(), a;
  }
  _checkModeProperty(e) {
    return (this.mode & Fk) === e;
  }
  isDirectory() {
    return this._checkModeProperty(Bk);
  }
  isFile() {
    return this._checkModeProperty($k);
  }
  isBlockDevice() {
    return this._checkModeProperty(Uk);
  }
  isCharacterDevice() {
    return this._checkModeProperty(Vk);
  }
  isSymbolicLink() {
    return this._checkModeProperty(Wk);
  }
  isFIFO() {
    return this._checkModeProperty(qk);
  }
  isSocket() {
    return this._checkModeProperty(Hk);
  }
}
Sl.Dirent = Pd;
Sl.default = Pd;
var Mn = {};
function hs(t) {
  if (typeof t != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
}
function aE(t, e) {
  for (var r = "", a = 0, l = -1, d = 0, h, n = 0; n <= t.length; ++n) {
    if (n < t.length)
      h = t.charCodeAt(n);
    else {
      if (h === 47)
        break;
      h = 47;
    }
    if (h === 47) {
      if (!(l === n - 1 || d === 1)) if (l !== n - 1 && d === 2) {
        if (r.length < 2 || a !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            var u = r.lastIndexOf("/");
            if (u !== r.length - 1) {
              u === -1 ? (r = "", a = 0) : (r = r.slice(0, u), a = r.length - 1 - r.lastIndexOf("/")), l = n, d = 0;
              continue;
            }
          } else if (r.length === 2 || r.length === 1) {
            r = "", a = 0, l = n, d = 0;
            continue;
          }
        }
        e && (r.length > 0 ? r += "/.." : r = "..", a = 2);
      } else
        r.length > 0 ? r += "/" + t.slice(l + 1, n) : r = t.slice(l + 1, n), a = n - l - 1;
      l = n, d = 0;
    } else h === 46 && d !== -1 ? ++d : d = -1;
  }
  return r;
}
function Gk(t, e) {
  var r = e.dir || e.root, a = e.base || (e.name || "") + (e.ext || "");
  return r ? r === e.root ? r + a : r + t + a : a;
}
var Xo = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var e = "", r = !1, a, l = arguments.length - 1; l >= -1 && !r; l--) {
      var d;
      l >= 0 ? d = arguments[l] : (a === void 0 && (a = Ze.cwd()), d = a), hs(d), d.length !== 0 && (e = d + "/" + e, r = d.charCodeAt(0) === 47);
    }
    return e = aE(e, !r), r ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
  },
  normalize: function(e) {
    if (hs(e), e.length === 0) return ".";
    var r = e.charCodeAt(0) === 47, a = e.charCodeAt(e.length - 1) === 47;
    return e = aE(e, !r), e.length === 0 && !r && (e = "."), e.length > 0 && a && (e += "/"), r ? "/" + e : e;
  },
  isAbsolute: function(e) {
    return hs(e), e.length > 0 && e.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var e, r = 0; r < arguments.length; ++r) {
      var a = arguments[r];
      hs(a), a.length > 0 && (e === void 0 ? e = a : e += "/" + a);
    }
    return e === void 0 ? "." : Xo.normalize(e);
  },
  relative: function(e, r) {
    if (hs(e), hs(r), e === r || (e = Xo.resolve(e), r = Xo.resolve(r), e === r)) return "";
    for (var a = 1; a < e.length && e.charCodeAt(a) === 47; ++a)
      ;
    for (var l = e.length, d = l - a, h = 1; h < r.length && r.charCodeAt(h) === 47; ++h)
      ;
    for (var n = r.length, u = n - h, i = d < u ? d : u, c = -1, f = 0; f <= i; ++f) {
      if (f === i) {
        if (u > i) {
          if (r.charCodeAt(h + f) === 47)
            return r.slice(h + f + 1);
          if (f === 0)
            return r.slice(h + f);
        } else d > i && (e.charCodeAt(a + f) === 47 ? c = f : f === 0 && (c = 0));
        break;
      }
      var s = e.charCodeAt(a + f), o = r.charCodeAt(h + f);
      if (s !== o)
        break;
      s === 47 && (c = f);
    }
    var y = "";
    for (f = a + c + 1; f <= l; ++f)
      (f === l || e.charCodeAt(f) === 47) && (y.length === 0 ? y += ".." : y += "/..");
    return y.length > 0 ? y + r.slice(h + c) : (h += c, r.charCodeAt(h) === 47 && ++h, r.slice(h));
  },
  _makeLong: function(e) {
    return e;
  },
  dirname: function(e) {
    if (hs(e), e.length === 0) return ".";
    for (var r = e.charCodeAt(0), a = r === 47, l = -1, d = !0, h = e.length - 1; h >= 1; --h)
      if (r = e.charCodeAt(h), r === 47) {
        if (!d) {
          l = h;
          break;
        }
      } else
        d = !1;
    return l === -1 ? a ? "/" : "." : a && l === 1 ? "//" : e.slice(0, l);
  },
  basename: function(e, r) {
    if (r !== void 0 && typeof r != "string") throw new TypeError('"ext" argument must be a string');
    hs(e);
    var a = 0, l = -1, d = !0, h;
    if (r !== void 0 && r.length > 0 && r.length <= e.length) {
      if (r.length === e.length && r === e) return "";
      var n = r.length - 1, u = -1;
      for (h = e.length - 1; h >= 0; --h) {
        var i = e.charCodeAt(h);
        if (i === 47) {
          if (!d) {
            a = h + 1;
            break;
          }
        } else
          u === -1 && (d = !1, u = h + 1), n >= 0 && (i === r.charCodeAt(n) ? --n === -1 && (l = h) : (n = -1, l = u));
      }
      return a === l ? l = u : l === -1 && (l = e.length), e.slice(a, l);
    } else {
      for (h = e.length - 1; h >= 0; --h)
        if (e.charCodeAt(h) === 47) {
          if (!d) {
            a = h + 1;
            break;
          }
        } else l === -1 && (d = !1, l = h + 1);
      return l === -1 ? "" : e.slice(a, l);
    }
  },
  extname: function(e) {
    hs(e);
    for (var r = -1, a = 0, l = -1, d = !0, h = 0, n = e.length - 1; n >= 0; --n) {
      var u = e.charCodeAt(n);
      if (u === 47) {
        if (!d) {
          a = n + 1;
          break;
        }
        continue;
      }
      l === -1 && (d = !1, l = n + 1), u === 46 ? r === -1 ? r = n : h !== 1 && (h = 1) : r !== -1 && (h = -1);
    }
    return r === -1 || l === -1 || // We saw a non-dot character immediately before the dot
    h === 0 || // The (right-most) trimmed path component is exactly '..'
    h === 1 && r === l - 1 && r === a + 1 ? "" : e.slice(r, l);
  },
  format: function(e) {
    if (e === null || typeof e != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
    return Gk("/", e);
  },
  parse: function(e) {
    hs(e);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (e.length === 0) return r;
    var a = e.charCodeAt(0), l = a === 47, d;
    l ? (r.root = "/", d = 1) : d = 0;
    for (var h = -1, n = 0, u = -1, i = !0, c = e.length - 1, f = 0; c >= d; --c) {
      if (a = e.charCodeAt(c), a === 47) {
        if (!i) {
          n = c + 1;
          break;
        }
        continue;
      }
      u === -1 && (i = !1, u = c + 1), a === 46 ? h === -1 ? h = c : f !== 1 && (f = 1) : h !== -1 && (f = -1);
    }
    return h === -1 || u === -1 || // We saw a non-dot character immediately before the dot
    f === 0 || // The (right-most) trimmed path component is exactly '..'
    f === 1 && h === u - 1 && h === n + 1 ? u !== -1 && (n === 0 && l ? r.base = r.name = e.slice(1, u) : r.base = r.name = e.slice(n, u)) : (n === 0 && l ? (r.name = e.slice(1, h), r.base = e.slice(1, u)) : (r.name = e.slice(n, h), r.base = e.slice(n, u)), r.ext = e.slice(h, u)), n > 0 ? r.dir = e.slice(0, n - 1) : l && (r.dir = "/"), r;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Xo.posix = Xo;
var Qr = Xo, X2 = {}, xl = {};
const ky = /* @__PURE__ */ vd(N7);
Object.defineProperty(xl, "__esModule", { value: !0 });
xl.createProcess = void 0;
const zk = () => {
  if (typeof Ze < "u")
    return Ze;
  try {
    return ky;
  } catch {
    return;
  }
};
function J2() {
  const t = zk() || {};
  return t.cwd || (t.cwd = () => "/"), t.emitWarning || (t.emitWarning = (e, r) => {
    console.warn(`${r}${r ? ": " : ""}${e}`);
  }), t.env || (t.env = {}), t;
}
xl.createProcess = J2;
xl.default = J2();
var Dy = { exports: {} }, Jo = typeof Reflect == "object" ? Reflect : null, oE = Jo && typeof Jo.apply == "function" ? Jo.apply : function(e, r, a) {
  return Function.prototype.apply.call(e, r, a);
}, bf;
Jo && typeof Jo.ownKeys == "function" ? bf = Jo.ownKeys : Object.getOwnPropertySymbols ? bf = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : bf = function(e) {
  return Object.getOwnPropertyNames(e);
};
function Kk(t) {
  console && console.warn && console.warn(t);
}
var Q2 = Number.isNaN || function(e) {
  return e !== e;
};
function Mr() {
  Mr.init.call(this);
}
Dy.exports = Mr;
Dy.exports.once = Qk;
Mr.EventEmitter = Mr;
Mr.prototype._events = void 0;
Mr.prototype._eventsCount = 0;
Mr.prototype._maxListeners = void 0;
var lE = 10;
function Cd(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(Mr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return lE;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || Q2(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    lE = t;
  }
});
Mr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Mr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || Q2(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function Z2(t) {
  return t._maxListeners === void 0 ? Mr.defaultMaxListeners : t._maxListeners;
}
Mr.prototype.getMaxListeners = function() {
  return Z2(this);
};
Mr.prototype.emit = function(e) {
  for (var r = [], a = 1; a < arguments.length; a++) r.push(arguments[a]);
  var l = e === "error", d = this._events;
  if (d !== void 0)
    l = l && d.error === void 0;
  else if (!l)
    return !1;
  if (l) {
    var h;
    if (r.length > 0 && (h = r[0]), h instanceof Error)
      throw h;
    var n = new Error("Unhandled error." + (h ? " (" + h.message + ")" : ""));
    throw n.context = h, n;
  }
  var u = d[e];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    oE(u, this, r);
  else
    for (var i = u.length, c = ix(u, i), a = 0; a < i; ++a)
      oE(c[a], this, r);
  return !0;
};
function ex(t, e, r, a) {
  var l, d, h;
  if (Cd(r), d = t._events, d === void 0 ? (d = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (d.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), d = t._events), h = d[e]), h === void 0)
    h = d[e] = r, ++t._eventsCount;
  else if (typeof h == "function" ? h = d[e] = a ? [r, h] : [h, r] : a ? h.unshift(r) : h.push(r), l = Z2(t), l > 0 && h.length > l && !h.warned) {
    h.warned = !0;
    var n = new Error("Possible EventEmitter memory leak detected. " + h.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    n.name = "MaxListenersExceededWarning", n.emitter = t, n.type = e, n.count = h.length, Kk(n);
  }
  return t;
}
Mr.prototype.addListener = function(e, r) {
  return ex(this, e, r, !1);
};
Mr.prototype.on = Mr.prototype.addListener;
Mr.prototype.prependListener = function(e, r) {
  return ex(this, e, r, !0);
};
function Yk() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function tx(t, e, r) {
  var a = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, l = Yk.bind(a);
  return l.listener = r, a.wrapFn = l, l;
}
Mr.prototype.once = function(e, r) {
  return Cd(r), this.on(e, tx(this, e, r)), this;
};
Mr.prototype.prependOnceListener = function(e, r) {
  return Cd(r), this.prependListener(e, tx(this, e, r)), this;
};
Mr.prototype.removeListener = function(e, r) {
  var a, l, d, h, n;
  if (Cd(r), l = this._events, l === void 0)
    return this;
  if (a = l[e], a === void 0)
    return this;
  if (a === r || a.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete l[e], l.removeListener && this.emit("removeListener", e, a.listener || r));
  else if (typeof a != "function") {
    for (d = -1, h = a.length - 1; h >= 0; h--)
      if (a[h] === r || a[h].listener === r) {
        n = a[h].listener, d = h;
        break;
      }
    if (d < 0)
      return this;
    d === 0 ? a.shift() : Xk(a, d), a.length === 1 && (l[e] = a[0]), l.removeListener !== void 0 && this.emit("removeListener", e, n || r);
  }
  return this;
};
Mr.prototype.off = Mr.prototype.removeListener;
Mr.prototype.removeAllListeners = function(e) {
  var r, a, l;
  if (a = this._events, a === void 0)
    return this;
  if (a.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : a[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete a[e]), this;
  if (arguments.length === 0) {
    var d = Object.keys(a), h;
    for (l = 0; l < d.length; ++l)
      h = d[l], h !== "removeListener" && this.removeAllListeners(h);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = a[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (l = r.length - 1; l >= 0; l--)
      this.removeListener(e, r[l]);
  return this;
};
function rx(t, e, r) {
  var a = t._events;
  if (a === void 0)
    return [];
  var l = a[e];
  return l === void 0 ? [] : typeof l == "function" ? r ? [l.listener || l] : [l] : r ? Jk(l) : ix(l, l.length);
}
Mr.prototype.listeners = function(e) {
  return rx(this, e, !0);
};
Mr.prototype.rawListeners = function(e) {
  return rx(this, e, !1);
};
Mr.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : nx.call(t, e);
};
Mr.prototype.listenerCount = nx;
function nx(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Mr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? bf(this._events) : [];
};
function ix(t, e) {
  for (var r = new Array(e), a = 0; a < e; ++a)
    r[a] = t[a];
  return r;
}
function Xk(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function Jk(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function Qk(t, e) {
  return new Promise(function(r, a) {
    function l(h) {
      t.removeListener(e, d), a(h);
    }
    function d() {
      typeof t.removeListener == "function" && t.removeListener("error", l), r([].slice.call(arguments));
    }
    sx(t, e, d, { once: !0 }), e !== "error" && Zk(t, l, { once: !0 });
  });
}
function Zk(t, e, r) {
  typeof t.on == "function" && sx(t, "error", e, r);
}
function sx(t, e, r, a) {
  if (typeof t.on == "function")
    a.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function l(d) {
      a.once && t.removeEventListener(e, l), r(d);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var po = Dy.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.File = t.Link = t.Node = t.SEP = void 0;
  const e = xl, r = rl, a = Us, l = po, d = fo, { S_IFMT: h, S_IFDIR: n, S_IFREG: u, S_IFLNK: i, O_APPEND: c } = a.constants, f = () => {
    var g, b;
    return (b = (g = e.default.getuid) === null || g === void 0 ? void 0 : g.call(e.default)) !== null && b !== void 0 ? b : 0;
  }, s = () => {
    var g, b;
    return (b = (g = e.default.getgid) === null || g === void 0 ? void 0 : g.call(e.default)) !== null && b !== void 0 ? b : 0;
  };
  t.SEP = "/";
  class o extends l.EventEmitter {
    constructor(b, v = 438) {
      super(), this._uid = f(), this._gid = s(), this._atime = /* @__PURE__ */ new Date(), this._mtime = /* @__PURE__ */ new Date(), this._ctime = /* @__PURE__ */ new Date(), this._perm = 438, this.mode = u, this._nlink = 1, this._perm = v, this.mode |= v, this.ino = b;
    }
    set ctime(b) {
      this._ctime = b;
    }
    get ctime() {
      return this._ctime;
    }
    set uid(b) {
      this._uid = b, this.ctime = /* @__PURE__ */ new Date();
    }
    get uid() {
      return this._uid;
    }
    set gid(b) {
      this._gid = b, this.ctime = /* @__PURE__ */ new Date();
    }
    get gid() {
      return this._gid;
    }
    set atime(b) {
      this._atime = b, this.ctime = /* @__PURE__ */ new Date();
    }
    get atime() {
      return this._atime;
    }
    set mtime(b) {
      this._mtime = b, this.ctime = /* @__PURE__ */ new Date();
    }
    get mtime() {
      return this._mtime;
    }
    set perm(b) {
      this._perm = b, this.ctime = /* @__PURE__ */ new Date();
    }
    get perm() {
      return this._perm;
    }
    set nlink(b) {
      this._nlink = b, this.ctime = /* @__PURE__ */ new Date();
    }
    get nlink() {
      return this._nlink;
    }
    getString(b = "utf8") {
      return this.atime = /* @__PURE__ */ new Date(), this.getBuffer().toString(b);
    }
    setString(b) {
      this.buf = (0, r.bufferFrom)(b, "utf8"), this.touch();
    }
    getBuffer() {
      return this.atime = /* @__PURE__ */ new Date(), this.buf || this.setBuffer((0, r.bufferAllocUnsafe)(0)), (0, r.bufferFrom)(this.buf);
    }
    setBuffer(b) {
      this.buf = (0, r.bufferFrom)(b), this.touch();
    }
    getSize() {
      return this.buf ? this.buf.length : 0;
    }
    setModeProperty(b) {
      this.mode = this.mode & ~h | b;
    }
    setIsFile() {
      this.setModeProperty(u);
    }
    setIsDirectory() {
      this.setModeProperty(n);
    }
    setIsSymlink() {
      this.setModeProperty(i);
    }
    isFile() {
      return (this.mode & h) === u;
    }
    isDirectory() {
      return (this.mode & h) === n;
    }
    isSymlink() {
      return (this.mode & h) === i;
    }
    makeSymlink(b) {
      this.symlink = b, this.setIsSymlink();
    }
    write(b, v = 0, T = b.length, E = 0) {
      if (this.buf || (this.buf = (0, r.bufferAllocUnsafe)(0)), E + T > this.buf.length) {
        const O = (0, r.bufferAllocUnsafe)(E + T);
        this.buf.copy(O, 0, 0, this.buf.length), this.buf = O;
      }
      return b.copy(this.buf, E, v, v + T), this.touch(), T;
    }
    // Returns the number of bytes read.
    read(b, v = 0, T = b.byteLength, E = 0) {
      this.atime = /* @__PURE__ */ new Date(), this.buf || (this.buf = (0, r.bufferAllocUnsafe)(0));
      let O = T;
      O > b.byteLength && (O = b.byteLength), O + E > this.buf.length && (O = this.buf.length - E);
      const D = b instanceof r.Buffer ? b : r.Buffer.from(b.buffer);
      return this.buf.copy(D, v, E, E + O), O;
    }
    truncate(b = 0) {
      if (!b)
        this.buf = (0, r.bufferAllocUnsafe)(0);
      else if (this.buf || (this.buf = (0, r.bufferAllocUnsafe)(0)), b <= this.buf.length)
        this.buf = this.buf.slice(0, b);
      else {
        const v = (0, r.bufferAllocUnsafe)(b);
        this.buf.copy(v), v.fill(0, this.buf.length), this.buf = v;
      }
      this.touch();
    }
    chmod(b) {
      this.perm = b, this.mode = this.mode & -512 | b, this.touch();
    }
    chown(b, v) {
      this.uid = b, this.gid = v, this.touch();
    }
    touch() {
      this.mtime = /* @__PURE__ */ new Date(), this.emit("change", this);
    }
    canRead(b = f(), v = s()) {
      return !!(this.perm & 4 || v === this.gid && this.perm & 32 || b === this.uid && this.perm & 256);
    }
    canWrite(b = f(), v = s()) {
      return !!(this.perm & 2 || v === this.gid && this.perm & 16 || b === this.uid && this.perm & 128);
    }
    del() {
      this.emit("delete", this);
    }
    toJSON() {
      return {
        ino: this.ino,
        uid: this.uid,
        gid: this.gid,
        atime: this.atime.getTime(),
        mtime: this.mtime.getTime(),
        ctime: this.ctime.getTime(),
        perm: this.perm,
        mode: this.mode,
        nlink: this.nlink,
        symlink: this.symlink,
        data: this.getString()
      };
    }
  }
  t.Node = o;
  class y extends l.EventEmitter {
    get steps() {
      return this._steps;
    }
    // Recursively sync children steps, e.g. in case of dir rename
    set steps(b) {
      this._steps = b;
      for (const [v, T] of this.children.entries())
        v === "." || v === ".." || T == null || T.syncSteps();
    }
    constructor(b, v, T) {
      super(), this.children = /* @__PURE__ */ new Map(), this._steps = [], this.ino = 0, this.length = 0, this.vol = b, this.parent = v, this.name = T, this.syncSteps();
    }
    setNode(b) {
      this.node = b, this.ino = b.ino;
    }
    getNode() {
      return this.node;
    }
    createChild(b, v = this.vol.createNode()) {
      const T = new y(this.vol, this, b);
      return T.setNode(v), v.isDirectory() && (T.children.set(".", T), T.getNode().nlink++), this.setChild(b, T), T;
    }
    setChild(b, v = new y(this.vol, this, b)) {
      return this.children.set(b, v), v.parent = this, this.length++, v.getNode().isDirectory() && (v.children.set("..", this), this.getNode().nlink++), this.getNode().mtime = /* @__PURE__ */ new Date(), this.emit("child:add", v, this), v;
    }
    deleteChild(b) {
      b.getNode().isDirectory() && (b.children.delete(".."), this.getNode().nlink--), this.children.delete(b.getName()), this.length--, this.getNode().mtime = /* @__PURE__ */ new Date(), this.emit("child:delete", b, this);
    }
    getChild(b) {
      return this.getNode().mtime = /* @__PURE__ */ new Date(), this.children.get(b);
    }
    getPath() {
      return this.steps.join(t.SEP);
    }
    getParentPath() {
      return this.steps.slice(0, -1).join(t.SEP);
    }
    getName() {
      return this.steps[this.steps.length - 1];
    }
    // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }
    /**
     * Walk the tree path and return the `Link` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the `steps` array.
     *
     * @return {Link|null}
     */
    walk(b, v = b.length, T = 0) {
      if (T >= b.length)
        return this;
      if (T >= v)
        return this;
      const E = b[T], O = this.getChild(E);
      return O ? O.walk(b, v, T + 1) : null;
    }
    toJSON() {
      return {
        steps: this.steps,
        ino: this.ino,
        children: Array.from(this.children.keys())
      };
    }
    syncSteps() {
      this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
    }
  }
  t.Link = y;
  class m {
    /**
     * Open a Link-Node pair. `node` is provided separately as that might be a different node
     * rather the one `link` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    constructor(b, v, T, E) {
      this.link = b, this.node = v, this.flags = T, this.fd = E, this.position = 0, this.flags & c && (this.position = this.getSize());
    }
    getString(b = "utf8") {
      return this.node.getString();
    }
    setString(b) {
      this.node.setString(b);
    }
    getBuffer() {
      return this.node.getBuffer();
    }
    setBuffer(b) {
      this.node.setBuffer(b);
    }
    getSize() {
      return this.node.getSize();
    }
    truncate(b) {
      this.node.truncate(b);
    }
    seekTo(b) {
      this.position = b;
    }
    stats() {
      return d.default.build(this.node);
    }
    write(b, v = 0, T = b.length, E) {
      typeof E != "number" && (E = this.position);
      const O = this.node.write(b, v, T, E);
      return this.position = E + O, O;
    }
    read(b, v = 0, T = b.byteLength, E) {
      typeof E != "number" && (E = this.position);
      const O = this.node.read(b, v, T, E);
      return this.position = E + O, O;
    }
    chmod(b) {
      this.node.chmod(b);
    }
    chown(b, v) {
      this.node.chown(b, v);
    }
  }
  t.File = m;
})(X2);
var Ny = {};
Object.defineProperty(Ny, "__esModule", { value: !0 });
let I0;
typeof setImmediate == "function" ? I0 = setImmediate.bind(typeof globalThis < "u" ? globalThis : jt) : I0 = setTimeout.bind(typeof globalThis < "u" ? globalThis : jt);
Ny.default = I0;
var Id = {};
Object.defineProperty(Id, "__esModule", { value: !0 });
Id.default = typeof queueMicrotask == "function" ? queueMicrotask : (t) => Promise.resolve().then(() => t()).catch(() => {
});
var Ry = {};
Object.defineProperty(Ry, "__esModule", { value: !0 });
function e8(t, e, r) {
  const a = setTimeout.apply(typeof globalThis < "u" ? globalThis : jt, arguments);
  return a && typeof a == "object" && typeof a.unref == "function" && a.unref(), a;
}
Ry.default = e8;
const t8 = {}, r8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: t8
}, Symbol.toStringTag, { value: "Module" })), Rr = /* @__PURE__ */ vd(r8);
var Od = {}, qu = {}, Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.FLAGS = Aa.ERRSTR = void 0;
const n8 = Us;
Aa.ERRSTR = {
  PATH_STR: "path must be a string or Buffer",
  // FD:             'file descriptor must be a unsigned 32-bit integer',
  FD: "fd must be a file descriptor",
  MODE_INT: "mode must be an int",
  CB: "callback must be a function",
  UID: "uid must be an unsigned int",
  GID: "gid must be an unsigned int",
  LEN: "len must be an integer",
  ATIME: "atime must be an integer",
  MTIME: "mtime must be an integer",
  PREFIX: "filename prefix is required",
  BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
  OFFSET: "offset must be an integer",
  LENGTH: "length must be an integer",
  POSITION: "position must be an integer"
};
const { O_RDONLY: uE, O_WRONLY: Oc, O_RDWR: Ro, O_CREAT: pa, O_EXCL: kc, O_TRUNC: Dc, O_APPEND: Nc, O_SYNC: cE } = n8.constants;
var fE;
(function(t) {
  t[t.r = uE] = "r", t[t["r+"] = Ro] = "r+", t[t.rs = uE | cE] = "rs", t[t.sr = t.rs] = "sr", t[t["rs+"] = Ro | cE] = "rs+", t[t["sr+"] = t["rs+"]] = "sr+", t[t.w = Oc | pa | Dc] = "w", t[t.wx = Oc | pa | Dc | kc] = "wx", t[t.xw = t.wx] = "xw", t[t["w+"] = Ro | pa | Dc] = "w+", t[t["wx+"] = Ro | pa | Dc | kc] = "wx+", t[t["xw+"] = t["wx+"]] = "xw+", t[t.a = Oc | Nc | pa] = "a", t[t.ax = Oc | Nc | pa | kc] = "ax", t[t.xa = t.ax] = "xa", t[t["a+"] = Ro | Nc | pa] = "a+", t[t["ax+"] = Ro | Nc | pa | kc] = "ax+", t[t["xa+"] = t["ax+"]] = "xa+";
})(fE || (Aa.FLAGS = fE = {}));
var Ns = {}, Ff = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
Ff.exports;
(function(t, e) {
  (function(r) {
    var a = e && !e.nodeType && e, l = t && !t.nodeType && t, d = typeof jt == "object" && jt;
    (d.global === d || d.window === d || d.self === d) && (r = d);
    var h, n = 2147483647, u = 36, i = 1, c = 26, f = 38, s = 700, o = 72, y = 128, m = "-", g = /^xn--/, b = /[^\x20-\x7E]/, v = /[\x2E\u3002\uFF0E\uFF61]/g, T = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, E = u - i, O = Math.floor, D = String.fromCharCode, $;
    function I(P) {
      throw new RangeError(T[P]);
    }
    function k(P, W) {
      for (var B = P.length, Q = []; B--; )
        Q[B] = W(P[B]);
      return Q;
    }
    function L(P, W) {
      var B = P.split("@"), Q = "";
      B.length > 1 && (Q = B[0] + "@", P = B[1]), P = P.replace(v, ".");
      var J = P.split("."), re = k(J, W).join(".");
      return Q + re;
    }
    function M(P) {
      for (var W = [], B = 0, Q = P.length, J, re; B < Q; )
        J = P.charCodeAt(B++), J >= 55296 && J <= 56319 && B < Q ? (re = P.charCodeAt(B++), (re & 64512) == 56320 ? W.push(((J & 1023) << 10) + (re & 1023) + 65536) : (W.push(J), B--)) : W.push(J);
      return W;
    }
    function x(P) {
      return k(P, function(W) {
        var B = "";
        return W > 65535 && (W -= 65536, B += D(W >>> 10 & 1023 | 55296), W = 56320 | W & 1023), B += D(W), B;
      }).join("");
    }
    function _(P) {
      return P - 48 < 10 ? P - 22 : P - 65 < 26 ? P - 65 : P - 97 < 26 ? P - 97 : u;
    }
    function S(P, W) {
      return P + 22 + 75 * (P < 26) - ((W != 0) << 5);
    }
    function C(P, W, B) {
      var Q = 0;
      for (P = B ? O(P / s) : P >> 1, P += O(P / W); P > E * c >> 1; Q += u)
        P = O(P / E);
      return O(Q + (E + 1) * P / (P + f));
    }
    function R(P) {
      var W = [], B = P.length, Q, J = 0, re = y, G = o, N, V, F, X, K, ie, fe, _e, Ae;
      for (N = P.lastIndexOf(m), N < 0 && (N = 0), V = 0; V < N; ++V)
        P.charCodeAt(V) >= 128 && I("not-basic"), W.push(P.charCodeAt(V));
      for (F = N > 0 ? N + 1 : 0; F < B; ) {
        for (X = J, K = 1, ie = u; F >= B && I("invalid-input"), fe = _(P.charCodeAt(F++)), (fe >= u || fe > O((n - J) / K)) && I("overflow"), J += fe * K, _e = ie <= G ? i : ie >= G + c ? c : ie - G, !(fe < _e); ie += u)
          Ae = u - _e, K > O(n / Ae) && I("overflow"), K *= Ae;
        Q = W.length + 1, G = C(J - X, Q, X == 0), O(J / Q) > n - re && I("overflow"), re += O(J / Q), J %= Q, W.splice(J++, 0, re);
      }
      return x(W);
    }
    function H(P) {
      var W, B, Q, J, re, G, N, V, F, X, K, ie = [], fe, _e, Ae, ce;
      for (P = M(P), fe = P.length, W = y, B = 0, re = o, G = 0; G < fe; ++G)
        K = P[G], K < 128 && ie.push(D(K));
      for (Q = J = ie.length, J && ie.push(m); Q < fe; ) {
        for (N = n, G = 0; G < fe; ++G)
          K = P[G], K >= W && K < N && (N = K);
        for (_e = Q + 1, N - W > O((n - B) / _e) && I("overflow"), B += (N - W) * _e, W = N, G = 0; G < fe; ++G)
          if (K = P[G], K < W && ++B > n && I("overflow"), K == W) {
            for (V = B, F = u; X = F <= re ? i : F >= re + c ? c : F - re, !(V < X); F += u)
              ce = V - X, Ae = u - X, ie.push(
                D(S(X + ce % Ae, 0))
              ), V = O(ce / Ae);
            ie.push(D(S(V, 0))), re = C(B, _e, Q == J), B = 0, ++Q;
          }
        ++B, ++W;
      }
      return ie.join("");
    }
    function z(P) {
      return L(P, function(W) {
        return g.test(W) ? R(W.slice(4).toLowerCase()) : W;
      });
    }
    function U(P) {
      return L(P, function(W) {
        return b.test(W) ? "xn--" + H(W) : W;
      });
    }
    if (h = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: M,
        encode: x
      },
      decode: R,
      encode: H,
      toASCII: U,
      toUnicode: z
    }, a && l)
      if (t.exports == a)
        l.exports = h;
      else
        for ($ in h)
          h.hasOwnProperty($) && (a[$] = h[$]);
    else
      r.punycode = h;
  })(jt);
})(Ff, Ff.exports);
var i8 = Ff.exports, My = typeof Map == "function" && Map.prototype, kh = Object.getOwnPropertyDescriptor && My ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Bf = My && kh && typeof kh.get == "function" ? kh.get : null, dE = My && Map.prototype.forEach, Ly = typeof Set == "function" && Set.prototype, Dh = Object.getOwnPropertyDescriptor && Ly ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, $f = Ly && Dh && typeof Dh.get == "function" ? Dh.get : null, pE = Ly && Set.prototype.forEach, s8 = typeof WeakMap == "function" && WeakMap.prototype, du = s8 ? WeakMap.prototype.has : null, a8 = typeof WeakSet == "function" && WeakSet.prototype, pu = a8 ? WeakSet.prototype.has : null, o8 = typeof WeakRef == "function" && WeakRef.prototype, hE = o8 ? WeakRef.prototype.deref : null, l8 = Boolean.prototype.valueOf, u8 = Object.prototype.toString, c8 = Function.prototype.toString, f8 = String.prototype.match, jy = String.prototype.slice, ga = String.prototype.replace, d8 = String.prototype.toUpperCase, mE = String.prototype.toLowerCase, ax = RegExp.prototype.test, yE = Array.prototype.concat, _s = Array.prototype.join, p8 = Array.prototype.slice, bE = Math.floor, O0 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Nh = Object.getOwnPropertySymbols, k0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, il = typeof Symbol == "function" && typeof Symbol.iterator == "object", ti = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === il || !0) ? Symbol.toStringTag : null, ox = Object.prototype.propertyIsEnumerable, gE = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
  return t.__proto__;
} : null);
function vE(t, e) {
  if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || ax.call(/e/, e))
    return e;
  var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof t == "number") {
    var a = t < 0 ? -bE(-t) : bE(t);
    if (a !== t) {
      var l = String(a), d = jy.call(e, l.length + 1);
      return ga.call(l, r, "$&_") + "." + ga.call(ga.call(d, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return ga.call(e, r, "$&_");
}
var D0 = Rr, EE = D0.custom, _E = ux(EE) ? EE : null, h8 = function t(e, r, a, l) {
  var d = r || {};
  if (ma(d, "quoteStyle") && d.quoteStyle !== "single" && d.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (ma(d, "maxStringLength") && (typeof d.maxStringLength == "number" ? d.maxStringLength < 0 && d.maxStringLength !== 1 / 0 : d.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var h = ma(d, "customInspect") ? d.customInspect : !0;
  if (typeof h != "boolean" && h !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (ma(d, "indent") && d.indent !== null && d.indent !== "	" && !(parseInt(d.indent, 10) === d.indent && d.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (ma(d, "numericSeparator") && typeof d.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var n = d.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return fx(e, d);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var u = String(e);
    return n ? vE(e, u) : u;
  }
  if (typeof e == "bigint") {
    var i = String(e) + "n";
    return n ? vE(e, i) : i;
  }
  var c = typeof d.depth > "u" ? 5 : d.depth;
  if (typeof a > "u" && (a = 0), a >= c && c > 0 && typeof e == "object")
    return N0(e) ? "[Array]" : "[Object]";
  var f = D8(d, a);
  if (typeof l > "u")
    l = [];
  else if (cx(l, e) >= 0)
    return "[Circular]";
  function s(_, S, C) {
    if (S && (l = p8.call(l), l.push(S)), C) {
      var R = {
        depth: d.depth
      };
      return ma(d, "quoteStyle") && (R.quoteStyle = d.quoteStyle), t(_, R, a + 1, l);
    }
    return t(_, d, a + 1, l);
  }
  if (typeof e == "function" && !SE(e)) {
    var o = w8(e), y = Rc(e, s);
    return "[Function" + (o ? ": " + o : " (anonymous)") + "]" + (y.length > 0 ? " { " + _s.call(y, ", ") + " }" : "");
  }
  if (ux(e)) {
    var m = il ? ga.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : k0.call(e);
    return typeof e == "object" && !il ? Vl(m) : m;
  }
  if (I8(e)) {
    for (var g = "<" + mE.call(String(e.nodeName)), b = e.attributes || [], v = 0; v < b.length; v++)
      g += " " + b[v].name + "=" + lx(m8(b[v].value), "double", d);
    return g += ">", e.childNodes && e.childNodes.length && (g += "..."), g += "</" + mE.call(String(e.nodeName)) + ">", g;
  }
  if (N0(e)) {
    if (e.length === 0)
      return "[]";
    var T = Rc(e, s);
    return f && !k8(T) ? "[" + R0(T, f) + "]" : "[ " + _s.call(T, ", ") + " ]";
  }
  if (b8(e)) {
    var E = Rc(e, s);
    return !("cause" in Error.prototype) && "cause" in e && !ox.call(e, "cause") ? "{ [" + String(e) + "] " + _s.call(yE.call("[cause]: " + s(e.cause), E), ", ") + " }" : E.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + _s.call(E, ", ") + " }";
  }
  if (typeof e == "object" && h) {
    if (_E && typeof e[_E] == "function" && D0)
      return D0(e, { depth: c - a });
    if (h !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (x8(e)) {
    var O = [];
    return dE && dE.call(e, function(_, S) {
      O.push(s(S, e, !0) + " => " + s(_, e));
    }), wE("Map", Bf.call(e), O, f);
  }
  if (P8(e)) {
    var D = [];
    return pE && pE.call(e, function(_) {
      D.push(s(_, e));
    }), wE("Set", $f.call(e), D, f);
  }
  if (T8(e))
    return Rh("WeakMap");
  if (C8(e))
    return Rh("WeakSet");
  if (A8(e))
    return Rh("WeakRef");
  if (v8(e))
    return Vl(s(Number(e)));
  if (_8(e))
    return Vl(s(O0.call(e)));
  if (E8(e))
    return Vl(l8.call(e));
  if (g8(e))
    return Vl(s(String(e)));
  if (typeof window < "u" && e === window)
    return "{ [object Window] }";
  if (e === jt)
    return "{ [object globalThis] }";
  if (!y8(e) && !SE(e)) {
    var $ = Rc(e, s), I = gE ? gE(e) === Object.prototype : e instanceof Object || e.constructor === Object, k = e instanceof Object ? "" : "null prototype", L = !I && ti && Object(e) === e && ti in e ? jy.call(Oa(e), 8, -1) : k ? "Object" : "", M = I || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", x = M + (L || k ? "[" + _s.call(yE.call([], L || [], k || []), ": ") + "] " : "");
    return $.length === 0 ? x + "{}" : f ? x + "{" + R0($, f) + "}" : x + "{ " + _s.call($, ", ") + " }";
  }
  return String(e);
};
function lx(t, e, r) {
  var a = (r.quoteStyle || e) === "double" ? '"' : "'";
  return a + t + a;
}
function m8(t) {
  return ga.call(String(t), /"/g, "&quot;");
}
function N0(t) {
  return Oa(t) === "[object Array]" && (!ti || !(typeof t == "object" && ti in t));
}
function y8(t) {
  return Oa(t) === "[object Date]" && (!ti || !(typeof t == "object" && ti in t));
}
function SE(t) {
  return Oa(t) === "[object RegExp]" && (!ti || !(typeof t == "object" && ti in t));
}
function b8(t) {
  return Oa(t) === "[object Error]" && (!ti || !(typeof t == "object" && ti in t));
}
function g8(t) {
  return Oa(t) === "[object String]" && (!ti || !(typeof t == "object" && ti in t));
}
function v8(t) {
  return Oa(t) === "[object Number]" && (!ti || !(typeof t == "object" && ti in t));
}
function E8(t) {
  return Oa(t) === "[object Boolean]" && (!ti || !(typeof t == "object" && ti in t));
}
function ux(t) {
  if (il)
    return t && typeof t == "object" && t instanceof Symbol;
  if (typeof t == "symbol")
    return !0;
  if (!t || typeof t != "object" || !k0)
    return !1;
  try {
    return k0.call(t), !0;
  } catch {
  }
  return !1;
}
function _8(t) {
  if (!t || typeof t != "object" || !O0)
    return !1;
  try {
    return O0.call(t), !0;
  } catch {
  }
  return !1;
}
var S8 = Object.prototype.hasOwnProperty || function(t) {
  return t in this;
};
function ma(t, e) {
  return S8.call(t, e);
}
function Oa(t) {
  return u8.call(t);
}
function w8(t) {
  if (t.name)
    return t.name;
  var e = f8.call(c8.call(t), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function cx(t, e) {
  if (t.indexOf)
    return t.indexOf(e);
  for (var r = 0, a = t.length; r < a; r++)
    if (t[r] === e)
      return r;
  return -1;
}
function x8(t) {
  if (!Bf || !t || typeof t != "object")
    return !1;
  try {
    Bf.call(t);
    try {
      $f.call(t);
    } catch {
      return !0;
    }
    return t instanceof Map;
  } catch {
  }
  return !1;
}
function T8(t) {
  if (!du || !t || typeof t != "object")
    return !1;
  try {
    du.call(t, du);
    try {
      pu.call(t, pu);
    } catch {
      return !0;
    }
    return t instanceof WeakMap;
  } catch {
  }
  return !1;
}
function A8(t) {
  if (!hE || !t || typeof t != "object")
    return !1;
  try {
    return hE.call(t), !0;
  } catch {
  }
  return !1;
}
function P8(t) {
  if (!$f || !t || typeof t != "object")
    return !1;
  try {
    $f.call(t);
    try {
      Bf.call(t);
    } catch {
      return !0;
    }
    return t instanceof Set;
  } catch {
  }
  return !1;
}
function C8(t) {
  if (!pu || !t || typeof t != "object")
    return !1;
  try {
    pu.call(t, pu);
    try {
      du.call(t, du);
    } catch {
      return !0;
    }
    return t instanceof WeakSet;
  } catch {
  }
  return !1;
}
function I8(t) {
  return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
}
function fx(t, e) {
  if (t.length > e.maxStringLength) {
    var r = t.length - e.maxStringLength, a = "... " + r + " more character" + (r > 1 ? "s" : "");
    return fx(jy.call(t, 0, e.maxStringLength), e) + a;
  }
  var l = ga.call(ga.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, O8);
  return lx(l, "single", e);
}
function O8(t) {
  var e = t.charCodeAt(0), r = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return r ? "\\" + r : "\\x" + (e < 16 ? "0" : "") + d8.call(e.toString(16));
}
function Vl(t) {
  return "Object(" + t + ")";
}
function Rh(t) {
  return t + " { ? }";
}
function wE(t, e, r, a) {
  var l = a ? R0(r, a) : _s.call(r, ", ");
  return t + " (" + e + ") {" + l + "}";
}
function k8(t) {
  for (var e = 0; e < t.length; e++)
    if (cx(t[e], `
`) >= 0)
      return !1;
  return !0;
}
function D8(t, e) {
  var r;
  if (t.indent === "	")
    r = "	";
  else if (typeof t.indent == "number" && t.indent > 0)
    r = _s.call(Array(t.indent + 1), " ");
  else
    return null;
  return {
    base: r,
    prev: _s.call(Array(e + 1), r)
  };
}
function R0(t, e) {
  if (t.length === 0)
    return "";
  var r = `
` + e.prev + e.base;
  return r + _s.call(t, "," + r) + `
` + e.prev;
}
function Rc(t, e) {
  var r = N0(t), a = [];
  if (r) {
    a.length = t.length;
    for (var l = 0; l < t.length; l++)
      a[l] = ma(t, l) ? e(t[l], t) : "";
  }
  var d = typeof Nh == "function" ? Nh(t) : [], h;
  if (il) {
    h = {};
    for (var n = 0; n < d.length; n++)
      h["$" + d[n]] = d[n];
  }
  for (var u in t)
    ma(t, u) && (r && String(Number(u)) === u && u < t.length || il && h["$" + u] instanceof Symbol || (ax.call(/[^\w$]/, u) ? a.push(e(u, t) + ": " + e(t[u], t)) : a.push(u + ": " + e(t[u], t))));
  if (typeof Nh == "function")
    for (var i = 0; i < d.length; i++)
      ox.call(t, d[i]) && a.push("[" + e(d[i]) + "]: " + e(t[d[i]], t));
  return a;
}
var dx = wl, Tl = Wu, N8 = h8, R8 = Uu, Mc = dx("%WeakMap%", !0), Lc = dx("%Map%", !0), M8 = Tl("WeakMap.prototype.get", !0), L8 = Tl("WeakMap.prototype.set", !0), j8 = Tl("WeakMap.prototype.has", !0), F8 = Tl("Map.prototype.get", !0), B8 = Tl("Map.prototype.set", !0), $8 = Tl("Map.prototype.has", !0), Fy = function(t, e) {
  for (var r = t, a; (a = r.next) !== null; r = a)
    if (a.key === e)
      return r.next = a.next, a.next = /** @type {NonNullable<typeof list.next>} */
      t.next, t.next = a, a;
}, U8 = function(t, e) {
  var r = Fy(t, e);
  return r && r.value;
}, V8 = function(t, e, r) {
  var a = Fy(t, e);
  a ? a.value = r : t.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: e,
    next: t.next,
    value: r
  };
}, W8 = function(t, e) {
  return !!Fy(t, e);
}, q8 = function() {
  var e, r, a, l = {
    assert: function(d) {
      if (!l.has(d))
        throw new R8("Side channel does not contain " + N8(d));
    },
    get: function(d) {
      if (Mc && d && (typeof d == "object" || typeof d == "function")) {
        if (e)
          return M8(e, d);
      } else if (Lc) {
        if (r)
          return F8(r, d);
      } else if (a)
        return U8(a, d);
    },
    has: function(d) {
      if (Mc && d && (typeof d == "object" || typeof d == "function")) {
        if (e)
          return j8(e, d);
      } else if (Lc) {
        if (r)
          return $8(r, d);
      } else if (a)
        return W8(a, d);
      return !1;
    },
    set: function(d, h) {
      Mc && d && (typeof d == "object" || typeof d == "function") ? (e || (e = new Mc()), L8(e, d, h)) : Lc ? (r || (r = new Lc()), B8(r, d, h)) : (a || (a = { key: {}, next: null }), V8(a, d, h));
    }
  };
  return l;
}, H8 = String.prototype.replace, G8 = /%20/g, Mh = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, By = {
  default: Mh.RFC3986,
  formatters: {
    RFC1738: function(t) {
      return H8.call(t, G8, "+");
    },
    RFC3986: function(t) {
      return String(t);
    }
  },
  RFC1738: Mh.RFC1738,
  RFC3986: Mh.RFC3986
}, z8 = By, Lh = Object.prototype.hasOwnProperty, Ha = Array.isArray, ms = function() {
  for (var t = [], e = 0; e < 256; ++e)
    t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return t;
}(), K8 = function(e) {
  for (; e.length > 1; ) {
    var r = e.pop(), a = r.obj[r.prop];
    if (Ha(a)) {
      for (var l = [], d = 0; d < a.length; ++d)
        typeof a[d] < "u" && l.push(a[d]);
      r.obj[r.prop] = l;
    }
  }
}, px = function(e, r) {
  for (var a = r && r.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, l = 0; l < e.length; ++l)
    typeof e[l] < "u" && (a[l] = e[l]);
  return a;
}, Y8 = function t(e, r, a) {
  if (!r)
    return e;
  if (typeof r != "object") {
    if (Ha(e))
      e.push(r);
    else if (e && typeof e == "object")
      (a && (a.plainObjects || a.allowPrototypes) || !Lh.call(Object.prototype, r)) && (e[r] = !0);
    else
      return [e, r];
    return e;
  }
  if (!e || typeof e != "object")
    return [e].concat(r);
  var l = e;
  return Ha(e) && !Ha(r) && (l = px(e, a)), Ha(e) && Ha(r) ? (r.forEach(function(d, h) {
    if (Lh.call(e, h)) {
      var n = e[h];
      n && typeof n == "object" && d && typeof d == "object" ? e[h] = t(n, d, a) : e.push(d);
    } else
      e[h] = d;
  }), e) : Object.keys(r).reduce(function(d, h) {
    var n = r[h];
    return Lh.call(d, h) ? d[h] = t(d[h], n, a) : d[h] = n, d;
  }, l);
}, X8 = function(e, r) {
  return Object.keys(r).reduce(function(a, l) {
    return a[l] = r[l], a;
  }, e);
}, J8 = function(t, e, r) {
  var a = t.replace(/\+/g, " ");
  if (r === "iso-8859-1")
    return a.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(a);
  } catch {
    return a;
  }
}, jh = 1024, Q8 = function(e, r, a, l, d) {
  if (e.length === 0)
    return e;
  var h = e;
  if (typeof e == "symbol" ? h = Symbol.prototype.toString.call(e) : typeof e != "string" && (h = String(e)), a === "iso-8859-1")
    return escape(h).replace(/%u[0-9a-f]{4}/gi, function(o) {
      return "%26%23" + parseInt(o.slice(2), 16) + "%3B";
    });
  for (var n = "", u = 0; u < h.length; u += jh) {
    for (var i = h.length >= jh ? h.slice(u, u + jh) : h, c = [], f = 0; f < i.length; ++f) {
      var s = i.charCodeAt(f);
      if (s === 45 || s === 46 || s === 95 || s === 126 || s >= 48 && s <= 57 || s >= 65 && s <= 90 || s >= 97 && s <= 122 || d === z8.RFC1738 && (s === 40 || s === 41)) {
        c[c.length] = i.charAt(f);
        continue;
      }
      if (s < 128) {
        c[c.length] = ms[s];
        continue;
      }
      if (s < 2048) {
        c[c.length] = ms[192 | s >> 6] + ms[128 | s & 63];
        continue;
      }
      if (s < 55296 || s >= 57344) {
        c[c.length] = ms[224 | s >> 12] + ms[128 | s >> 6 & 63] + ms[128 | s & 63];
        continue;
      }
      f += 1, s = 65536 + ((s & 1023) << 10 | i.charCodeAt(f) & 1023), c[c.length] = ms[240 | s >> 18] + ms[128 | s >> 12 & 63] + ms[128 | s >> 6 & 63] + ms[128 | s & 63];
    }
    n += c.join("");
  }
  return n;
}, Z8 = function(e) {
  for (var r = [{ obj: { o: e }, prop: "o" }], a = [], l = 0; l < r.length; ++l)
    for (var d = r[l], h = d.obj[d.prop], n = Object.keys(h), u = 0; u < n.length; ++u) {
      var i = n[u], c = h[i];
      typeof c == "object" && c !== null && a.indexOf(c) === -1 && (r.push({ obj: h, prop: i }), a.push(c));
    }
  return K8(r), e;
}, eD = function(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}, tD = function(e) {
  return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}, rD = function(e, r) {
  return [].concat(e, r);
}, nD = function(e, r) {
  if (Ha(e)) {
    for (var a = [], l = 0; l < e.length; l += 1)
      a.push(r(e[l]));
    return a;
  }
  return r(e);
}, hx = {
  arrayToObject: px,
  assign: X8,
  combine: rD,
  compact: Z8,
  decode: J8,
  encode: Q8,
  isBuffer: tD,
  isRegExp: eD,
  maybeMap: nD,
  merge: Y8
}, mx = q8, gf = hx, hu = By, iD = Object.prototype.hasOwnProperty, yx = {
  brackets: function(e) {
    return e + "[]";
  },
  comma: "comma",
  indices: function(e, r) {
    return e + "[" + r + "]";
  },
  repeat: function(e) {
    return e;
  }
}, Es = Array.isArray, sD = Array.prototype.push, bx = function(t, e) {
  sD.apply(t, Es(e) ? e : [e]);
}, aD = Date.prototype.toISOString, xE = hu.default, An = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: gf.encode,
  encodeValuesOnly: !1,
  format: xE,
  formatter: hu.formatters[xE],
  // deprecated
  indices: !1,
  serializeDate: function(e) {
    return aD.call(e);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, oD = function(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
}, Fh = {}, lD = function t(e, r, a, l, d, h, n, u, i, c, f, s, o, y, m, g, b, v) {
  for (var T = e, E = v, O = 0, D = !1; (E = E.get(Fh)) !== void 0 && !D; ) {
    var $ = E.get(e);
    if (O += 1, typeof $ < "u") {
      if ($ === O)
        throw new RangeError("Cyclic object value");
      D = !0;
    }
    typeof E.get(Fh) > "u" && (O = 0);
  }
  if (typeof c == "function" ? T = c(r, T) : T instanceof Date ? T = o(T) : a === "comma" && Es(T) && (T = gf.maybeMap(T, function(P) {
    return P instanceof Date ? o(P) : P;
  })), T === null) {
    if (h)
      return i && !g ? i(r, An.encoder, b, "key", y) : r;
    T = "";
  }
  if (oD(T) || gf.isBuffer(T)) {
    if (i) {
      var I = g ? r : i(r, An.encoder, b, "key", y);
      return [m(I) + "=" + m(i(T, An.encoder, b, "value", y))];
    }
    return [m(r) + "=" + m(String(T))];
  }
  var k = [];
  if (typeof T > "u")
    return k;
  var L;
  if (a === "comma" && Es(T))
    g && i && (T = gf.maybeMap(T, i)), L = [{ value: T.length > 0 ? T.join(",") || null : void 0 }];
  else if (Es(c))
    L = c;
  else {
    var M = Object.keys(T);
    L = f ? M.sort(f) : M;
  }
  var x = u ? r.replace(/\./g, "%2E") : r, _ = l && Es(T) && T.length === 1 ? x + "[]" : x;
  if (d && Es(T) && T.length === 0)
    return _ + "[]";
  for (var S = 0; S < L.length; ++S) {
    var C = L[S], R = typeof C == "object" && typeof C.value < "u" ? C.value : T[C];
    if (!(n && R === null)) {
      var H = s && u ? C.replace(/\./g, "%2E") : C, z = Es(T) ? typeof a == "function" ? a(_, H) : _ : _ + (s ? "." + H : "[" + H + "]");
      v.set(e, O);
      var U = mx();
      U.set(Fh, v), bx(k, t(
        R,
        z,
        a,
        l,
        d,
        h,
        n,
        u,
        a === "comma" && g && Es(T) ? null : i,
        c,
        f,
        s,
        o,
        y,
        m,
        g,
        b,
        U
      ));
    }
  }
  return k;
}, uD = function(e) {
  if (!e)
    return An;
  if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var r = e.charset || An.charset;
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var a = hu.default;
  if (typeof e.format < "u") {
    if (!iD.call(hu.formatters, e.format))
      throw new TypeError("Unknown format option provided.");
    a = e.format;
  }
  var l = hu.formatters[a], d = An.filter;
  (typeof e.filter == "function" || Es(e.filter)) && (d = e.filter);
  var h;
  if (e.arrayFormat in yx ? h = e.arrayFormat : "indices" in e ? h = e.indices ? "indices" : "repeat" : h = An.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var n = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : An.allowDots : !!e.allowDots;
  return {
    addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : An.addQueryPrefix,
    allowDots: n,
    allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : An.allowEmptyArrays,
    arrayFormat: h,
    charset: r,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : An.charsetSentinel,
    commaRoundTrip: e.commaRoundTrip,
    delimiter: typeof e.delimiter > "u" ? An.delimiter : e.delimiter,
    encode: typeof e.encode == "boolean" ? e.encode : An.encode,
    encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : An.encodeDotInKeys,
    encoder: typeof e.encoder == "function" ? e.encoder : An.encoder,
    encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : An.encodeValuesOnly,
    filter: d,
    format: a,
    formatter: l,
    serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : An.serializeDate,
    skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : An.skipNulls,
    sort: typeof e.sort == "function" ? e.sort : null,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : An.strictNullHandling
  };
}, cD = function(t, e) {
  var r = t, a = uD(e), l, d;
  typeof a.filter == "function" ? (d = a.filter, r = d("", r)) : Es(a.filter) && (d = a.filter, l = d);
  var h = [];
  if (typeof r != "object" || r === null)
    return "";
  var n = yx[a.arrayFormat], u = n === "comma" && a.commaRoundTrip;
  l || (l = Object.keys(r)), a.sort && l.sort(a.sort);
  for (var i = mx(), c = 0; c < l.length; ++c) {
    var f = l[c];
    a.skipNulls && r[f] === null || bx(h, lD(
      r[f],
      f,
      n,
      u,
      a.allowEmptyArrays,
      a.strictNullHandling,
      a.skipNulls,
      a.encodeDotInKeys,
      a.encode ? a.encoder : null,
      a.filter,
      a.sort,
      a.allowDots,
      a.serializeDate,
      a.format,
      a.formatter,
      a.encodeValuesOnly,
      a.charset,
      i
    ));
  }
  var s = h.join(a.delimiter), o = a.addQueryPrefix === !0 ? "?" : "";
  return a.charsetSentinel && (a.charset === "iso-8859-1" ? o += "utf8=%26%2310003%3B&" : o += "utf8=%E2%9C%93&"), s.length > 0 ? o + s : "";
}, sl = hx, M0 = Object.prototype.hasOwnProperty, fD = Array.isArray, un = {
  allowDots: !1,
  allowEmptyArrays: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decodeDotInKeys: !1,
  decoder: sl.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, dD = function(t) {
  return t.replace(/&#(\d+);/g, function(e, r) {
    return String.fromCharCode(parseInt(r, 10));
  });
}, gx = function(t, e) {
  return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t;
}, pD = "utf8=%26%2310003%3B", hD = "utf8=%E2%9C%93", mD = function(e, r) {
  var a = { __proto__: null }, l = r.ignoreQueryPrefix ? e.replace(/^\?/, "") : e, d = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, h = l.split(r.delimiter, d), n = -1, u, i = r.charset;
  if (r.charsetSentinel)
    for (u = 0; u < h.length; ++u)
      h[u].indexOf("utf8=") === 0 && (h[u] === hD ? i = "utf-8" : h[u] === pD && (i = "iso-8859-1"), n = u, u = h.length);
  for (u = 0; u < h.length; ++u)
    if (u !== n) {
      var c = h[u], f = c.indexOf("]="), s = f === -1 ? c.indexOf("=") : f + 1, o, y;
      s === -1 ? (o = r.decoder(c, un.decoder, i, "key"), y = r.strictNullHandling ? null : "") : (o = r.decoder(c.slice(0, s), un.decoder, i, "key"), y = sl.maybeMap(
        gx(c.slice(s + 1), r),
        function(g) {
          return r.decoder(g, un.decoder, i, "value");
        }
      )), y && r.interpretNumericEntities && i === "iso-8859-1" && (y = dD(y)), c.indexOf("[]=") > -1 && (y = fD(y) ? [y] : y);
      var m = M0.call(a, o);
      m && r.duplicates === "combine" ? a[o] = sl.combine(a[o], y) : (!m || r.duplicates === "last") && (a[o] = y);
    }
  return a;
}, yD = function(t, e, r, a) {
  for (var l = a ? e : gx(e, r), d = t.length - 1; d >= 0; --d) {
    var h, n = t[d];
    if (n === "[]" && r.parseArrays)
      h = r.allowEmptyArrays && l === "" ? [] : [].concat(l);
    else {
      h = r.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var u = n.charAt(0) === "[" && n.charAt(n.length - 1) === "]" ? n.slice(1, -1) : n, i = r.decodeDotInKeys ? u.replace(/%2E/g, ".") : u, c = parseInt(i, 10);
      !r.parseArrays && i === "" ? h = { 0: l } : !isNaN(c) && n !== i && String(c) === i && c >= 0 && r.parseArrays && c <= r.arrayLimit ? (h = [], h[c] = l) : i !== "__proto__" && (h[i] = l);
    }
    l = h;
  }
  return l;
}, bD = function(e, r, a, l) {
  if (e) {
    var d = a.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, h = /(\[[^[\]]*])/, n = /(\[[^[\]]*])/g, u = a.depth > 0 && h.exec(d), i = u ? d.slice(0, u.index) : d, c = [];
    if (i) {
      if (!a.plainObjects && M0.call(Object.prototype, i) && !a.allowPrototypes)
        return;
      c.push(i);
    }
    for (var f = 0; a.depth > 0 && (u = n.exec(d)) !== null && f < a.depth; ) {
      if (f += 1, !a.plainObjects && M0.call(Object.prototype, u[1].slice(1, -1)) && !a.allowPrototypes)
        return;
      c.push(u[1]);
    }
    return u && c.push("[" + d.slice(u.index) + "]"), yD(c, r, a, l);
  }
}, gD = function(e) {
  if (!e)
    return un;
  if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean")
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = typeof e.charset > "u" ? un.charset : e.charset, a = typeof e.duplicates > "u" ? un.duplicates : e.duplicates;
  if (a !== "combine" && a !== "first" && a !== "last")
    throw new TypeError("The duplicates option must be either combine, first, or last");
  var l = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : un.allowDots : !!e.allowDots;
  return {
    allowDots: l,
    allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : un.allowEmptyArrays,
    allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : un.allowPrototypes,
    allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : un.allowSparse,
    arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : un.arrayLimit,
    charset: r,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : un.charsetSentinel,
    comma: typeof e.comma == "boolean" ? e.comma : un.comma,
    decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : un.decodeDotInKeys,
    decoder: typeof e.decoder == "function" ? e.decoder : un.decoder,
    delimiter: typeof e.delimiter == "string" || sl.isRegExp(e.delimiter) ? e.delimiter : un.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : un.depth,
    duplicates: a,
    ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : un.interpretNumericEntities,
    parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : un.parameterLimit,
    parseArrays: e.parseArrays !== !1,
    plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : un.plainObjects,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : un.strictNullHandling
  };
}, vD = function(t, e) {
  var r = gD(e);
  if (t === "" || t === null || typeof t > "u")
    return r.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var a = typeof t == "string" ? mD(t, r) : t, l = r.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, d = Object.keys(a), h = 0; h < d.length; ++h) {
    var n = d[h], u = bD(n, a[n], r, typeof t == "string");
    l = sl.merge(l, u, r);
  }
  return r.allowSparse === !0 ? l : sl.compact(l);
}, ED = cD, _D = vD, SD = By, wD = {
  formats: SD,
  parse: _D,
  stringify: ED
}, xD = i8;
function Li() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var TD = /^([a-z0-9.+-]+:)/i, AD = /:[0-9]*$/, PD = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, CD = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  `
`,
  "	"
], ID = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(CD), L0 = ["'"].concat(ID), TE = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(L0), AE = [
  "/",
  "?",
  "#"
], OD = 255, PE = /^[+a-z0-9A-Z_-]{0,63}$/, kD = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, DD = {
  javascript: !0,
  "javascript:": !0
}, j0 = {
  javascript: !0,
  "javascript:": !0
}, Qo = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, F0 = wD;
function Hu(t, e, r) {
  if (t && typeof t == "object" && t instanceof Li)
    return t;
  var a = new Li();
  return a.parse(t, e, r), a;
}
Li.prototype.parse = function(t, e, r) {
  if (typeof t != "string")
    throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
  var a = t.indexOf("?"), l = a !== -1 && a < t.indexOf("#") ? "?" : "#", d = t.split(l), h = /\\/g;
  d[0] = d[0].replace(h, "/"), t = d.join(l);
  var n = t;
  if (n = n.trim(), !r && t.split("#").length === 1) {
    var u = PD.exec(n);
    if (u)
      return this.path = n, this.href = n, this.pathname = u[1], u[2] ? (this.search = u[2], e ? this.query = F0.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
  }
  var i = TD.exec(n);
  if (i) {
    i = i[0];
    var c = i.toLowerCase();
    this.protocol = c, n = n.substr(i.length);
  }
  if (r || i || n.match(/^\/\/[^@/]+@[^@/]+/)) {
    var f = n.substr(0, 2) === "//";
    f && !(i && j0[i]) && (n = n.substr(2), this.slashes = !0);
  }
  if (!j0[i] && (f || i && !Qo[i])) {
    for (var s = -1, o = 0; o < AE.length; o++) {
      var y = n.indexOf(AE[o]);
      y !== -1 && (s === -1 || y < s) && (s = y);
    }
    var m, g;
    s === -1 ? g = n.lastIndexOf("@") : g = n.lastIndexOf("@", s), g !== -1 && (m = n.slice(0, g), n = n.slice(g + 1), this.auth = decodeURIComponent(m)), s = -1;
    for (var o = 0; o < TE.length; o++) {
      var y = n.indexOf(TE[o]);
      y !== -1 && (s === -1 || y < s) && (s = y);
    }
    s === -1 && (s = n.length), this.host = n.slice(0, s), n = n.slice(s), this.parseHost(), this.hostname = this.hostname || "";
    var b = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!b)
      for (var v = this.hostname.split(/\./), o = 0, T = v.length; o < T; o++) {
        var E = v[o];
        if (E && !E.match(PE)) {
          for (var O = "", D = 0, $ = E.length; D < $; D++)
            E.charCodeAt(D) > 127 ? O += "x" : O += E[D];
          if (!O.match(PE)) {
            var I = v.slice(0, o), k = v.slice(o + 1), L = E.match(kD);
            L && (I.push(L[1]), k.unshift(L[2])), k.length && (n = "/" + k.join(".") + n), this.hostname = I.join(".");
            break;
          }
        }
      }
    this.hostname.length > OD ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), b || (this.hostname = xD.toASCII(this.hostname));
    var M = this.port ? ":" + this.port : "", x = this.hostname || "";
    this.host = x + M, this.href += this.host, b && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), n[0] !== "/" && (n = "/" + n));
  }
  if (!DD[c])
    for (var o = 0, T = L0.length; o < T; o++) {
      var _ = L0[o];
      if (n.indexOf(_) !== -1) {
        var S = encodeURIComponent(_);
        S === _ && (S = escape(_)), n = n.split(_).join(S);
      }
    }
  var C = n.indexOf("#");
  C !== -1 && (this.hash = n.substr(C), n = n.slice(0, C));
  var R = n.indexOf("?");
  if (R !== -1 ? (this.search = n.substr(R), this.query = n.substr(R + 1), e && (this.query = F0.parse(this.query)), n = n.slice(0, R)) : e && (this.search = "", this.query = {}), n && (this.pathname = n), Qo[c] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var M = this.pathname || "", H = this.search || "";
    this.path = M + H;
  }
  return this.href = this.format(), this;
};
function ND(t) {
  return typeof t == "string" && (t = Hu(t)), t instanceof Li ? t.format() : Li.prototype.format.call(t);
}
Li.prototype.format = function() {
  var t = this.auth || "";
  t && (t = encodeURIComponent(t), t = t.replace(/%3A/i, ":"), t += "@");
  var e = this.protocol || "", r = this.pathname || "", a = this.hash || "", l = !1, d = "";
  this.host ? l = t + this.host : this.hostname && (l = t + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (l += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (d = F0.stringify(this.query, {
    arrayFormat: "repeat",
    addQueryPrefix: !1
  }));
  var h = this.search || d && "?" + d || "";
  return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || Qo[e]) && l !== !1 ? (l = "//" + (l || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : l || (l = ""), a && a.charAt(0) !== "#" && (a = "#" + a), h && h.charAt(0) !== "?" && (h = "?" + h), r = r.replace(/[?#]/g, function(n) {
    return encodeURIComponent(n);
  }), h = h.replace("#", "%23"), e + l + r + h + a;
};
function RD(t, e) {
  return Hu(t, !1, !0).resolve(e);
}
Li.prototype.resolve = function(t) {
  return this.resolveObject(Hu(t, !1, !0)).format();
};
function MD(t, e) {
  return t ? Hu(t, !1, !0).resolveObject(e) : e;
}
Li.prototype.resolveObject = function(t) {
  if (typeof t == "string") {
    var e = new Li();
    e.parse(t, !1, !0), t = e;
  }
  for (var r = new Li(), a = Object.keys(this), l = 0; l < a.length; l++) {
    var d = a[l];
    r[d] = this[d];
  }
  if (r.hash = t.hash, t.href === "")
    return r.href = r.format(), r;
  if (t.slashes && !t.protocol) {
    for (var h = Object.keys(t), n = 0; n < h.length; n++) {
      var u = h[n];
      u !== "protocol" && (r[u] = t[u]);
    }
    return Qo[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
  }
  if (t.protocol && t.protocol !== r.protocol) {
    if (!Qo[t.protocol]) {
      for (var i = Object.keys(t), c = 0; c < i.length; c++) {
        var f = i[c];
        r[f] = t[f];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = t.protocol, !t.host && !j0[t.protocol]) {
      for (var T = (t.pathname || "").split("/"); T.length && !(t.host = T.shift()); )
        ;
      t.host || (t.host = ""), t.hostname || (t.hostname = ""), T[0] !== "" && T.unshift(""), T.length < 2 && T.unshift(""), r.pathname = T.join("/");
    } else
      r.pathname = t.pathname;
    if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
      var s = r.pathname || "", o = r.search || "";
      r.path = s + o;
    }
    return r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
  }
  var y = r.pathname && r.pathname.charAt(0) === "/", m = t.host || t.pathname && t.pathname.charAt(0) === "/", g = m || y || r.host && t.pathname, b = g, v = r.pathname && r.pathname.split("/") || [], T = t.pathname && t.pathname.split("/") || [], E = r.protocol && !Qo[r.protocol];
  if (E && (r.hostname = "", r.port = null, r.host && (v[0] === "" ? v[0] = r.host : v.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && (T[0] === "" ? T[0] = t.host : T.unshift(t.host)), t.host = null), g = g && (T[0] === "" || v[0] === "")), m)
    r.host = t.host || t.host === "" ? t.host : r.host, r.hostname = t.hostname || t.hostname === "" ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, v = T;
  else if (T.length)
    v || (v = []), v.pop(), v = v.concat(T), r.search = t.search, r.query = t.query;
  else if (t.search != null) {
    if (E) {
      r.host = v.shift(), r.hostname = r.host;
      var O = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
      O && (r.auth = O.shift(), r.hostname = O.shift(), r.host = r.hostname);
    }
    return r.search = t.search, r.query = t.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  }
  if (!v.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var D = v.slice(-1)[0], $ = (r.host || t.host || v.length > 1) && (D === "." || D === "..") || D === "", I = 0, k = v.length; k >= 0; k--)
    D = v[k], D === "." ? v.splice(k, 1) : D === ".." ? (v.splice(k, 1), I++) : I && (v.splice(k, 1), I--);
  if (!g && !b)
    for (; I--; I)
      v.unshift("..");
  g && v[0] !== "" && (!v[0] || v[0].charAt(0) !== "/") && v.unshift(""), $ && v.join("/").substr(-1) !== "/" && v.push("");
  var L = v[0] === "" || v[0] && v[0].charAt(0) === "/";
  if (E) {
    r.hostname = L ? "" : v.length ? v.shift() : "", r.host = r.hostname;
    var O = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
    O && (r.auth = O.shift(), r.hostname = O.shift(), r.host = r.hostname);
  }
  return g = g || r.host && v.length, g && !L && v.unshift(""), v.length > 0 ? r.pathname = v.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
};
Li.prototype.parseHost = function() {
  var t = this.host, e = AD.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
Ns.parse = Hu;
Ns.resolve = RD;
Ns.resolveObject = MD;
Ns.format = ND;
Ns.Url = Li;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.unixify = t.bufferToEncoding = t.getWriteSyncArgs = t.getWriteArgs = t.bufToUint8 = t.dataToBuffer = t.validateFd = t.isFd = t.flagsToNumber = t.genRndStr6 = t.createError = t.pathToFilename = t.nullCheck = t.modeToNumber = t.validateCallback = t.promisify = t.isWin = void 0;
  const e = Aa, r = Sy, a = rl, l = $u, d = rl, h = Id;
  t.isWin = Ze.platform === "win32";
  function n(N, V, F = (X) => X) {
    return (...X) => new Promise((K, ie) => {
      N[V].bind(N)(...X, (fe, _e) => fe ? ie(fe) : K(F(_e)));
    });
  }
  t.promisify = n;
  function u(N) {
    if (typeof N != "function")
      throw TypeError(e.ERRSTR.CB);
    return N;
  }
  t.validateCallback = u;
  function i(N, V) {
    if (typeof N == "number")
      return N;
    if (typeof N == "string")
      return parseInt(N, 8);
    if (V)
      return c(V);
  }
  function c(N, V) {
    const F = i(N, V);
    if (typeof F != "number" || isNaN(F))
      throw new TypeError(e.ERRSTR.MODE_INT);
    return F;
  }
  t.modeToNumber = c;
  function f(N, V) {
    if (("" + N).indexOf("\0") !== -1) {
      const F = new Error("Path must be a string without null bytes");
      if (F.code = "ENOENT", typeof V != "function")
        throw F;
      return (0, h.default)(() => {
        V(F);
      }), !1;
    }
    return !0;
  }
  t.nullCheck = f;
  function s(N) {
    if (N.hostname !== "")
      throw new r.TypeError("ERR_INVALID_FILE_URL_HOST", Ze.platform);
    const V = N.pathname;
    for (let F = 0; F < V.length; F++)
      if (V[F] === "%") {
        const X = V.codePointAt(F + 2) | 32;
        if (V[F + 1] === "2" && X === 102)
          throw new r.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
      }
    return decodeURIComponent(V);
  }
  function o(N) {
    if (typeof N != "string" && !a.Buffer.isBuffer(N)) {
      try {
        if (!(N instanceof Ns.URL))
          throw new TypeError(e.ERRSTR.PATH_STR);
      } catch {
        throw new TypeError(e.ERRSTR.PATH_STR);
      }
      N = s(N);
    }
    const V = String(N);
    return f(V), V;
  }
  t.pathToFilename = o;
  const y = "ENOENT", m = "EBADF", g = "EINVAL", b = "EPERM", v = "EPROTO", T = "EEXIST", E = "ENOTDIR", O = "EMFILE", D = "EACCES", $ = "EISDIR", I = "ENOTEMPTY", k = "ENOSYS", L = "ERR_FS_EISDIR", M = "ERR_OUT_OF_RANGE";
  function x(N, V = "", F = "", X = "") {
    let K = "";
    switch (F && (K = ` '${F}'`), X && (K += ` -> '${X}'`), N) {
      case y:
        return `ENOENT: no such file or directory, ${V}${K}`;
      case m:
        return `EBADF: bad file descriptor, ${V}${K}`;
      case g:
        return `EINVAL: invalid argument, ${V}${K}`;
      case b:
        return `EPERM: operation not permitted, ${V}${K}`;
      case v:
        return `EPROTO: protocol error, ${V}${K}`;
      case T:
        return `EEXIST: file already exists, ${V}${K}`;
      case E:
        return `ENOTDIR: not a directory, ${V}${K}`;
      case $:
        return `EISDIR: illegal operation on a directory, ${V}${K}`;
      case D:
        return `EACCES: permission denied, ${V}${K}`;
      case I:
        return `ENOTEMPTY: directory not empty, ${V}${K}`;
      case O:
        return `EMFILE: too many open files, ${V}${K}`;
      case k:
        return `ENOSYS: function not implemented, ${V}${K}`;
      case L:
        return `[ERR_FS_EISDIR]: Path is a directory: ${V} returned EISDIR (is a directory) ${F}`;
      case M:
        return `[ERR_OUT_OF_RANGE]: value out of range, ${V}${K}`;
      default:
        return `${N}: error occurred, ${V}${K}`;
    }
  }
  function _(N, V = "", F = "", X = "", K = Error) {
    const ie = new K(x(N, V, F, X));
    return ie.code = N, F && (ie.path = F), ie;
  }
  t.createError = _;
  function S() {
    const N = (Math.random() + 1).toString(36).substring(2, 8);
    return N.length === 6 ? N : S();
  }
  t.genRndStr6 = S;
  function C(N) {
    if (typeof N == "number")
      return N;
    if (typeof N == "string") {
      const V = e.FLAGS[N];
      if (typeof V < "u")
        return V;
    }
    throw new r.TypeError("ERR_INVALID_OPT_VALUE", "flags", N);
  }
  t.flagsToNumber = C;
  function R(N) {
    return N >>> 0 === N;
  }
  t.isFd = R;
  function H(N) {
    if (!R(N))
      throw TypeError(e.ERRSTR.FD);
  }
  t.validateFd = H;
  function z(N, V = l.ENCODING_UTF8) {
    return a.Buffer.isBuffer(N) ? N : N instanceof Uint8Array ? (0, d.bufferFrom)(N) : (0, d.bufferFrom)(String(N), V);
  }
  t.dataToBuffer = z;
  const U = (N) => new Uint8Array(N.buffer, N.byteOffset, N.byteLength);
  t.bufToUint8 = U;
  const P = (N, V, F, X, K, ie) => {
    H(N);
    let fe = 0, _e, Ae = null, ce, ee;
    const ae = typeof V, oe = typeof F, me = typeof X, ye = typeof K;
    ae !== "string" ? oe === "function" ? ee = F : me === "function" ? (fe = F | 0, ee = X) : ye === "function" ? (fe = F | 0, _e = X, ee = K) : (fe = F | 0, _e = X, Ae = K, ee = ie) : oe === "function" ? ee = F : me === "function" ? (Ae = F, ee = X) : ye === "function" && (Ae = F, ce = X, ee = K);
    const we = z(V, ce);
    ae !== "string" ? typeof _e > "u" && (_e = we.length) : (fe = 0, _e = we.length);
    const ge = u(ee);
    return [N, ae === "string", we, fe, _e, Ae, ge];
  };
  t.getWriteArgs = P;
  const W = (N, V, F, X, K) => {
    H(N);
    let ie, fe, _e, Ae;
    const ce = typeof V != "string";
    ce ? (fe = (F || 0) | 0, _e = X, Ae = K) : (Ae = F, ie = X);
    const ee = z(V, ie);
    return ce ? typeof _e > "u" && (_e = ee.length) : (fe = 0, _e = ee.length), [N, ee, fe || 0, _e, Ae];
  };
  t.getWriteSyncArgs = W;
  function B(N, V) {
    return !V || V === "buffer" ? N : N.toString(V);
  }
  t.bufferToEncoding = B;
  const Q = (N, V) => {
    let F = N[V];
    return V > 0 && (F === "/" || t.isWin && F === "\\");
  }, J = (N) => {
    let V = N.length - 1;
    if (V < 2)
      return N;
    for (; Q(N, V); )
      V--;
    return N.substr(0, V + 1);
  }, re = (N, V) => {
    if (typeof N != "string")
      throw new TypeError("expected a string");
    return N = N.replace(/[\\\/]+/g, "/"), V !== !1 && (N = J(N)), N;
  }, G = (N, V = !0) => t.isWin ? (N = re(N, V), N.replace(/^([a-zA-Z]+:|\.\/)/, "")) : N;
  t.unixify = G;
})(qu);
Object.defineProperty(Od, "__esModule", { value: !0 });
Od.FileHandle = void 0;
const si = qu;
class LD {
  constructor(e, r) {
    this.fs = e, this.fd = r;
  }
  appendFile(e, r) {
    return (0, si.promisify)(this.fs, "appendFile")(this.fd, e, r);
  }
  chmod(e) {
    return (0, si.promisify)(this.fs, "fchmod")(this.fd, e);
  }
  chown(e, r) {
    return (0, si.promisify)(this.fs, "fchown")(this.fd, e, r);
  }
  close() {
    return (0, si.promisify)(this.fs, "close")(this.fd);
  }
  datasync() {
    return (0, si.promisify)(this.fs, "fdatasync")(this.fd);
  }
  read(e, r, a, l) {
    return (0, si.promisify)(this.fs, "read", (d) => ({ bytesRead: d, buffer: e }))(this.fd, e, r, a, l);
  }
  readv(e, r) {
    return (0, si.promisify)(this.fs, "readv", (a) => ({ bytesRead: a, buffers: e }))(this.fd, e, r);
  }
  readFile(e) {
    return (0, si.promisify)(this.fs, "readFile")(this.fd, e);
  }
  stat(e) {
    return (0, si.promisify)(this.fs, "fstat")(this.fd, e);
  }
  sync() {
    return (0, si.promisify)(this.fs, "fsync")(this.fd);
  }
  truncate(e) {
    return (0, si.promisify)(this.fs, "ftruncate")(this.fd, e);
  }
  utimes(e, r) {
    return (0, si.promisify)(this.fs, "futimes")(this.fd, e, r);
  }
  write(e, r, a, l) {
    return (0, si.promisify)(this.fs, "write", (d) => ({ bytesWritten: d, buffer: e }))(this.fd, e, r, a, l);
  }
  writev(e, r) {
    return (0, si.promisify)(this.fs, "writev", (a) => ({ bytesWritten: a, buffers: e }))(this.fd, e, r);
  }
  writeFile(e, r) {
    return (0, si.promisify)(this.fs, "writeFile")(this.fd, e, r);
  }
}
Od.FileHandle = LD;
var kd = {};
Object.defineProperty(kd, "__esModule", { value: !0 });
kd.FsPromises = void 0;
const Ir = qu, jD = Us;
class FD {
  constructor(e, r) {
    this.fs = e, this.FileHandle = r, this.constants = jD.constants, this.cp = (0, Ir.promisify)(this.fs, "cp"), this.opendir = (0, Ir.promisify)(this.fs, "opendir"), this.statfs = (0, Ir.promisify)(this.fs, "statfs"), this.lutimes = (0, Ir.promisify)(this.fs, "lutimes"), this.access = (0, Ir.promisify)(this.fs, "access"), this.chmod = (0, Ir.promisify)(this.fs, "chmod"), this.chown = (0, Ir.promisify)(this.fs, "chown"), this.copyFile = (0, Ir.promisify)(this.fs, "copyFile"), this.lchmod = (0, Ir.promisify)(this.fs, "lchmod"), this.lchown = (0, Ir.promisify)(this.fs, "lchown"), this.link = (0, Ir.promisify)(this.fs, "link"), this.lstat = (0, Ir.promisify)(this.fs, "lstat"), this.mkdir = (0, Ir.promisify)(this.fs, "mkdir"), this.mkdtemp = (0, Ir.promisify)(this.fs, "mkdtemp"), this.readdir = (0, Ir.promisify)(this.fs, "readdir"), this.readlink = (0, Ir.promisify)(this.fs, "readlink"), this.realpath = (0, Ir.promisify)(this.fs, "realpath"), this.rename = (0, Ir.promisify)(this.fs, "rename"), this.rmdir = (0, Ir.promisify)(this.fs, "rmdir"), this.rm = (0, Ir.promisify)(this.fs, "rm"), this.stat = (0, Ir.promisify)(this.fs, "stat"), this.symlink = (0, Ir.promisify)(this.fs, "symlink"), this.truncate = (0, Ir.promisify)(this.fs, "truncate"), this.unlink = (0, Ir.promisify)(this.fs, "unlink"), this.utimes = (0, Ir.promisify)(this.fs, "utimes"), this.readFile = (a, l) => (0, Ir.promisify)(this.fs, "readFile")(a instanceof this.FileHandle ? a.fd : a, l), this.appendFile = (a, l, d) => (0, Ir.promisify)(this.fs, "appendFile")(a instanceof this.FileHandle ? a.fd : a, l, d), this.open = (a, l = "r", d) => (0, Ir.promisify)(this.fs, "open", (h) => new this.FileHandle(this.fs, h))(a, l, d), this.writeFile = (a, l, d) => (0, Ir.promisify)(this.fs, "writeFile")(a instanceof this.FileHandle ? a.fd : a, l, d), this.watch = () => {
      throw new Error("Not implemented");
    };
  }
}
kd.FsPromises = FD;
var vx = {}, Ex = {}, B0 = function(t, e) {
  return B0 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, a) {
    r.__proto__ = a;
  } || function(r, a) {
    for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (r[l] = a[l]);
  }, B0(t, e);
};
function _x(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  B0(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var Uf = function() {
  return Uf = Object.assign || function(e) {
    for (var r, a = 1, l = arguments.length; a < l; a++) {
      r = arguments[a];
      for (var d in r) Object.prototype.hasOwnProperty.call(r, d) && (e[d] = r[d]);
    }
    return e;
  }, Uf.apply(this, arguments);
};
function Sx(t, e) {
  var r = {};
  for (var a in t) Object.prototype.hasOwnProperty.call(t, a) && e.indexOf(a) < 0 && (r[a] = t[a]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var l = 0, a = Object.getOwnPropertySymbols(t); l < a.length; l++)
      e.indexOf(a[l]) < 0 && Object.prototype.propertyIsEnumerable.call(t, a[l]) && (r[a[l]] = t[a[l]]);
  return r;
}
function wx(t, e, r, a) {
  var l = arguments.length, d = l < 3 ? e : a === null ? a = Object.getOwnPropertyDescriptor(e, r) : a, h;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") d = Reflect.decorate(t, e, r, a);
  else for (var n = t.length - 1; n >= 0; n--) (h = t[n]) && (d = (l < 3 ? h(d) : l > 3 ? h(e, r, d) : h(e, r)) || d);
  return l > 3 && d && Object.defineProperty(e, r, d), d;
}
function xx(t, e) {
  return function(r, a) {
    e(r, a, t);
  };
}
function BD(t, e, r, a, l, d) {
  function h(b) {
    if (b !== void 0 && typeof b != "function") throw new TypeError("Function expected");
    return b;
  }
  for (var n = a.kind, u = n === "getter" ? "get" : n === "setter" ? "set" : "value", i = !e && t ? a.static ? t : t.prototype : null, c = e || (i ? Object.getOwnPropertyDescriptor(i, a.name) : {}), f, s = !1, o = r.length - 1; o >= 0; o--) {
    var y = {};
    for (var m in a) y[m] = m === "access" ? {} : a[m];
    for (var m in a.access) y.access[m] = a.access[m];
    y.addInitializer = function(b) {
      if (s) throw new TypeError("Cannot add initializers after decoration has completed");
      d.push(h(b || null));
    };
    var g = (0, r[o])(n === "accessor" ? { get: c.get, set: c.set } : c[u], y);
    if (n === "accessor") {
      if (g === void 0) continue;
      if (g === null || typeof g != "object") throw new TypeError("Object expected");
      (f = h(g.get)) && (c.get = f), (f = h(g.set)) && (c.set = f), (f = h(g.init)) && l.unshift(f);
    } else (f = h(g)) && (n === "field" ? l.unshift(f) : c[u] = f);
  }
  i && Object.defineProperty(i, a.name, c), s = !0;
}
function $D(t, e, r) {
  for (var a = arguments.length > 2, l = 0; l < e.length; l++)
    r = a ? e[l].call(t, r) : e[l].call(t);
  return a ? r : void 0;
}
function UD(t) {
  return typeof t == "symbol" ? t : "".concat(t);
}
function VD(t, e, r) {
  return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: r ? "".concat(r, " ", e) : e });
}
function Tx(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function Ax(t, e, r, a) {
  function l(d) {
    return d instanceof r ? d : new r(function(h) {
      h(d);
    });
  }
  return new (r || (r = Promise))(function(d, h) {
    function n(c) {
      try {
        i(a.next(c));
      } catch (f) {
        h(f);
      }
    }
    function u(c) {
      try {
        i(a.throw(c));
      } catch (f) {
        h(f);
      }
    }
    function i(c) {
      c.done ? d(c.value) : l(c.value).then(n, u);
    }
    i((a = a.apply(t, e || [])).next());
  });
}
function Px(t, e) {
  var r = { label: 0, sent: function() {
    if (d[0] & 1) throw d[1];
    return d[1];
  }, trys: [], ops: [] }, a, l, d, h;
  return h = { next: n(0), throw: n(1), return: n(2) }, typeof Symbol == "function" && (h[Symbol.iterator] = function() {
    return this;
  }), h;
  function n(i) {
    return function(c) {
      return u([i, c]);
    };
  }
  function u(i) {
    if (a) throw new TypeError("Generator is already executing.");
    for (; h && (h = 0, i[0] && (r = 0)), r; ) try {
      if (a = 1, l && (d = i[0] & 2 ? l.return : i[0] ? l.throw || ((d = l.return) && d.call(l), 0) : l.next) && !(d = d.call(l, i[1])).done) return d;
      switch (l = 0, d && (i = [i[0] & 2, d.value]), i[0]) {
        case 0:
        case 1:
          d = i;
          break;
        case 4:
          return r.label++, { value: i[1], done: !1 };
        case 5:
          r.label++, l = i[1], i = [0];
          continue;
        case 7:
          i = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (d = r.trys, !(d = d.length > 0 && d[d.length - 1]) && (i[0] === 6 || i[0] === 2)) {
            r = 0;
            continue;
          }
          if (i[0] === 3 && (!d || i[1] > d[0] && i[1] < d[3])) {
            r.label = i[1];
            break;
          }
          if (i[0] === 6 && r.label < d[1]) {
            r.label = d[1], d = i;
            break;
          }
          if (d && r.label < d[2]) {
            r.label = d[2], r.ops.push(i);
            break;
          }
          d[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      i = e.call(t, r);
    } catch (c) {
      i = [6, c], l = 0;
    } finally {
      a = d = 0;
    }
    if (i[0] & 5) throw i[1];
    return { value: i[0] ? i[1] : void 0, done: !0 };
  }
}
var Dd = Object.create ? function(t, e, r, a) {
  a === void 0 && (a = r);
  var l = Object.getOwnPropertyDescriptor(e, r);
  (!l || ("get" in l ? !e.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
    return e[r];
  } }), Object.defineProperty(t, a, l);
} : function(t, e, r, a) {
  a === void 0 && (a = r), t[a] = e[r];
};
function Cx(t, e) {
  for (var r in t) r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && Dd(e, t, r);
}
function Vf(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], a = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && a >= t.length && (t = void 0), { value: t && t[a++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function $y(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var a = r.call(t), l, d = [], h;
  try {
    for (; (e === void 0 || e-- > 0) && !(l = a.next()).done; ) d.push(l.value);
  } catch (n) {
    h = { error: n };
  } finally {
    try {
      l && !l.done && (r = a.return) && r.call(a);
    } finally {
      if (h) throw h.error;
    }
  }
  return d;
}
function Ix() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat($y(arguments[e]));
  return t;
}
function Ox() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var a = Array(t), l = 0, e = 0; e < r; e++)
    for (var d = arguments[e], h = 0, n = d.length; h < n; h++, l++)
      a[l] = d[h];
  return a;
}
function kx(t, e, r) {
  if (r || arguments.length === 2) for (var a = 0, l = e.length, d; a < l; a++)
    (d || !(a in e)) && (d || (d = Array.prototype.slice.call(e, 0, a)), d[a] = e[a]);
  return t.concat(d || Array.prototype.slice.call(e));
}
function al(t) {
  return this instanceof al ? (this.v = t, this) : new al(t);
}
function Dx(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var a = r.apply(t, e || []), l, d = [];
  return l = {}, n("next"), n("throw"), n("return", h), l[Symbol.asyncIterator] = function() {
    return this;
  }, l;
  function h(o) {
    return function(y) {
      return Promise.resolve(y).then(o, f);
    };
  }
  function n(o, y) {
    a[o] && (l[o] = function(m) {
      return new Promise(function(g, b) {
        d.push([o, m, g, b]) > 1 || u(o, m);
      });
    }, y && (l[o] = y(l[o])));
  }
  function u(o, y) {
    try {
      i(a[o](y));
    } catch (m) {
      s(d[0][3], m);
    }
  }
  function i(o) {
    o.value instanceof al ? Promise.resolve(o.value.v).then(c, f) : s(d[0][2], o);
  }
  function c(o) {
    u("next", o);
  }
  function f(o) {
    u("throw", o);
  }
  function s(o, y) {
    o(y), d.shift(), d.length && u(d[0][0], d[0][1]);
  }
}
function Nx(t) {
  var e, r;
  return e = {}, a("next"), a("throw", function(l) {
    throw l;
  }), a("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function a(l, d) {
    e[l] = t[l] ? function(h) {
      return (r = !r) ? { value: al(t[l](h)), done: !1 } : d ? d(h) : h;
    } : d;
  }
}
function Rx(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof Vf == "function" ? Vf(t) : t[Symbol.iterator](), r = {}, a("next"), a("throw"), a("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function a(d) {
    r[d] = t[d] && function(h) {
      return new Promise(function(n, u) {
        h = t[d](h), l(n, u, h.done, h.value);
      });
    };
  }
  function l(d, h, n, u) {
    Promise.resolve(u).then(function(i) {
      d({ value: i, done: n });
    }, h);
  }
}
function Mx(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
var WD = Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
};
function Lx(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Dd(e, t, r);
  return WD(e, t), e;
}
function jx(t) {
  return t && t.__esModule ? t : { default: t };
}
function Fx(t, e, r, a) {
  if (r === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !a : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? a : r === "a" ? a.call(t) : a ? a.value : e.get(t);
}
function Bx(t, e, r, a, l) {
  if (a === "m") throw new TypeError("Private method is not writable");
  if (a === "a" && !l) throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !l : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return a === "a" ? l.call(t, r) : l ? l.value = r : e.set(t, r), r;
}
function $x(t, e) {
  if (e === null || typeof e != "object" && typeof e != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof t == "function" ? e === t : t.has(e);
}
function Ux(t, e, r) {
  if (e != null) {
    if (typeof e != "object" && typeof e != "function") throw new TypeError("Object expected.");
    var a, l;
    if (r) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      a = e[Symbol.asyncDispose];
    }
    if (a === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      a = e[Symbol.dispose], r && (l = a);
    }
    if (typeof a != "function") throw new TypeError("Object not disposable.");
    l && (a = function() {
      try {
        l.call(this);
      } catch (d) {
        return Promise.reject(d);
      }
    }), t.stack.push({ value: e, dispose: a, async: r });
  } else r && t.stack.push({ async: !0 });
  return e;
}
var qD = typeof SuppressedError == "function" ? SuppressedError : function(t, e, r) {
  var a = new Error(r);
  return a.name = "SuppressedError", a.error = t, a.suppressed = e, a;
};
function Vx(t) {
  function e(a) {
    t.error = t.hasError ? new qD(a, t.error, "An error was suppressed during disposal.") : a, t.hasError = !0;
  }
  function r() {
    for (; t.stack.length; ) {
      var a = t.stack.pop();
      try {
        var l = a.dispose && a.dispose.call(a.value);
        if (a.async) return Promise.resolve(l).then(r, function(d) {
          return e(d), r();
        });
      } catch (d) {
        e(d);
      }
    }
    if (t.hasError) throw t.error;
  }
  return r();
}
const HD = {
  __extends: _x,
  __assign: Uf,
  __rest: Sx,
  __decorate: wx,
  __param: xx,
  __metadata: Tx,
  __awaiter: Ax,
  __generator: Px,
  __createBinding: Dd,
  __exportStar: Cx,
  __values: Vf,
  __read: $y,
  __spread: Ix,
  __spreadArrays: Ox,
  __spreadArray: kx,
  __await: al,
  __asyncGenerator: Dx,
  __asyncDelegator: Nx,
  __asyncValues: Rx,
  __makeTemplateObject: Mx,
  __importStar: Lx,
  __importDefault: jx,
  __classPrivateFieldGet: Fx,
  __classPrivateFieldSet: Bx,
  __classPrivateFieldIn: $x,
  __addDisposableResource: Ux,
  __disposeResources: Vx
}, GD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource: Ux,
  get __assign() {
    return Uf;
  },
  __asyncDelegator: Nx,
  __asyncGenerator: Dx,
  __asyncValues: Rx,
  __await: al,
  __awaiter: Ax,
  __classPrivateFieldGet: Fx,
  __classPrivateFieldIn: $x,
  __classPrivateFieldSet: Bx,
  __createBinding: Dd,
  __decorate: wx,
  __disposeResources: Vx,
  __esDecorate: BD,
  __exportStar: Cx,
  __extends: _x,
  __generator: Px,
  __importDefault: jx,
  __importStar: Lx,
  __makeTemplateObject: Mx,
  __metadata: Tx,
  __param: xx,
  __propKey: UD,
  __read: $y,
  __rest: Sx,
  __runInitializers: $D,
  __setFunctionName: VD,
  __spread: Ix,
  __spreadArray: kx,
  __spreadArrays: Ox,
  __values: Vf,
  default: HD
}, Symbol.toStringTag, { value: "Module" })), zD = /* @__PURE__ */ vd(GD);
var Wl = {}, CE;
function KD() {
  if (CE) return Wl;
  CE = 1, Object.defineProperty(Wl, "__esModule", { value: !0 }), Wl.printTree = void 0;
  const t = (e = "", r) => {
    let a = "", l = r.length - 1;
    for (; l >= 0 && !r[l]; l--)
      ;
    for (let d = 0; d <= l; d++) {
      const h = r[d];
      if (!h)
        continue;
      const n = d === l, u = h(e + (n ? " " : "│") + "  "), i = u ? n ? "└─" : "├─" : "│";
      a += `
` + e + i + (u ? " " + u : "");
    }
    return a;
  };
  return Wl.printTree = t, Wl;
}
var ql = {}, IE;
function YD() {
  if (IE) return ql;
  IE = 1, Object.defineProperty(ql, "__esModule", { value: !0 }), ql.printBinary = void 0;
  const t = (e = "", r) => {
    const a = r[0], l = r[1];
    let d = "";
    return a && (d += `
` + e + "← " + a(e + "  ")), l && (d += `
` + e + "→ " + l(e + "  ")), d;
  };
  return ql.printBinary = t, ql;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = zD;
  e.__exportStar(KD(), t), e.__exportStar(YD(), t);
})(Ex);
var Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.newNotAllowedError = Qn.newTypeMismatchError = Qn.newNotFoundError = Qn.assertCanWrite = Qn.assertName = Qn.basename = Qn.ctx = void 0;
const XD = (t = {}) => Object.assign({ separator: "/", syncHandleAllowed: !1, mode: "read" }, t);
Qn.ctx = XD;
const JD = (t, e) => {
  t[t.length - 1] === e && (t = t.slice(0, -1));
  const r = t.lastIndexOf(e);
  return r === -1 ? t : t.slice(r + 1);
};
Qn.basename = JD;
const QD = /^(\.{1,2})$|^(.*([\/\\]).*)$/, ZD = (t, e, r) => {
  if (!t || QD.test(t))
    throw new TypeError(`Failed to execute '${e}' on '${r}': Name is not allowed.`);
};
Qn.assertName = ZD;
const e5 = (t) => {
  if (t !== "readwrite")
    throw new DOMException("The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError");
};
Qn.assertCanWrite = e5;
const t5 = () => new DOMException("A requested file or directory could not be found at the time an operation was processed.", "NotFoundError");
Qn.newNotFoundError = t5;
const r5 = () => new DOMException("The path supplied exists, but was not an entry of requested type.", "TypeMismatchError");
Qn.newTypeMismatchError = r5;
const n5 = () => new DOMException("Permission not granted.", "NotAllowedError");
Qn.newNotAllowedError = n5;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.toTreeSync = void 0;
  const e = Ex, r = Qn, a = (l, d = {}) => {
    var h;
    const n = d.separator || "/";
    let u = d.dir || n;
    u[u.length - 1] !== n && (u += n);
    const i = d.tab || "", c = (h = d.depth) !== null && h !== void 0 ? h : 10;
    let f = " (...)";
    if (c > 0) {
      const o = l.readdirSync(u, { withFileTypes: !0 });
      f = (0, e.printTree)(i, o.map((y) => (m) => y.isDirectory() ? (0, t.toTreeSync)(l, { dir: u + y.name, depth: c - 1, tab: m }) : y.isSymbolicLink() ? "" + y.name + " → " + l.readlinkSync(u + y.name) : "" + y.name));
    }
    return (0, r.basename)(u, n) + n + f;
  };
  t.toTreeSync = a;
})(vx);
var Wx = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.getWriteFileOptions = t.writeFileDefaults = t.getRealpathOptsAndCb = t.getRealpathOptions = t.getStatOptsAndCb = t.getStatOptions = t.getAppendFileOptsAndCb = t.getAppendFileOpts = t.getReaddirOptsAndCb = t.getReaddirOptions = t.getReadFileOptions = t.getRmOptsAndCb = t.getRmdirOptions = t.getDefaultOptsAndCb = t.getDefaultOpts = t.optsDefaults = t.optsAndCbGenerator = t.optsGenerator = t.getOptions = t.getMkdirOptions = void 0;
  const e = Aa, r = $u, a = qu, l = {
    mode: 511,
    recursive: !1
  }, d = (E) => typeof E == "number" ? Object.assign({}, l, { mode: E }) : Object.assign({}, l, E);
  t.getMkdirOptions = d;
  const h = (E) => `Expected options to be either an object or a string, but got ${E} instead`;
  function n(E, O) {
    let D;
    if (O) {
      const $ = typeof O;
      switch ($) {
        case "string":
          D = Object.assign({}, E, { encoding: O });
          break;
        case "object":
          D = Object.assign({}, E, O);
          break;
        default:
          throw TypeError(h($));
      }
    } else
      return E;
    return D.encoding !== "buffer" && (0, r.assertEncoding)(D.encoding), D;
  }
  t.getOptions = n;
  function u(E) {
    return (O) => n(E, O);
  }
  t.optsGenerator = u;
  function i(E) {
    return (O, D) => typeof O == "function" ? [E(), O] : [E(O), (0, a.validateCallback)(D)];
  }
  t.optsAndCbGenerator = i, t.optsDefaults = {
    encoding: "utf8"
  }, t.getDefaultOpts = u(t.optsDefaults), t.getDefaultOptsAndCb = i(t.getDefaultOpts);
  const c = {
    recursive: !1
  }, f = (E) => Object.assign({}, c, E);
  t.getRmdirOptions = f;
  const s = u(t.optsDefaults);
  t.getRmOptsAndCb = i(s);
  const o = {
    flag: "r"
  };
  t.getReadFileOptions = u(o);
  const y = {
    encoding: "utf8",
    recursive: !1,
    withFileTypes: !1
  };
  t.getReaddirOptions = u(y), t.getReaddirOptsAndCb = i(t.getReaddirOptions);
  const m = {
    encoding: "utf8",
    mode: 438,
    flag: e.FLAGS[e.FLAGS.a]
  };
  t.getAppendFileOpts = u(m), t.getAppendFileOptsAndCb = i(t.getAppendFileOpts);
  const g = {
    bigint: !1
  }, b = (E = {}) => Object.assign({}, g, E);
  t.getStatOptions = b;
  const v = (E, O) => typeof E == "function" ? [(0, t.getStatOptions)(), E] : [(0, t.getStatOptions)(E), (0, a.validateCallback)(O)];
  t.getStatOptsAndCb = v;
  const T = t.optsDefaults;
  t.getRealpathOptions = u(T), t.getRealpathOptsAndCb = i(t.getRealpathOptions), t.writeFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: e.FLAGS[e.FLAGS.w]
  }, t.getWriteFileOptions = u(t.writeFileDefaults);
})(Wx);
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.FSWatcher = Mn.StatWatcher = Mn.Volume = Mn.toUnixTimestamp = Mn.dataToStr = Mn.pathToSteps = Mn.filenameToSteps = void 0;
const Zo = Qr, Bh = X2, $h = fo, i5 = Sl, Pa = rl, Mo = Ny, Nd = Id, qx = xl, s5 = Ry, Rd = Rr, a5 = Us, Hx = po, ro = $u, o5 = Od, Gx = Fi, l5 = kd, u5 = vx, mu = Aa, Ar = Wx, nt = qu, c5 = Zo.resolve, { O_RDONLY: OE, O_WRONLY: kE, O_RDWR: DE, O_CREAT: NE, O_EXCL: f5, O_TRUNC: d5, O_APPEND: p5, O_DIRECTORY: h5, O_SYMLINK: RE, F_OK: ME, COPYFILE_EXCL: m5, COPYFILE_FICLONE_FORCE: y5 } = a5.constants, { sep: Qi, relative: yu, join: b5, dirname: g5 } = Zo.posix ? Zo.posix : Zo, v5 = 128, E5 = "EPERM", Tn = "ENOENT", Uh = "EBADF", _5 = "EINVAL", Ba = "EEXIST", Lo = "ENOTDIR", S5 = "EMFILE", w5 = "EACCES", LE = "EISDIR", x5 = "ENOTEMPTY", T5 = "ENOSYS", A5 = "ERR_FS_EISDIR", P5 = "ERR_OUT_OF_RANGE";
let wu = (t, e = qx.default.cwd()) => c5(e, t);
if (nt.isWin) {
  const t = wu;
  wu = (e, r) => (0, nt.unixify)(t(e, r));
}
function mn(t, e) {
  const a = wu(t, e).substring(1);
  return a ? a.split(Qi) : [];
}
Mn.filenameToSteps = mn;
function C5(t) {
  return mn((0, nt.pathToFilename)(t));
}
Mn.pathToSteps = C5;
function I5(t, e = ro.ENCODING_UTF8) {
  return Pa.Buffer.isBuffer(t) ? t.toString(e) : t instanceof Uint8Array ? (0, Pa.bufferFrom)(t).toString(e) : String(t);
}
Mn.dataToStr = I5;
function Xs(t) {
  if (typeof t == "string" && +t == t)
    return +t;
  if (t instanceof Date)
    return t.getTime() / 1e3;
  if (isFinite(t))
    return t < 0 ? Date.now() / 1e3 : t;
  throw new Error("Cannot parse time: " + t);
}
Mn.toUnixTimestamp = Xs;
function jo(t) {
  if (typeof t != "number")
    throw TypeError(mu.ERRSTR.UID);
}
function Fo(t) {
  if (typeof t != "number")
    throw TypeError(mu.ERRSTR.GID);
}
function O5(t) {
  const e = {};
  function r(a, l) {
    for (const d in l) {
      const h = l[d], n = b5(a, d);
      typeof h == "string" || h instanceof Pa.Buffer ? e[n] = h : typeof h == "object" && h !== null && Object.keys(h).length > 0 ? r(n, h) : e[n] = null;
    }
  }
  return r("", t), e;
}
const zs = () => {
  throw new Error("Not implemented");
};
class el {
  static fromJSON(e, r) {
    const a = new el();
    return a.fromJSON(e, r), a;
  }
  static fromNestedJSON(e, r) {
    const a = new el();
    return a.fromNestedJSON(e, r), a;
  }
  get promises() {
    if (this.promisesApi === null)
      throw new Error("Promise is not supported in this environment.");
    return this.promisesApi;
  }
  constructor(e = {}) {
    this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.maxFiles = 1e4, this.openFiles = 0, this.promisesApi = new l5.FsPromises(this, o5.FileHandle), this.statWatchers = {}, this.cpSync = zs, this.lutimesSync = zs, this.statfsSync = zs, this.opendirSync = zs, this.cp = zs, this.lutimes = zs, this.statfs = zs, this.openAsBlob = zs, this.opendir = zs, this.props = Object.assign({ Node: Bh.Node, Link: Bh.Link, File: Bh.File }, e);
    const r = this.createLink();
    r.setNode(this.createNode(!0));
    const a = this;
    this.StatWatcher = class extends zx {
      constructor() {
        super(a);
      }
    };
    const l = Rs;
    this.ReadStream = class extends l {
      constructor(...h) {
        super(a, ...h);
      }
    };
    const d = Bi;
    this.WriteStream = class extends d {
      constructor(...h) {
        super(a, ...h);
      }
    }, this.FSWatcher = class extends Yx {
      constructor() {
        super(a);
      }
    }, r.setChild(".", r), r.getNode().nlink++, r.setChild("..", r), r.getNode().nlink++, this.root = r;
  }
  createLink(e, r, a = !1, l) {
    if (!e)
      return new this.props.Link(this, null, "");
    if (!r)
      throw new Error("createLink: name cannot be empty");
    return e.createChild(r, this.createNode(a, l));
  }
  deleteLink(e) {
    const r = e.parent;
    return r ? (r.deleteChild(e), !0) : !1;
  }
  newInoNumber() {
    const e = this.releasedInos.pop();
    return e || (this.ino = (this.ino + 1) % 4294967295, this.ino);
  }
  newFdNumber() {
    const e = this.releasedFds.pop();
    return typeof e == "number" ? e : el.fd--;
  }
  createNode(e = !1, r) {
    const a = new this.props.Node(this.newInoNumber(), r);
    return e && a.setIsDirectory(), this.inodes[a.ino] = a, a;
  }
  deleteNode(e) {
    e.del(), delete this.inodes[e.ino], this.releasedInos.push(e.ino);
  }
  // Returns a `Link` (hard link) referenced by path "split" into steps.
  getLink(e) {
    return this.root.walk(e);
  }
  // Just link `getLink`, but throws a correct user error, if link to found.
  getLinkOrThrow(e, r) {
    const a = mn(e), l = this.getLink(a);
    if (!l)
      throw (0, nt.createError)(Tn, r, e);
    return l;
  }
  // Just like `getLink`, but also dereference/resolves symbolic links.
  getResolvedLink(e) {
    let r = typeof e == "string" ? mn(e) : e, a = this.root, l = 0;
    for (; l < r.length; ) {
      const d = r[l];
      if (a = a.getChild(d), !a)
        return null;
      const h = a.getNode();
      if (h.isSymlink()) {
        r = h.symlink.concat(r.slice(l + 1)), a = this.root, l = 0;
        continue;
      }
      l++;
    }
    return a;
  }
  // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
  getResolvedLinkOrThrow(e, r) {
    const a = this.getResolvedLink(e);
    if (!a)
      throw (0, nt.createError)(Tn, r, e);
    return a;
  }
  resolveSymlinks(e) {
    return this.getResolvedLink(e.steps.slice(1));
  }
  // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
  getLinkAsDirOrThrow(e, r) {
    const a = this.getLinkOrThrow(e, r);
    if (!a.getNode().isDirectory())
      throw (0, nt.createError)(Lo, r, e);
    return a;
  }
  // Get the immediate parent directory of the link.
  getLinkParent(e) {
    return this.root.walk(e, e.length - 1);
  }
  getLinkParentAsDirOrThrow(e, r) {
    const a = e instanceof Array ? e : mn(e), l = this.getLinkParent(a);
    if (!l)
      throw (0, nt.createError)(Tn, r, Qi + a.join(Qi));
    if (!l.getNode().isDirectory())
      throw (0, nt.createError)(Lo, r, Qi + a.join(Qi));
    return l;
  }
  getFileByFd(e) {
    return this.fds[String(e)];
  }
  getFileByFdOrThrow(e, r) {
    if (!(0, nt.isFd)(e))
      throw TypeError(mu.ERRSTR.FD);
    const a = this.getFileByFd(e);
    if (!a)
      throw (0, nt.createError)(Uh, r);
    return a;
  }
  /**
   * @todo This is not used anymore. Remove.
   */
  /*
    private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {
      if (typeof id === 'number') {
        const file = this.getFileByFd(id);
        if (!file) throw Error('File nto found');
        return file.node;
      } else {
        const steps = pathToSteps(id as PathLike);
        let link = this.getLink(steps);
        if (link) return link.getNode();
  
        // Try creating a node if not found.
        if (flags & O_CREAT) {
          const dirLink = this.getLinkParent(steps);
          if (dirLink) {
            const name = steps[steps.length - 1];
            link = this.createLink(dirLink, name, false, perm);
            return link.getNode();
          }
        }
  
        throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
      }
    }
    */
  wrapAsync(e, r, a) {
    (0, nt.validateCallback)(a), (0, Mo.default)(() => {
      let l;
      try {
        l = e.apply(this, r);
      } catch (d) {
        a(d);
        return;
      }
      a(null, l);
    });
  }
  _toJSON(e = this.root, r = {}, a, l) {
    let d = !0, h = e.children;
    e.getNode().isFile() && (h = /* @__PURE__ */ new Map([[e.getName(), e.parent.getChild(e.getName())]]), e = e.parent);
    for (const u of h.keys()) {
      if (u === "." || u === "..")
        continue;
      d = !1;
      const i = e.getChild(u);
      if (!i)
        throw new Error("_toJSON: unexpected undefined");
      const c = i.getNode();
      if (c.isFile()) {
        let f = i.getPath();
        a && (f = yu(a, f)), r[f] = l ? c.getBuffer() : c.getString();
      } else c.isDirectory() && this._toJSON(i, r, a);
    }
    let n = e.getPath();
    return a && (n = yu(a, n)), n && d && (r[n] = null), r;
  }
  toJSON(e, r = {}, a = !1, l = !1) {
    const d = [];
    if (e) {
      Array.isArray(e) || (e = [e]);
      for (const h of e) {
        const n = (0, nt.pathToFilename)(h), u = this.getResolvedLink(n);
        u && d.push(u);
      }
    } else
      d.push(this.root);
    if (!d.length)
      return r;
    for (const h of d)
      this._toJSON(h, r, a ? h.getPath() : "", l);
    return r;
  }
  // TODO: `cwd` should probably not invoke `process.cwd()`.
  fromJSON(e, r = qx.default.cwd()) {
    for (let a in e) {
      const l = e[a];
      if (a = wu(a, r), typeof l == "string" || l instanceof Pa.Buffer) {
        const d = g5(a);
        this.mkdirpBase(
          d,
          511
          /* MODE.DIR */
        ), this.writeFileSync(a, l);
      } else
        this.mkdirpBase(
          a,
          511
          /* MODE.DIR */
        );
    }
  }
  fromNestedJSON(e, r) {
    this.fromJSON(O5(e), r);
  }
  toTree(e = { separator: Qi }) {
    return (0, u5.toTreeSync)(this, e);
  }
  reset() {
    this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.openFiles = 0, this.root = this.createLink(), this.root.setNode(this.createNode(!0));
  }
  // Legacy interface
  mountSync(e, r) {
    this.fromJSON(r, e);
  }
  openLink(e, r, a = !0) {
    if (this.openFiles >= this.maxFiles)
      throw (0, nt.createError)(S5, "open", e.getPath());
    let l = e;
    if (a && (l = this.resolveSymlinks(e)), !l)
      throw (0, nt.createError)(Tn, "open", e.getPath());
    const d = l.getNode();
    if (d.isDirectory()) {
      if ((r & (OE | DE | kE)) !== OE)
        throw (0, nt.createError)(LE, "open", e.getPath());
    } else if (r & h5)
      throw (0, nt.createError)(Lo, "open", e.getPath());
    if (!(r & kE) && !d.canRead())
      throw (0, nt.createError)(w5, "open", e.getPath());
    const h = new this.props.File(e, d, r, this.newFdNumber());
    return this.fds[h.fd] = h, this.openFiles++, r & d5 && h.truncate(), h;
  }
  openFile(e, r, a, l = !0) {
    const d = mn(e);
    let h = l ? this.getResolvedLink(d) : this.getLink(d);
    if (h && r & f5)
      throw (0, nt.createError)(Ba, "open", e);
    if (!h && r & NE) {
      const n = this.getResolvedLink(d.slice(0, d.length - 1));
      if (!n)
        throw (0, nt.createError)(Tn, "open", Qi + d.join(Qi));
      r & NE && typeof a == "number" && (h = this.createLink(n, d[d.length - 1], !1, a));
    }
    if (h)
      return this.openLink(h, r, l);
    throw (0, nt.createError)(Tn, "open", e);
  }
  openBase(e, r, a, l = !0) {
    const d = this.openFile(e, r, a, l);
    if (!d)
      throw (0, nt.createError)(Tn, "open", e);
    return d.fd;
  }
  openSync(e, r, a = 438) {
    const l = (0, nt.modeToNumber)(a), d = (0, nt.pathToFilename)(e), h = (0, nt.flagsToNumber)(r);
    return this.openBase(d, h, l, !(h & RE));
  }
  open(e, r, a, l) {
    let d = a, h = l;
    typeof a == "function" && (d = 438, h = a), d = d || 438;
    const n = (0, nt.modeToNumber)(d), u = (0, nt.pathToFilename)(e), i = (0, nt.flagsToNumber)(r);
    this.wrapAsync(this.openBase, [u, i, n, !(i & RE)], h);
  }
  closeFile(e) {
    this.fds[e.fd] && (this.openFiles--, delete this.fds[e.fd], this.releasedFds.push(e.fd));
  }
  closeSync(e) {
    (0, nt.validateFd)(e);
    const r = this.getFileByFdOrThrow(e, "close");
    this.closeFile(r);
  }
  close(e, r) {
    (0, nt.validateFd)(e), this.wrapAsync(this.closeSync, [e], r);
  }
  openFileOrGetById(e, r, a) {
    if (typeof e == "number") {
      const l = this.fds[e];
      if (!l)
        throw (0, nt.createError)(Tn);
      return l;
    } else
      return this.openFile((0, nt.pathToFilename)(e), r, a);
  }
  readBase(e, r, a, l, d) {
    if (r.byteLength < l)
      throw (0, nt.createError)(P5, "read", void 0, void 0, RangeError);
    const h = this.getFileByFdOrThrow(e);
    if (h.node.isSymlink())
      throw (0, nt.createError)(E5, "read", h.link.getPath());
    return h.read(r, Number(a), Number(l), d === -1 || typeof d != "number" ? void 0 : d);
  }
  readSync(e, r, a, l, d) {
    return (0, nt.validateFd)(e), this.readBase(e, r, a, l, d);
  }
  read(e, r, a, l, d, h) {
    if ((0, nt.validateCallback)(h), l === 0)
      return (0, Nd.default)(() => {
        h && h(null, 0, r);
      });
    (0, Mo.default)(() => {
      try {
        const n = this.readBase(e, r, a, l, d);
        h(null, n, r);
      } catch (n) {
        h(n);
      }
    });
  }
  readvBase(e, r, a) {
    const l = this.getFileByFdOrThrow(e);
    let d = a ?? void 0;
    d === -1 && (d = void 0);
    let h = 0;
    for (const n of r) {
      const u = l.read(n, 0, n.byteLength, d);
      if (d = void 0, h += u, u < n.byteLength)
        break;
    }
    return h;
  }
  readv(e, r, a, l) {
    let d = a, h = l;
    typeof a == "function" && (d = null, h = a), (0, nt.validateCallback)(h), (0, Mo.default)(() => {
      try {
        const n = this.readvBase(e, r, d);
        h(null, n, r);
      } catch (n) {
        h(n);
      }
    });
  }
  readvSync(e, r, a) {
    return (0, nt.validateFd)(e), this.readvBase(e, r, a);
  }
  readFileBase(e, r, a) {
    let l;
    const h = typeof e == "number" && (0, nt.isFd)(e);
    let n;
    if (h)
      n = e;
    else {
      const u = (0, nt.pathToFilename)(e), i = mn(u), c = this.getResolvedLink(i);
      if (c && c.getNode().isDirectory())
        throw (0, nt.createError)(LE, "open", c.getPath());
      n = this.openSync(e, r);
    }
    try {
      l = (0, nt.bufferToEncoding)(this.getFileByFdOrThrow(n).getBuffer(), a);
    } finally {
      h || this.closeSync(n);
    }
    return l;
  }
  readFileSync(e, r) {
    const a = (0, Ar.getReadFileOptions)(r), l = (0, nt.flagsToNumber)(a.flag);
    return this.readFileBase(e, l, a.encoding);
  }
  readFile(e, r, a) {
    const [l, d] = (0, Ar.optsAndCbGenerator)(Ar.getReadFileOptions)(r, a), h = (0, nt.flagsToNumber)(l.flag);
    this.wrapAsync(this.readFileBase, [e, h, l.encoding], d);
  }
  writeBase(e, r, a, l, d) {
    const h = this.getFileByFdOrThrow(e, "write");
    if (h.node.isSymlink())
      throw (0, nt.createError)(Uh, "write", h.link.getPath());
    return h.write(r, a, l, d === -1 || typeof d != "number" ? void 0 : d);
  }
  writeSync(e, r, a, l, d) {
    const [, h, n, u, i] = (0, nt.getWriteSyncArgs)(e, r, a, l, d);
    return this.writeBase(e, h, n, u, i);
  }
  write(e, r, a, l, d, h) {
    const [, n, u, i, c, f, s] = (0, nt.getWriteArgs)(e, r, a, l, d, h);
    (0, Mo.default)(() => {
      try {
        const o = this.writeBase(e, u, i, c, f);
        n ? s(null, o, r) : s(null, o, u);
      } catch (o) {
        s(o);
      }
    });
  }
  writevBase(e, r, a) {
    const l = this.getFileByFdOrThrow(e);
    let d = a ?? void 0;
    d === -1 && (d = void 0);
    let h = 0;
    for (const n of r) {
      const u = Pa.Buffer.from(n.buffer, n.byteOffset, n.byteLength), i = l.write(u, 0, u.byteLength, d);
      if (d = void 0, h += i, i < u.byteLength)
        break;
    }
    return h;
  }
  writev(e, r, a, l) {
    let d = a, h = l;
    typeof a == "function" && (d = null, h = a), (0, nt.validateCallback)(h), (0, Mo.default)(() => {
      try {
        const n = this.writevBase(e, r, d);
        h(null, n, r);
      } catch (n) {
        h(n);
      }
    });
  }
  writevSync(e, r, a) {
    return (0, nt.validateFd)(e), this.writevBase(e, r, a);
  }
  writeFileBase(e, r, a, l) {
    const d = typeof e == "number";
    let h;
    d ? h = e : h = this.openBase((0, nt.pathToFilename)(e), a, l);
    let n = 0, u = r.length, i = a & p5 ? void 0 : 0;
    try {
      for (; u > 0; ) {
        const c = this.writeSync(h, r, n, u, i);
        n += c, u -= c, i !== void 0 && (i += c);
      }
    } finally {
      d || this.closeSync(h);
    }
  }
  writeFileSync(e, r, a) {
    const l = (0, Ar.getWriteFileOptions)(a), d = (0, nt.flagsToNumber)(l.flag), h = (0, nt.modeToNumber)(l.mode), n = (0, nt.dataToBuffer)(r, l.encoding);
    this.writeFileBase(e, n, d, h);
  }
  writeFile(e, r, a, l) {
    let d = a, h = l;
    typeof a == "function" && (d = Ar.writeFileDefaults, h = a);
    const n = (0, nt.validateCallback)(h), u = (0, Ar.getWriteFileOptions)(d), i = (0, nt.flagsToNumber)(u.flag), c = (0, nt.modeToNumber)(u.mode), f = (0, nt.dataToBuffer)(r, u.encoding);
    this.wrapAsync(this.writeFileBase, [e, f, i, c], n);
  }
  linkBase(e, r) {
    const a = mn(e), l = this.getLink(a);
    if (!l)
      throw (0, nt.createError)(Tn, "link", e, r);
    const d = mn(r), h = this.getLinkParent(d);
    if (!h)
      throw (0, nt.createError)(Tn, "link", e, r);
    const n = d[d.length - 1];
    if (h.getChild(n))
      throw (0, nt.createError)(Ba, "link", e, r);
    const u = l.getNode();
    u.nlink++, h.createChild(n, u);
  }
  copyFileBase(e, r, a) {
    const l = this.readFileSync(e);
    if (a & m5 && this.existsSync(r))
      throw (0, nt.createError)(Ba, "copyFile", e, r);
    if (a & y5)
      throw (0, nt.createError)(T5, "copyFile", e, r);
    this.writeFileBase(
      r,
      l,
      mu.FLAGS.w,
      438
      /* MODE.DEFAULT */
    );
  }
  copyFileSync(e, r, a) {
    const l = (0, nt.pathToFilename)(e), d = (0, nt.pathToFilename)(r);
    return this.copyFileBase(l, d, (a || 0) | 0);
  }
  copyFile(e, r, a, l) {
    const d = (0, nt.pathToFilename)(e), h = (0, nt.pathToFilename)(r);
    let n, u;
    typeof a == "function" ? (n = 0, u = a) : (n = a, u = l), (0, nt.validateCallback)(u), this.wrapAsync(this.copyFileBase, [d, h, n], u);
  }
  linkSync(e, r) {
    const a = (0, nt.pathToFilename)(e), l = (0, nt.pathToFilename)(r);
    this.linkBase(a, l);
  }
  link(e, r, a) {
    const l = (0, nt.pathToFilename)(e), d = (0, nt.pathToFilename)(r);
    this.wrapAsync(this.linkBase, [l, d], a);
  }
  unlinkBase(e) {
    const r = mn(e), a = this.getLink(r);
    if (!a)
      throw (0, nt.createError)(Tn, "unlink", e);
    if (a.length)
      throw Error("Dir not empty...");
    this.deleteLink(a);
    const l = a.getNode();
    l.nlink--, l.nlink <= 0 && this.deleteNode(l);
  }
  unlinkSync(e) {
    const r = (0, nt.pathToFilename)(e);
    this.unlinkBase(r);
  }
  unlink(e, r) {
    const a = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.unlinkBase, [a], r);
  }
  symlinkBase(e, r) {
    const a = mn(r), l = this.getLinkParent(a);
    if (!l)
      throw (0, nt.createError)(Tn, "symlink", e, r);
    const d = a[a.length - 1];
    if (l.getChild(d))
      throw (0, nt.createError)(Ba, "symlink", e, r);
    const h = l.createChild(d);
    return h.getNode().makeSymlink(mn(e)), h;
  }
  // `type` argument works only on Windows.
  symlinkSync(e, r, a) {
    const l = (0, nt.pathToFilename)(e), d = (0, nt.pathToFilename)(r);
    this.symlinkBase(l, d);
  }
  symlink(e, r, a, l) {
    const d = (0, nt.validateCallback)(typeof a == "function" ? a : l), h = (0, nt.pathToFilename)(e), n = (0, nt.pathToFilename)(r);
    this.wrapAsync(this.symlinkBase, [h, n], d);
  }
  realpathBase(e, r) {
    const a = mn(e), l = this.getResolvedLink(a);
    if (!l)
      throw (0, nt.createError)(Tn, "realpath", e);
    return (0, ro.strToEncoding)(l.getPath() || "/", r);
  }
  realpathSync(e, r) {
    return this.realpathBase((0, nt.pathToFilename)(e), (0, Ar.getRealpathOptions)(r).encoding);
  }
  realpath(e, r, a) {
    const [l, d] = (0, Ar.getRealpathOptsAndCb)(r, a), h = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.realpathBase, [h, l.encoding], d);
  }
  lstatBase(e, r = !1, a = !1) {
    const l = this.getLink(mn(e));
    if (l)
      return $h.default.build(l.getNode(), r);
    if (a)
      throw (0, nt.createError)(Tn, "lstat", e);
  }
  lstatSync(e, r) {
    const { throwIfNoEntry: a = !0, bigint: l = !1 } = (0, Ar.getStatOptions)(r);
    return this.lstatBase((0, nt.pathToFilename)(e), l, a);
  }
  lstat(e, r, a) {
    const [{ throwIfNoEntry: l = !0, bigint: d = !1 }, h] = (0, Ar.getStatOptsAndCb)(r, a);
    this.wrapAsync(this.lstatBase, [(0, nt.pathToFilename)(e), d, l], h);
  }
  statBase(e, r = !1, a = !0) {
    const l = this.getResolvedLink(mn(e));
    if (l)
      return $h.default.build(l.getNode(), r);
    if (a)
      throw (0, nt.createError)(Tn, "stat", e);
  }
  statSync(e, r) {
    const { bigint: a = !0, throwIfNoEntry: l = !0 } = (0, Ar.getStatOptions)(r);
    return this.statBase((0, nt.pathToFilename)(e), a, l);
  }
  stat(e, r, a) {
    const [{ bigint: l = !1, throwIfNoEntry: d = !0 }, h] = (0, Ar.getStatOptsAndCb)(r, a);
    this.wrapAsync(this.statBase, [(0, nt.pathToFilename)(e), l, d], h);
  }
  fstatBase(e, r = !1) {
    const a = this.getFileByFd(e);
    if (!a)
      throw (0, nt.createError)(Uh, "fstat");
    return $h.default.build(a.node, r);
  }
  fstatSync(e, r) {
    return this.fstatBase(e, (0, Ar.getStatOptions)(r).bigint);
  }
  fstat(e, r, a) {
    const [l, d] = (0, Ar.getStatOptsAndCb)(r, a);
    this.wrapAsync(this.fstatBase, [e, l.bigint], d);
  }
  renameBase(e, r) {
    const a = this.getLink(mn(e));
    if (!a)
      throw (0, nt.createError)(Tn, "rename", e, r);
    const l = mn(r), d = this.getLinkParent(l);
    if (!d)
      throw (0, nt.createError)(Tn, "rename", e, r);
    const h = a.parent;
    h && h.deleteChild(a);
    const n = l[l.length - 1];
    a.name = n, a.steps = [...d.steps, n], d.setChild(a.getName(), a);
  }
  renameSync(e, r) {
    const a = (0, nt.pathToFilename)(e), l = (0, nt.pathToFilename)(r);
    this.renameBase(a, l);
  }
  rename(e, r, a) {
    const l = (0, nt.pathToFilename)(e), d = (0, nt.pathToFilename)(r);
    this.wrapAsync(this.renameBase, [l, d], a);
  }
  existsBase(e) {
    return !!this.statBase(e);
  }
  existsSync(e) {
    try {
      return this.existsBase((0, nt.pathToFilename)(e));
    } catch {
      return !1;
    }
  }
  exists(e, r) {
    const a = (0, nt.pathToFilename)(e);
    if (typeof r != "function")
      throw Error(mu.ERRSTR.CB);
    (0, Mo.default)(() => {
      try {
        r(this.existsBase(a));
      } catch {
        r(!1);
      }
    });
  }
  accessBase(e, r) {
    this.getLinkOrThrow(e, "access");
  }
  accessSync(e, r = ME) {
    const a = (0, nt.pathToFilename)(e);
    r = r | 0, this.accessBase(a, r);
  }
  access(e, r, a) {
    let l = ME, d;
    typeof r != "function" ? (l = r | 0, d = (0, nt.validateCallback)(a)) : d = r;
    const h = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.accessBase, [h, l], d);
  }
  appendFileSync(e, r, a) {
    const l = (0, Ar.getAppendFileOpts)(a);
    (!l.flag || (0, nt.isFd)(e)) && (l.flag = "a"), this.writeFileSync(e, r, l);
  }
  appendFile(e, r, a, l) {
    const [d, h] = (0, Ar.getAppendFileOptsAndCb)(a, l);
    (!d.flag || (0, nt.isFd)(e)) && (d.flag = "a"), this.writeFile(e, r, d, h);
  }
  readdirBase(e, r) {
    const a = mn(e), l = this.getResolvedLink(a);
    if (!l)
      throw (0, nt.createError)(Tn, "readdir", e);
    if (!l.getNode().isDirectory())
      throw (0, nt.createError)(Lo, "scandir", e);
    const h = [];
    for (const u of l.children.keys()) {
      const i = l.getChild(u);
      if (!(!i || u === "." || u === "..") && (h.push(i5.default.build(i, r.encoding)), r.recursive && i.children.size)) {
        const c = Object.assign(Object.assign({}, r), { recursive: !0, withFileTypes: !0 }), f = this.readdirBase(i.getPath(), c);
        h.push(...f);
      }
    }
    if (!nt.isWin && r.encoding !== "buffer" && h.sort((u, i) => u.name < i.name ? -1 : u.name > i.name ? 1 : 0), r.withFileTypes)
      return h;
    let n = e;
    return nt.isWin && (n = n.replace(/\\/g, "/")), h.map((u) => {
      if (r.recursive) {
        let i = Zo.join(u.path, u.name.toString());
        return nt.isWin && (i = i.replace(/\\/g, "/")), i.replace(n + Zo.posix.sep, "");
      }
      return u.name;
    });
  }
  readdirSync(e, r) {
    const a = (0, Ar.getReaddirOptions)(r), l = (0, nt.pathToFilename)(e);
    return this.readdirBase(l, a);
  }
  readdir(e, r, a) {
    const [l, d] = (0, Ar.getReaddirOptsAndCb)(r, a), h = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.readdirBase, [h, l], d);
  }
  readlinkBase(e, r) {
    const l = this.getLinkOrThrow(e, "readlink").getNode();
    if (!l.isSymlink())
      throw (0, nt.createError)(_5, "readlink", e);
    const d = Qi + l.symlink.join(Qi);
    return (0, ro.strToEncoding)(d, r);
  }
  readlinkSync(e, r) {
    const a = (0, Ar.getDefaultOpts)(r), l = (0, nt.pathToFilename)(e);
    return this.readlinkBase(l, a.encoding);
  }
  readlink(e, r, a) {
    const [l, d] = (0, Ar.getDefaultOptsAndCb)(r, a), h = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.readlinkBase, [h, l.encoding], d);
  }
  fsyncBase(e) {
    this.getFileByFdOrThrow(e, "fsync");
  }
  fsyncSync(e) {
    this.fsyncBase(e);
  }
  fsync(e, r) {
    this.wrapAsync(this.fsyncBase, [e], r);
  }
  fdatasyncBase(e) {
    this.getFileByFdOrThrow(e, "fdatasync");
  }
  fdatasyncSync(e) {
    this.fdatasyncBase(e);
  }
  fdatasync(e, r) {
    this.wrapAsync(this.fdatasyncBase, [e], r);
  }
  ftruncateBase(e, r) {
    this.getFileByFdOrThrow(e, "ftruncate").truncate(r);
  }
  ftruncateSync(e, r) {
    this.ftruncateBase(e, r);
  }
  ftruncate(e, r, a) {
    const l = typeof r == "number" ? r : 0, d = (0, nt.validateCallback)(typeof r == "number" ? a : r);
    this.wrapAsync(this.ftruncateBase, [e, l], d);
  }
  truncateBase(e, r) {
    const a = this.openSync(e, "r+");
    try {
      this.ftruncateSync(a, r);
    } finally {
      this.closeSync(a);
    }
  }
  /**
   * `id` should be a file descriptor or a path. `id` as file descriptor will
   * not be supported soon.
   */
  truncateSync(e, r) {
    if ((0, nt.isFd)(e))
      return this.ftruncateSync(e, r);
    this.truncateBase(e, r);
  }
  truncate(e, r, a) {
    const l = typeof r == "number" ? r : 0, d = (0, nt.validateCallback)(typeof r == "number" ? a : r);
    if ((0, nt.isFd)(e))
      return this.ftruncate(e, l, d);
    this.wrapAsync(this.truncateBase, [e, l], d);
  }
  futimesBase(e, r, a) {
    const d = this.getFileByFdOrThrow(e, "futimes").node;
    d.atime = new Date(r * 1e3), d.mtime = new Date(a * 1e3);
  }
  futimesSync(e, r, a) {
    this.futimesBase(e, Xs(r), Xs(a));
  }
  futimes(e, r, a, l) {
    this.wrapAsync(this.futimesBase, [e, Xs(r), Xs(a)], l);
  }
  utimesBase(e, r, a) {
    const l = this.openSync(e, "r");
    try {
      this.futimesBase(l, r, a);
    } finally {
      this.closeSync(l);
    }
  }
  utimesSync(e, r, a) {
    this.utimesBase((0, nt.pathToFilename)(e), Xs(r), Xs(a));
  }
  utimes(e, r, a, l) {
    this.wrapAsync(this.utimesBase, [(0, nt.pathToFilename)(e), Xs(r), Xs(a)], l);
  }
  mkdirBase(e, r) {
    const a = mn(e);
    if (!a.length)
      throw (0, nt.createError)(Ba, "mkdir", e);
    const l = this.getLinkParentAsDirOrThrow(e, "mkdir"), d = a[a.length - 1];
    if (l.getChild(d))
      throw (0, nt.createError)(Ba, "mkdir", e);
    l.createChild(d, this.createNode(!0, r));
  }
  /**
   * Creates directory tree recursively.
   * @param filename
   * @param modeNum
   */
  mkdirpBase(e, r) {
    const a = wu(e), l = a.substring(1), d = l ? l.split(Qi) : [];
    let h = this.root, n = !1;
    for (let u = 0; u < d.length; u++) {
      const i = d[u];
      if (!h.getNode().isDirectory())
        throw (0, nt.createError)(Lo, "mkdir", h.getPath());
      const c = h.getChild(i);
      if (c)
        if (c.getNode().isDirectory())
          h = c;
        else
          throw (0, nt.createError)(Lo, "mkdir", c.getPath());
      else
        h = h.createChild(i, this.createNode(!0, r)), n = !0;
    }
    return n ? a : void 0;
  }
  mkdirSync(e, r) {
    const a = (0, Ar.getMkdirOptions)(r), l = (0, nt.modeToNumber)(a.mode, 511), d = (0, nt.pathToFilename)(e);
    if (a.recursive)
      return this.mkdirpBase(d, l);
    this.mkdirBase(d, l);
  }
  mkdir(e, r, a) {
    const l = (0, Ar.getMkdirOptions)(r), d = (0, nt.validateCallback)(typeof r == "function" ? r : a), h = (0, nt.modeToNumber)(l.mode, 511), n = (0, nt.pathToFilename)(e);
    l.recursive ? this.wrapAsync(this.mkdirpBase, [n, h], d) : this.wrapAsync(this.mkdirBase, [n, h], d);
  }
  mkdtempBase(e, r, a = 5) {
    const l = e + (0, nt.genRndStr6)();
    try {
      return this.mkdirBase(
        l,
        511
        /* MODE.DIR */
      ), (0, ro.strToEncoding)(l, r);
    } catch (d) {
      if (d.code === Ba) {
        if (a > 1)
          return this.mkdtempBase(e, r, a - 1);
        throw Error("Could not create temp dir.");
      } else
        throw d;
    }
  }
  mkdtempSync(e, r) {
    const { encoding: a } = (0, Ar.getDefaultOpts)(r);
    if (!e || typeof e != "string")
      throw new TypeError("filename prefix is required");
    return (0, nt.nullCheck)(e), this.mkdtempBase(e, a);
  }
  mkdtemp(e, r, a) {
    const [{ encoding: l }, d] = (0, Ar.getDefaultOptsAndCb)(r, a);
    if (!e || typeof e != "string")
      throw new TypeError("filename prefix is required");
    (0, nt.nullCheck)(e) && this.wrapAsync(this.mkdtempBase, [e, l], d);
  }
  rmdirBase(e, r) {
    const a = (0, Ar.getRmdirOptions)(r), l = this.getLinkAsDirOrThrow(e, "rmdir");
    if (l.length && !a.recursive)
      throw (0, nt.createError)(x5, "rmdir", e);
    this.deleteLink(l);
  }
  rmdirSync(e, r) {
    this.rmdirBase((0, nt.pathToFilename)(e), r);
  }
  rmdir(e, r, a) {
    const l = (0, Ar.getRmdirOptions)(r), d = (0, nt.validateCallback)(typeof r == "function" ? r : a);
    this.wrapAsync(this.rmdirBase, [(0, nt.pathToFilename)(e), l], d);
  }
  rmBase(e, r = {}) {
    const a = this.getResolvedLink(e);
    if (!a) {
      if (!r.force)
        throw (0, nt.createError)(Tn, "stat", e);
      return;
    }
    if (a.getNode().isDirectory() && !r.recursive)
      throw (0, nt.createError)(A5, "rm", e);
    this.deleteLink(a);
  }
  rmSync(e, r) {
    this.rmBase((0, nt.pathToFilename)(e), r);
  }
  rm(e, r, a) {
    const [l, d] = (0, Ar.getRmOptsAndCb)(r, a);
    this.wrapAsync(this.rmBase, [(0, nt.pathToFilename)(e), l], d);
  }
  fchmodBase(e, r) {
    this.getFileByFdOrThrow(e, "fchmod").chmod(r);
  }
  fchmodSync(e, r) {
    this.fchmodBase(e, (0, nt.modeToNumber)(r));
  }
  fchmod(e, r, a) {
    this.wrapAsync(this.fchmodBase, [e, (0, nt.modeToNumber)(r)], a);
  }
  chmodBase(e, r) {
    const a = this.openSync(e, "r");
    try {
      this.fchmodBase(a, r);
    } finally {
      this.closeSync(a);
    }
  }
  chmodSync(e, r) {
    const a = (0, nt.modeToNumber)(r), l = (0, nt.pathToFilename)(e);
    this.chmodBase(l, a);
  }
  chmod(e, r, a) {
    const l = (0, nt.modeToNumber)(r), d = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.chmodBase, [d, l], a);
  }
  lchmodBase(e, r) {
    const a = this.openBase(e, DE, 0, !1);
    try {
      this.fchmodBase(a, r);
    } finally {
      this.closeSync(a);
    }
  }
  lchmodSync(e, r) {
    const a = (0, nt.modeToNumber)(r), l = (0, nt.pathToFilename)(e);
    this.lchmodBase(l, a);
  }
  lchmod(e, r, a) {
    const l = (0, nt.modeToNumber)(r), d = (0, nt.pathToFilename)(e);
    this.wrapAsync(this.lchmodBase, [d, l], a);
  }
  fchownBase(e, r, a) {
    this.getFileByFdOrThrow(e, "fchown").chown(r, a);
  }
  fchownSync(e, r, a) {
    jo(r), Fo(a), this.fchownBase(e, r, a);
  }
  fchown(e, r, a, l) {
    jo(r), Fo(a), this.wrapAsync(this.fchownBase, [e, r, a], l);
  }
  chownBase(e, r, a) {
    this.getResolvedLinkOrThrow(e, "chown").getNode().chown(r, a);
  }
  chownSync(e, r, a) {
    jo(r), Fo(a), this.chownBase((0, nt.pathToFilename)(e), r, a);
  }
  chown(e, r, a, l) {
    jo(r), Fo(a), this.wrapAsync(this.chownBase, [(0, nt.pathToFilename)(e), r, a], l);
  }
  lchownBase(e, r, a) {
    this.getLinkOrThrow(e, "lchown").getNode().chown(r, a);
  }
  lchownSync(e, r, a) {
    jo(r), Fo(a), this.lchownBase((0, nt.pathToFilename)(e), r, a);
  }
  lchown(e, r, a, l) {
    jo(r), Fo(a), this.wrapAsync(this.lchownBase, [(0, nt.pathToFilename)(e), r, a], l);
  }
  watchFile(e, r, a) {
    const l = (0, nt.pathToFilename)(e);
    let d = r, h = a;
    if (typeof d == "function" && (h = r, d = null), typeof h != "function")
      throw Error('"watchFile()" requires a listener function');
    let n = 5007, u = !0;
    d && typeof d == "object" && (typeof d.interval == "number" && (n = d.interval), typeof d.persistent == "boolean" && (u = d.persistent));
    let i = this.statWatchers[l];
    return i || (i = new this.StatWatcher(), i.start(l, u, n), this.statWatchers[l] = i), i.addListener("change", h), i;
  }
  unwatchFile(e, r) {
    const a = (0, nt.pathToFilename)(e), l = this.statWatchers[a];
    l && (typeof r == "function" ? l.removeListener("change", r) : l.removeAllListeners("change"), l.listenerCount("change") === 0 && (l.stop(), delete this.statWatchers[a]));
  }
  createReadStream(e, r) {
    return new this.ReadStream(e, r);
  }
  createWriteStream(e, r) {
    return new this.WriteStream(e, r);
  }
  // watch(path: PathLike): FSWatcher;
  // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
  watch(e, r, a) {
    const l = (0, nt.pathToFilename)(e);
    let d = r;
    typeof r == "function" && (a = r, d = null);
    let { persistent: h, recursive: n, encoding: u } = (0, Ar.getDefaultOpts)(d);
    h === void 0 && (h = !0), n === void 0 && (n = !1);
    const i = new this.FSWatcher();
    return i.start(l, h, n, u), a && i.addListener("change", a), i;
  }
}
Mn.Volume = el;
el.fd = 2147483647;
function k5(t) {
  t.emit("stop");
}
class zx extends Hx.EventEmitter {
  constructor(e) {
    super(), this.onInterval = () => {
      try {
        const r = this.vol.statSync(this.filename);
        this.hasChanged(r) && (this.emit("change", r, this.prev), this.prev = r);
      } finally {
        this.loop();
      }
    }, this.vol = e;
  }
  loop() {
    this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
  }
  hasChanged(e) {
    return e.mtimeMs > this.prev.mtimeMs || e.nlink !== this.prev.nlink;
  }
  start(e, r = !0, a = 5007) {
    this.filename = (0, nt.pathToFilename)(e), this.setTimeout = r ? setTimeout.bind(typeof globalThis < "u" ? globalThis : jt) : s5.default, this.interval = a, this.prev = this.vol.statSync(this.filename), this.loop();
  }
  stop() {
    clearTimeout(this.timeoutRef), (0, Nd.default)(() => {
      k5.call(this, this);
    });
  }
}
Mn.StatWatcher = zx;
var Ii;
function D5(t) {
  Ii = (0, Pa.bufferAllocUnsafe)(t), Ii.used = 0;
}
Gx.inherits(Rs, Rd.Readable);
Mn.ReadStream = Rs;
function Rs(t, e, r) {
  if (!(this instanceof Rs))
    return new Rs(t, e, r);
  if (this._vol = t, r = Object.assign({}, (0, Ar.getOptions)(r, {})), r.highWaterMark === void 0 && (r.highWaterMark = 64 * 1024), Rd.Readable.call(this, r), this.path = (0, nt.pathToFilename)(e), this.fd = r.fd === void 0 ? null : r.fd, this.flags = r.flags === void 0 ? "r" : r.flags, this.mode = r.mode === void 0 ? 438 : r.mode, this.start = r.start, this.end = r.end, this.autoClose = r.autoClose === void 0 ? !0 : r.autoClose, this.pos = void 0, this.bytesRead = 0, this.start !== void 0) {
    if (typeof this.start != "number")
      throw new TypeError('"start" option must be a Number');
    if (this.end === void 0)
      this.end = 1 / 0;
    else if (typeof this.end != "number")
      throw new TypeError('"end" option must be a Number');
    if (this.start > this.end)
      throw new Error('"start" option must be <= "end" option');
    this.pos = this.start;
  }
  typeof this.fd != "number" && this.open(), this.on("end", function() {
    this.autoClose && this.destroy && this.destroy();
  });
}
Rs.prototype.open = function() {
  var t = this;
  this._vol.open(this.path, this.flags, this.mode, (e, r) => {
    if (e) {
      t.autoClose && t.destroy && t.destroy(), t.emit("error", e);
      return;
    }
    t.fd = r, t.emit("open", r), t.read();
  });
};
Rs.prototype._read = function(t) {
  if (typeof this.fd != "number")
    return this.once("open", function() {
      this._read(t);
    });
  if (this.destroyed)
    return;
  (!Ii || Ii.length - Ii.used < v5) && D5(this._readableState.highWaterMark);
  var e = Ii, r = Math.min(Ii.length - Ii.used, t), a = Ii.used;
  if (this.pos !== void 0 && (r = Math.min(this.end - this.pos + 1, r)), r <= 0)
    return this.push(null);
  var l = this;
  this._vol.read(this.fd, Ii, Ii.used, r, this.pos, d), this.pos !== void 0 && (this.pos += r), Ii.used += r;
  function d(h, n) {
    if (h)
      l.autoClose && l.destroy && l.destroy(), l.emit("error", h);
    else {
      var u = null;
      n > 0 && (l.bytesRead += n, u = e.slice(a, a + n)), l.push(u);
    }
  }
};
Rs.prototype._destroy = function(t, e) {
  this.close((r) => {
    e(t || r);
  });
};
Rs.prototype.close = function(t) {
  var e;
  if (t && this.once("close", t), this.closed || typeof this.fd != "number") {
    if (typeof this.fd != "number") {
      this.once("open", Kx);
      return;
    }
    return (0, Nd.default)(() => this.emit("close"));
  }
  typeof ((e = this._readableState) === null || e === void 0 ? void 0 : e.closed) == "boolean" ? this._readableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, (r) => {
    r ? this.emit("error", r) : this.emit("close");
  }), this.fd = null;
};
function Kx(t) {
  this.close();
}
Gx.inherits(Bi, Rd.Writable);
Mn.WriteStream = Bi;
function Bi(t, e, r) {
  if (!(this instanceof Bi))
    return new Bi(t, e, r);
  if (this._vol = t, r = Object.assign({}, (0, Ar.getOptions)(r, {})), Rd.Writable.call(this, r), this.path = (0, nt.pathToFilename)(e), this.fd = r.fd === void 0 ? null : r.fd, this.flags = r.flags === void 0 ? "w" : r.flags, this.mode = r.mode === void 0 ? 438 : r.mode, this.start = r.start, this.autoClose = r.autoClose === void 0 ? !0 : !!r.autoClose, this.pos = void 0, this.bytesWritten = 0, this.pending = !0, this.start !== void 0) {
    if (typeof this.start != "number")
      throw new TypeError('"start" option must be a Number');
    if (this.start < 0)
      throw new Error('"start" must be >= zero');
    this.pos = this.start;
  }
  r.encoding && this.setDefaultEncoding(r.encoding), typeof this.fd != "number" && this.open(), this.once("finish", function() {
    this.autoClose && this.close();
  });
}
Bi.prototype.open = function() {
  this._vol.open(this.path, this.flags, this.mode, (function(t, e) {
    if (t) {
      this.autoClose && this.destroy && this.destroy(), this.emit("error", t);
      return;
    }
    this.fd = e, this.pending = !1, this.emit("open", e);
  }).bind(this));
};
Bi.prototype._write = function(t, e, r) {
  if (!(t instanceof Pa.Buffer || t instanceof Uint8Array))
    return this.emit("error", new Error("Invalid data"));
  if (typeof this.fd != "number")
    return this.once("open", function() {
      this._write(t, e, r);
    });
  var a = this;
  this._vol.write(this.fd, t, 0, t.length, this.pos, (l, d) => {
    if (l)
      return a.autoClose && a.destroy && a.destroy(), r(l);
    a.bytesWritten += d, r();
  }), this.pos !== void 0 && (this.pos += t.length);
};
Bi.prototype._writev = function(t, e) {
  if (typeof this.fd != "number")
    return this.once("open", function() {
      this._writev(t, e);
    });
  const r = this, a = t.length, l = new Array(a);
  for (var d = 0, h = 0; h < a; h++) {
    var n = t[h].chunk;
    l[h] = n, d += n.length;
  }
  const u = Pa.Buffer.concat(l);
  this._vol.write(this.fd, u, 0, u.length, this.pos, (i, c) => {
    if (i)
      return r.destroy && r.destroy(), e(i);
    r.bytesWritten += c, e();
  }), this.pos !== void 0 && (this.pos += d);
};
Bi.prototype.close = function(t) {
  var e;
  if (t && this.once("close", t), this.closed || typeof this.fd != "number") {
    if (typeof this.fd != "number") {
      this.once("open", Kx);
      return;
    }
    return (0, Nd.default)(() => this.emit("close"));
  }
  typeof ((e = this._writableState) === null || e === void 0 ? void 0 : e.closed) == "boolean" ? this._writableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, (r) => {
    r ? this.emit("error", r) : this.emit("close");
  }), this.fd = null;
};
Bi.prototype._destroy = Rs.prototype._destroy;
Bi.prototype.destroySoon = Bi.prototype.end;
class Yx extends Hx.EventEmitter {
  constructor(e) {
    super(), this._filename = "", this._filenameEncoded = "", this._recursive = !1, this._encoding = ro.ENCODING_UTF8, this._listenerRemovers = /* @__PURE__ */ new Map(), this._onParentChild = (r) => {
      r.getName() === this._getName() && this._emit("rename");
    }, this._emit = (r) => {
      this.emit("change", r, this._filenameEncoded);
    }, this._persist = () => {
      this._timer = setTimeout(this._persist, 1e6);
    }, this._vol = e;
  }
  _getName() {
    return this._steps[this._steps.length - 1];
  }
  start(e, r = !0, a = !1, l = ro.ENCODING_UTF8) {
    this._filename = (0, nt.pathToFilename)(e), this._steps = mn(this._filename), this._filenameEncoded = (0, ro.strToEncoding)(this._filename), this._recursive = a, this._encoding = l;
    try {
      this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
    } catch (u) {
      const i = new Error(`watch ${this._filename} ${u.code}`);
      throw i.code = u.code, i.errno = u.code, i;
    }
    const d = (u) => {
      var i;
      const c = u.getPath(), f = u.getNode(), s = () => {
        let y = yu(this._filename, c);
        return y || (y = this._getName()), this.emit("change", "change", y);
      };
      f.on("change", s);
      const o = (i = this._listenerRemovers.get(f.ino)) !== null && i !== void 0 ? i : [];
      o.push(() => f.removeListener("change", s)), this._listenerRemovers.set(f.ino, o);
    }, h = (u) => {
      var i;
      const c = u.getNode(), f = (y) => {
        this.emit("change", "rename", yu(this._filename, y.getPath())), setTimeout(() => {
          d(y), h(y);
        });
      }, s = (y) => {
        const m = (g) => {
          const b = g.getNode().ino, v = this._listenerRemovers.get(b);
          v && (v.forEach((T) => T()), this._listenerRemovers.delete(b));
          for (const [T, E] of g.children.entries())
            E && T !== "." && T !== ".." && m(E);
        };
        m(y), this.emit("change", "rename", yu(this._filename, y.getPath()));
      };
      for (const [y, m] of u.children.entries())
        m && y !== "." && y !== ".." && d(m);
      if (u.on("child:add", f), u.on("child:delete", s), ((i = this._listenerRemovers.get(c.ino)) !== null && i !== void 0 ? i : []).push(() => {
        u.removeListener("child:add", f), u.removeListener("child:delete", s);
      }), a)
        for (const [y, m] of u.children.entries())
          m && y !== "." && y !== ".." && h(m);
    };
    d(this._link), h(this._link);
    const n = this._link.parent;
    n && (n.setMaxListeners(n.getMaxListeners() + 1), n.on("child:delete", this._onParentChild)), r && this._persist();
  }
  close() {
    clearTimeout(this._timer), this._listenerRemovers.forEach((r) => {
      r.forEach((a) => a());
    }), this._listenerRemovers.clear();
    const e = this._link.parent;
    e && e.removeListener("child:delete", this._onParentChild);
  }
}
Mn.FSWatcher = Yx;
var Md = {};
Object.defineProperty(Md, "__esModule", { value: !0 });
Md.fsSynchronousApiList = void 0;
Md.fsSynchronousApiList = [
  "accessSync",
  "appendFileSync",
  "chmodSync",
  "chownSync",
  "closeSync",
  "copyFileSync",
  "existsSync",
  "fchmodSync",
  "fchownSync",
  "fdatasyncSync",
  "fstatSync",
  "fsyncSync",
  "ftruncateSync",
  "futimesSync",
  "lchmodSync",
  "lchownSync",
  "linkSync",
  "lstatSync",
  "mkdirSync",
  "mkdtempSync",
  "openSync",
  "readdirSync",
  "readFileSync",
  "readlinkSync",
  "readSync",
  "readvSync",
  "realpathSync",
  "renameSync",
  "rmdirSync",
  "rmSync",
  "statSync",
  "symlinkSync",
  "truncateSync",
  "unlinkSync",
  "utimesSync",
  "writeFileSync",
  "writeSync",
  "writevSync"
  // 'cpSync',
  // 'lutimesSync',
  // 'statfsSync',
];
var Ld = {};
Object.defineProperty(Ld, "__esModule", { value: !0 });
Ld.fsCallbackApiList = void 0;
Ld.fsCallbackApiList = [
  "access",
  "appendFile",
  "chmod",
  "chown",
  "close",
  "copyFile",
  "createReadStream",
  "createWriteStream",
  "exists",
  "fchmod",
  "fchown",
  "fdatasync",
  "fstat",
  "fsync",
  "ftruncate",
  "futimes",
  "lchmod",
  "lchown",
  "link",
  "lstat",
  "mkdir",
  "mkdtemp",
  "open",
  "read",
  "readv",
  "readdir",
  "readFile",
  "readlink",
  "realpath",
  "rename",
  "rm",
  "rmdir",
  "stat",
  "symlink",
  "truncate",
  "unlink",
  "unwatchFile",
  "utimes",
  "watch",
  "watchFile",
  "write",
  "writev",
  "writeFile"
];
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.memfs = e.fs = e.createFsFromVolume = e.vol = e.Volume = void 0;
  const r = fo, a = Sl, l = Mn, d = Us, h = Md, n = Ld, { F_OK: u, R_OK: i, W_OK: c, X_OK: f } = d.constants;
  e.Volume = l.Volume, e.vol = new l.Volume();
  function s(y) {
    const m = { F_OK: u, R_OK: i, W_OK: c, X_OK: f, constants: d.constants, Stats: r.default, Dirent: a.default };
    for (const g of h.fsSynchronousApiList)
      typeof y[g] == "function" && (m[g] = y[g].bind(y));
    for (const g of n.fsCallbackApiList)
      typeof y[g] == "function" && (m[g] = y[g].bind(y));
    return m.StatWatcher = y.StatWatcher, m.FSWatcher = y.FSWatcher, m.WriteStream = y.WriteStream, m.ReadStream = y.ReadStream, m.promises = y.promises, m._toUnixTimestamp = l.toUnixTimestamp, m.__vol = y, m;
  }
  e.createFsFromVolume = s, e.fs = s(e.vol);
  const o = (y = {}, m = "/") => {
    const g = e.Volume.fromNestedJSON(y, m);
    return { fs: s(g), vol: g };
  };
  e.memfs = o, t.exports = Object.assign(Object.assign({}, t.exports), e.fs), t.exports.semantic = !0;
})(_0, _0.exports);
var oi = _0.exports;
class N5 {
  constructor(e = {}) {
    if (!(e.maxSize && e.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof e.maxAge == "number" && e.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = e.maxSize, this.maxAge = e.maxAge || 1 / 0, this.onEviction = e.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _emitEvictions(e) {
    if (typeof this.onEviction == "function")
      for (const [r, a] of e)
        this.onEviction(r, a.value);
  }
  _deleteIfExpired(e, r) {
    return typeof r.expiry == "number" && r.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, r.value), this.delete(e)) : !1;
  }
  _getOrDeleteIfExpired(e, r) {
    if (this._deleteIfExpired(e, r) === !1)
      return r.value;
  }
  _getItemValue(e, r) {
    return r.expiry ? this._getOrDeleteIfExpired(e, r) : r.value;
  }
  _peek(e, r) {
    const a = r.get(e);
    return this._getItemValue(e, a);
  }
  _set(e, r) {
    this.cache.set(e, r), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(e, r) {
    this.oldCache.delete(e), this._set(e, r);
  }
  *_entriesAscending() {
    for (const e of this.oldCache) {
      const [r, a] = e;
      this.cache.has(r) || this._deleteIfExpired(r, a) === !1 && (yield e);
    }
    for (const e of this.cache) {
      const [r, a] = e;
      this._deleteIfExpired(r, a) === !1 && (yield e);
    }
  }
  get(e) {
    if (this.cache.has(e)) {
      const r = this.cache.get(e);
      return this._getItemValue(e, r);
    }
    if (this.oldCache.has(e)) {
      const r = this.oldCache.get(e);
      if (this._deleteIfExpired(e, r) === !1)
        return this._moveToRecent(e, r), r.value;
    }
  }
  set(e, r, { maxAge: a = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
    this.cache.has(e) ? this.cache.set(e, {
      value: r,
      maxAge: a
    }) : this._set(e, { value: r, expiry: a });
  }
  has(e) {
    return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1;
  }
  peek(e) {
    if (this.cache.has(e))
      return this._peek(e, this.cache);
    if (this.oldCache.has(e))
      return this._peek(e, this.oldCache);
  }
  delete(e) {
    const r = this.cache.delete(e);
    return r && this._size--, this.oldCache.delete(e) || r;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(e) {
    if (!(e && e > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const r = [...this._entriesAscending()], a = r.length - e;
    a < 0 ? (this.cache = new Map(r), this.oldCache = /* @__PURE__ */ new Map(), this._size = r.length) : (a > 0 && this._emitEvictions(r.slice(0, a)), this.oldCache = new Map(r.slice(a)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = e;
  }
  *keys() {
    for (const [e] of this)
      yield e;
  }
  *values() {
    for (const [, e] of this)
      yield e;
  }
  *[Symbol.iterator]() {
    for (const e of this.cache) {
      const [r, a] = e;
      this._deleteIfExpired(r, a) === !1 && (yield [r, a.value]);
    }
    for (const e of this.oldCache) {
      const [r, a] = e;
      this.cache.has(r) || this._deleteIfExpired(r, a) === !1 && (yield [r, a.value]);
    }
  }
  *entriesDescending() {
    let e = [...this.cache];
    for (let r = e.length - 1; r >= 0; --r) {
      const a = e[r], [l, d] = a;
      this._deleteIfExpired(l, d) === !1 && (yield [l, d.value]);
    }
    e = [...this.oldCache];
    for (let r = e.length - 1; r >= 0; --r) {
      const a = e[r], [l, d] = a;
      this.cache.has(l) || this._deleteIfExpired(l, d) === !1 && (yield [l, d.value]);
    }
  }
  *entriesAscending() {
    for (const [e, r] of this._entriesAscending())
      yield [e, r.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let e = 0;
    for (const r of this.oldCache.keys())
      this.cache.has(r) || e++;
    return Math.min(this._size + e, this.maxSize);
  }
}
var Xx = N5, Jx = {};
function au(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Qx = { exports: {} };
(function(t, e) {
  (function(r) {
    t.exports = r();
  })(function() {
    return function r(a, l, d) {
      function h(i, c) {
        if (!l[i]) {
          if (!a[i]) {
            var f = typeof au == "function" && au;
            if (!c && f) return f(i, !0);
            if (n) return n(i, !0);
            throw new Error("Cannot find module '" + i + "'");
          }
          c = l[i] = { exports: {} }, a[i][0].call(c.exports, function(s) {
            var o = a[i][1][s];
            return h(o || s);
          }, c, c.exports, r, a, l, d);
        }
        return l[i].exports;
      }
      for (var n = typeof au == "function" && au, u = 0; u < d.length; u++) h(d[u]);
      return h;
    }({ 1: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        var y = r("crypto");
        function m(D, $) {
          $ = v(D, $);
          var I;
          return (I = $.algorithm !== "passthrough" ? y.createHash($.algorithm) : new O()).write === void 0 && (I.write = I.update, I.end = I.update), E($, I).dispatch(D), I.update || I.end(""), I.digest ? I.digest($.encoding === "buffer" ? void 0 : $.encoding) : (D = I.read(), $.encoding !== "buffer" ? D.toString($.encoding) : D);
        }
        (l = a.exports = m).sha1 = function(D) {
          return m(D);
        }, l.keys = function(D) {
          return m(D, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, l.MD5 = function(D) {
          return m(D, { algorithm: "md5", encoding: "hex" });
        }, l.keysMD5 = function(D) {
          return m(D, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var g = y.getHashes ? y.getHashes().slice() : ["sha1", "md5"], b = (g.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function v(D, $) {
          var I = {};
          if (I.algorithm = ($ = $ || {}).algorithm || "sha1", I.encoding = $.encoding || "hex", I.excludeValues = !!$.excludeValues, I.algorithm = I.algorithm.toLowerCase(), I.encoding = I.encoding.toLowerCase(), I.ignoreUnknown = $.ignoreUnknown === !0, I.respectType = $.respectType !== !1, I.respectFunctionNames = $.respectFunctionNames !== !1, I.respectFunctionProperties = $.respectFunctionProperties !== !1, I.unorderedArrays = $.unorderedArrays === !0, I.unorderedSets = $.unorderedSets !== !1, I.unorderedObjects = $.unorderedObjects !== !1, I.replacer = $.replacer || void 0, I.excludeKeys = $.excludeKeys || void 0, D === void 0) throw new Error("Object argument required.");
          for (var k = 0; k < g.length; ++k) g[k].toLowerCase() === I.algorithm.toLowerCase() && (I.algorithm = g[k]);
          if (g.indexOf(I.algorithm) === -1) throw new Error('Algorithm "' + I.algorithm + '"  not supported. supported values: ' + g.join(", "));
          if (b.indexOf(I.encoding) === -1 && I.algorithm !== "passthrough") throw new Error('Encoding "' + I.encoding + '"  not supported. supported values: ' + b.join(", "));
          return I;
        }
        function T(D) {
          if (typeof D == "function") return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(D)) != null;
        }
        function E(D, $, I) {
          I = I || [];
          function k(L) {
            return $.update ? $.update(L, "utf8") : $.write(L, "utf8");
          }
          return { dispatch: function(L) {
            return this["_" + ((L = D.replacer ? D.replacer(L) : L) === null ? "null" : typeof L)](L);
          }, _object: function(L) {
            var M, x = Object.prototype.toString.call(L), _ = /\[object (.*)\]/i.exec(x);
            if (_ = (_ = _ ? _[1] : "unknown:[" + x + "]").toLowerCase(), 0 <= (x = I.indexOf(L))) return this.dispatch("[CIRCULAR:" + x + "]");
            if (I.push(L), n !== void 0 && n.isBuffer && n.isBuffer(L)) return k("buffer:"), k(L);
            if (_ === "object" || _ === "function" || _ === "asyncfunction") return x = Object.keys(L), D.unorderedObjects && (x = x.sort()), D.respectType === !1 || T(L) || x.splice(0, 0, "prototype", "__proto__", "constructor"), D.excludeKeys && (x = x.filter(function(S) {
              return !D.excludeKeys(S);
            })), k("object:" + x.length + ":"), M = this, x.forEach(function(S) {
              M.dispatch(S), k(":"), D.excludeValues || M.dispatch(L[S]), k(",");
            });
            if (!this["_" + _]) {
              if (D.ignoreUnknown) return k("[" + _ + "]");
              throw new Error('Unknown object type "' + _ + '"');
            }
            this["_" + _](L);
          }, _array: function(L, S) {
            S = S !== void 0 ? S : D.unorderedArrays !== !1;
            var x = this;
            if (k("array:" + L.length + ":"), !S || L.length <= 1) return L.forEach(function(C) {
              return x.dispatch(C);
            });
            var _ = [], S = L.map(function(C) {
              var R = new O(), H = I.slice();
              return E(D, R, H).dispatch(C), _ = _.concat(H.slice(I.length)), R.read().toString();
            });
            return I = I.concat(_), S.sort(), this._array(S, !1);
          }, _date: function(L) {
            return k("date:" + L.toJSON());
          }, _symbol: function(L) {
            return k("symbol:" + L.toString());
          }, _error: function(L) {
            return k("error:" + L.toString());
          }, _boolean: function(L) {
            return k("bool:" + L.toString());
          }, _string: function(L) {
            k("string:" + L.length + ":"), k(L.toString());
          }, _function: function(L) {
            k("fn:"), T(L) ? this.dispatch("[native]") : this.dispatch(L.toString()), D.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(L.name)), D.respectFunctionProperties && this._object(L);
          }, _number: function(L) {
            return k("number:" + L.toString());
          }, _xml: function(L) {
            return k("xml:" + L.toString());
          }, _null: function() {
            return k("Null");
          }, _undefined: function() {
            return k("Undefined");
          }, _regexp: function(L) {
            return k("regex:" + L.toString());
          }, _uint8array: function(L) {
            return k("uint8array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _uint8clampedarray: function(L) {
            return k("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(L));
          }, _int8array: function(L) {
            return k("int8array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _uint16array: function(L) {
            return k("uint16array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _int16array: function(L) {
            return k("int16array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _uint32array: function(L) {
            return k("uint32array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _int32array: function(L) {
            return k("int32array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _float32array: function(L) {
            return k("float32array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _float64array: function(L) {
            return k("float64array:"), this.dispatch(Array.prototype.slice.call(L));
          }, _arraybuffer: function(L) {
            return k("arraybuffer:"), this.dispatch(new Uint8Array(L));
          }, _url: function(L) {
            return k("url:" + L.toString());
          }, _map: function(L) {
            return k("map:"), L = Array.from(L), this._array(L, D.unorderedSets !== !1);
          }, _set: function(L) {
            return k("set:"), L = Array.from(L), this._array(L, D.unorderedSets !== !1);
          }, _file: function(L) {
            return k("file:"), this.dispatch([L.name, L.size, L.type, L.lastModfied]);
          }, _blob: function() {
            if (D.ignoreUnknown) return k("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return k("domwindow");
          }, _bigint: function(L) {
            return k("bigint:" + L.toString());
          }, _process: function() {
            return k("process");
          }, _timer: function() {
            return k("timer");
          }, _pipe: function() {
            return k("pipe");
          }, _tcp: function() {
            return k("tcp");
          }, _udp: function() {
            return k("udp");
          }, _tty: function() {
            return k("tty");
          }, _statwatcher: function() {
            return k("statwatcher");
          }, _securecontext: function() {
            return k("securecontext");
          }, _connection: function() {
            return k("connection");
          }, _zlib: function() {
            return k("zlib");
          }, _context: function() {
            return k("context");
          }, _nodescript: function() {
            return k("nodescript");
          }, _httpparser: function() {
            return k("httpparser");
          }, _dataview: function() {
            return k("dataview");
          }, _signal: function() {
            return k("signal");
          }, _fsevent: function() {
            return k("fsevent");
          }, _tlswrap: function() {
            return k("tlswrap");
          } };
        }
        function O() {
          return { buf: "", write: function(D) {
            this.buf += D;
          }, end: function(D) {
            this.buf += D;
          }, read: function() {
            return this.buf;
          } };
        }
        l.writeToStream = function(D, $, I) {
          return I === void 0 && (I = $, $ = {}), E($ = v(D, $), I).dispatch(D);
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        (function(y) {
          var m = typeof Uint8Array < "u" ? Uint8Array : Array, g = 43, b = 47, v = 48, T = 97, E = 65, O = 45, D = 95;
          function $(I) {
            return I = I.charCodeAt(0), I === g || I === O ? 62 : I === b || I === D ? 63 : I < v ? -1 : I < v + 10 ? I - v + 26 + 26 : I < E + 26 ? I - E : I < T + 26 ? I - T + 26 : void 0;
          }
          y.toByteArray = function(I) {
            var k, L;
            if (0 < I.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
            var M = I.length, M = I.charAt(M - 2) === "=" ? 2 : I.charAt(M - 1) === "=" ? 1 : 0, x = new m(3 * I.length / 4 - M), _ = 0 < M ? I.length - 4 : I.length, S = 0;
            function C(R) {
              x[S++] = R;
            }
            for (k = 0; k < _; k += 4, 0) C((16711680 & (L = $(I.charAt(k)) << 18 | $(I.charAt(k + 1)) << 12 | $(I.charAt(k + 2)) << 6 | $(I.charAt(k + 3)))) >> 16), C((65280 & L) >> 8), C(255 & L);
            return M == 2 ? C(255 & (L = $(I.charAt(k)) << 2 | $(I.charAt(k + 1)) >> 4)) : M == 1 && (C((L = $(I.charAt(k)) << 10 | $(I.charAt(k + 1)) << 4 | $(I.charAt(k + 2)) >> 2) >> 8 & 255), C(255 & L)), x;
          }, y.fromByteArray = function(I) {
            var k, L, M, x, _ = I.length % 3, S = "";
            function C(R) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(R);
            }
            for (k = 0, M = I.length - _; k < M; k += 3) L = (I[k] << 16) + (I[k + 1] << 8) + I[k + 2], S += C((x = L) >> 18 & 63) + C(x >> 12 & 63) + C(x >> 6 & 63) + C(63 & x);
            switch (_) {
              case 1:
                S = (S += C((L = I[I.length - 1]) >> 2)) + C(L << 4 & 63) + "==";
                break;
              case 2:
                S = (S = (S += C((L = (I[I.length - 2] << 8) + I[I.length - 1]) >> 10)) + C(L >> 4 & 63)) + C(L << 2 & 63) + "=";
            }
            return S;
          };
        })(l === void 0 ? this.base64js = {} : l);
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(r, a, l) {
      (function(d, h, g, u, i, c, f, s, o) {
        var y = r("base64-js"), m = r("ieee754");
        function g(F, X, K) {
          if (!(this instanceof g)) return new g(F, X, K);
          var ie, fe, _e, Ae, ce = typeof F;
          if (X === "base64" && ce == "string") for (F = (Ae = F).trim ? Ae.trim() : Ae.replace(/^\s+|\s+$/g, ""); F.length % 4 != 0; ) F += "=";
          if (ce == "number") ie = z(F);
          else if (ce == "string") ie = g.byteLength(F, X);
          else {
            if (ce != "object") throw new Error("First argument needs to be a number, array or string.");
            ie = z(F.length);
          }
          if (g._useTypedArrays ? fe = g._augment(new Uint8Array(ie)) : ((fe = this).length = ie, fe._isBuffer = !0), g._useTypedArrays && typeof F.byteLength == "number") fe._set(F);
          else if (U(Ae = F) || g.isBuffer(Ae) || Ae && typeof Ae == "object" && typeof Ae.length == "number") for (_e = 0; _e < ie; _e++) g.isBuffer(F) ? fe[_e] = F.readUInt8(_e) : fe[_e] = F[_e];
          else if (ce == "string") fe.write(F, 0, X);
          else if (ce == "number" && !g._useTypedArrays && !K) for (_e = 0; _e < ie; _e++) fe[_e] = 0;
          return fe;
        }
        function b(F, X, K, ie) {
          return g._charsWritten = Q(function(fe) {
            for (var _e = [], Ae = 0; Ae < fe.length; Ae++) _e.push(255 & fe.charCodeAt(Ae));
            return _e;
          }(X), F, K, ie);
        }
        function v(F, X, K, ie) {
          return g._charsWritten = Q(function(fe) {
            for (var _e, Ae, ce = [], ee = 0; ee < fe.length; ee++) Ae = fe.charCodeAt(ee), _e = Ae >> 8, Ae = Ae % 256, ce.push(Ae), ce.push(_e);
            return ce;
          }(X), F, K, ie);
        }
        function T(F, X, K) {
          var ie = "";
          K = Math.min(F.length, K);
          for (var fe = X; fe < K; fe++) ie += String.fromCharCode(F[fe]);
          return ie;
        }
        function E(F, X, K, _e) {
          _e || (V(typeof K == "boolean", "missing or invalid endian"), V(X != null, "missing offset"), V(X + 1 < F.length, "Trying to read beyond buffer length"));
          var fe, _e = F.length;
          if (!(_e <= X)) return K ? (fe = F[X], X + 1 < _e && (fe |= F[X + 1] << 8)) : (fe = F[X] << 8, X + 1 < _e && (fe |= F[X + 1])), fe;
        }
        function O(F, X, K, _e) {
          _e || (V(typeof K == "boolean", "missing or invalid endian"), V(X != null, "missing offset"), V(X + 3 < F.length, "Trying to read beyond buffer length"));
          var fe, _e = F.length;
          if (!(_e <= X)) return K ? (X + 2 < _e && (fe = F[X + 2] << 16), X + 1 < _e && (fe |= F[X + 1] << 8), fe |= F[X], X + 3 < _e && (fe += F[X + 3] << 24 >>> 0)) : (X + 1 < _e && (fe = F[X + 1] << 16), X + 2 < _e && (fe |= F[X + 2] << 8), X + 3 < _e && (fe |= F[X + 3]), fe += F[X] << 24 >>> 0), fe;
        }
        function D(F, X, K, ie) {
          if (ie || (V(typeof K == "boolean", "missing or invalid endian"), V(X != null, "missing offset"), V(X + 1 < F.length, "Trying to read beyond buffer length")), !(F.length <= X)) return ie = E(F, X, K, !0), 32768 & ie ? -1 * (65535 - ie + 1) : ie;
        }
        function $(F, X, K, ie) {
          if (ie || (V(typeof K == "boolean", "missing or invalid endian"), V(X != null, "missing offset"), V(X + 3 < F.length, "Trying to read beyond buffer length")), !(F.length <= X)) return ie = O(F, X, K, !0), 2147483648 & ie ? -1 * (4294967295 - ie + 1) : ie;
        }
        function I(F, X, K, ie) {
          return ie || (V(typeof K == "boolean", "missing or invalid endian"), V(X + 3 < F.length, "Trying to read beyond buffer length")), m.read(F, X, K, 23, 4);
        }
        function k(F, X, K, ie) {
          return ie || (V(typeof K == "boolean", "missing or invalid endian"), V(X + 7 < F.length, "Trying to read beyond buffer length")), m.read(F, X, K, 52, 8);
        }
        function L(F, X, K, ie, fe) {
          if (fe || (V(X != null, "missing value"), V(typeof ie == "boolean", "missing or invalid endian"), V(K != null, "missing offset"), V(K + 1 < F.length, "trying to write beyond buffer length"), re(X, 65535)), fe = F.length, !(fe <= K)) for (var _e = 0, Ae = Math.min(fe - K, 2); _e < Ae; _e++) F[K + _e] = (X & 255 << 8 * (ie ? _e : 1 - _e)) >>> 8 * (ie ? _e : 1 - _e);
        }
        function M(F, X, K, ie, fe) {
          if (fe || (V(X != null, "missing value"), V(typeof ie == "boolean", "missing or invalid endian"), V(K != null, "missing offset"), V(K + 3 < F.length, "trying to write beyond buffer length"), re(X, 4294967295)), fe = F.length, !(fe <= K)) for (var _e = 0, Ae = Math.min(fe - K, 4); _e < Ae; _e++) F[K + _e] = X >>> 8 * (ie ? _e : 3 - _e) & 255;
        }
        function x(F, X, K, ie, fe) {
          fe || (V(X != null, "missing value"), V(typeof ie == "boolean", "missing or invalid endian"), V(K != null, "missing offset"), V(K + 1 < F.length, "Trying to write beyond buffer length"), G(X, 32767, -32768)), F.length <= K || L(F, 0 <= X ? X : 65535 + X + 1, K, ie, fe);
        }
        function _(F, X, K, ie, fe) {
          fe || (V(X != null, "missing value"), V(typeof ie == "boolean", "missing or invalid endian"), V(K != null, "missing offset"), V(K + 3 < F.length, "Trying to write beyond buffer length"), G(X, 2147483647, -2147483648)), F.length <= K || M(F, 0 <= X ? X : 4294967295 + X + 1, K, ie, fe);
        }
        function S(F, X, K, ie, fe) {
          fe || (V(X != null, "missing value"), V(typeof ie == "boolean", "missing or invalid endian"), V(K != null, "missing offset"), V(K + 3 < F.length, "Trying to write beyond buffer length"), N(X, 34028234663852886e22, -34028234663852886e22)), F.length <= K || m.write(F, X, K, ie, 23, 4);
        }
        function C(F, X, K, ie, fe) {
          fe || (V(X != null, "missing value"), V(typeof ie == "boolean", "missing or invalid endian"), V(K != null, "missing offset"), V(K + 7 < F.length, "Trying to write beyond buffer length"), N(X, 17976931348623157e292, -17976931348623157e292)), F.length <= K || m.write(F, X, K, ie, 52, 8);
        }
        l.Buffer = g, l.SlowBuffer = g, l.INSPECT_MAX_BYTES = 50, g.poolSize = 8192, g._useTypedArrays = function() {
          try {
            var F = new ArrayBuffer(0), X = new Uint8Array(F);
            return X.foo = function() {
              return 42;
            }, X.foo() === 42 && typeof X.subarray == "function";
          } catch {
            return !1;
          }
        }(), g.isEncoding = function(F) {
          switch (String(F).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, g.isBuffer = function(F) {
          return !(F == null || !F._isBuffer);
        }, g.byteLength = function(F, X) {
          var K;
          switch (F += "", X || "utf8") {
            case "hex":
              K = F.length / 2;
              break;
            case "utf8":
            case "utf-8":
              K = W(F).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              K = F.length;
              break;
            case "base64":
              K = B(F).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              K = 2 * F.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return K;
        }, g.concat = function(F, X) {
          if (V(U(F), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), F.length === 0) return new g(0);
          if (F.length === 1) return F[0];
          if (typeof X != "number") for (fe = X = 0; fe < F.length; fe++) X += F[fe].length;
          for (var K = new g(X), ie = 0, fe = 0; fe < F.length; fe++) {
            var _e = F[fe];
            _e.copy(K, ie), ie += _e.length;
          }
          return K;
        }, g.prototype.write = function(F, X, K, ie) {
          isFinite(X) ? isFinite(K) || (ie = K, K = void 0) : (ee = ie, ie = X, X = K, K = ee), X = Number(X) || 0;
          var fe, _e, Ae, ce, ee = this.length - X;
          switch ((!K || ee < (K = Number(K))) && (K = ee), ie = String(ie || "utf8").toLowerCase()) {
            case "hex":
              fe = function(ae, oe, me, ye) {
                me = Number(me) || 0;
                var we = ae.length - me;
                (!ye || we < (ye = Number(ye))) && (ye = we), V((we = oe.length) % 2 == 0, "Invalid hex string"), we / 2 < ye && (ye = we / 2);
                for (var ge = 0; ge < ye; ge++) {
                  var se = parseInt(oe.substr(2 * ge, 2), 16);
                  V(!isNaN(se), "Invalid hex string"), ae[me + ge] = se;
                }
                return g._charsWritten = 2 * ge, ge;
              }(this, F, X, K);
              break;
            case "utf8":
            case "utf-8":
              _e = this, Ae = X, ce = K, fe = g._charsWritten = Q(W(F), _e, Ae, ce);
              break;
            case "ascii":
            case "binary":
              fe = b(this, F, X, K);
              break;
            case "base64":
              _e = this, Ae = X, ce = K, fe = g._charsWritten = Q(B(F), _e, Ae, ce);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              fe = v(this, F, X, K);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return fe;
        }, g.prototype.toString = function(F, X, K) {
          var ie, fe, _e, Ae, ce = this;
          if (F = String(F || "utf8").toLowerCase(), X = Number(X) || 0, (K = K !== void 0 ? Number(K) : ce.length) === X) return "";
          switch (F) {
            case "hex":
              ie = function(ee, ae, oe) {
                var me = ee.length;
                (!ae || ae < 0) && (ae = 0), (!oe || oe < 0 || me < oe) && (oe = me);
                for (var ye = "", we = ae; we < oe; we++) ye += P(ee[we]);
                return ye;
              }(ce, X, K);
              break;
            case "utf8":
            case "utf-8":
              ie = function(ee, ae, oe) {
                var me = "", ye = "";
                oe = Math.min(ee.length, oe);
                for (var we = ae; we < oe; we++) ee[we] <= 127 ? (me += J(ye) + String.fromCharCode(ee[we]), ye = "") : ye += "%" + ee[we].toString(16);
                return me + J(ye);
              }(ce, X, K);
              break;
            case "ascii":
            case "binary":
              ie = T(ce, X, K);
              break;
            case "base64":
              fe = ce, Ae = K, ie = (_e = X) === 0 && Ae === fe.length ? y.fromByteArray(fe) : y.fromByteArray(fe.slice(_e, Ae));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              ie = function(ee, ae, oe) {
                for (var me = ee.slice(ae, oe), ye = "", we = 0; we < me.length; we += 2) ye += String.fromCharCode(me[we] + 256 * me[we + 1]);
                return ye;
              }(ce, X, K);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return ie;
        }, g.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, g.prototype.copy = function(F, X, K, ie) {
          if (X = X || 0, (ie = ie || ie === 0 ? ie : this.length) !== (K = K || 0) && F.length !== 0 && this.length !== 0) {
            V(K <= ie, "sourceEnd < sourceStart"), V(0 <= X && X < F.length, "targetStart out of bounds"), V(0 <= K && K < this.length, "sourceStart out of bounds"), V(0 <= ie && ie <= this.length, "sourceEnd out of bounds"), ie > this.length && (ie = this.length);
            var fe = (ie = F.length - X < ie - K ? F.length - X + K : ie) - K;
            if (fe < 100 || !g._useTypedArrays) for (var _e = 0; _e < fe; _e++) F[_e + X] = this[_e + K];
            else F._set(this.subarray(K, K + fe), X);
          }
        }, g.prototype.slice = function(F, X) {
          var K = this.length;
          if (F = H(F, K, 0), X = H(X, K, K), g._useTypedArrays) return g._augment(this.subarray(F, X));
          for (var ie = X - F, fe = new g(ie, void 0, !0), _e = 0; _e < ie; _e++) fe[_e] = this[_e + F];
          return fe;
        }, g.prototype.get = function(F) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(F);
        }, g.prototype.set = function(F, X) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(F, X);
        }, g.prototype.readUInt8 = function(F, X) {
          if (X || (V(F != null, "missing offset"), V(F < this.length, "Trying to read beyond buffer length")), !(F >= this.length)) return this[F];
        }, g.prototype.readUInt16LE = function(F, X) {
          return E(this, F, !0, X);
        }, g.prototype.readUInt16BE = function(F, X) {
          return E(this, F, !1, X);
        }, g.prototype.readUInt32LE = function(F, X) {
          return O(this, F, !0, X);
        }, g.prototype.readUInt32BE = function(F, X) {
          return O(this, F, !1, X);
        }, g.prototype.readInt8 = function(F, X) {
          if (X || (V(F != null, "missing offset"), V(F < this.length, "Trying to read beyond buffer length")), !(F >= this.length)) return 128 & this[F] ? -1 * (255 - this[F] + 1) : this[F];
        }, g.prototype.readInt16LE = function(F, X) {
          return D(this, F, !0, X);
        }, g.prototype.readInt16BE = function(F, X) {
          return D(this, F, !1, X);
        }, g.prototype.readInt32LE = function(F, X) {
          return $(this, F, !0, X);
        }, g.prototype.readInt32BE = function(F, X) {
          return $(this, F, !1, X);
        }, g.prototype.readFloatLE = function(F, X) {
          return I(this, F, !0, X);
        }, g.prototype.readFloatBE = function(F, X) {
          return I(this, F, !1, X);
        }, g.prototype.readDoubleLE = function(F, X) {
          return k(this, F, !0, X);
        }, g.prototype.readDoubleBE = function(F, X) {
          return k(this, F, !1, X);
        }, g.prototype.writeUInt8 = function(F, X, K) {
          K || (V(F != null, "missing value"), V(X != null, "missing offset"), V(X < this.length, "trying to write beyond buffer length"), re(F, 255)), X >= this.length || (this[X] = F);
        }, g.prototype.writeUInt16LE = function(F, X, K) {
          L(this, F, X, !0, K);
        }, g.prototype.writeUInt16BE = function(F, X, K) {
          L(this, F, X, !1, K);
        }, g.prototype.writeUInt32LE = function(F, X, K) {
          M(this, F, X, !0, K);
        }, g.prototype.writeUInt32BE = function(F, X, K) {
          M(this, F, X, !1, K);
        }, g.prototype.writeInt8 = function(F, X, K) {
          K || (V(F != null, "missing value"), V(X != null, "missing offset"), V(X < this.length, "Trying to write beyond buffer length"), G(F, 127, -128)), X >= this.length || (0 <= F ? this.writeUInt8(F, X, K) : this.writeUInt8(255 + F + 1, X, K));
        }, g.prototype.writeInt16LE = function(F, X, K) {
          x(this, F, X, !0, K);
        }, g.prototype.writeInt16BE = function(F, X, K) {
          x(this, F, X, !1, K);
        }, g.prototype.writeInt32LE = function(F, X, K) {
          _(this, F, X, !0, K);
        }, g.prototype.writeInt32BE = function(F, X, K) {
          _(this, F, X, !1, K);
        }, g.prototype.writeFloatLE = function(F, X, K) {
          S(this, F, X, !0, K);
        }, g.prototype.writeFloatBE = function(F, X, K) {
          S(this, F, X, !1, K);
        }, g.prototype.writeDoubleLE = function(F, X, K) {
          C(this, F, X, !0, K);
        }, g.prototype.writeDoubleBE = function(F, X, K) {
          C(this, F, X, !1, K);
        }, g.prototype.fill = function(F, X, K) {
          if (X = X || 0, K = K || this.length, V(typeof (F = typeof (F = F || 0) == "string" ? F.charCodeAt(0) : F) == "number" && !isNaN(F), "value is not a number"), V(X <= K, "end < start"), K !== X && this.length !== 0) {
            V(0 <= X && X < this.length, "start out of bounds"), V(0 <= K && K <= this.length, "end out of bounds");
            for (var ie = X; ie < K; ie++) this[ie] = F;
          }
        }, g.prototype.inspect = function() {
          for (var F = [], X = this.length, K = 0; K < X; K++) if (F[K] = P(this[K]), K === l.INSPECT_MAX_BYTES) {
            F[K + 1] = "...";
            break;
          }
          return "<Buffer " + F.join(" ") + ">";
        }, g.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u") throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (g._useTypedArrays) return new g(this).buffer;
          for (var F = new Uint8Array(this.length), X = 0, K = F.length; X < K; X += 1) F[X] = this[X];
          return F.buffer;
        };
        var R = g.prototype;
        function H(F, X, K) {
          return typeof F != "number" ? K : X <= (F = ~~F) ? X : 0 <= F || 0 <= (F += X) ? F : 0;
        }
        function z(F) {
          return (F = ~~Math.ceil(+F)) < 0 ? 0 : F;
        }
        function U(F) {
          return (Array.isArray || function(X) {
            return Object.prototype.toString.call(X) === "[object Array]";
          })(F);
        }
        function P(F) {
          return F < 16 ? "0" + F.toString(16) : F.toString(16);
        }
        function W(F) {
          for (var X = [], K = 0; K < F.length; K++) {
            var ie = F.charCodeAt(K);
            if (ie <= 127) X.push(F.charCodeAt(K));
            else for (var fe = K, _e = (55296 <= ie && ie <= 57343 && K++, encodeURIComponent(F.slice(fe, K + 1)).substr(1).split("%")), Ae = 0; Ae < _e.length; Ae++) X.push(parseInt(_e[Ae], 16));
          }
          return X;
        }
        function B(F) {
          return y.toByteArray(F);
        }
        function Q(F, X, K, ie) {
          for (var fe = 0; fe < ie && !(fe + K >= X.length || fe >= F.length); fe++) X[fe + K] = F[fe];
          return fe;
        }
        function J(F) {
          try {
            return decodeURIComponent(F);
          } catch {
            return "�";
          }
        }
        function re(F, X) {
          V(typeof F == "number", "cannot write a non-number as a number"), V(0 <= F, "specified a negative value for writing an unsigned value"), V(F <= X, "value is larger than maximum value for type"), V(Math.floor(F) === F, "value has a fractional component");
        }
        function G(F, X, K) {
          V(typeof F == "number", "cannot write a non-number as a number"), V(F <= X, "value larger than maximum allowed value"), V(K <= F, "value smaller than minimum allowed value"), V(Math.floor(F) === F, "value has a fractional component");
        }
        function N(F, X, K) {
          V(typeof F == "number", "cannot write a non-number as a number"), V(F <= X, "value larger than maximum allowed value"), V(K <= F, "value smaller than minimum allowed value");
        }
        function V(F, X) {
          if (!F) throw new Error(X || "Failed assertion");
        }
        g._augment = function(F) {
          return F._isBuffer = !0, F._get = F.get, F._set = F.set, F.get = R.get, F.set = R.set, F.write = R.write, F.toString = R.toString, F.toLocaleString = R.toString, F.toJSON = R.toJSON, F.copy = R.copy, F.slice = R.slice, F.readUInt8 = R.readUInt8, F.readUInt16LE = R.readUInt16LE, F.readUInt16BE = R.readUInt16BE, F.readUInt32LE = R.readUInt32LE, F.readUInt32BE = R.readUInt32BE, F.readInt8 = R.readInt8, F.readInt16LE = R.readInt16LE, F.readInt16BE = R.readInt16BE, F.readInt32LE = R.readInt32LE, F.readInt32BE = R.readInt32BE, F.readFloatLE = R.readFloatLE, F.readFloatBE = R.readFloatBE, F.readDoubleLE = R.readDoubleLE, F.readDoubleBE = R.readDoubleBE, F.writeUInt8 = R.writeUInt8, F.writeUInt16LE = R.writeUInt16LE, F.writeUInt16BE = R.writeUInt16BE, F.writeUInt32LE = R.writeUInt32LE, F.writeUInt32BE = R.writeUInt32BE, F.writeInt8 = R.writeInt8, F.writeInt16LE = R.writeInt16LE, F.writeInt16BE = R.writeInt16BE, F.writeInt32LE = R.writeInt32LE, F.writeInt32BE = R.writeInt32BE, F.writeFloatLE = R.writeFloatLE, F.writeFloatBE = R.writeFloatBE, F.writeDoubleLE = R.writeDoubleLE, F.writeDoubleBE = R.writeDoubleBE, F.fill = R.fill, F.inspect = R.inspect, F.toArrayBuffer = R.toArrayBuffer, F;
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(r, a, l) {
      (function(d, h, y, u, i, c, f, s, o) {
        var y = r("buffer").Buffer, m = 4, g = new y(m);
        g.fill(0), a.exports = { hash: function(b, v, T, E) {
          for (var O = v(function(L, M) {
            L.length % m != 0 && (x = L.length + (m - L.length % m), L = y.concat([L, g], x));
            for (var x, _ = [], S = M ? L.readInt32BE : L.readInt32LE, C = 0; C < L.length; C += m) _.push(S.call(L, C));
            return _;
          }(b = y.isBuffer(b) ? b : new y(b), E), 8 * b.length), v = E, D = new y(T), $ = v ? D.writeInt32BE : D.writeInt32LE, I = 0; I < O.length; I++) $.call(D, O[I], 4 * I, !0);
          return D;
        } };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(r, a, l) {
      (function(d, h, y, u, i, c, f, s, o) {
        var y = r("buffer").Buffer, m = r("./sha"), g = r("./sha256"), b = r("./rng"), v = { sha1: m, sha256: g, md5: r("./md5") }, T = 64, E = new y(T);
        function O(L, M) {
          var x = v[L = L || "sha1"], _ = [];
          return x || D("algorithm:", L, "is not yet supported"), { update: function(S) {
            return y.isBuffer(S) || (S = new y(S)), _.push(S), S.length, this;
          }, digest: function(S) {
            var C = y.concat(_), C = M ? function(R, H, z) {
              y.isBuffer(H) || (H = new y(H)), y.isBuffer(z) || (z = new y(z)), H.length > T ? H = R(H) : H.length < T && (H = y.concat([H, E], T));
              for (var U = new y(T), P = new y(T), W = 0; W < T; W++) U[W] = 54 ^ H[W], P[W] = 92 ^ H[W];
              return z = R(y.concat([U, z])), R(y.concat([P, z]));
            }(x, M, C) : x(C);
            return _ = null, S ? C.toString(S) : C;
          } };
        }
        function D() {
          var L = [].slice.call(arguments).join(" ");
          throw new Error([L, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        E.fill(0), l.createHash = function(L) {
          return O(L);
        }, l.createHmac = O, l.randomBytes = function(L, M) {
          if (!M || !M.call) return new y(b(L));
          try {
            M.call(this, void 0, new y(b(L)));
          } catch (x) {
            M(x);
          }
        };
        var $, I = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], k = function(L) {
          l[L] = function() {
            D("sorry,", L, "is not implemented yet");
          };
        };
        for ($ in I) k(I[$]);
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        var y = r("./helpers");
        function m(D, $) {
          D[$ >> 5] |= 128 << $ % 32, D[14 + ($ + 64 >>> 9 << 4)] = $;
          for (var I = 1732584193, k = -271733879, L = -1732584194, M = 271733878, x = 0; x < D.length; x += 16) {
            var _ = I, S = k, C = L, R = M, I = b(I, k, L, M, D[x + 0], 7, -680876936), M = b(M, I, k, L, D[x + 1], 12, -389564586), L = b(L, M, I, k, D[x + 2], 17, 606105819), k = b(k, L, M, I, D[x + 3], 22, -1044525330);
            I = b(I, k, L, M, D[x + 4], 7, -176418897), M = b(M, I, k, L, D[x + 5], 12, 1200080426), L = b(L, M, I, k, D[x + 6], 17, -1473231341), k = b(k, L, M, I, D[x + 7], 22, -45705983), I = b(I, k, L, M, D[x + 8], 7, 1770035416), M = b(M, I, k, L, D[x + 9], 12, -1958414417), L = b(L, M, I, k, D[x + 10], 17, -42063), k = b(k, L, M, I, D[x + 11], 22, -1990404162), I = b(I, k, L, M, D[x + 12], 7, 1804603682), M = b(M, I, k, L, D[x + 13], 12, -40341101), L = b(L, M, I, k, D[x + 14], 17, -1502002290), I = v(I, k = b(k, L, M, I, D[x + 15], 22, 1236535329), L, M, D[x + 1], 5, -165796510), M = v(M, I, k, L, D[x + 6], 9, -1069501632), L = v(L, M, I, k, D[x + 11], 14, 643717713), k = v(k, L, M, I, D[x + 0], 20, -373897302), I = v(I, k, L, M, D[x + 5], 5, -701558691), M = v(M, I, k, L, D[x + 10], 9, 38016083), L = v(L, M, I, k, D[x + 15], 14, -660478335), k = v(k, L, M, I, D[x + 4], 20, -405537848), I = v(I, k, L, M, D[x + 9], 5, 568446438), M = v(M, I, k, L, D[x + 14], 9, -1019803690), L = v(L, M, I, k, D[x + 3], 14, -187363961), k = v(k, L, M, I, D[x + 8], 20, 1163531501), I = v(I, k, L, M, D[x + 13], 5, -1444681467), M = v(M, I, k, L, D[x + 2], 9, -51403784), L = v(L, M, I, k, D[x + 7], 14, 1735328473), I = T(I, k = v(k, L, M, I, D[x + 12], 20, -1926607734), L, M, D[x + 5], 4, -378558), M = T(M, I, k, L, D[x + 8], 11, -2022574463), L = T(L, M, I, k, D[x + 11], 16, 1839030562), k = T(k, L, M, I, D[x + 14], 23, -35309556), I = T(I, k, L, M, D[x + 1], 4, -1530992060), M = T(M, I, k, L, D[x + 4], 11, 1272893353), L = T(L, M, I, k, D[x + 7], 16, -155497632), k = T(k, L, M, I, D[x + 10], 23, -1094730640), I = T(I, k, L, M, D[x + 13], 4, 681279174), M = T(M, I, k, L, D[x + 0], 11, -358537222), L = T(L, M, I, k, D[x + 3], 16, -722521979), k = T(k, L, M, I, D[x + 6], 23, 76029189), I = T(I, k, L, M, D[x + 9], 4, -640364487), M = T(M, I, k, L, D[x + 12], 11, -421815835), L = T(L, M, I, k, D[x + 15], 16, 530742520), I = E(I, k = T(k, L, M, I, D[x + 2], 23, -995338651), L, M, D[x + 0], 6, -198630844), M = E(M, I, k, L, D[x + 7], 10, 1126891415), L = E(L, M, I, k, D[x + 14], 15, -1416354905), k = E(k, L, M, I, D[x + 5], 21, -57434055), I = E(I, k, L, M, D[x + 12], 6, 1700485571), M = E(M, I, k, L, D[x + 3], 10, -1894986606), L = E(L, M, I, k, D[x + 10], 15, -1051523), k = E(k, L, M, I, D[x + 1], 21, -2054922799), I = E(I, k, L, M, D[x + 8], 6, 1873313359), M = E(M, I, k, L, D[x + 15], 10, -30611744), L = E(L, M, I, k, D[x + 6], 15, -1560198380), k = E(k, L, M, I, D[x + 13], 21, 1309151649), I = E(I, k, L, M, D[x + 4], 6, -145523070), M = E(M, I, k, L, D[x + 11], 10, -1120210379), L = E(L, M, I, k, D[x + 2], 15, 718787259), k = E(k, L, M, I, D[x + 9], 21, -343485551), I = O(I, _), k = O(k, S), L = O(L, C), M = O(M, R);
          }
          return Array(I, k, L, M);
        }
        function g(D, $, I, k, L, M) {
          return O(($ = O(O($, D), O(k, M))) << L | $ >>> 32 - L, I);
        }
        function b(D, $, I, k, L, M, x) {
          return g($ & I | ~$ & k, D, $, L, M, x);
        }
        function v(D, $, I, k, L, M, x) {
          return g($ & k | I & ~k, D, $, L, M, x);
        }
        function T(D, $, I, k, L, M, x) {
          return g($ ^ I ^ k, D, $, L, M, x);
        }
        function E(D, $, I, k, L, M, x) {
          return g(I ^ ($ | ~k), D, $, L, M, x);
        }
        function O(D, $) {
          var I = (65535 & D) + (65535 & $);
          return (D >> 16) + ($ >> 16) + (I >> 16) << 16 | 65535 & I;
        }
        a.exports = function(D) {
          return y.hash(D, m, 16);
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        a.exports = function(y) {
          for (var m, g = new Array(y), b = 0; b < y; b++) !(3 & b) && (m = 4294967296 * Math.random()), g[b] = m >>> ((3 & b) << 3) & 255;
          return g;
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        var y = r("./helpers");
        function m(v, T) {
          v[T >> 5] |= 128 << 24 - T % 32, v[15 + (T + 64 >> 9 << 4)] = T;
          for (var E, O, D, $ = Array(80), I = 1732584193, k = -271733879, L = -1732584194, M = 271733878, x = -1009589776, _ = 0; _ < v.length; _ += 16) {
            for (var S = I, C = k, R = L, H = M, z = x, U = 0; U < 80; U++) {
              $[U] = U < 16 ? v[_ + U] : b($[U - 3] ^ $[U - 8] ^ $[U - 14] ^ $[U - 16], 1);
              var P = g(g(b(I, 5), (P = k, O = L, D = M, (E = U) < 20 ? P & O | ~P & D : !(E < 40) && E < 60 ? P & O | P & D | O & D : P ^ O ^ D)), g(g(x, $[U]), (E = U) < 20 ? 1518500249 : E < 40 ? 1859775393 : E < 60 ? -1894007588 : -899497514)), x = M, M = L, L = b(k, 30), k = I, I = P;
            }
            I = g(I, S), k = g(k, C), L = g(L, R), M = g(M, H), x = g(x, z);
          }
          return Array(I, k, L, M, x);
        }
        function g(v, T) {
          var E = (65535 & v) + (65535 & T);
          return (v >> 16) + (T >> 16) + (E >> 16) << 16 | 65535 & E;
        }
        function b(v, T) {
          return v << T | v >>> 32 - T;
        }
        a.exports = function(v) {
          return y.hash(v, m, 20, !0);
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        function y(T, E) {
          var O = (65535 & T) + (65535 & E);
          return (T >> 16) + (E >> 16) + (O >> 16) << 16 | 65535 & O;
        }
        function m(T, E) {
          var O, D = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), $ = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), I = new Array(64);
          T[E >> 5] |= 128 << 24 - E % 32, T[15 + (E + 64 >> 9 << 4)] = E;
          for (var k, L, M = 0; M < T.length; M += 16) {
            for (var x = $[0], _ = $[1], S = $[2], C = $[3], R = $[4], H = $[5], z = $[6], U = $[7], P = 0; P < 64; P++) I[P] = P < 16 ? T[P + M] : y(y(y((L = I[P - 2], b(L, 17) ^ b(L, 19) ^ v(L, 10)), I[P - 7]), (L = I[P - 15], b(L, 7) ^ b(L, 18) ^ v(L, 3))), I[P - 16]), O = y(y(y(y(U, b(L = R, 6) ^ b(L, 11) ^ b(L, 25)), R & H ^ ~R & z), D[P]), I[P]), k = y(b(k = x, 2) ^ b(k, 13) ^ b(k, 22), x & _ ^ x & S ^ _ & S), U = z, z = H, H = R, R = y(C, O), C = S, S = _, _ = x, x = y(O, k);
            $[0] = y(x, $[0]), $[1] = y(_, $[1]), $[2] = y(S, $[2]), $[3] = y(C, $[3]), $[4] = y(R, $[4]), $[5] = y(H, $[5]), $[6] = y(z, $[6]), $[7] = y(U, $[7]);
          }
          return $;
        }
        var g = r("./helpers"), b = function(T, E) {
          return T >>> E | T << 32 - E;
        }, v = function(T, E) {
          return T >>> E;
        };
        a.exports = function(T) {
          return g.hash(T, m, 32, !0);
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        l.read = function(y, m, g, b, M) {
          var T, E, O = 8 * M - b - 1, D = (1 << O) - 1, $ = D >> 1, I = -7, k = g ? M - 1 : 0, L = g ? -1 : 1, M = y[m + k];
          for (k += L, T = M & (1 << -I) - 1, M >>= -I, I += O; 0 < I; T = 256 * T + y[m + k], k += L, I -= 8) ;
          for (E = T & (1 << -I) - 1, T >>= -I, I += b; 0 < I; E = 256 * E + y[m + k], k += L, I -= 8) ;
          if (T === 0) T = 1 - $;
          else {
            if (T === D) return E ? NaN : 1 / 0 * (M ? -1 : 1);
            E += Math.pow(2, b), T -= $;
          }
          return (M ? -1 : 1) * E * Math.pow(2, T - b);
        }, l.write = function(y, m, g, b, v, x) {
          var E, O, D = 8 * x - v - 1, $ = (1 << D) - 1, I = $ >> 1, k = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, L = b ? 0 : x - 1, M = b ? 1 : -1, x = m < 0 || m === 0 && 1 / m < 0 ? 1 : 0;
          for (m = Math.abs(m), isNaN(m) || m === 1 / 0 ? (O = isNaN(m) ? 1 : 0, E = $) : (E = Math.floor(Math.log(m) / Math.LN2), m * (b = Math.pow(2, -E)) < 1 && (E--, b *= 2), 2 <= (m += 1 <= E + I ? k / b : k * Math.pow(2, 1 - I)) * b && (E++, b /= 2), $ <= E + I ? (O = 0, E = $) : 1 <= E + I ? (O = (m * b - 1) * Math.pow(2, v), E += I) : (O = m * Math.pow(2, I - 1) * Math.pow(2, v), E = 0)); 8 <= v; y[g + L] = 255 & O, L += M, O /= 256, v -= 8) ;
          for (E = E << v | O, D += v; 0 < D; y[g + L] = 255 & E, L += M, E /= 256, D -= 8) ;
          y[g + L - M] |= 128 * x;
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(r, a, l) {
      (function(d, h, n, u, i, c, f, s, o) {
        var y, m, g;
        function b() {
        }
        (d = a.exports = {}).nextTick = (m = typeof window < "u" && window.setImmediate, g = typeof window < "u" && window.postMessage && window.addEventListener, m ? function(v) {
          return window.setImmediate(v);
        } : g ? (y = [], window.addEventListener("message", function(v) {
          var T = v.source;
          T !== window && T !== null || v.data !== "process-tick" || (v.stopPropagation(), 0 < y.length && y.shift()());
        }, !0), function(v) {
          y.push(v), window.postMessage("process-tick", "*");
        }) : function(v) {
          setTimeout(v, 0);
        }), d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.on = b, d.addListener = b, d.once = b, d.off = b, d.removeListener = b, d.removeAllListeners = b, d.emit = b, d.binding = function(v) {
          throw new Error("process.binding is not supported");
        }, d.cwd = function() {
          return "/";
        }, d.chdir = function(v) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, r("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, r("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(Qx);
var R5 = Qx.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ r(R5);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function a(l) {
    return (0, e.default)(l, {
      ignoreUnknown: !0
    });
  }
})(Jx);
var Zx = {}, eT = {}, jd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    if (r = `${r}`, r === "0")
      return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(r))
      return r.replace(/^[+-]?/, (l) => l === "-" ? "" : "-");
    let a = [
      "var",
      "calc",
      "min",
      "max",
      "clamp"
    ];
    for (const l of a)
      if (r.includes(`${l}(`))
        return `calc(${r} * -1)`;
  }
})(jd);
var tT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  const e = [
    "preflight",
    "container",
    "accessibility",
    "pointerEvents",
    "visibility",
    "position",
    "inset",
    "isolation",
    "zIndex",
    "order",
    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRow",
    "gridRowStart",
    "gridRowEnd",
    "float",
    "clear",
    "margin",
    "boxSizing",
    "lineClamp",
    "display",
    "aspectRatio",
    "height",
    "maxHeight",
    "minHeight",
    "width",
    "minWidth",
    "maxWidth",
    "flex",
    "flexShrink",
    "flexGrow",
    "flexBasis",
    "tableLayout",
    "captionSide",
    "borderCollapse",
    "borderSpacing",
    "transformOrigin",
    "translate",
    "rotate",
    "skew",
    "scale",
    "transform",
    "animation",
    "cursor",
    "touchAction",
    "userSelect",
    "resize",
    "scrollSnapType",
    "scrollSnapAlign",
    "scrollSnapStop",
    "scrollMargin",
    "scrollPadding",
    "listStylePosition",
    "listStyleType",
    "listStyleImage",
    "appearance",
    "columns",
    "breakBefore",
    "breakInside",
    "breakAfter",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridTemplateColumns",
    "gridTemplateRows",
    "flexDirection",
    "flexWrap",
    "placeContent",
    "placeItems",
    "alignContent",
    "alignItems",
    "justifyContent",
    "justifyItems",
    "gap",
    "space",
    "divideWidth",
    "divideStyle",
    "divideColor",
    "divideOpacity",
    "placeSelf",
    "alignSelf",
    "justifySelf",
    "overflow",
    "overscrollBehavior",
    "scrollBehavior",
    "textOverflow",
    "hyphens",
    "whitespace",
    "wordBreak",
    "borderRadius",
    "borderWidth",
    "borderStyle",
    "borderColor",
    "borderOpacity",
    "backgroundColor",
    "backgroundOpacity",
    "backgroundImage",
    "gradientColorStops",
    "boxDecorationBreak",
    "backgroundSize",
    "backgroundAttachment",
    "backgroundClip",
    "backgroundPosition",
    "backgroundRepeat",
    "backgroundOrigin",
    "fill",
    "stroke",
    "strokeWidth",
    "objectFit",
    "objectPosition",
    "padding",
    "textAlign",
    "textIndent",
    "verticalAlign",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "textTransform",
    "fontStyle",
    "fontVariantNumeric",
    "lineHeight",
    "letterSpacing",
    "textColor",
    "textOpacity",
    "textDecoration",
    "textDecorationColor",
    "textDecorationStyle",
    "textDecorationThickness",
    "textUnderlineOffset",
    "fontSmoothing",
    "placeholderColor",
    "placeholderOpacity",
    "caretColor",
    "accentColor",
    "opacity",
    "backgroundBlendMode",
    "mixBlendMode",
    "boxShadow",
    "boxShadowColor",
    "outlineStyle",
    "outlineWidth",
    "outlineOffset",
    "outlineColor",
    "ringWidth",
    "ringColor",
    "ringOpacity",
    "ringOffsetWidth",
    "ringOffsetColor",
    "blur",
    "brightness",
    "contrast",
    "dropShadow",
    "grayscale",
    "hueRotate",
    "invert",
    "saturate",
    "sepia",
    "filter",
    "backdropBlur",
    "backdropBrightness",
    "backdropContrast",
    "backdropGrayscale",
    "backdropHueRotate",
    "backdropInvert",
    "backdropOpacity",
    "backdropSaturate",
    "backdropSepia",
    "backdropFilter",
    "transitionProperty",
    "transitionDelay",
    "transitionDuration",
    "transitionTimingFunction",
    "willChange",
    "content"
  ];
})(tT);
var rT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, a) {
    return r === void 0 ? a : Array.isArray(r) ? r : [
      ...new Set(a.filter((d) => r !== !1 && r[d] !== !1).concat(Object.keys(r).filter((d) => r[d] !== !1)))
    ];
  }
})(rT);
var nT = {}, as = {}, Uy = { exports: {} }, qr = String, iT = function() {
  return { isColorSupported: !1, reset: qr, bold: qr, dim: qr, italic: qr, underline: qr, inverse: qr, hidden: qr, strikethrough: qr, black: qr, red: qr, green: qr, yellow: qr, blue: qr, magenta: qr, cyan: qr, white: qr, gray: qr, bgBlack: qr, bgRed: qr, bgGreen: qr, bgYellow: qr, bgBlue: qr, bgMagenta: qr, bgCyan: qr, bgWhite: qr };
};
Uy.exports = iT();
Uy.exports.createColors = iT;
var Vy = Uy.exports;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(u, i) {
    for (var c in i) Object.defineProperty(u, c, {
      enumerable: !0,
      get: i[c]
    });
  }
  e(t, {
    dim: function() {
      return h;
    },
    default: function() {
      return n;
    }
  });
  const r = /* @__PURE__ */ a(Vy);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  let l = /* @__PURE__ */ new Set();
  function d(u, i, c) {
    typeof Ze < "u" && Ze.env.JEST_WORKER_ID || c && l.has(c) || (c && l.add(c), console.warn(""), i.forEach((f) => console.warn(u, "-", f)));
  }
  function h(u) {
    return r.default.dim(u);
  }
  const n = {
    info(u, i) {
      d(r.default.bold(r.default.cyan("info")), ...Array.isArray(u) ? [
        u
      ] : [
        i,
        u
      ]);
    },
    warn(u, i) {
      d(r.default.bold(r.default.yellow("warn")), ...Array.isArray(u) ? [
        u
      ] : [
        i,
        u
      ]);
    },
    risk(u, i) {
      d(r.default.bold(r.default.magenta("risk")), ...Array.isArray(u) ? [
        u
      ] : [
        i,
        u
      ]);
    }
  };
})(as);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ r(as);
  function r(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function a({ version: d, from: h, to: n }) {
    e.default.warn(`${h}-color-renamed`, [
      `As of Tailwind CSS ${d}, \`${h}\` has been renamed to \`${n}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  const l = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    get lightBlue() {
      return a({
        version: "v2.2",
        from: "lightBlue",
        to: "sky"
      }), this.sky;
    },
    get warmGray() {
      return a({
        version: "v3.0",
        from: "warmGray",
        to: "stone"
      }), this.stone;
    },
    get trueGray() {
      return a({
        version: "v3.0",
        from: "trueGray",
        to: "neutral"
      }), this.neutral;
    },
    get coolGray() {
      return a({
        version: "v3.0",
        from: "coolGray",
        to: "gray"
      }), this.gray;
    },
    get blueGray() {
      return a({
        version: "v3.0",
        from: "blueGray",
        to: "slate"
      }), this.slate;
    }
  };
})(nT);
var sT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "defaults", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, ...a) {
    for (let h of a) {
      for (let n in h) {
        var l;
        !(r == null || (l = r.hasOwnProperty) === null || l === void 0) && l.call(r, n) || (r[n] = h[n]);
      }
      for (let n of Object.getOwnPropertySymbols(h)) {
        var d;
        !(r == null || (d = r.hasOwnProperty) === null || d === void 0) && d.call(r, n) || (r[n] = h[n]);
      }
    }
    return r;
  }
})(sT);
var Fd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "toPath", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    if (Array.isArray(r)) return r;
    let a = r.split("[").length - 1, l = r.split("]").length - 1;
    if (a !== l)
      throw new Error(`Path is invalid. Has unbalanced brackets: ${r}`);
    return r.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
})(Fd);
var aT = {}, Vs = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(f, s) {
    for (var o in s) Object.defineProperty(f, o, {
      enumerable: !0,
      get: s[o]
    });
  }
  e(t, {
    flagEnabled: function() {
      return n;
    },
    issueFlagNotices: function() {
      return i;
    },
    default: function() {
      return c;
    }
  });
  const r = /* @__PURE__ */ l(Vy), a = /* @__PURE__ */ l(as);
  function l(f) {
    return f && f.__esModule ? f : {
      default: f
    };
  }
  let d = {
    optimizeUniversalDefaults: !1,
    generalizedModifiers: !0,
    get disableColorOpacityUtilitiesByDefault() {
      return !1;
    },
    get relativeContentPathsByDefault() {
      return !1;
    }
  }, h = {
    future: [
      "hoverOnlyWhenSupported",
      "respectDefaultRingColorOpacity",
      "disableColorOpacityUtilitiesByDefault",
      "relativeContentPathsByDefault"
    ],
    experimental: [
      "optimizeUniversalDefaults",
      "generalizedModifiers"
    ]
  };
  function n(f, s) {
    if (h.future.includes(s)) {
      var o, y, m;
      return f.future === "all" || ((m = (y = f == null || (o = f.future) === null || o === void 0 ? void 0 : o[s]) !== null && y !== void 0 ? y : d[s]) !== null && m !== void 0 ? m : !1);
    }
    if (h.experimental.includes(s)) {
      var g, b, v;
      return f.experimental === "all" || ((v = (b = f == null || (g = f.experimental) === null || g === void 0 ? void 0 : g[s]) !== null && b !== void 0 ? b : d[s]) !== null && v !== void 0 ? v : !1);
    }
    return !1;
  }
  function u(f) {
    if (f.experimental === "all")
      return h.experimental;
    var s;
    return Object.keys((s = f == null ? void 0 : f.experimental) !== null && s !== void 0 ? s : {}).filter((o) => h.experimental.includes(o) && f.experimental[o]);
  }
  function i(f) {
    if (Ze.env.JEST_WORKER_ID === void 0 && u(f).length > 0) {
      let s = u(f).map((o) => r.default.yellow(o)).join(", ");
      a.default.warn("experimental-flags-enabled", [
        `You have enabled experimental features: ${s}`,
        "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
      ]);
    }
  }
  const c = h;
})(Vs);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "normalizeConfig", {
    enumerable: !0,
    get: function() {
      return d;
    }
  });
  const e = Vs, r = /* @__PURE__ */ l(as);
  function a(h) {
    if (typeof WeakMap != "function") return null;
    var n = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
    return (a = function(i) {
      return i ? u : n;
    })(h);
  }
  function l(h, n) {
    if (h && h.__esModule)
      return h;
    if (h === null || typeof h != "object" && typeof h != "function")
      return {
        default: h
      };
    var u = a(n);
    if (u && u.has(h))
      return u.get(h);
    var i = {}, c = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var f in h)
      if (f !== "default" && Object.prototype.hasOwnProperty.call(h, f)) {
        var s = c ? Object.getOwnPropertyDescriptor(h, f) : null;
        s && (s.get || s.set) ? Object.defineProperty(i, f, s) : i[f] = h[f];
      }
    return i.default = h, u && u.set(h, i), i;
  }
  function d(h) {
    if ((() => {
      if (h.purge || !h.content || !Array.isArray(h.content) && !(typeof h.content == "object" && h.content !== null))
        return !1;
      if (Array.isArray(h.content))
        return h.content.every((i) => typeof i == "string" ? !0 : !(typeof (i == null ? void 0 : i.raw) != "string" || i != null && i.extension && typeof (i == null ? void 0 : i.extension) != "string"));
      if (typeof h.content == "object" && h.content !== null) {
        if (Object.keys(h.content).some((i) => ![
          "files",
          "relative",
          "extract",
          "transform"
        ].includes(i)))
          return !1;
        if (Array.isArray(h.content.files)) {
          if (!h.content.files.every((i) => typeof i == "string" ? !0 : !(typeof (i == null ? void 0 : i.raw) != "string" || i != null && i.extension && typeof (i == null ? void 0 : i.extension) != "string")))
            return !1;
          if (typeof h.content.extract == "object") {
            for (let i of Object.values(h.content.extract))
              if (typeof i != "function")
                return !1;
          } else if (!(h.content.extract === void 0 || typeof h.content.extract == "function"))
            return !1;
          if (typeof h.content.transform == "object") {
            for (let i of Object.values(h.content.transform))
              if (typeof i != "function")
                return !1;
          } else if (!(h.content.transform === void 0 || typeof h.content.transform == "function"))
            return !1;
          if (typeof h.content.relative != "boolean" && typeof h.content.relative < "u")
            return !1;
        }
        return !0;
      }
      return !1;
    })() || r.default.warn("purge-deprecation", [
      "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
      "Update your configuration file to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]), h.safelist = (() => {
      var i;
      let { content: c, purge: f, safelist: s } = h;
      return Array.isArray(s) ? s : Array.isArray(c == null ? void 0 : c.safelist) ? c.safelist : Array.isArray(f == null ? void 0 : f.safelist) ? f.safelist : Array.isArray(f == null || (i = f.options) === null || i === void 0 ? void 0 : i.safelist) ? f.options.safelist : [];
    })(), h.blocklist = (() => {
      let { blocklist: i } = h;
      if (Array.isArray(i)) {
        if (i.every((c) => typeof c == "string"))
          return i;
        r.default.warn("blocklist-invalid", [
          "The `blocklist` option must be an array of strings.",
          "https://tailwindcss.com/docs/content-configuration#discarding-classes"
        ]);
      }
      return [];
    })(), typeof h.prefix == "function")
      r.default.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
      ]), h.prefix = "";
    else {
      var u;
      h.prefix = (u = h.prefix) !== null && u !== void 0 ? u : "";
    }
    h.content = {
      relative: (() => {
        let { content: i } = h;
        return i != null && i.relative ? i.relative : (0, e.flagEnabled)(h, "relativeContentPathsByDefault");
      })(),
      files: (() => {
        let { content: i, purge: c } = h;
        return Array.isArray(c) ? c : Array.isArray(c == null ? void 0 : c.content) ? c.content : Array.isArray(i) ? i : Array.isArray(i == null ? void 0 : i.content) ? i.content : Array.isArray(i == null ? void 0 : i.files) ? i.files : [];
      })(),
      extract: (() => {
        let i = (() => {
          var s, o, y, m, g, b, v, T, E, O;
          return !((s = h.purge) === null || s === void 0) && s.extract ? h.purge.extract : !((o = h.content) === null || o === void 0) && o.extract ? h.content.extract : !((y = h.purge) === null || y === void 0 || (m = y.extract) === null || m === void 0) && m.DEFAULT ? h.purge.extract.DEFAULT : !((g = h.content) === null || g === void 0 || (b = g.extract) === null || b === void 0) && b.DEFAULT ? h.content.extract.DEFAULT : !((v = h.purge) === null || v === void 0 || (T = v.options) === null || T === void 0) && T.extractors ? h.purge.options.extractors : !((E = h.content) === null || E === void 0 || (O = E.options) === null || O === void 0) && O.extractors ? h.content.options.extractors : {};
        })(), c = {}, f = (() => {
          var s, o, y, m;
          if (!((s = h.purge) === null || s === void 0 || (o = s.options) === null || o === void 0) && o.defaultExtractor)
            return h.purge.options.defaultExtractor;
          if (!((y = h.content) === null || y === void 0 || (m = y.options) === null || m === void 0) && m.defaultExtractor)
            return h.content.options.defaultExtractor;
        })();
        if (f !== void 0 && (c.DEFAULT = f), typeof i == "function")
          c.DEFAULT = i;
        else if (Array.isArray(i))
          for (let { extensions: s, extractor: o } of i ?? [])
            for (let y of s)
              c[y] = o;
        else typeof i == "object" && i !== null && Object.assign(c, i);
        return c;
      })(),
      transform: (() => {
        let i = (() => {
          var f, s, o, y, m, g;
          return !((f = h.purge) === null || f === void 0) && f.transform ? h.purge.transform : !((s = h.content) === null || s === void 0) && s.transform ? h.content.transform : !((o = h.purge) === null || o === void 0 || (y = o.transform) === null || y === void 0) && y.DEFAULT ? h.purge.transform.DEFAULT : !((m = h.content) === null || m === void 0 || (g = m.transform) === null || g === void 0) && g.DEFAULT ? h.content.transform.DEFAULT : {};
        })(), c = {};
        return typeof i == "function" && (c.DEFAULT = i), typeof i == "object" && i !== null && Object.assign(c, i), c;
      })()
    };
    for (let i of h.content.files)
      if (typeof i == "string" && /{([^,]*?)}/g.test(i)) {
        r.default.warn("invalid-glob-braces", [
          `The glob pattern ${(0, r.dim)(i)} in your Tailwind CSS configuration is invalid.`,
          `Update it to ${(0, r.dim)(i.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
        ]);
        break;
      }
    return h;
  }
})(aT);
var Al = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    if (Object.prototype.toString.call(r) !== "[object Object]")
      return !1;
    const a = Object.getPrototypeOf(r);
    return a === null || a === Object.prototype;
  }
})(Al);
var oT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "cloneDeep", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    return Array.isArray(r) ? r.map((a) => e(a)) : typeof r == "object" && r !== null ? Object.fromEntries(Object.entries(r).map(([a, l]) => [
      a,
      e(l)
    ])) : r;
  }
})(oT);
var Gu = {}, Bd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    return r.replace(/\\,/g, "\\2c ");
  }
})(Bd);
var zu = {}, Wy = {}, lT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  const e = {
    aliceblue: [
      240,
      248,
      255
    ],
    antiquewhite: [
      250,
      235,
      215
    ],
    aqua: [
      0,
      255,
      255
    ],
    aquamarine: [
      127,
      255,
      212
    ],
    azure: [
      240,
      255,
      255
    ],
    beige: [
      245,
      245,
      220
    ],
    bisque: [
      255,
      228,
      196
    ],
    black: [
      0,
      0,
      0
    ],
    blanchedalmond: [
      255,
      235,
      205
    ],
    blue: [
      0,
      0,
      255
    ],
    blueviolet: [
      138,
      43,
      226
    ],
    brown: [
      165,
      42,
      42
    ],
    burlywood: [
      222,
      184,
      135
    ],
    cadetblue: [
      95,
      158,
      160
    ],
    chartreuse: [
      127,
      255,
      0
    ],
    chocolate: [
      210,
      105,
      30
    ],
    coral: [
      255,
      127,
      80
    ],
    cornflowerblue: [
      100,
      149,
      237
    ],
    cornsilk: [
      255,
      248,
      220
    ],
    crimson: [
      220,
      20,
      60
    ],
    cyan: [
      0,
      255,
      255
    ],
    darkblue: [
      0,
      0,
      139
    ],
    darkcyan: [
      0,
      139,
      139
    ],
    darkgoldenrod: [
      184,
      134,
      11
    ],
    darkgray: [
      169,
      169,
      169
    ],
    darkgreen: [
      0,
      100,
      0
    ],
    darkgrey: [
      169,
      169,
      169
    ],
    darkkhaki: [
      189,
      183,
      107
    ],
    darkmagenta: [
      139,
      0,
      139
    ],
    darkolivegreen: [
      85,
      107,
      47
    ],
    darkorange: [
      255,
      140,
      0
    ],
    darkorchid: [
      153,
      50,
      204
    ],
    darkred: [
      139,
      0,
      0
    ],
    darksalmon: [
      233,
      150,
      122
    ],
    darkseagreen: [
      143,
      188,
      143
    ],
    darkslateblue: [
      72,
      61,
      139
    ],
    darkslategray: [
      47,
      79,
      79
    ],
    darkslategrey: [
      47,
      79,
      79
    ],
    darkturquoise: [
      0,
      206,
      209
    ],
    darkviolet: [
      148,
      0,
      211
    ],
    deeppink: [
      255,
      20,
      147
    ],
    deepskyblue: [
      0,
      191,
      255
    ],
    dimgray: [
      105,
      105,
      105
    ],
    dimgrey: [
      105,
      105,
      105
    ],
    dodgerblue: [
      30,
      144,
      255
    ],
    firebrick: [
      178,
      34,
      34
    ],
    floralwhite: [
      255,
      250,
      240
    ],
    forestgreen: [
      34,
      139,
      34
    ],
    fuchsia: [
      255,
      0,
      255
    ],
    gainsboro: [
      220,
      220,
      220
    ],
    ghostwhite: [
      248,
      248,
      255
    ],
    gold: [
      255,
      215,
      0
    ],
    goldenrod: [
      218,
      165,
      32
    ],
    gray: [
      128,
      128,
      128
    ],
    green: [
      0,
      128,
      0
    ],
    greenyellow: [
      173,
      255,
      47
    ],
    grey: [
      128,
      128,
      128
    ],
    honeydew: [
      240,
      255,
      240
    ],
    hotpink: [
      255,
      105,
      180
    ],
    indianred: [
      205,
      92,
      92
    ],
    indigo: [
      75,
      0,
      130
    ],
    ivory: [
      255,
      255,
      240
    ],
    khaki: [
      240,
      230,
      140
    ],
    lavender: [
      230,
      230,
      250
    ],
    lavenderblush: [
      255,
      240,
      245
    ],
    lawngreen: [
      124,
      252,
      0
    ],
    lemonchiffon: [
      255,
      250,
      205
    ],
    lightblue: [
      173,
      216,
      230
    ],
    lightcoral: [
      240,
      128,
      128
    ],
    lightcyan: [
      224,
      255,
      255
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210
    ],
    lightgray: [
      211,
      211,
      211
    ],
    lightgreen: [
      144,
      238,
      144
    ],
    lightgrey: [
      211,
      211,
      211
    ],
    lightpink: [
      255,
      182,
      193
    ],
    lightsalmon: [
      255,
      160,
      122
    ],
    lightseagreen: [
      32,
      178,
      170
    ],
    lightskyblue: [
      135,
      206,
      250
    ],
    lightslategray: [
      119,
      136,
      153
    ],
    lightslategrey: [
      119,
      136,
      153
    ],
    lightsteelblue: [
      176,
      196,
      222
    ],
    lightyellow: [
      255,
      255,
      224
    ],
    lime: [
      0,
      255,
      0
    ],
    limegreen: [
      50,
      205,
      50
    ],
    linen: [
      250,
      240,
      230
    ],
    magenta: [
      255,
      0,
      255
    ],
    maroon: [
      128,
      0,
      0
    ],
    mediumaquamarine: [
      102,
      205,
      170
    ],
    mediumblue: [
      0,
      0,
      205
    ],
    mediumorchid: [
      186,
      85,
      211
    ],
    mediumpurple: [
      147,
      112,
      219
    ],
    mediumseagreen: [
      60,
      179,
      113
    ],
    mediumslateblue: [
      123,
      104,
      238
    ],
    mediumspringgreen: [
      0,
      250,
      154
    ],
    mediumturquoise: [
      72,
      209,
      204
    ],
    mediumvioletred: [
      199,
      21,
      133
    ],
    midnightblue: [
      25,
      25,
      112
    ],
    mintcream: [
      245,
      255,
      250
    ],
    mistyrose: [
      255,
      228,
      225
    ],
    moccasin: [
      255,
      228,
      181
    ],
    navajowhite: [
      255,
      222,
      173
    ],
    navy: [
      0,
      0,
      128
    ],
    oldlace: [
      253,
      245,
      230
    ],
    olive: [
      128,
      128,
      0
    ],
    olivedrab: [
      107,
      142,
      35
    ],
    orange: [
      255,
      165,
      0
    ],
    orangered: [
      255,
      69,
      0
    ],
    orchid: [
      218,
      112,
      214
    ],
    palegoldenrod: [
      238,
      232,
      170
    ],
    palegreen: [
      152,
      251,
      152
    ],
    paleturquoise: [
      175,
      238,
      238
    ],
    palevioletred: [
      219,
      112,
      147
    ],
    papayawhip: [
      255,
      239,
      213
    ],
    peachpuff: [
      255,
      218,
      185
    ],
    peru: [
      205,
      133,
      63
    ],
    pink: [
      255,
      192,
      203
    ],
    plum: [
      221,
      160,
      221
    ],
    powderblue: [
      176,
      224,
      230
    ],
    purple: [
      128,
      0,
      128
    ],
    rebeccapurple: [
      102,
      51,
      153
    ],
    red: [
      255,
      0,
      0
    ],
    rosybrown: [
      188,
      143,
      143
    ],
    royalblue: [
      65,
      105,
      225
    ],
    saddlebrown: [
      139,
      69,
      19
    ],
    salmon: [
      250,
      128,
      114
    ],
    sandybrown: [
      244,
      164,
      96
    ],
    seagreen: [
      46,
      139,
      87
    ],
    seashell: [
      255,
      245,
      238
    ],
    sienna: [
      160,
      82,
      45
    ],
    silver: [
      192,
      192,
      192
    ],
    skyblue: [
      135,
      206,
      235
    ],
    slateblue: [
      106,
      90,
      205
    ],
    slategray: [
      112,
      128,
      144
    ],
    slategrey: [
      112,
      128,
      144
    ],
    snow: [
      255,
      250,
      250
    ],
    springgreen: [
      0,
      255,
      127
    ],
    steelblue: [
      70,
      130,
      180
    ],
    tan: [
      210,
      180,
      140
    ],
    teal: [
      0,
      128,
      128
    ],
    thistle: [
      216,
      191,
      216
    ],
    tomato: [
      255,
      99,
      71
    ],
    turquoise: [
      64,
      224,
      208
    ],
    violet: [
      238,
      130,
      238
    ],
    wheat: [
      245,
      222,
      179
    ],
    white: [
      255,
      255,
      255
    ],
    whitesmoke: [
      245,
      245,
      245
    ],
    yellow: [
      255,
      255,
      0
    ],
    yellowgreen: [
      154,
      205,
      50
    ]
  };
})(lT);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(y, m) {
    for (var g in m) Object.defineProperty(y, g, {
      enumerable: !0,
      get: m[g]
    });
  }
  e(t, {
    parseColor: function() {
      return s;
    },
    formatColor: function() {
      return o;
    }
  });
  const r = /* @__PURE__ */ a(lT);
  function a(y) {
    return y && y.__esModule ? y : {
      default: y
    };
  }
  let l = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, d = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, h = /(?:\d+|\d*\.\d+)%?/, n = /(?:\s*,\s*|\s+)/, u = /\s*[,/]\s*/, i = /var\(--(?:[^ )]*?)\)/, c = new RegExp(`^(rgba?)\\(\\s*(${h.source}|${i.source})(?:${n.source}(${h.source}|${i.source}))?(?:${n.source}(${h.source}|${i.source}))?(?:${u.source}(${h.source}|${i.source}))?\\s*\\)$`), f = new RegExp(`^(hsla?)\\(\\s*((?:${h.source})(?:deg|rad|grad|turn)?|${i.source})(?:${n.source}(${h.source}|${i.source}))?(?:${n.source}(${h.source}|${i.source}))?(?:${u.source}(${h.source}|${i.source}))?\\s*\\)$`);
  function s(y, { loose: m = !1 } = {}) {
    var g, b;
    if (typeof y != "string")
      return null;
    if (y = y.trim(), y === "transparent")
      return {
        mode: "rgb",
        color: [
          "0",
          "0",
          "0"
        ],
        alpha: "0"
      };
    if (y in r.default)
      return {
        mode: "rgb",
        color: r.default[y].map((D) => D.toString())
      };
    let v = y.replace(d, (D, $, I, k, L) => [
      "#",
      $,
      $,
      I,
      I,
      k,
      k,
      L ? L + L : ""
    ].join("")).match(l);
    if (v !== null)
      return {
        mode: "rgb",
        color: [
          parseInt(v[1], 16),
          parseInt(v[2], 16),
          parseInt(v[3], 16)
        ].map((D) => D.toString()),
        alpha: v[4] ? (parseInt(v[4], 16) / 255).toString() : void 0
      };
    var T;
    let E = (T = y.match(c)) !== null && T !== void 0 ? T : y.match(f);
    if (E === null)
      return null;
    let O = [
      E[2],
      E[3],
      E[4]
    ].filter(Boolean).map((D) => D.toString());
    return O.length === 2 && O[0].startsWith("var(") ? {
      mode: E[1],
      color: [
        O[0]
      ],
      alpha: O[1]
    } : !m && O.length !== 3 || O.length < 3 && !O.some((D) => /^var\(.*?\)$/.test(D)) ? null : {
      mode: E[1],
      color: O,
      alpha: (g = E[5]) === null || g === void 0 || (b = g.toString) === null || b === void 0 ? void 0 : b.call(g)
    };
  }
  function o({ mode: y, color: m, alpha: g }) {
    let b = g !== void 0;
    return y === "rgba" || y === "hsla" ? `${y}(${m.join(", ")}${b ? `, ${g}` : ""})` : `${y}(${m.join(" ")}${b ? ` / ${g}` : ""})`;
  }
})(Wy);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(d, h) {
    for (var n in h) Object.defineProperty(d, n, {
      enumerable: !0,
      get: h[n]
    });
  }
  e(t, {
    withAlphaValue: function() {
      return a;
    },
    default: function() {
      return l;
    }
  });
  const r = Wy;
  function a(d, h, n) {
    if (typeof d == "function")
      return d({
        opacityValue: h
      });
    let u = (0, r.parseColor)(d, {
      loose: !0
    });
    return u === null ? n : (0, r.formatColor)({
      ...u,
      alpha: h
    });
  }
  function l({ color: d, property: h, variable: n }) {
    let u = [].concat(h);
    if (typeof d == "function")
      return {
        [n]: "1",
        ...Object.fromEntries(u.map((c) => [
          c,
          d({
            opacityVariable: n,
            opacityValue: `var(${n})`
          })
        ]))
      };
    const i = (0, r.parseColor)(d);
    return i === null ? Object.fromEntries(u.map((c) => [
      c,
      d
    ])) : i.alpha !== void 0 ? Object.fromEntries(u.map((c) => [
      c,
      d
    ])) : {
      [n]: "1",
      ...Object.fromEntries(u.map((c) => [
        c,
        (0, r.formatColor)({
          ...i,
          alpha: `var(${n})`
        })
      ]))
    };
  }
})(zu);
var Ku = {}, qy = {}, Yu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "splitAtTopLevelOnly", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, a) {
    let l = [], d = [], h = 0, n = !1;
    for (let u = 0; u < r.length; u++) {
      let i = r[u];
      l.length === 0 && i === a[0] && !n && (a.length === 1 || r.slice(u, u + a.length) === a) && (d.push(r.slice(h, u)), h = u + a.length), n ? n = !1 : i === "\\" && (n = !0), i === "(" || i === "[" || i === "{" ? l.push(i) : (i === ")" && l[l.length - 1] === "(" || i === "]" && l[l.length - 1] === "[" || i === "}" && l[l.length - 1] === "{") && l.pop();
    }
    return d.push(r.slice(h)), d;
  }
})(Yu);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(u, i) {
    for (var c in i) Object.defineProperty(u, c, {
      enumerable: !0,
      get: i[c]
    });
  }
  e(t, {
    parseBoxShadowValue: function() {
      return h;
    },
    formatBoxShadowValue: function() {
      return n;
    }
  });
  const r = Yu;
  let a = /* @__PURE__ */ new Set([
    "inset",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]), l = /\ +(?![^(]*\))/g, d = /^-?(\d+|\.\d+)(.*?)$/g;
  function h(u) {
    return (0, r.splitAtTopLevelOnly)(u, ",").map((c) => {
      let f = c.trim(), s = {
        raw: f
      }, o = f.split(l), y = /* @__PURE__ */ new Set();
      for (let m of o)
        d.lastIndex = 0, !y.has("KEYWORD") && a.has(m) ? (s.keyword = m, y.add("KEYWORD")) : d.test(m) ? y.has("X") ? y.has("Y") ? y.has("BLUR") ? y.has("SPREAD") || (s.spread = m, y.add("SPREAD")) : (s.blur = m, y.add("BLUR")) : (s.y = m, y.add("Y")) : (s.x = m, y.add("X")) : s.color ? (s.unknown || (s.unknown = []), s.unknown.push(m)) : s.color = m;
      return s.valid = s.x !== void 0 && s.y !== void 0, s;
    });
  }
  function n(u) {
    return u.map((i) => i.valid ? [
      i.keyword,
      i.x,
      i.y,
      i.blur,
      i.spread,
      i.color
    ].filter(Boolean).join(" ") : i.raw).join(", ");
  }
})(qy);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(R, H) {
    for (var z in H) Object.defineProperty(R, z, {
      enumerable: !0,
      get: H[z]
    });
  }
  e(t, {
    normalize: function() {
      return i;
    },
    url: function() {
      return c;
    },
    number: function() {
      return f;
    },
    percentage: function() {
      return s;
    },
    length: function() {
      return m;
    },
    lineWidth: function() {
      return b;
    },
    shadow: function() {
      return v;
    },
    color: function() {
      return T;
    },
    image: function() {
      return E;
    },
    gradient: function() {
      return D;
    },
    position: function() {
      return I;
    },
    familyName: function() {
      return k;
    },
    genericName: function() {
      return M;
    },
    absoluteSize: function() {
      return _;
    },
    relativeSize: function() {
      return C;
    }
  });
  const r = Wy, a = qy, l = Yu;
  let d = [
    "min",
    "max",
    "clamp",
    "calc"
  ];
  function h(R) {
    return d.some((H) => new RegExp(`^${H}\\(.*\\)`).test(R));
  }
  const n = "--tw-placeholder", u = new RegExp(n, "g");
  function i(R, H = !0) {
    return R.startsWith("--") ? `var(${R})` : R.includes("url(") ? R.split(/(url\(.*?\))/g).filter(Boolean).map((z) => /^url\(.*?\)$/.test(z) ? z : i(z, !1)).join("") : (R = R.replace(/([^\\])_+/g, (z, U) => U + " ".repeat(z.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), H && (R = R.trim()), R = R.replace(/(calc|min|max|clamp)\(.+\)/g, (z) => {
      let U = [];
      return z.replace(/var\((--.+?)[,)]/g, (P, W) => (U.push(W), P.replace(W, n))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(u, () => U.shift());
    }), R);
  }
  function c(R) {
    return R.startsWith("url(");
  }
  function f(R) {
    return !isNaN(Number(R)) || h(R);
  }
  function s(R) {
    return R.endsWith("%") && f(R.slice(0, -1)) || h(R);
  }
  let y = `(?:${[
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ].join("|")})`;
  function m(R) {
    return R === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${y}$`).test(R) || h(R);
  }
  let g = /* @__PURE__ */ new Set([
    "thin",
    "medium",
    "thick"
  ]);
  function b(R) {
    return g.has(R);
  }
  function v(R) {
    let H = (0, a.parseBoxShadowValue)(i(R));
    for (let z of H)
      if (!z.valid)
        return !1;
    return !0;
  }
  function T(R) {
    let H = 0;
    return (0, l.splitAtTopLevelOnly)(R, "_").every((U) => (U = i(U), U.startsWith("var(") ? !0 : (0, r.parseColor)(U, {
      loose: !0
    }) !== null ? (H++, !0) : !1)) ? H > 0 : !1;
  }
  function E(R) {
    let H = 0;
    return (0, l.splitAtTopLevelOnly)(R, ",").every((U) => (U = i(U), U.startsWith("var(") ? !0 : c(U) || D(U) || [
      "element(",
      "image(",
      "cross-fade(",
      "image-set("
    ].some((P) => U.startsWith(P)) ? (H++, !0) : !1)) ? H > 0 : !1;
  }
  let O = /* @__PURE__ */ new Set([
    "linear-gradient",
    "radial-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "conic-gradient"
  ]);
  function D(R) {
    R = i(R);
    for (let H of O)
      if (R.startsWith(`${H}(`))
        return !0;
    return !1;
  }
  let $ = /* @__PURE__ */ new Set([
    "center",
    "top",
    "right",
    "bottom",
    "left"
  ]);
  function I(R) {
    let H = 0;
    return (0, l.splitAtTopLevelOnly)(R, "_").every((U) => (U = i(U), U.startsWith("var(") ? !0 : $.has(U) || m(U) || s(U) ? (H++, !0) : !1)) ? H > 0 : !1;
  }
  function k(R) {
    let H = 0;
    return (0, l.splitAtTopLevelOnly)(R, ",").every((U) => (U = i(U), U.startsWith("var(") ? !0 : U.includes(" ") && !/(['"])([^"']+)\1/g.test(U) || /^\d/g.test(U) ? !1 : (H++, !0))) ? H > 0 : !1;
  }
  let L = /* @__PURE__ */ new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
  ]);
  function M(R) {
    return L.has(R);
  }
  let x = /* @__PURE__ */ new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
  ]);
  function _(R) {
    return x.has(R);
  }
  let S = /* @__PURE__ */ new Set([
    "larger",
    "smaller"
  ]);
  function C(R) {
    return S.has(R);
  }
})(Ku);
var uT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "backgroundSize", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = Ku, r = Yu;
  function a(l) {
    let d = [
      "cover",
      "contain"
    ];
    return (0, r.splitAtTopLevelOnly)(l, ",").every((h) => {
      let n = (0, r.splitAtTopLevelOnly)(h, "_").filter(Boolean);
      return n.length === 1 && d.includes(n[0]) ? !0 : n.length !== 1 && n.length !== 2 ? !1 : n.every((u) => (0, e.length)(u) || (0, e.percentage)(u) || u === "auto");
    });
  }
})(uT);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(k, L) {
    for (var M in L) Object.defineProperty(k, M, {
      enumerable: !0,
      get: L[M]
    });
  }
  e(t, {
    updateAllClasses: function() {
      return i;
    },
    asValue: function() {
      return s;
    },
    parseColorFormat: function() {
      return m;
    },
    asColor: function() {
      return b;
    },
    asLookupValue: function() {
      return v;
    },
    typeMap: function() {
      return E;
    },
    coerceValue: function() {
      return $;
    },
    getMatchingTypes: function() {
      return I;
    }
  });
  const r = /* @__PURE__ */ u(Bd), a = zu, l = Ku, d = /* @__PURE__ */ u(jd), h = uT, n = Vs;
  function u(k) {
    return k && k.__esModule ? k : {
      default: k
    };
  }
  function i(k, L) {
    k.walkClasses((M) => {
      M.value = L(M.value), M.raws && M.raws.value && (M.raws.value = (0, r.default)(M.raws.value));
    });
  }
  function c(k, L) {
    if (!o(k))
      return;
    let M = k.slice(1, -1);
    if (L(M))
      return (0, l.normalize)(M);
  }
  function f(k, L = {}, M) {
    let x = L[k];
    if (x !== void 0)
      return (0, d.default)(x);
    if (o(k)) {
      let _ = c(k, M);
      return _ === void 0 ? void 0 : (0, d.default)(_);
    }
  }
  function s(k, L = {}, { validate: M = () => !0 } = {}) {
    var x;
    let _ = (x = L.values) === null || x === void 0 ? void 0 : x[k];
    return _ !== void 0 ? _ : L.supportsNegativeValues && k.startsWith("-") ? f(k.slice(1), L.values, M) : c(k, M);
  }
  function o(k) {
    return k.startsWith("[") && k.endsWith("]");
  }
  function y(k) {
    let L = k.lastIndexOf("/");
    return L === -1 || L === k.length - 1 ? [
      k,
      void 0
    ] : o(k) && !k.includes("]/[") ? [
      k,
      void 0
    ] : [
      k.slice(0, L),
      k.slice(L + 1)
    ];
  }
  function m(k) {
    if (typeof k == "string" && k.includes("<alpha-value>")) {
      let L = k;
      return ({ opacityValue: M = 1 }) => L.replace("<alpha-value>", M);
    }
    return k;
  }
  function g(k) {
    return (0, l.normalize)(k.slice(1, -1));
  }
  function b(k, L = {}, { tailwindConfig: M = {} } = {}) {
    var x;
    if (((x = L.values) === null || x === void 0 ? void 0 : x[k]) !== void 0) {
      var _;
      return m((_ = L.values) === null || _ === void 0 ? void 0 : _[k]);
    }
    let [S, C] = y(k);
    if (C !== void 0) {
      var R, H, z, U;
      let P = (U = (R = L.values) === null || R === void 0 ? void 0 : R[S]) !== null && U !== void 0 ? U : o(S) ? S.slice(1, -1) : void 0;
      return P === void 0 ? void 0 : (P = m(P), o(C) ? (0, a.withAlphaValue)(P, g(C)) : ((H = M.theme) === null || H === void 0 || (z = H.opacity) === null || z === void 0 ? void 0 : z[C]) === void 0 ? void 0 : (0, a.withAlphaValue)(P, M.theme.opacity[C]));
    }
    return s(k, L, {
      validate: l.color
    });
  }
  function v(k, L = {}) {
    var M;
    return (M = L.values) === null || M === void 0 ? void 0 : M[k];
  }
  function T(k) {
    return (L, M) => s(L, M, {
      validate: k
    });
  }
  let E = {
    any: s,
    color: b,
    url: T(l.url),
    image: T(l.image),
    length: T(l.length),
    percentage: T(l.percentage),
    position: T(l.position),
    lookup: v,
    "generic-name": T(l.genericName),
    "family-name": T(l.familyName),
    number: T(l.number),
    "line-width": T(l.lineWidth),
    "absolute-size": T(l.absoluteSize),
    "relative-size": T(l.relativeSize),
    shadow: T(l.shadow),
    size: T(h.backgroundSize)
  }, O = Object.keys(E);
  function D(k, L) {
    let M = k.indexOf(L);
    return M === -1 ? [
      void 0,
      k
    ] : [
      k.slice(0, M),
      k.slice(M + 1)
    ];
  }
  function $(k, L, M, x) {
    if (M.values && L in M.values)
      for (let { type: S } of k ?? []) {
        let C = E[S](L, M, {
          tailwindConfig: x
        });
        if (C !== void 0)
          return [
            C,
            S,
            null
          ];
      }
    if (o(L)) {
      let S = L.slice(1, -1), [C, R] = D(S, ":");
      if (!/^[\w-_]+$/g.test(C))
        R = S;
      else if (C !== void 0 && !O.includes(C))
        return [];
      if (R.length > 0 && O.includes(C))
        return [
          s(`[${R}]`, M),
          C,
          null
        ];
    }
    let _ = I(k, L, M, x);
    for (let S of _)
      return S;
    return [];
  }
  function* I(k, L, M, x) {
    let _ = (0, n.flagEnabled)(x, "generalizedModifiers"), [S, C] = y(L);
    if (_ && M.modifiers != null && (M.modifiers === "any" || typeof M.modifiers == "object" && (C && o(C) || C in M.modifiers)) || (S = L, C = void 0), C !== void 0 && S === "" && (S = "DEFAULT"), C !== void 0 && typeof M.modifiers == "object") {
      var H, z;
      let U = (z = (H = M.modifiers) === null || H === void 0 ? void 0 : H[C]) !== null && z !== void 0 ? z : null;
      U !== null ? C = U : o(C) && (C = g(C));
    }
    for (let { type: U } of k ?? []) {
      let P = E[U](S, M, {
        tailwindConfig: x
      });
      P !== void 0 && (yield [
        P,
        U,
        C ?? null
      ]);
    }
  }
})(Gu);
var Hy = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    return typeof r == "function" ? r({}) : r;
  }
})(Hy);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return M;
    }
  });
  const e = /* @__PURE__ */ o(jd), r = /* @__PURE__ */ o(tT), a = /* @__PURE__ */ o(rT), l = /* @__PURE__ */ o(nT), d = sT, h = Fd, n = aT, u = /* @__PURE__ */ o(Al), i = oT, c = Gu, f = zu, s = /* @__PURE__ */ o(Hy);
  function o(x) {
    return x && x.__esModule ? x : {
      default: x
    };
  }
  function y(x) {
    return typeof x == "function";
  }
  function m(x, ..._) {
    let S = _.pop();
    for (let C of _)
      for (let R in C) {
        let H = S(x[R], C[R]);
        H === void 0 ? (0, u.default)(x[R]) && (0, u.default)(C[R]) ? x[R] = m({}, x[R], C[R], S) : x[R] = C[R] : x[R] = H;
      }
    return x;
  }
  const g = {
    colors: l.default,
    negative(x) {
      return Object.keys(x).filter((_) => x[_] !== "0").reduce((_, S) => {
        let C = (0, e.default)(x[S]);
        return C !== void 0 && (_[`-${S}`] = C), _;
      }, {});
    },
    breakpoints(x) {
      return Object.keys(x).filter((_) => typeof x[_] == "string").reduce((_, S) => ({
        ..._,
        [`screen-${S}`]: x[S]
      }), {});
    }
  };
  function b(x, ..._) {
    return y(x) ? x(..._) : x;
  }
  function v(x) {
    return x.reduce((_, { extend: S }) => m(_, S, (C, R) => C === void 0 ? [
      R
    ] : Array.isArray(C) ? [
      R,
      ...C
    ] : [
      R,
      C
    ]), {});
  }
  function T(x) {
    return {
      ...x.reduce((_, S) => (0, d.defaults)(_, S), {}),
      // In order to resolve n config objects, we combine all of their `extend` properties
      // into arrays instead of objects so they aren't overridden.
      extend: v(x)
    };
  }
  function E(x, _) {
    if (Array.isArray(x) && (0, u.default)(x[0]))
      return x.concat(_);
    if (Array.isArray(_) && (0, u.default)(_[0]) && (0, u.default)(x))
      return [
        x,
        ..._
      ];
    if (Array.isArray(_))
      return _;
  }
  function O({ extend: x, ..._ }) {
    return m(_, x, (S, C) => !y(S) && !C.some(y) ? m({}, S, ...C, E) : (R, H) => m({}, ...[
      S,
      ...C
    ].map((z) => b(z, R, H)), E));
  }
  function* D(x) {
    let _ = (0, h.toPath)(x);
    if (_.length === 0 || (yield _, Array.isArray(x)))
      return;
    let S = /^(.*?)\s*\/\s*([^/]+)$/, C = x.match(S);
    if (C !== null) {
      let [, R, H] = C, z = (0, h.toPath)(R);
      z.alpha = H, yield z;
    }
  }
  function $(x) {
    const _ = (S, C) => {
      for (const R of D(S)) {
        let H = 0, z = x;
        for (; z != null && H < R.length; )
          z = z[R[H++]], z = y(z) && (R.alpha === void 0 || H <= R.length - 1) ? z(_, g) : z;
        if (z !== void 0) {
          if (R.alpha !== void 0) {
            let U = (0, c.parseColorFormat)(z);
            return (0, f.withAlphaValue)(U, R.alpha, (0, s.default)(U));
          }
          return (0, u.default)(z) ? (0, i.cloneDeep)(z) : z;
        }
      }
      return C;
    };
    return Object.assign(_, {
      theme: _,
      ...g
    }), Object.keys(x).reduce((S, C) => (S[C] = y(x[C]) ? x[C](_, g) : x[C], S), {});
  }
  function I(x) {
    let _ = [];
    return x.forEach((S) => {
      _ = [
        ..._,
        S
      ];
      var C;
      const R = (C = S == null ? void 0 : S.plugins) !== null && C !== void 0 ? C : [];
      R.length !== 0 && R.forEach((H) => {
        H.__isOptionsFunction && (H = H());
        var z;
        _ = [
          ..._,
          ...I([
            (z = H == null ? void 0 : H.config) !== null && z !== void 0 ? z : {}
          ])
        ];
      });
    }), _;
  }
  function k(x) {
    return [
      ...x
    ].reduceRight((S, C) => y(C) ? C({
      corePlugins: S
    }) : (0, a.default)(C, S), r.default);
  }
  function L(x) {
    return [
      ...x
    ].reduceRight((S, C) => [
      ...S,
      ...C
    ], []);
  }
  function M(x) {
    let _ = [
      ...I(x),
      {
        prefix: "",
        important: !1,
        separator: ":"
      }
    ];
    var S, C;
    return (0, n.normalizeConfig)((0, d.defaults)({
      theme: $(O(T(_.map((R) => (S = R == null ? void 0 : R.theme) !== null && S !== void 0 ? S : {})))),
      corePlugins: k(_.map((R) => R.corePlugins)),
      plugins: L(x.map((R) => (C = R == null ? void 0 : R.plugins) !== null && C !== void 0 ? C : []))
    }, ..._));
  }
})(eT);
var cT = {}, M5 = {
  content: [],
  presets: [],
  darkMode: "media",
  // or 'class'
  theme: {
    accentColor: ({ theme: t }) => ({
      ...t("colors"),
      auto: "auto"
    }),
    animation: {
      none: "none",
      spin: "spin 1s linear infinite",
      ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
      pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      bounce: "bounce 1s infinite"
    },
    aria: {
      checked: 'checked="true"',
      disabled: 'disabled="true"',
      expanded: 'expanded="true"',
      hidden: 'hidden="true"',
      pressed: 'pressed="true"',
      readonly: 'readonly="true"',
      required: 'required="true"',
      selected: 'selected="true"'
    },
    aspectRatio: {
      auto: "auto",
      square: "1 / 1",
      video: "16 / 9"
    },
    backdropBlur: ({ theme: t }) => t("blur"),
    backdropBrightness: ({ theme: t }) => t("brightness"),
    backdropContrast: ({ theme: t }) => t("contrast"),
    backdropGrayscale: ({ theme: t }) => t("grayscale"),
    backdropHueRotate: ({ theme: t }) => t("hueRotate"),
    backdropInvert: ({ theme: t }) => t("invert"),
    backdropOpacity: ({ theme: t }) => t("opacity"),
    backdropSaturate: ({ theme: t }) => t("saturate"),
    backdropSepia: ({ theme: t }) => t("sepia"),
    backgroundColor: ({ theme: t }) => t("colors"),
    backgroundImage: {
      none: "none",
      "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
      "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
      "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
      "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
      "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
      "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
      "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
      "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: t }) => t("opacity"),
    backgroundPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    backgroundSize: {
      auto: "auto",
      cover: "cover",
      contain: "contain"
    },
    blur: {
      0: "0",
      none: "0",
      sm: "4px",
      DEFAULT: "8px",
      md: "12px",
      lg: "16px",
      xl: "24px",
      "2xl": "40px",
      "3xl": "64px"
    },
    borderColor: ({ theme: t }) => ({
      ...t("colors"),
      DEFAULT: t("colors.gray.200", "currentColor")
    }),
    borderOpacity: ({ theme: t }) => t("opacity"),
    borderRadius: {
      none: "0px",
      sm: "0.125rem",
      DEFAULT: "0.25rem",
      md: "0.375rem",
      lg: "0.5rem",
      xl: "0.75rem",
      "2xl": "1rem",
      "3xl": "1.5rem",
      full: "9999px"
    },
    borderSpacing: ({ theme: t }) => ({
      ...t("spacing")
    }),
    borderWidth: {
      DEFAULT: "1px",
      0: "0px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    boxShadow: {
      sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
      DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
      md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
      lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
      xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
      "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
      inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
      none: "none"
    },
    boxShadowColor: ({ theme: t }) => t("colors"),
    brightness: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    caretColor: ({ theme: t }) => t("colors"),
    colors: ({ colors: t }) => ({
      inherit: t.inherit,
      current: t.current,
      transparent: t.transparent,
      black: t.black,
      white: t.white,
      slate: t.slate,
      gray: t.gray,
      zinc: t.zinc,
      neutral: t.neutral,
      stone: t.stone,
      red: t.red,
      orange: t.orange,
      amber: t.amber,
      yellow: t.yellow,
      lime: t.lime,
      green: t.green,
      emerald: t.emerald,
      teal: t.teal,
      cyan: t.cyan,
      sky: t.sky,
      blue: t.blue,
      indigo: t.indigo,
      violet: t.violet,
      purple: t.purple,
      fuchsia: t.fuchsia,
      pink: t.pink,
      rose: t.rose
    }),
    columns: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      "3xs": "16rem",
      "2xs": "18rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem"
    },
    container: {},
    content: {
      none: "none"
    },
    contrast: {
      0: "0",
      50: ".5",
      75: ".75",
      100: "1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    cursor: {
      auto: "auto",
      default: "default",
      pointer: "pointer",
      wait: "wait",
      text: "text",
      move: "move",
      help: "help",
      "not-allowed": "not-allowed",
      none: "none",
      "context-menu": "context-menu",
      progress: "progress",
      cell: "cell",
      crosshair: "crosshair",
      "vertical-text": "vertical-text",
      alias: "alias",
      copy: "copy",
      "no-drop": "no-drop",
      grab: "grab",
      grabbing: "grabbing",
      "all-scroll": "all-scroll",
      "col-resize": "col-resize",
      "row-resize": "row-resize",
      "n-resize": "n-resize",
      "e-resize": "e-resize",
      "s-resize": "s-resize",
      "w-resize": "w-resize",
      "ne-resize": "ne-resize",
      "nw-resize": "nw-resize",
      "se-resize": "se-resize",
      "sw-resize": "sw-resize",
      "ew-resize": "ew-resize",
      "ns-resize": "ns-resize",
      "nesw-resize": "nesw-resize",
      "nwse-resize": "nwse-resize",
      "zoom-in": "zoom-in",
      "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: t }) => t("borderColor"),
    divideOpacity: ({ theme: t }) => t("borderOpacity"),
    divideWidth: ({ theme: t }) => t("borderWidth"),
    dropShadow: {
      sm: "0 1px 1px rgb(0 0 0 / 0.05)",
      DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
      md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
      lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
      xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
      "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
      none: "0 0 #0000"
    },
    fill: ({ theme: t }) => ({
      none: "none",
      ...t("colors")
    }),
    flex: {
      1: "1 1 0%",
      auto: "1 1 auto",
      initial: "0 1 auto",
      none: "none"
    },
    flexBasis: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%"
    }),
    flexGrow: {
      0: "0",
      DEFAULT: "1"
    },
    flexShrink: {
      0: "0",
      DEFAULT: "1"
    },
    fontFamily: {
      sans: [
        "ui-sans-serif",
        "system-ui",
        "-apple-system",
        "BlinkMacSystemFont",
        '"Segoe UI"',
        "Roboto",
        '"Helvetica Neue"',
        "Arial",
        '"Noto Sans"',
        "sans-serif",
        '"Apple Color Emoji"',
        '"Segoe UI Emoji"',
        '"Segoe UI Symbol"',
        '"Noto Color Emoji"'
      ],
      serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
      mono: [
        "ui-monospace",
        "SFMono-Regular",
        "Menlo",
        "Monaco",
        "Consolas",
        '"Liberation Mono"',
        '"Courier New"',
        "monospace"
      ]
    },
    fontSize: {
      xs: ["0.75rem", { lineHeight: "1rem" }],
      sm: ["0.875rem", { lineHeight: "1.25rem" }],
      base: ["1rem", { lineHeight: "1.5rem" }],
      lg: ["1.125rem", { lineHeight: "1.75rem" }],
      xl: ["1.25rem", { lineHeight: "1.75rem" }],
      "2xl": ["1.5rem", { lineHeight: "2rem" }],
      "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
      "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
      "5xl": ["3rem", { lineHeight: "1" }],
      "6xl": ["3.75rem", { lineHeight: "1" }],
      "7xl": ["4.5rem", { lineHeight: "1" }],
      "8xl": ["6rem", { lineHeight: "1" }],
      "9xl": ["8rem", { lineHeight: "1" }]
    },
    fontWeight: {
      thin: "100",
      extralight: "200",
      light: "300",
      normal: "400",
      medium: "500",
      semibold: "600",
      bold: "700",
      extrabold: "800",
      black: "900"
    },
    gap: ({ theme: t }) => t("spacing"),
    gradientColorStops: ({ theme: t }) => t("colors"),
    gradientColorStopPositions: {
      "0%": "0%",
      "5%": "5%",
      "10%": "10%",
      "15%": "15%",
      "20%": "20%",
      "25%": "25%",
      "30%": "30%",
      "35%": "35%",
      "40%": "40%",
      "45%": "45%",
      "50%": "50%",
      "55%": "55%",
      "60%": "60%",
      "65%": "65%",
      "70%": "70%",
      "75%": "75%",
      "80%": "80%",
      "85%": "85%",
      "90%": "90%",
      "95%": "95%",
      "100%": "100%"
    },
    grayscale: {
      0: "0",
      DEFAULT: "100%"
    },
    gridAutoColumns: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridColumn: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-7": "span 7 / span 7",
      "span-8": "span 8 / span 8",
      "span-9": "span 9 / span 9",
      "span-10": "span 10 / span 10",
      "span-11": "span 11 / span 11",
      "span-12": "span 12 / span 12",
      "span-full": "1 / -1"
    },
    gridColumnEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridColumnStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridRow: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-full": "1 / -1"
    },
    gridRowEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7"
    },
    gridRowStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7"
    },
    gridTemplateColumns: {
      none: "none",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))",
      7: "repeat(7, minmax(0, 1fr))",
      8: "repeat(8, minmax(0, 1fr))",
      9: "repeat(9, minmax(0, 1fr))",
      10: "repeat(10, minmax(0, 1fr))",
      11: "repeat(11, minmax(0, 1fr))",
      12: "repeat(12, minmax(0, 1fr))"
    },
    gridTemplateRows: {
      none: "none",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))"
    },
    height: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    hueRotate: {
      0: "0deg",
      15: "15deg",
      30: "30deg",
      60: "60deg",
      90: "90deg",
      180: "180deg"
    },
    inset: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    invert: {
      0: "0",
      DEFAULT: "100%"
    },
    keyframes: {
      spin: {
        to: {
          transform: "rotate(360deg)"
        }
      },
      ping: {
        "75%, 100%": {
          transform: "scale(2)",
          opacity: "0"
        }
      },
      pulse: {
        "50%": {
          opacity: ".5"
        }
      },
      bounce: {
        "0%, 100%": {
          transform: "translateY(-25%)",
          animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
        },
        "50%": {
          transform: "none",
          animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
        }
      }
    },
    letterSpacing: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0em",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeight: {
      none: "1",
      tight: "1.25",
      snug: "1.375",
      normal: "1.5",
      relaxed: "1.625",
      loose: "2",
      3: ".75rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem"
    },
    listStyleType: {
      none: "none",
      disc: "disc",
      decimal: "decimal"
    },
    listStyleImage: {
      none: "none"
    },
    margin: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing")
    }),
    lineClamp: {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6"
    },
    maxHeight: ({ theme: t }) => ({
      ...t("spacing"),
      none: "none",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    maxWidth: ({ theme: t, breakpoints: e }) => ({
      none: "none",
      0: "0rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content",
      prose: "65ch",
      ...e(t("screens"))
    }),
    minHeight: {
      0: "0px",
      full: "100%",
      screen: "100vh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    },
    minWidth: {
      0: "0px",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    },
    objectPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    opacity: {
      0: "0",
      5: "0.05",
      10: "0.1",
      20: "0.2",
      25: "0.25",
      30: "0.3",
      40: "0.4",
      50: "0.5",
      60: "0.6",
      70: "0.7",
      75: "0.75",
      80: "0.8",
      90: "0.9",
      95: "0.95",
      100: "1"
    },
    order: {
      first: "-9999",
      last: "9999",
      none: "0",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12"
    },
    outlineColor: ({ theme: t }) => t("colors"),
    outlineOffset: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    outlineWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    padding: ({ theme: t }) => t("spacing"),
    placeholderColor: ({ theme: t }) => t("colors"),
    placeholderOpacity: ({ theme: t }) => t("opacity"),
    ringColor: ({ theme: t }) => ({
      DEFAULT: t("colors.blue.500", "#3b82f6"),
      ...t("colors")
    }),
    ringOffsetColor: ({ theme: t }) => t("colors"),
    ringOffsetWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    ringOpacity: ({ theme: t }) => ({
      DEFAULT: "0.5",
      ...t("opacity")
    }),
    ringWidth: {
      DEFAULT: "3px",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    rotate: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg",
      45: "45deg",
      90: "90deg",
      180: "180deg"
    },
    saturate: {
      0: "0",
      50: ".5",
      100: "1",
      150: "1.5",
      200: "2"
    },
    scale: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5"
    },
    screens: {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      "2xl": "1536px"
    },
    scrollMargin: ({ theme: t }) => ({
      ...t("spacing")
    }),
    scrollPadding: ({ theme: t }) => t("spacing"),
    sepia: {
      0: "0",
      DEFAULT: "100%"
    },
    skew: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg"
    },
    space: ({ theme: t }) => ({
      ...t("spacing")
    }),
    spacing: {
      px: "1px",
      0: "0px",
      0.5: "0.125rem",
      1: "0.25rem",
      1.5: "0.375rem",
      2: "0.5rem",
      2.5: "0.625rem",
      3: "0.75rem",
      3.5: "0.875rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem",
      11: "2.75rem",
      12: "3rem",
      14: "3.5rem",
      16: "4rem",
      20: "5rem",
      24: "6rem",
      28: "7rem",
      32: "8rem",
      36: "9rem",
      40: "10rem",
      44: "11rem",
      48: "12rem",
      52: "13rem",
      56: "14rem",
      60: "15rem",
      64: "16rem",
      72: "18rem",
      80: "20rem",
      96: "24rem"
    },
    stroke: ({ theme: t }) => ({
      none: "none",
      ...t("colors")
    }),
    strokeWidth: {
      0: "0",
      1: "1",
      2: "2"
    },
    supports: {},
    data: {},
    textColor: ({ theme: t }) => t("colors"),
    textDecorationColor: ({ theme: t }) => t("colors"),
    textDecorationThickness: {
      auto: "auto",
      "from-font": "from-font",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    textIndent: ({ theme: t }) => ({
      ...t("spacing")
    }),
    textOpacity: ({ theme: t }) => t("opacity"),
    textUnderlineOffset: {
      auto: "auto",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    transformOrigin: {
      center: "center",
      top: "top",
      "top-right": "top right",
      right: "right",
      "bottom-right": "bottom right",
      bottom: "bottom",
      "bottom-left": "bottom left",
      left: "left",
      "top-left": "top left"
    },
    transitionDelay: {
      0: "0s",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionDuration: {
      DEFAULT: "150ms",
      0: "0s",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionProperty: {
      none: "none",
      all: "all",
      DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
      colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
      opacity: "opacity",
      shadow: "box-shadow",
      transform: "transform"
    },
    transitionTimingFunction: {
      DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
      linear: "linear",
      in: "cubic-bezier(0.4, 0, 1, 1)",
      out: "cubic-bezier(0, 0, 0.2, 1)",
      "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: t }) => ({
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    width: ({ theme: t }) => ({
      auto: "auto",
      ...t("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%",
      screen: "100vw",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    willChange: {
      auto: "auto",
      scroll: "scroll-position",
      contents: "contents",
      transform: "transform"
    },
    zIndex: {
      auto: "auto",
      0: "0",
      10: "10",
      20: "20",
      30: "30",
      40: "40",
      50: "50"
    }
  },
  plugins: []
};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(M5), r = Vs;
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l(d) {
    var h;
    const n = ((h = d == null ? void 0 : d.presets) !== null && h !== void 0 ? h : [
      e.default
    ]).slice().reverse().flatMap((c) => l(c instanceof Function ? c() : c)), u = {
      // Add experimental configs here...
      respectDefaultRingColorOpacity: {
        theme: {
          ringColor: ({ theme: c }) => ({
            DEFAULT: "#3b82f67f",
            ...c("colors")
          })
        }
      },
      disableColorOpacityUtilitiesByDefault: {
        corePlugins: {
          backgroundOpacity: !1,
          borderOpacity: !1,
          divideOpacity: !1,
          placeholderOpacity: !1,
          ringOpacity: !1,
          textOpacity: !1
        }
      }
    }, i = Object.keys(u).filter((c) => (0, r.flagEnabled)(d, c)).map((c) => u[c]);
    return [
      d,
      ...i,
      ...n
    ];
  }
})(cT);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(eT), r = /* @__PURE__ */ a(cT);
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l(...d) {
    let [, ...h] = (0, r.default)(d[0]);
    return (0, e.default)([
      ...d,
      ...h
    ]);
  }
})(Zx);
var fT = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(f, s) {
    for (var o in s) Object.defineProperty(f, o, {
      enumerable: !0,
      get: s[o]
    });
  }
  e(t, {
    default: function() {
      return i;
    },
    resolveDefaultConfigPath: function() {
      return c;
    }
  });
  const r = /* @__PURE__ */ l(oi), a = /* @__PURE__ */ l(Qr);
  function l(f) {
    return f && f.__esModule ? f : {
      default: f
    };
  }
  const d = [
    "./tailwind.config.js",
    "./tailwind.config.cjs",
    "./tailwind.config.mjs",
    "./tailwind.config.ts"
  ];
  function h(f) {
    return typeof f == "object" && f !== null;
  }
  function n(f) {
    return Object.keys(f).length === 0;
  }
  function u(f) {
    return typeof f == "string" || f instanceof String;
  }
  function i(f) {
    return h(f) && f.config === void 0 && !n(f) ? null : h(f) && f.config !== void 0 && u(f.config) ? a.default.resolve(f.config) : h(f) && f.config !== void 0 && h(f.config) ? null : u(f) ? a.default.resolve(f) : c();
  }
  function c() {
    for (const f of d)
      try {
        const s = a.default.resolve(f);
        return r.default.accessSync(s), s;
      } catch {
      }
    return null;
  }
})(fT);
var Vh = {};
let jE = Vy, FE = Rr, $0 = class dT extends Error {
  constructor(e, r, a, l, d, h) {
    super(e), this.name = "CssSyntaxError", this.reason = e, d && (this.file = d), l && (this.source = l), h && (this.plugin = h), typeof r < "u" && typeof a < "u" && (typeof r == "number" ? (this.line = r, this.column = a) : (this.line = r.line, this.column = r.column, this.endLine = a.line, this.endColumn = a.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, dT);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let r = this.source;
    e == null && (e = jE.isColorSupported), FE && e && (r = FE(r));
    let a = r.split(/\r?\n/), l = Math.max(this.line - 3, 0), d = Math.min(this.line + 2, a.length), h = String(d).length, n, u;
    if (e) {
      let { bold: i, gray: c, red: f } = jE.createColors(!0);
      n = (s) => i(f(s)), u = (s) => c(s);
    } else
      n = u = (i) => i;
    return a.slice(l, d).map((i, c) => {
      let f = l + 1 + c, s = " " + (" " + f).slice(-h) + " | ";
      if (f === this.line) {
        let o = u(s.replace(/\d/g, " ")) + i.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return n(">") + u(s) + i + `
 ` + o + n("^");
      }
      return " " + u(s) + i;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var Gy = $0;
$0.default = $0;
var Xu = {};
Xu.isClean = Symbol("isClean");
Xu.my = Symbol("my");
const BE = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function L5(t) {
  return t[0].toUpperCase() + t.slice(1);
}
let U0 = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, r) {
    let a = "@" + e.name, l = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? a += e.raws.afterName : l && (a += " "), e.nodes)
      this.block(e, a + l);
    else {
      let d = (e.raws.between || "") + (r ? ";" : "");
      this.builder(a + l + d, e);
    }
  }
  beforeAfter(e, r) {
    let a;
    e.type === "decl" ? a = this.raw(e, null, "beforeDecl") : e.type === "comment" ? a = this.raw(e, null, "beforeComment") : r === "before" ? a = this.raw(e, null, "beforeRule") : a = this.raw(e, null, "beforeClose");
    let l = e.parent, d = 0;
    for (; l && l.type !== "root"; )
      d += 1, l = l.parent;
    if (a.includes(`
`)) {
      let h = this.raw(e, null, "indent");
      if (h.length)
        for (let n = 0; n < d; n++) a += h;
    }
    return a;
  }
  block(e, r) {
    let a = this.raw(e, "between", "beforeOpen");
    this.builder(r + a + "{", e, "start");
    let l;
    e.nodes && e.nodes.length ? (this.body(e), l = this.raw(e, "after")) : l = this.raw(e, "after", "emptyBody"), l && this.builder(l), this.builder("}", e, "end");
  }
  body(e) {
    let r = e.nodes.length - 1;
    for (; r > 0 && e.nodes[r].type === "comment"; )
      r -= 1;
    let a = this.raw(e, "semicolon");
    for (let l = 0; l < e.nodes.length; l++) {
      let d = e.nodes[l], h = this.raw(d, "before");
      h && this.builder(h), this.stringify(d, r !== l || a);
    }
  }
  comment(e) {
    let r = this.raw(e, "left", "commentLeft"), a = this.raw(e, "right", "commentRight");
    this.builder("/*" + r + e.text + a + "*/", e);
  }
  decl(e, r) {
    let a = this.raw(e, "between", "colon"), l = e.prop + a + this.rawValue(e, "value");
    e.important && (l += e.raws.important || " !important"), r && (l += ";"), this.builder(l, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, r, a) {
    let l;
    if (a || (a = r), r && (l = e.raws[r], typeof l < "u"))
      return l;
    let d = e.parent;
    if (a === "before" && (!d || d.type === "root" && d.first === e || d && d.type === "document"))
      return "";
    if (!d) return BE[a];
    let h = e.root();
    if (h.rawCache || (h.rawCache = {}), typeof h.rawCache[a] < "u")
      return h.rawCache[a];
    if (a === "before" || a === "after")
      return this.beforeAfter(e, a);
    {
      let n = "raw" + L5(a);
      this[n] ? l = this[n](h, e) : h.walk((u) => {
        if (l = u.raws[r], typeof l < "u") return !1;
      });
    }
    return typeof l > "u" && (l = BE[a]), h.rawCache[a] = l, l;
  }
  rawBeforeClose(e) {
    let r;
    return e.walk((a) => {
      if (a.nodes && a.nodes.length > 0 && typeof a.raws.after < "u")
        return r = a.raws.after, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeComment(e, r) {
    let a;
    return e.walkComments((l) => {
      if (typeof l.raws.before < "u")
        return a = l.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
    }), typeof a > "u" ? a = this.raw(r, null, "beforeDecl") : a && (a = a.replace(/\S/g, "")), a;
  }
  rawBeforeDecl(e, r) {
    let a;
    return e.walkDecls((l) => {
      if (typeof l.raws.before < "u")
        return a = l.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
    }), typeof a > "u" ? a = this.raw(r, null, "beforeRule") : a && (a = a.replace(/\S/g, "")), a;
  }
  rawBeforeOpen(e) {
    let r;
    return e.walk((a) => {
      if (a.type !== "decl" && (r = a.raws.between, typeof r < "u"))
        return !1;
    }), r;
  }
  rawBeforeRule(e) {
    let r;
    return e.walk((a) => {
      if (a.nodes && (a.parent !== e || e.first !== a) && typeof a.raws.before < "u")
        return r = a.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), r && (r = r.replace(/\S/g, "")), r;
  }
  rawColon(e) {
    let r;
    return e.walkDecls((a) => {
      if (typeof a.raws.between < "u")
        return r = a.raws.between.replace(/[^\s:]/g, ""), !1;
    }), r;
  }
  rawEmptyBody(e) {
    let r;
    return e.walk((a) => {
      if (a.nodes && a.nodes.length === 0 && (r = a.raws.after, typeof r < "u"))
        return !1;
    }), r;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let r;
    return e.walk((a) => {
      let l = a.parent;
      if (l && l !== e && l.parent && l.parent === e && typeof a.raws.before < "u") {
        let d = a.raws.before.split(`
`);
        return r = d[d.length - 1], r = r.replace(/\S/g, ""), !1;
      }
    }), r;
  }
  rawSemicolon(e) {
    let r;
    return e.walk((a) => {
      if (a.nodes && a.nodes.length && a.last.type === "decl" && (r = a.raws.semicolon, typeof r < "u"))
        return !1;
    }), r;
  }
  rawValue(e, r) {
    let a = e[r], l = e.raws[r];
    return l && l.value === a ? l.raw : a;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, r) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, r);
  }
};
var pT = U0;
U0.default = U0;
let j5 = pT;
function V0(t, e) {
  new j5(e).stringify(t);
}
var $d = V0;
V0.default = V0;
let { isClean: jc, my: F5 } = Xu, B5 = Gy, $5 = pT, U5 = $d;
function W0(t, e) {
  let r = new t.constructor();
  for (let a in t) {
    if (!Object.prototype.hasOwnProperty.call(t, a) || a === "proxyCache") continue;
    let l = t[a], d = typeof l;
    a === "parent" && d === "object" ? e && (r[a] = e) : a === "source" ? r[a] = l : Array.isArray(l) ? r[a] = l.map((h) => W0(h, r)) : (d === "object" && l !== null && (l = W0(l)), r[a] = l);
  }
  return r;
}
let q0 = class {
  constructor(e = {}) {
    this.raws = {}, this[jc] = !1, this[F5] = !0;
    for (let r in e)
      if (r === "nodes") {
        this.nodes = [];
        for (let a of e[r])
          typeof a.clone == "function" ? this.append(a.clone()) : this.append(a);
      } else
        this[r] = e[r];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let r = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${r.input.from}:${r.start.line}:${r.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let r in e)
      this[r] = e[r];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let r = W0(this);
    for (let a in e)
      r[a] = e[a];
    return r;
  }
  cloneAfter(e = {}) {
    let r = this.clone(e);
    return this.parent.insertAfter(this, r), r;
  }
  cloneBefore(e = {}) {
    let r = this.clone(e);
    return this.parent.insertBefore(this, r), r;
  }
  error(e, r = {}) {
    if (this.source) {
      let { end: a, start: l } = this.rangeBy(r);
      return this.source.input.error(
        e,
        { column: l.column, line: l.line },
        { column: a.column, line: a.line },
        r
      );
    }
    return new B5(e);
  }
  getProxyProcessor() {
    return {
      get(e, r) {
        return r === "proxyOf" ? e : r === "root" ? () => e.root().toProxy() : e[r];
      },
      set(e, r, a) {
        return e[r] === a || (e[r] = a, (r === "prop" || r === "value" || r === "name" || r === "params" || r === "important" || /* c8 ignore next */
        r === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[jc]) {
      this[jc] = !1;
      let e = this;
      for (; e = e.parent; )
        e[jc] = !1;
    }
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, r) {
    let a = this.source.start;
    if (e.index)
      a = this.positionInside(e.index, r);
    else if (e.word) {
      r = this.toString();
      let l = r.indexOf(e.word);
      l !== -1 && (a = this.positionInside(l, r));
    }
    return a;
  }
  positionInside(e, r) {
    let a = r || this.toString(), l = this.source.start.column, d = this.source.start.line;
    for (let h = 0; h < e; h++)
      a[h] === `
` ? (l = 1, d += 1) : l += 1;
    return { column: l, line: d };
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let r = {
      column: this.source.start.column,
      line: this.source.start.line
    }, a = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: r.column + 1,
      line: r.line
    };
    if (e.word) {
      let l = this.toString(), d = l.indexOf(e.word);
      d !== -1 && (r = this.positionInside(d, l), a = this.positionInside(d + e.word.length, l));
    } else
      e.start ? r = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (r = this.positionInside(e.index)), e.end ? a = {
        column: e.end.column,
        line: e.end.line
      } : typeof e.endIndex == "number" ? a = this.positionInside(e.endIndex) : e.index && (a = this.positionInside(e.index + 1));
    return (a.line < r.line || a.line === r.line && a.column <= r.column) && (a = { column: r.column + 1, line: r.line }), { end: a, start: r };
  }
  raw(e, r) {
    return new $5().raw(this, e, r);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let r = this, a = !1;
      for (let l of e)
        l === this ? a = !0 : a ? (this.parent.insertAfter(r, l), r = l) : this.parent.insertBefore(r, l);
      a || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, r) {
    let a = {}, l = r == null;
    r = r || /* @__PURE__ */ new Map();
    let d = 0;
    for (let h in this) {
      if (!Object.prototype.hasOwnProperty.call(this, h) || h === "parent" || h === "proxyCache") continue;
      let n = this[h];
      if (Array.isArray(n))
        a[h] = n.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, r) : u);
      else if (typeof n == "object" && n.toJSON)
        a[h] = n.toJSON(null, r);
      else if (h === "source") {
        let u = r.get(n.input);
        u == null && (u = d, r.set(n.input, d), d++), a[h] = {
          end: n.end,
          inputId: u,
          start: n.start
        };
      } else
        a[h] = n;
    }
    return l && (a.inputs = [...r.keys()].map((h) => h.toJSON())), a;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = U5) {
    e.stringify && (e = e.stringify);
    let r = "";
    return e(this, (a) => {
      r += a;
    }), r;
  }
  warn(e, r, a) {
    let l = { node: this };
    for (let d in a) l[d] = a[d];
    return e.warn(r, l);
  }
  get proxyOf() {
    return this;
  }
};
var Ud = q0;
q0.default = q0;
let V5 = Ud, H0 = class extends V5 {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var Vd = H0;
H0.default = H0;
let W5 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", q5 = (t, e = 21) => (r = e) => {
  let a = "", l = r;
  for (; l--; )
    a += t[Math.random() * t.length | 0];
  return a;
}, H5 = (t = 21) => {
  let e = "", r = t;
  for (; r--; )
    e += W5[Math.random() * 64 | 0];
  return e;
};
var G5 = { nanoid: H5, customAlphabet: q5 };
let { SourceMapConsumer: $E, SourceMapGenerator: UE } = Rr, { existsSync: z5, readFileSync: K5 } = oi, { dirname: Wh, join: Y5 } = Qr;
function X5(t) {
  return Gt ? Gt.from(t, "base64").toString() : window.atob(t);
}
let G0 = class {
  constructor(e, r) {
    if (r.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let a = r.map ? r.map.prev : void 0, l = this.loadMap(r.from, a);
    !this.mapFile && r.from && (this.mapFile = r.from), this.mapFile && (this.root = Wh(this.mapFile)), l && (this.text = l);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new $E(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let r = /^data:application\/json;charset=utf-?8;base64,/, a = /^data:application\/json;base64,/, l = /^data:application\/json;charset=utf-?8,/, d = /^data:application\/json,/;
    if (l.test(e) || d.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (r.test(e) || a.test(e))
      return X5(e.substr(RegExp.lastMatch.length));
    let h = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + h);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let r = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!r) return;
    let a = e.lastIndexOf(r.pop()), l = e.indexOf("*/", a);
    a > -1 && l > -1 && (this.annotation = this.getAnnotationURL(e.substring(a, l)));
  }
  loadFile(e) {
    if (this.root = Wh(e), z5(e))
      return this.mapFile = e, K5(e, "utf-8").toString().trim();
  }
  loadMap(e, r) {
    if (r === !1) return !1;
    if (r) {
      if (typeof r == "string")
        return r;
      if (typeof r == "function") {
        let a = r(e);
        if (a) {
          let l = this.loadFile(a);
          if (!l)
            throw new Error(
              "Unable to load previous source map: " + a.toString()
            );
          return l;
        }
      } else {
        if (r instanceof $E)
          return UE.fromSourceMap(r).toString();
        if (r instanceof UE)
          return r.toString();
        if (this.isMap(r))
          return JSON.stringify(r);
        throw new Error(
          "Unsupported previous source map format: " + r.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let a = this.annotation;
        return e && (a = Y5(Wh(e), a)), this.loadFile(a);
      }
    }
  }
  startWith(e, r) {
    return e ? e.substr(0, r.length) === r : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var hT = G0;
G0.default = G0;
let { SourceMapConsumer: J5, SourceMapGenerator: Q5 } = Rr, { fileURLToPath: VE, pathToFileURL: Fc } = Rr, { isAbsolute: z0, resolve: K0 } = Qr, { nanoid: Z5 } = G5, qh = Rr, WE = Gy, eN = hT, Hh = Symbol("fromOffsetCache"), tN = !!(J5 && Q5), qE = !!(K0 && z0), Wf = class {
  constructor(e, r = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, r.from && (!qE || /^\w+:\/\//.test(r.from) || z0(r.from) ? this.file = r.from : this.file = K0(r.from)), qE && tN) {
      let a = new eN(this.css, r);
      if (a.text) {
        this.map = a;
        let l = a.consumer().file;
        !this.file && l && (this.file = this.mapResolve(l));
      }
    }
    this.file || (this.id = "<input css " + Z5(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, r, a, l = {}) {
    let d, h, n;
    if (r && typeof r == "object") {
      let i = r, c = a;
      if (typeof i.offset == "number") {
        let f = this.fromOffset(i.offset);
        r = f.line, a = f.col;
      } else
        r = i.line, a = i.column;
      if (typeof c.offset == "number") {
        let f = this.fromOffset(c.offset);
        h = f.line, n = f.col;
      } else
        h = c.line, n = c.column;
    } else if (!a) {
      let i = this.fromOffset(r);
      r = i.line, a = i.col;
    }
    let u = this.origin(r, a, h, n);
    return u ? d = new WE(
      e,
      u.endLine === void 0 ? u.line : { column: u.column, line: u.line },
      u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine },
      u.source,
      u.file,
      l.plugin
    ) : d = new WE(
      e,
      h === void 0 ? r : { column: a, line: r },
      h === void 0 ? a : { column: n, line: h },
      this.css,
      this.file,
      l.plugin
    ), d.input = { column: a, endColumn: n, endLine: h, line: r, source: this.css }, this.file && (Fc && (d.input.url = Fc(this.file).toString()), d.input.file = this.file), d;
  }
  fromOffset(e) {
    let r, a;
    if (this[Hh])
      a = this[Hh];
    else {
      let d = this.css.split(`
`);
      a = new Array(d.length);
      let h = 0;
      for (let n = 0, u = d.length; n < u; n++)
        a[n] = h, h += d[n].length + 1;
      this[Hh] = a;
    }
    r = a[a.length - 1];
    let l = 0;
    if (e >= r)
      l = a.length - 1;
    else {
      let d = a.length - 2, h;
      for (; l < d; )
        if (h = l + (d - l >> 1), e < a[h])
          d = h - 1;
        else if (e >= a[h + 1])
          l = h + 1;
        else {
          l = h;
          break;
        }
    }
    return {
      col: e - a[l] + 1,
      line: l + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : K0(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, r, a, l) {
    if (!this.map) return !1;
    let d = this.map.consumer(), h = d.originalPositionFor({ column: r, line: e });
    if (!h.source) return !1;
    let n;
    typeof a == "number" && (n = d.originalPositionFor({ column: l, line: a }));
    let u;
    z0(h.source) ? u = Fc(h.source) : u = new URL(
      h.source,
      this.map.consumer().sourceRoot || Fc(this.map.mapFile)
    );
    let i = {
      column: h.column,
      endColumn: n && n.column,
      endLine: n && n.line,
      line: h.line,
      url: u.toString()
    };
    if (u.protocol === "file:")
      if (VE)
        i.file = VE(u);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = d.sourceContentFor(h.source);
    return c && (i.source = c), i;
  }
  toJSON() {
    let e = {};
    for (let r of ["hasBOM", "css", "file", "id"])
      this[r] != null && (e[r] = this[r]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var Wd = Wf;
Wf.default = Wf;
qh && qh.registerInput && qh.registerInput(Wf);
let { SourceMapConsumer: mT, SourceMapGenerator: vf } = Rr, { dirname: Ef, relative: yT, resolve: bT, sep: gT } = Qr, { pathToFileURL: HE } = Rr, rN = Wd, nN = !!(mT && vf), iN = !!(Ef && bT && yT && gT), sN = class {
  constructor(e, r, a, l) {
    this.stringify = e, this.mapOpts = a.map || {}, this.root = r, this.opts = a, this.css = l, this.originalCSS = l, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let r = `
`;
    this.css.includes(`\r
`) && (r = `\r
`), this.css += r + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let r = this.toUrl(this.path(e.file)), a = e.root || Ef(e.file), l;
      this.mapOpts.sourcesContent === !1 ? (l = new mT(e.text), l.sourcesContent && (l.sourcesContent = null)) : l = e.consumer(), this.map.applySourceMap(l, r, this.toUrl(this.path(a)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let r = this.root.nodes.length - 1; r >= 0; r--)
          e = this.root.nodes[r], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r);
      } else this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), iN && nN && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (r) => {
        e += r;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = vf.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new vf({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new vf({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, r = 1, a = "<no source>", l = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, d, h;
    this.stringify(this.root, (n, u, i) => {
      if (this.css += n, u && i !== "end" && (l.generated.line = e, l.generated.column = r - 1, u.source && u.source.start ? (l.source = this.sourcePath(u), l.original.line = u.source.start.line, l.original.column = u.source.start.column - 1, this.map.addMapping(l)) : (l.source = a, l.original.line = 1, l.original.column = 0, this.map.addMapping(l))), d = n.match(/\n/g), d ? (e += d.length, h = n.lastIndexOf(`
`), r = n.length - h) : r += n.length, u && i !== "start") {
        let c = u.parent || { raws: {} };
        (!(u.type === "decl" || u.type === "atrule" && !u.nodes) || u !== c.last || c.raws.semicolon) && (u.source && u.source.end ? (l.source = this.sourcePath(u), l.original.line = u.source.end.line, l.original.column = u.source.end.column - 1, l.generated.line = e, l.generated.column = r - 2, this.map.addMapping(l)) : (l.source = a, l.original.line = 1, l.original.column = 0, l.generated.line = e, l.generated.column = r - 1, this.map.addMapping(l)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((r) => r.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e)) return e;
    let r = this.memoizedPaths.get(e);
    if (r) return r;
    let a = this.opts.to ? Ef(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (a = Ef(bT(a, this.mapOpts.annotation)));
    let l = yT(a, e);
    return this.memoizedPaths.set(e, l), l;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let r = e.source.input.map;
            this.previousMaps.includes(r) || this.previousMaps.push(r);
          }
        });
      else {
        let e = new rN(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((r) => {
        if (r.source) {
          let a = r.source.input.from;
          if (a && !e[a]) {
            e[a] = !0;
            let l = this.usesFileUrls ? this.toFileUrl(a) : this.toUrl(this.path(a));
            this.map.setSourceContent(l, r.source.input.css);
          }
        }
      });
    else if (this.css) {
      let r = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(r, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Gt ? Gt.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let r = this.memoizedFileURLs.get(e);
    if (r) return r;
    if (HE) {
      let a = HE(e).toString();
      return this.memoizedFileURLs.set(e, a), a;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let r = this.memoizedURLs.get(e);
    if (r) return r;
    gT === "\\" && (e = e.replace(/\\/g, "/"));
    let a = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, a), a;
  }
};
var vT = sN;
let aN = Ud, Y0 = class extends aN {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var qd = Y0;
Y0.default = Y0;
let { isClean: ET, my: _T } = Xu, ST = Vd, wT = qd, oN = Ud, xT, zy, Ky, TT;
function AT(t) {
  return t.map((e) => (e.nodes && (e.nodes = AT(e.nodes)), delete e.source, e));
}
function PT(t) {
  if (t[ET] = !1, t.proxyOf.nodes)
    for (let e of t.proxyOf.nodes)
      PT(e);
}
let ta = class CT extends oN {
  append(...e) {
    for (let r of e) {
      let a = this.normalize(r, this.last);
      for (let l of a) this.proxyOf.nodes.push(l);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let r of this.nodes) r.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let r = this.getIterator(), a, l;
    for (; this.indexes[r] < this.proxyOf.nodes.length && (a = this.indexes[r], l = e(this.proxyOf.nodes[a], a), l !== !1); )
      this.indexes[r] += 1;
    return delete this.indexes[r], l;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, r) {
        return r === "proxyOf" ? e : e[r] ? r === "each" || typeof r == "string" && r.startsWith("walk") ? (...a) => e[r](
          ...a.map((l) => typeof l == "function" ? (d, h) => l(d.toProxy(), h) : l)
        ) : r === "every" || r === "some" ? (a) => e[r](
          (l, ...d) => a(l.toProxy(), ...d)
        ) : r === "root" ? () => e.root().toProxy() : r === "nodes" ? e.nodes.map((a) => a.toProxy()) : r === "first" || r === "last" ? e[r].toProxy() : e[r] : e[r];
      },
      set(e, r, a) {
        return e[r] === a || (e[r] = a, (r === "name" || r === "params" || r === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, r) {
    let a = this.index(e), l = this.normalize(r, this.proxyOf.nodes[a]).reverse();
    a = this.index(e);
    for (let h of l) this.proxyOf.nodes.splice(a + 1, 0, h);
    let d;
    for (let h in this.indexes)
      d = this.indexes[h], a < d && (this.indexes[h] = d + l.length);
    return this.markDirty(), this;
  }
  insertBefore(e, r) {
    let a = this.index(e), l = a === 0 ? "prepend" : !1, d = this.normalize(r, this.proxyOf.nodes[a], l).reverse();
    a = this.index(e);
    for (let n of d) this.proxyOf.nodes.splice(a, 0, n);
    let h;
    for (let n in this.indexes)
      h = this.indexes[n], a <= h && (this.indexes[n] = h + d.length);
    return this.markDirty(), this;
  }
  normalize(e, r) {
    if (typeof e == "string")
      e = AT(xT(e).nodes);
    else if (typeof e > "u")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let l of e)
        l.parent && l.parent.removeChild(l, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let l of e)
        l.parent && l.parent.removeChild(l, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new ST(e)];
    } else if (e.selector)
      e = [new zy(e)];
    else if (e.name)
      e = [new Ky(e)];
    else if (e.text)
      e = [new wT(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((l) => (l[_T] || CT.rebuild(l), l = l.proxyOf, l.parent && l.parent.removeChild(l), l[ET] && PT(l), typeof l.raws.before > "u" && r && typeof r.raws.before < "u" && (l.raws.before = r.raws.before.replace(/\S/g, "")), l.parent = this.proxyOf, l));
  }
  prepend(...e) {
    e = e.reverse();
    for (let r of e) {
      let a = this.normalize(r, this.first, "prepend").reverse();
      for (let l of a) this.proxyOf.nodes.unshift(l);
      for (let l in this.indexes)
        this.indexes[l] = this.indexes[l] + a.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let r;
    for (let a in this.indexes)
      r = this.indexes[a], r >= e && (this.indexes[a] = r - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, r, a) {
    return a || (a = r, r = {}), this.walkDecls((l) => {
      r.props && !r.props.includes(l.prop) || r.fast && !l.value.includes(r.fast) || (l.value = l.value.replace(e, a));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((r, a) => {
      let l;
      try {
        l = e(r, a);
      } catch (d) {
        throw r.addToError(d);
      }
      return l !== !1 && r.walk && (l = r.walk(e)), l;
    });
  }
  walkAtRules(e, r) {
    return r ? e instanceof RegExp ? this.walk((a, l) => {
      if (a.type === "atrule" && e.test(a.name))
        return r(a, l);
    }) : this.walk((a, l) => {
      if (a.type === "atrule" && a.name === e)
        return r(a, l);
    }) : (r = e, this.walk((a, l) => {
      if (a.type === "atrule")
        return r(a, l);
    }));
  }
  walkComments(e) {
    return this.walk((r, a) => {
      if (r.type === "comment")
        return e(r, a);
    });
  }
  walkDecls(e, r) {
    return r ? e instanceof RegExp ? this.walk((a, l) => {
      if (a.type === "decl" && e.test(a.prop))
        return r(a, l);
    }) : this.walk((a, l) => {
      if (a.type === "decl" && a.prop === e)
        return r(a, l);
    }) : (r = e, this.walk((a, l) => {
      if (a.type === "decl")
        return r(a, l);
    }));
  }
  walkRules(e, r) {
    return r ? e instanceof RegExp ? this.walk((a, l) => {
      if (a.type === "rule" && e.test(a.selector))
        return r(a, l);
    }) : this.walk((a, l) => {
      if (a.type === "rule" && a.selector === e)
        return r(a, l);
    }) : (r = e, this.walk((a, l) => {
      if (a.type === "rule")
        return r(a, l);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
ta.registerParse = (t) => {
  xT = t;
};
ta.registerRule = (t) => {
  zy = t;
};
ta.registerAtRule = (t) => {
  Ky = t;
};
ta.registerRoot = (t) => {
  TT = t;
};
var ho = ta;
ta.default = ta;
ta.rebuild = (t) => {
  t.type === "atrule" ? Object.setPrototypeOf(t, Ky.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, zy.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, ST.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, wT.prototype) : t.type === "root" && Object.setPrototypeOf(t, TT.prototype), t[_T] = !0, t.nodes && t.nodes.forEach((e) => {
    ta.rebuild(e);
  });
};
let lN = ho, IT, OT, xu = class extends lN {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new IT(new OT(), this, e).stringify();
  }
};
xu.registerLazyResult = (t) => {
  IT = t;
};
xu.registerProcessor = (t) => {
  OT = t;
};
var Yy = xu;
xu.default = xu;
let GE = {};
var kT = function(e) {
  GE[e] || (GE[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let X0 = class {
  constructor(e, r = {}) {
    if (this.type = "warning", this.text = e, r.node && r.node.source) {
      let a = r.node.rangeBy(r);
      this.line = a.start.line, this.column = a.start.column, this.endLine = a.end.line, this.endColumn = a.end.column;
    }
    for (let a in r) this[a] = r[a];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var DT = X0;
X0.default = X0;
let uN = DT, J0 = class {
  constructor(e, r, a) {
    this.processor = e, this.messages = [], this.root = r, this.opts = a, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, r = {}) {
    r.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r.plugin = this.lastPlugin.postcssPlugin);
    let a = new uN(e, r);
    return this.messages.push(a), a;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var Xy = J0;
J0.default = J0;
const Gh = 39, zE = 34, Bc = 92, KE = 47, $c = 10, Hl = 32, Uc = 12, Vc = 9, Wc = 13, cN = 91, fN = 93, dN = 40, pN = 41, hN = 123, mN = 125, yN = 59, bN = 42, gN = 58, vN = 64, qc = /[\t\n\f\r "#'()/;[\\\]{}]/g, Hc = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, EN = /.[\r\n"'(/\\]/, YE = /[\da-f]/i;
var _N = function(e, r = {}) {
  let a = e.css.valueOf(), l = r.ignoreErrors, d, h, n, u, i, c, f, s, o, y, m = a.length, g = 0, b = [], v = [];
  function T() {
    return g;
  }
  function E(I) {
    throw e.error("Unclosed " + I, g);
  }
  function O() {
    return v.length === 0 && g >= m;
  }
  function D(I) {
    if (v.length) return v.pop();
    if (g >= m) return;
    let k = I ? I.ignoreUnclosed : !1;
    switch (d = a.charCodeAt(g), d) {
      case $c:
      case Hl:
      case Vc:
      case Wc:
      case Uc: {
        h = g;
        do
          h += 1, d = a.charCodeAt(h);
        while (d === Hl || d === $c || d === Vc || d === Wc || d === Uc);
        y = ["space", a.slice(g, h)], g = h - 1;
        break;
      }
      case cN:
      case fN:
      case hN:
      case mN:
      case gN:
      case yN:
      case pN: {
        let L = String.fromCharCode(d);
        y = [L, L, g];
        break;
      }
      case dN: {
        if (s = b.length ? b.pop()[1] : "", o = a.charCodeAt(g + 1), s === "url" && o !== Gh && o !== zE && o !== Hl && o !== $c && o !== Vc && o !== Uc && o !== Wc) {
          h = g;
          do {
            if (c = !1, h = a.indexOf(")", h + 1), h === -1)
              if (l || k) {
                h = g;
                break;
              } else
                E("bracket");
            for (f = h; a.charCodeAt(f - 1) === Bc; )
              f -= 1, c = !c;
          } while (c);
          y = ["brackets", a.slice(g, h + 1), g, h], g = h;
        } else
          h = a.indexOf(")", g + 1), u = a.slice(g, h + 1), h === -1 || EN.test(u) ? y = ["(", "(", g] : (y = ["brackets", u, g, h], g = h);
        break;
      }
      case Gh:
      case zE: {
        n = d === Gh ? "'" : '"', h = g;
        do {
          if (c = !1, h = a.indexOf(n, h + 1), h === -1)
            if (l || k) {
              h = g + 1;
              break;
            } else
              E("string");
          for (f = h; a.charCodeAt(f - 1) === Bc; )
            f -= 1, c = !c;
        } while (c);
        y = ["string", a.slice(g, h + 1), g, h], g = h;
        break;
      }
      case vN: {
        qc.lastIndex = g + 1, qc.test(a), qc.lastIndex === 0 ? h = a.length - 1 : h = qc.lastIndex - 2, y = ["at-word", a.slice(g, h + 1), g, h], g = h;
        break;
      }
      case Bc: {
        for (h = g, i = !0; a.charCodeAt(h + 1) === Bc; )
          h += 1, i = !i;
        if (d = a.charCodeAt(h + 1), i && d !== KE && d !== Hl && d !== $c && d !== Vc && d !== Wc && d !== Uc && (h += 1, YE.test(a.charAt(h)))) {
          for (; YE.test(a.charAt(h + 1)); )
            h += 1;
          a.charCodeAt(h + 1) === Hl && (h += 1);
        }
        y = ["word", a.slice(g, h + 1), g, h], g = h;
        break;
      }
      default: {
        d === KE && a.charCodeAt(g + 1) === bN ? (h = a.indexOf("*/", g + 2) + 1, h === 0 && (l || k ? h = a.length : E("comment")), y = ["comment", a.slice(g, h + 1), g, h], g = h) : (Hc.lastIndex = g + 1, Hc.test(a), Hc.lastIndex === 0 ? h = a.length - 1 : h = Hc.lastIndex - 2, y = ["word", a.slice(g, h + 1), g, h], b.push(y), g = h);
        break;
      }
    }
    return g++, y;
  }
  function $(I) {
    v.push(I);
  }
  return {
    back: $,
    endOfFile: O,
    nextToken: D,
    position: T
  };
};
let NT = ho, qf = class extends NT {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var Jy = qf;
qf.default = qf;
NT.registerAtRule(qf);
let RT = ho, MT, LT, ol = class extends RT {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, r, a) {
    let l = super.normalize(e);
    if (r) {
      if (a === "prepend")
        this.nodes.length > 1 ? r.raws.before = this.nodes[1].raws.before : delete r.raws.before;
      else if (this.first !== r)
        for (let d of l)
          d.raws.before = r.raws.before;
    }
    return l;
  }
  removeChild(e, r) {
    let a = this.index(e);
    return !r && a === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[a].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new MT(new LT(), this, e).stringify();
  }
};
ol.registerLazyResult = (t) => {
  MT = t;
};
ol.registerProcessor = (t) => {
  LT = t;
};
var Ju = ol;
ol.default = ol;
RT.registerRoot(ol);
let Tu = {
  comma(t) {
    return Tu.split(t, [","], !0);
  },
  space(t) {
    let e = [" ", `
`, "	"];
    return Tu.split(t, e);
  },
  split(t, e, r) {
    let a = [], l = "", d = !1, h = 0, n = !1, u = "", i = !1;
    for (let c of t)
      i ? i = !1 : c === "\\" ? i = !0 : n ? c === u && (n = !1) : c === '"' || c === "'" ? (n = !0, u = c) : c === "(" ? h += 1 : c === ")" ? h > 0 && (h -= 1) : h === 0 && e.includes(c) && (d = !0), d ? (l !== "" && a.push(l.trim()), l = "", d = !1) : l += c;
    return (r || l !== "") && a.push(l.trim()), a;
  }
};
var jT = Tu;
Tu.default = Tu;
let FT = ho, SN = jT, Hf = class extends FT {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return SN.comma(this.selector);
  }
  set selectors(e) {
    let r = this.selector ? this.selector.match(/,\s*/) : null, a = r ? r[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(a);
  }
};
var Qy = Hf;
Hf.default = Hf;
FT.registerRule(Hf);
let wN = Vd, xN = _N, TN = qd, AN = Jy, PN = Ju, XE = Qy;
const JE = {
  empty: !0,
  space: !0
};
function CN(t) {
  for (let e = t.length - 1; e >= 0; e--) {
    let r = t[e], a = r[3] || r[2];
    if (a) return a;
  }
}
let IN = class {
  constructor(e) {
    this.input = e, this.root = new PN(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let r = new AN();
    r.name = e[1].slice(1), r.name === "" && this.unnamedAtrule(r, e), this.init(r, e[2]);
    let a, l, d, h = !1, n = !1, u = [], i = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), a = e[0], a === "(" || a === "[" ? i.push(a === "(" ? ")" : "]") : a === "{" && i.length > 0 ? i.push("}") : a === i[i.length - 1] && i.pop(), i.length === 0)
        if (a === ";") {
          r.source.end = this.getPosition(e[2]), r.source.end.offset++, this.semicolon = !0;
          break;
        } else if (a === "{") {
          n = !0;
          break;
        } else if (a === "}") {
          if (u.length > 0) {
            for (d = u.length - 1, l = u[d]; l && l[0] === "space"; )
              l = u[--d];
            l && (r.source.end = this.getPosition(l[3] || l[2]), r.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          u.push(e);
      else
        u.push(e);
      if (this.tokenizer.endOfFile()) {
        h = !0;
        break;
      }
    }
    r.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (r.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(r, "params", u), h && (e = u[u.length - 1], r.source.end = this.getPosition(e[3] || e[2]), r.source.end.offset++, this.spaces = r.raws.between, r.raws.between = "")) : (r.raws.afterName = "", r.params = ""), n && (r.nodes = [], this.current = r);
  }
  checkMissedSemicolon(e) {
    let r = this.colon(e);
    if (r === !1) return;
    let a = 0, l;
    for (let d = r - 1; d >= 0 && (l = e[d], !(l[0] !== "space" && (a += 1, a === 2))); d--)
      ;
    throw this.input.error(
      "Missed semicolon",
      l[0] === "word" ? l[3] + 1 : l[2]
    );
  }
  colon(e) {
    let r = 0, a, l, d;
    for (let [h, n] of e.entries()) {
      if (a = n, l = a[0], l === "(" && (r += 1), l === ")" && (r -= 1), r === 0 && l === ":")
        if (!d)
          this.doubleColon(a);
        else {
          if (d[0] === "word" && d[1] === "progid")
            continue;
          return h;
        }
      d = a;
    }
    return !1;
  }
  comment(e) {
    let r = new TN();
    this.init(r, e[2]), r.source.end = this.getPosition(e[3] || e[2]), r.source.end.offset++;
    let a = e[1].slice(2, -2);
    if (/^\s*$/.test(a))
      r.text = "", r.raws.left = a, r.raws.right = "";
    else {
      let l = a.match(/^(\s*)([^]*\S)(\s*)$/);
      r.text = l[2], r.raws.left = l[1], r.raws.right = l[3];
    }
  }
  createTokenizer() {
    this.tokenizer = xN(this.input);
  }
  decl(e, r) {
    let a = new wN();
    this.init(a, e[0][2]);
    let l = e[e.length - 1];
    for (l[0] === ";" && (this.semicolon = !0, e.pop()), a.source.end = this.getPosition(
      l[3] || l[2] || CN(e)
    ), a.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), a.raws.before += e.shift()[1];
    for (a.source.start = this.getPosition(e[0][2]), a.prop = ""; e.length; ) {
      let i = e[0][0];
      if (i === ":" || i === "space" || i === "comment")
        break;
      a.prop += e.shift()[1];
    }
    a.raws.between = "";
    let d;
    for (; e.length; )
      if (d = e.shift(), d[0] === ":") {
        a.raws.between += d[1];
        break;
      } else
        d[0] === "word" && /\w/.test(d[1]) && this.unknownWord([d]), a.raws.between += d[1];
    (a.prop[0] === "_" || a.prop[0] === "*") && (a.raws.before += a.prop[0], a.prop = a.prop.slice(1));
    let h = [], n;
    for (; e.length && (n = e[0][0], !(n !== "space" && n !== "comment")); )
      h.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let i = e.length - 1; i >= 0; i--) {
      if (d = e[i], d[1].toLowerCase() === "!important") {
        a.important = !0;
        let c = this.stringFrom(e, i);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (a.raws.important = c);
        break;
      } else if (d[1].toLowerCase() === "important") {
        let c = e.slice(0), f = "";
        for (let s = i; s > 0; s--) {
          let o = c[s][0];
          if (f.trim().indexOf("!") === 0 && o !== "space")
            break;
          f = c.pop()[1] + f;
        }
        f.trim().indexOf("!") === 0 && (a.important = !0, a.raws.important = f, e = c);
      }
      if (d[0] !== "space" && d[0] !== "comment")
        break;
    }
    e.some((i) => i[0] !== "space" && i[0] !== "comment") && (a.raws.between += h.map((i) => i[1]).join(""), h = []), this.raw(a, "value", h.concat(e), r), a.value.includes(":") && !r && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let r = new XE();
    this.init(r, e[2]), r.selector = "", r.raws.between = "", this.current = r;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let r = this.current.nodes[this.current.nodes.length - 1];
      r && r.type === "rule" && !r.raws.ownSemicolon && (r.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let r = this.input.fromOffset(e);
    return {
      column: r.col,
      line: r.line,
      offset: e
    };
  }
  init(e, r) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(r)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let r = !1, a = null, l = !1, d = null, h = [], n = e[1].startsWith("--"), u = [], i = e;
    for (; i; ) {
      if (a = i[0], u.push(i), a === "(" || a === "[")
        d || (d = i), h.push(a === "(" ? ")" : "]");
      else if (n && l && a === "{")
        d || (d = i), h.push("}");
      else if (h.length === 0)
        if (a === ";")
          if (l) {
            this.decl(u, n);
            return;
          } else
            break;
        else if (a === "{") {
          this.rule(u);
          return;
        } else if (a === "}") {
          this.tokenizer.back(u.pop()), r = !0;
          break;
        } else a === ":" && (l = !0);
      else a === h[h.length - 1] && (h.pop(), h.length === 0 && (d = null));
      i = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (r = !0), h.length > 0 && this.unclosedBracket(d), r && l) {
      if (!n)
        for (; u.length && (i = u[u.length - 1][0], !(i !== "space" && i !== "comment")); )
          this.tokenizer.back(u.pop());
      this.decl(u, n);
    } else
      this.unknownWord(u);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, r, a, l) {
    let d, h, n = a.length, u = "", i = !0, c, f;
    for (let s = 0; s < n; s += 1)
      d = a[s], h = d[0], h === "space" && s === n - 1 && !l ? i = !1 : h === "comment" ? (f = a[s - 1] ? a[s - 1][0] : "empty", c = a[s + 1] ? a[s + 1][0] : "empty", !JE[f] && !JE[c] ? u.slice(-1) === "," ? i = !1 : u += d[1] : i = !1) : u += d[1];
    if (!i) {
      let s = a.reduce((o, y) => o + y[1], "");
      e.raws[r] = { raw: s, value: u };
    }
    e[r] = u;
  }
  rule(e) {
    e.pop();
    let r = new XE();
    this.init(r, e[0][2]), r.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(r, "selector", e), this.current = r;
  }
  spacesAndCommentsFromEnd(e) {
    let r, a = "";
    for (; e.length && (r = e[e.length - 1][0], !(r !== "space" && r !== "comment")); )
      a = e.pop()[1] + a;
    return a;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let r, a = "";
    for (; e.length && (r = e[0][0], !(r !== "space" && r !== "comment")); )
      a += e.shift()[1];
    return a;
  }
  spacesFromEnd(e) {
    let r, a = "";
    for (; e.length && (r = e[e.length - 1][0], r === "space"); )
      a = e.pop()[1] + a;
    return a;
  }
  stringFrom(e, r) {
    let a = "";
    for (let l = r; l < e.length; l++)
      a += e[l][1];
    return e.splice(r, e.length - r), a;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, r) {
    throw this.input.error(
      "At-rule without name",
      { offset: r[2] },
      { offset: r[2] + r[1].length }
    );
  }
};
var ON = IN;
let kN = ho, DN = ON, NN = Wd;
function Gf(t, e) {
  let r = new NN(t, e), a = new DN(r);
  try {
    a.parse();
  } catch (l) {
    throw Ze.env.NODE_ENV !== "production" && l.name === "CssSyntaxError" && e && e.from && (/\.scss$/i.test(e.from) ? l.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(e.from) ? l.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(e.from) && (l.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), l;
  }
  return a.root;
}
var Zy = Gf;
Gf.default = Gf;
kN.registerParse(Gf);
let { isClean: ys, my: RN } = Xu, MN = vT, LN = $d, jN = ho, FN = Yy, BN = kT, QE = Xy, $N = Zy, UN = Ju;
const VN = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, WN = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, qN = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, ll = 0;
function Gl(t) {
  return typeof t == "object" && typeof t.then == "function";
}
function BT(t) {
  let e = !1, r = VN[t.type];
  return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [
    r,
    r + "-" + e,
    ll,
    r + "Exit",
    r + "Exit-" + e
  ] : e ? [r, r + "-" + e, r + "Exit", r + "Exit-" + e] : t.append ? [r, ll, r + "Exit"] : [r, r + "Exit"];
}
function ZE(t) {
  let e;
  return t.type === "document" ? e = ["Document", ll, "DocumentExit"] : t.type === "root" ? e = ["Root", ll, "RootExit"] : e = BT(t), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: t,
    visitorIndex: 0,
    visitors: []
  };
}
function Q0(t) {
  return t[ys] = !1, t.nodes && t.nodes.forEach((e) => Q0(e)), t;
}
let Z0 = {}, ul = class $T {
  constructor(e, r, a) {
    this.stringified = !1, this.processed = !1;
    let l;
    if (typeof r == "object" && r !== null && (r.type === "root" || r.type === "document"))
      l = Q0(r);
    else if (r instanceof $T || r instanceof QE)
      l = Q0(r.root), r.map && (typeof a.map > "u" && (a.map = {}), a.map.inline || (a.map.inline = !1), a.map.prev = r.map);
    else {
      let d = $N;
      a.syntax && (d = a.syntax.parse), a.parser && (d = a.parser), d.parse && (d = d.parse);
      try {
        l = d(r, a);
      } catch (h) {
        this.processed = !0, this.error = h;
      }
      l && !l[RN] && jN.rebuild(l);
    }
    this.result = new QE(e, l, a), this.helpers = { ...Z0, postcss: Z0, result: this.result }, this.plugins = this.processor.plugins.map((d) => typeof d == "object" && d.prepare ? { ...d, ...d.prepare(this.result) } : d);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, r) {
    let a = this.result.lastPlugin;
    try {
      if (r && r.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = a.postcssPlugin, e.setMessage();
      else if (a.postcssVersion && Ze.env.NODE_ENV !== "production") {
        let l = a.postcssPlugin, d = a.postcssVersion, h = this.result.processor.version, n = d.split("."), u = h.split(".");
        (n[0] !== u[0] || parseInt(n[1]) > parseInt(u[1])) && console.error(
          "Unknown error from PostCSS plugin. Your current PostCSS version is " + h + ", but " + l + " uses " + d + ". Perhaps this is the source of the error below."
        );
      }
    } catch (l) {
      console && console.error && console.error(l);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (r, a, l) => {
      this.listeners[a] || (this.listeners[a] = []), this.listeners[a].push([r, l]);
    };
    for (let r of this.plugins)
      if (typeof r == "object")
        for (let a in r) {
          if (!WN[a] && /^[A-Z]/.test(a))
            throw new Error(
              `Unknown event ${a} in ${r.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!qN[a])
            if (typeof r[a] == "object")
              for (let l in r[a])
                l === "*" ? e(r, a, r[a][l]) : e(
                  r,
                  a + "-" + l.toLowerCase(),
                  r[a][l]
                );
            else typeof r[a] == "function" && e(r, a, r[a]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let r = this.plugins[e], a = this.runOnRoot(r);
      if (Gl(a))
        try {
          await a;
        } catch (l) {
          throw this.handleError(l);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[ys]; ) {
        e[ys] = !0;
        let r = [ZE(e)];
        for (; r.length > 0; ) {
          let a = this.visitTick(r);
          if (Gl(a))
            try {
              await a;
            } catch (l) {
              let d = r[r.length - 1].node;
              throw this.handleError(l, d);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [r, a] of this.listeners.OnceExit) {
          this.result.lastPlugin = r;
          try {
            if (e.type === "document") {
              let l = e.nodes.map(
                (d) => a(d, this.helpers)
              );
              await Promise.all(l);
            } else
              await a(e, this.helpers);
          } catch (l) {
            throw this.handleError(l);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let r = this.result.root.nodes.map(
            (a) => e.Once(a, this.helpers)
          );
          return Gl(r[0]) ? Promise.all(r) : r;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (r) {
      throw this.handleError(r);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, r = LN;
    e.syntax && (r = e.syntax.stringify), e.stringifier && (r = e.stringifier), r.stringify && (r = r.stringify);
    let l = new MN(r, this.result.root, this.result.opts).generate();
    return this.result.css = l[0], this.result.map = l[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let r = this.runOnRoot(e);
      if (Gl(r))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[ys]; )
        e[ys] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let r of e.nodes)
            this.visitSync(this.listeners.OnceExit, r);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, r) {
    return Ze.env.NODE_ENV !== "production" && ("from" in this.opts || BN(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, r);
  }
  toString() {
    return this.css;
  }
  visitSync(e, r) {
    for (let [a, l] of e) {
      this.result.lastPlugin = a;
      let d;
      try {
        d = l(r, this.helpers);
      } catch (h) {
        throw this.handleError(h, r.proxyOf);
      }
      if (r.type !== "root" && r.type !== "document" && !r.parent)
        return !0;
      if (Gl(d))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let r = e[e.length - 1], { node: a, visitors: l } = r;
    if (a.type !== "root" && a.type !== "document" && !a.parent) {
      e.pop();
      return;
    }
    if (l.length > 0 && r.visitorIndex < l.length) {
      let [h, n] = l[r.visitorIndex];
      r.visitorIndex += 1, r.visitorIndex === l.length && (r.visitors = [], r.visitorIndex = 0), this.result.lastPlugin = h;
      try {
        return n(a.toProxy(), this.helpers);
      } catch (u) {
        throw this.handleError(u, a);
      }
    }
    if (r.iterator !== 0) {
      let h = r.iterator, n;
      for (; n = a.nodes[a.indexes[h]]; )
        if (a.indexes[h] += 1, !n[ys]) {
          n[ys] = !0, e.push(ZE(n));
          return;
        }
      r.iterator = 0, delete a.indexes[h];
    }
    let d = r.events;
    for (; r.eventIndex < d.length; ) {
      let h = d[r.eventIndex];
      if (r.eventIndex += 1, h === ll) {
        a.nodes && a.nodes.length && (a[ys] = !0, r.iterator = a.getIterator());
        return;
      } else if (this.listeners[h]) {
        r.visitors = this.listeners[h];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[ys] = !0;
    let r = BT(e);
    for (let a of r)
      if (a === ll)
        e.nodes && e.each((l) => {
          l[ys] || this.walkSync(l);
        });
      else {
        let l = this.listeners[a];
        if (l && this.visitSync(l, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
ul.registerPostcss = (t) => {
  Z0 = t;
};
var UT = ul;
ul.default = ul;
UN.registerLazyResult(ul);
FN.registerLazyResult(ul);
let HN = vT, GN = $d, zN = kT, KN = Zy;
const YN = Xy;
let e1 = class {
  constructor(e, r, a) {
    r = r.toString(), this.stringified = !1, this._processor = e, this._css = r, this._opts = a, this._map = void 0;
    let l, d = GN;
    this.result = new YN(this._processor, l, this._opts), this.result.css = r;
    let h = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return h.root;
      }
    });
    let n = new HN(d, l, this._opts, r);
    if (n.isMap()) {
      let [u, i] = n.generate();
      u && (this.result.css = u), i && (this.result.map = i);
    } else
      n.clearAnnotation(), this.result.css = n.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(e, r) {
    return Ze.env.NODE_ENV !== "production" && ("from" in this._opts || zN(
      "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
    )), this.async().then(e, r);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, r = KN;
    try {
      e = r(this._css, this._opts);
    } catch (a) {
      this.error = a;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var XN = e1;
e1.default = e1;
let JN = XN, QN = UT, ZN = Yy, eR = Ju, Au = class {
  constructor(e = []) {
    this.version = "8.4.38", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let r = [];
    for (let a of e)
      if (a.postcss === !0 ? a = a() : a.postcss && (a = a.postcss), typeof a == "object" && Array.isArray(a.plugins))
        r = r.concat(a.plugins);
      else if (typeof a == "object" && a.postcssPlugin)
        r.push(a);
      else if (typeof a == "function")
        r.push(a);
      else if (typeof a == "object" && (a.parse || a.stringify)) {
        if (Ze.env.NODE_ENV !== "production")
          throw new Error(
            "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
          );
      } else
        throw new Error(a + " is not a PostCSS plugin");
    return r;
  }
  process(e, r = {}) {
    return !this.plugins.length && !r.parser && !r.stringifier && !r.syntax ? new JN(this, e, r) : new QN(this, e, r);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var tR = Au;
Au.default = Au;
eR.registerProcessor(Au);
ZN.registerProcessor(Au);
let rR = Vd, nR = hT, iR = qd, sR = Jy, aR = Wd, oR = Ju, lR = Qy;
function Pu(t, e) {
  if (Array.isArray(t)) return t.map((l) => Pu(l));
  let { inputs: r, ...a } = t;
  if (r) {
    e = [];
    for (let l of r) {
      let d = { ...l, __proto__: aR.prototype };
      d.map && (d.map = {
        ...d.map,
        __proto__: nR.prototype
      }), e.push(d);
    }
  }
  if (a.nodes && (a.nodes = t.nodes.map((l) => Pu(l, e))), a.source) {
    let { inputId: l, ...d } = a.source;
    a.source = d, l != null && (a.source.input = e[l]);
  }
  if (a.type === "root")
    return new oR(a);
  if (a.type === "decl")
    return new rR(a);
  if (a.type === "rule")
    return new lR(a);
  if (a.type === "comment")
    return new iR(a);
  if (a.type === "atrule")
    return new sR(a);
  throw new Error("Unknown node type: " + t.type);
}
var uR = Pu;
Pu.default = Pu;
let cR = Gy, VT = Vd, fR = UT, dR = ho, eb = tR, pR = $d, hR = uR, WT = Yy, mR = DT, qT = qd, HT = Jy, yR = Xy, bR = Wd, gR = Zy, vR = jT, GT = Qy, zT = Ju, ER = Ud;
function kr(...t) {
  return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new eb(t);
}
kr.plugin = function(e, r) {
  let a = !1;
  function l(...h) {
    console && console.warn && !a && (a = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), Ze.env.LANG && Ze.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let n = r(...h);
    return n.postcssPlugin = e, n.postcssVersion = new eb().version, n;
  }
  let d;
  return Object.defineProperty(l, "postcss", {
    get() {
      return d || (d = l()), d;
    }
  }), l.process = function(h, n, u) {
    return kr([l(u)]).process(h, n);
  }, l;
};
kr.stringify = pR;
kr.parse = gR;
kr.fromJSON = hR;
kr.list = vR;
kr.comment = (t) => new qT(t);
kr.atRule = (t) => new HT(t);
kr.decl = (t) => new VT(t);
kr.rule = (t) => new GT(t);
kr.root = (t) => new zT(t);
kr.document = (t) => new WT(t);
kr.CssSyntaxError = cR;
kr.Declaration = VT;
kr.Container = dR;
kr.Processor = eb;
kr.Document = WT;
kr.Comment = qT;
kr.Warning = mR;
kr.AtRule = HT;
kr.Result = yR;
kr.Input = bR;
kr.Rule = GT;
kr.Root = zT;
kr.Node = ER;
fR.registerPostcss(kr);
var Vi = kr;
kr.default = kr;
const Hr = /* @__PURE__ */ gd(Vi);
var KT = { exports: {} };
(function(t, e) {
  (function(r, a) {
    t.exports = function(l, d, h, n, u) {
      for (d = d.split ? d.split(".") : d, n = 0; n < d.length; n++) l = l ? l[d[n]] : u;
      return l === u ? h : l;
    };
  })();
})(KT);
var YT = KT.exports, t1 = { exports: {} }, r1 = { exports: {} }, n1 = { exports: {} }, i1 = { exports: {} }, s1 = { exports: {} }, a1 = { exports: {} }, vi = {}, o1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = l;
  function r(d) {
    for (var h = d.toLowerCase(), n = "", u = !1, i = 0; i < 6 && h[i] !== void 0; i++) {
      var c = h.charCodeAt(i), f = c >= 97 && c <= 102 || c >= 48 && c <= 57;
      if (u = c === 32, !f)
        break;
      n += h[i];
    }
    if (n.length !== 0) {
      var s = parseInt(n, 16), o = s >= 55296 && s <= 57343;
      return o || s === 0 || s > 1114111 ? ["�", n.length + (u ? 1 : 0)] : [String.fromCodePoint(s), n.length + (u ? 1 : 0)];
    }
  }
  var a = /\\/;
  function l(d) {
    var h = a.test(d);
    if (!h)
      return d;
    for (var n = "", u = 0; u < d.length; u++) {
      if (d[u] === "\\") {
        var i = r(d.slice(u + 1, u + 7));
        if (i !== void 0) {
          n += i[0], u += i[1];
          continue;
        }
        if (d[u + 1] === "\\") {
          n += "\\", u++;
          continue;
        }
        d.length === u + 1 && (n += d[u]);
        continue;
      }
      n += d[u];
    }
    return n;
  }
  t.exports = e.default;
})(o1, o1.exports);
var tb = o1.exports, l1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = r;
  function r(a) {
    for (var l = arguments.length, d = new Array(l > 1 ? l - 1 : 0), h = 1; h < l; h++)
      d[h - 1] = arguments[h];
    for (; d.length > 0; ) {
      var n = d.shift();
      if (!a[n])
        return;
      a = a[n];
    }
    return a;
  }
  t.exports = e.default;
})(l1, l1.exports);
var _R = l1.exports, u1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = r;
  function r(a) {
    for (var l = arguments.length, d = new Array(l > 1 ? l - 1 : 0), h = 1; h < l; h++)
      d[h - 1] = arguments[h];
    for (; d.length > 0; ) {
      var n = d.shift();
      a[n] || (a[n] = {}), a = a[n];
    }
  }
  t.exports = e.default;
})(u1, u1.exports);
var SR = u1.exports, c1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = r;
  function r(a) {
    for (var l = "", d = a.indexOf("/*"), h = 0; d >= 0; ) {
      l = l + a.slice(h, d);
      var n = a.indexOf("*/", d + 2);
      if (n < 0)
        return l;
      h = n + 2, d = a.indexOf("/*", h);
    }
    return l = l + a.slice(h), l;
  }
  t.exports = e.default;
})(c1, c1.exports);
var wR = c1.exports;
vi.__esModule = !0;
vi.unesc = vi.stripComments = vi.getProp = vi.ensureObject = void 0;
var xR = Hd(tb);
vi.unesc = xR.default;
var TR = Hd(_R);
vi.getProp = TR.default;
var AR = Hd(SR);
vi.ensureObject = AR.default;
var PR = Hd(wR);
vi.stripComments = PR.default;
function Hd(t) {
  return t && t.__esModule ? t : { default: t };
}
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = vi;
  function a(n, u) {
    for (var i = 0; i < u.length; i++) {
      var c = u[i];
      c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(n, c.key, c);
    }
  }
  function l(n, u, i) {
    return u && a(n.prototype, u), Object.defineProperty(n, "prototype", { writable: !1 }), n;
  }
  var d = function n(u, i) {
    if (typeof u != "object" || u === null)
      return u;
    var c = new u.constructor();
    for (var f in u)
      if (u.hasOwnProperty(f)) {
        var s = u[f], o = typeof s;
        f === "parent" && o === "object" ? i && (c[f] = i) : s instanceof Array ? c[f] = s.map(function(y) {
          return n(y, c);
        }) : c[f] = n(s, c);
      }
    return c;
  }, h = /* @__PURE__ */ function() {
    function n(i) {
      i === void 0 && (i = {}), Object.assign(this, i), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var u = n.prototype;
    return u.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, u.replaceWith = function() {
      if (this.parent) {
        for (var c in arguments)
          this.parent.insertBefore(this, arguments[c]);
        this.remove();
      }
      return this;
    }, u.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, u.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, u.clone = function(c) {
      c === void 0 && (c = {});
      var f = d(this);
      for (var s in c)
        f[s] = c[s];
      return f;
    }, u.appendToPropertyAndEscape = function(c, f, s) {
      this.raws || (this.raws = {});
      var o = this[c], y = this.raws[c];
      this[c] = o + f, y || s !== f ? this.raws[c] = (y || o) + s : delete this.raws[c];
    }, u.setPropertyAndEscape = function(c, f, s) {
      this.raws || (this.raws = {}), this[c] = f, this.raws[c] = s;
    }, u.setPropertyWithoutEscape = function(c, f) {
      this[c] = f, this.raws && delete this.raws[c];
    }, u.isAtPosition = function(c, f) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > c || this.source.end.line < c || this.source.start.line === c && this.source.start.column > f || this.source.end.line === c && this.source.end.column < f);
    }, u.stringifyProperty = function(c) {
      return this.raws && this.raws[c] || this[c];
    }, u.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, u.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, l(n, [{
      key: "rawSpaceBefore",
      get: function() {
        var c = this.raws && this.raws.spaces && this.raws.spaces.before;
        return c === void 0 && (c = this.spaces && this.spaces.before), c || "";
      },
      set: function(c) {
        (0, r.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = c;
      }
    }, {
      key: "rawSpaceAfter",
      get: function() {
        var c = this.raws && this.raws.spaces && this.raws.spaces.after;
        return c === void 0 && (c = this.spaces.after), c || "";
      },
      set: function(c) {
        (0, r.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = c;
      }
    }]), n;
  }();
  e.default = h, t.exports = e.default;
})(a1, a1.exports);
var ka = a1.exports, lr = {};
lr.__esModule = !0;
lr.UNIVERSAL = lr.TAG = lr.STRING = lr.SELECTOR = lr.ROOT = lr.PSEUDO = lr.NESTING = lr.ID = lr.COMMENT = lr.COMBINATOR = lr.CLASS = lr.ATTRIBUTE = void 0;
var CR = "tag";
lr.TAG = CR;
var IR = "string";
lr.STRING = IR;
var OR = "selector";
lr.SELECTOR = OR;
var kR = "root";
lr.ROOT = kR;
var DR = "pseudo";
lr.PSEUDO = DR;
var NR = "nesting";
lr.NESTING = NR;
var RR = "id";
lr.ID = RR;
var MR = "comment";
lr.COMMENT = MR;
var LR = "combinator";
lr.COMBINATOR = LR;
var jR = "class";
lr.CLASS = jR;
var FR = "attribute";
lr.ATTRIBUTE = FR;
var BR = "universal";
lr.UNIVERSAL = BR;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = h(ka), a = d(lr);
  function l(m) {
    if (typeof WeakMap != "function") return null;
    var g = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
    return (l = function(T) {
      return T ? b : g;
    })(m);
  }
  function d(m, g) {
    if (m && m.__esModule)
      return m;
    if (m === null || typeof m != "object" && typeof m != "function")
      return { default: m };
    var b = l(g);
    if (b && b.has(m))
      return b.get(m);
    var v = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var E in m)
      if (E !== "default" && Object.prototype.hasOwnProperty.call(m, E)) {
        var O = T ? Object.getOwnPropertyDescriptor(m, E) : null;
        O && (O.get || O.set) ? Object.defineProperty(v, E, O) : v[E] = m[E];
      }
    return v.default = m, b && b.set(m, v), v;
  }
  function h(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function n(m, g) {
    var b = typeof Symbol < "u" && m[Symbol.iterator] || m["@@iterator"];
    if (b) return (b = b.call(m)).next.bind(b);
    if (Array.isArray(m) || (b = u(m)) || g) {
      b && (m = b);
      var v = 0;
      return function() {
        return v >= m.length ? { done: !0 } : { done: !1, value: m[v++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function u(m, g) {
    if (m) {
      if (typeof m == "string") return i(m, g);
      var b = Object.prototype.toString.call(m).slice(8, -1);
      if (b === "Object" && m.constructor && (b = m.constructor.name), b === "Map" || b === "Set") return Array.from(m);
      if (b === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(b)) return i(m, g);
    }
  }
  function i(m, g) {
    (g == null || g > m.length) && (g = m.length);
    for (var b = 0, v = new Array(g); b < g; b++)
      v[b] = m[b];
    return v;
  }
  function c(m, g) {
    for (var b = 0; b < g.length; b++) {
      var v = g[b];
      v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(m, v.key, v);
    }
  }
  function f(m, g, b) {
    return g && c(m.prototype, g), Object.defineProperty(m, "prototype", { writable: !1 }), m;
  }
  function s(m, g) {
    m.prototype = Object.create(g.prototype), m.prototype.constructor = m, o(m, g);
  }
  function o(m, g) {
    return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v, T) {
      return v.__proto__ = T, v;
    }, o(m, g);
  }
  var y = /* @__PURE__ */ function(m) {
    s(g, m);
    function g(v) {
      var T;
      return T = m.call(this, v) || this, T.nodes || (T.nodes = []), T;
    }
    var b = g.prototype;
    return b.append = function(T) {
      return T.parent = this, this.nodes.push(T), this;
    }, b.prepend = function(T) {
      return T.parent = this, this.nodes.unshift(T), this;
    }, b.at = function(T) {
      return this.nodes[T];
    }, b.index = function(T) {
      return typeof T == "number" ? T : this.nodes.indexOf(T);
    }, b.removeChild = function(T) {
      T = this.index(T), this.at(T).parent = void 0, this.nodes.splice(T, 1);
      var E;
      for (var O in this.indexes)
        E = this.indexes[O], E >= T && (this.indexes[O] = E - 1);
      return this;
    }, b.removeAll = function() {
      for (var T = n(this.nodes), E; !(E = T()).done; ) {
        var O = E.value;
        O.parent = void 0;
      }
      return this.nodes = [], this;
    }, b.empty = function() {
      return this.removeAll();
    }, b.insertAfter = function(T, E) {
      E.parent = this;
      var O = this.index(T);
      this.nodes.splice(O + 1, 0, E), E.parent = this;
      var D;
      for (var $ in this.indexes)
        D = this.indexes[$], O <= D && (this.indexes[$] = D + 1);
      return this;
    }, b.insertBefore = function(T, E) {
      E.parent = this;
      var O = this.index(T);
      this.nodes.splice(O, 0, E), E.parent = this;
      var D;
      for (var $ in this.indexes)
        D = this.indexes[$], D <= O && (this.indexes[$] = D + 1);
      return this;
    }, b._findChildAtPosition = function(T, E) {
      var O = void 0;
      return this.each(function(D) {
        if (D.atPosition) {
          var $ = D.atPosition(T, E);
          if ($)
            return O = $, !1;
        } else if (D.isAtPosition(T, E))
          return O = D, !1;
      }), O;
    }, b.atPosition = function(T, E) {
      if (this.isAtPosition(T, E))
        return this._findChildAtPosition(T, E) || this;
    }, b._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, b.each = function(T) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var E = this.lastEach;
      if (this.indexes[E] = 0, !!this.length) {
        for (var O, D; this.indexes[E] < this.length && (O = this.indexes[E], D = T(this.at(O), O), D !== !1); )
          this.indexes[E] += 1;
        if (delete this.indexes[E], D === !1)
          return !1;
      }
    }, b.walk = function(T) {
      return this.each(function(E, O) {
        var D = T(E, O);
        if (D !== !1 && E.length && (D = E.walk(T)), D === !1)
          return !1;
      });
    }, b.walkAttributes = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.ATTRIBUTE)
          return T.call(E, O);
      });
    }, b.walkClasses = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.CLASS)
          return T.call(E, O);
      });
    }, b.walkCombinators = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.COMBINATOR)
          return T.call(E, O);
      });
    }, b.walkComments = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.COMMENT)
          return T.call(E, O);
      });
    }, b.walkIds = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.ID)
          return T.call(E, O);
      });
    }, b.walkNesting = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.NESTING)
          return T.call(E, O);
      });
    }, b.walkPseudos = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.PSEUDO)
          return T.call(E, O);
      });
    }, b.walkTags = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.TAG)
          return T.call(E, O);
      });
    }, b.walkUniversals = function(T) {
      var E = this;
      return this.walk(function(O) {
        if (O.type === a.UNIVERSAL)
          return T.call(E, O);
      });
    }, b.split = function(T) {
      var E = this, O = [];
      return this.reduce(function(D, $, I) {
        var k = T.call(E, $);
        return O.push($), k ? (D.push(O), O = []) : I === E.length - 1 && D.push(O), D;
      }, []);
    }, b.map = function(T) {
      return this.nodes.map(T);
    }, b.reduce = function(T, E) {
      return this.nodes.reduce(T, E);
    }, b.every = function(T) {
      return this.nodes.every(T);
    }, b.some = function(T) {
      return this.nodes.some(T);
    }, b.filter = function(T) {
      return this.nodes.filter(T);
    }, b.sort = function(T) {
      return this.nodes.sort(T);
    }, b.toString = function() {
      return this.map(String).join("");
    }, f(g, [{
      key: "first",
      get: function() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function() {
        return this.nodes.length;
      }
    }]), g;
  }(r.default);
  e.default = y, t.exports = e.default;
})(s1, s1.exports);
var rb = s1.exports;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(rb), a = lr;
  function l(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function d(c, f) {
    for (var s = 0; s < f.length; s++) {
      var o = f[s];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(c, o.key, o);
    }
  }
  function h(c, f, s) {
    return f && d(c.prototype, f), Object.defineProperty(c, "prototype", { writable: !1 }), c;
  }
  function n(c, f) {
    c.prototype = Object.create(f.prototype), c.prototype.constructor = c, u(c, f);
  }
  function u(c, f) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, y) {
      return o.__proto__ = y, o;
    }, u(c, f);
  }
  var i = /* @__PURE__ */ function(c) {
    n(f, c);
    function f(o) {
      var y;
      return y = c.call(this, o) || this, y.type = a.ROOT, y;
    }
    var s = f.prototype;
    return s.toString = function() {
      var y = this.reduce(function(m, g) {
        return m.push(String(g)), m;
      }, []).join(",");
      return this.trailingComma ? y + "," : y;
    }, s.error = function(y, m) {
      return this._error ? this._error(y, m) : new Error(y);
    }, h(f, [{
      key: "errorGenerator",
      set: function(y) {
        this._error = y;
      }
    }]), f;
  }(r.default);
  e.default = i, t.exports = e.default;
})(i1, i1.exports);
var XT = i1.exports, f1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(rb), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.SELECTOR, f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(f1, f1.exports);
var JT = f1.exports, d1 = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var $R = {}, UR = $R.hasOwnProperty, VR = function(e, r) {
  if (!e)
    return r;
  var a = {};
  for (var l in r)
    a[l] = UR.call(e, l) ? e[l] : r[l];
  return a;
}, WR = /[ -,\.\/:-@\[-\^`\{-~]/, qR = /[ -,\.\/:-@\[\]\^`\{-~]/, HR = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, nb = function t(e, r) {
  r = VR(r, t.options), r.quotes != "single" && r.quotes != "double" && (r.quotes = "single");
  for (var a = r.quotes == "double" ? '"' : "'", l = r.isIdentifier, d = e.charAt(0), h = "", n = 0, u = e.length; n < u; ) {
    var i = e.charAt(n++), c = i.charCodeAt(), f = void 0;
    if (c < 32 || c > 126) {
      if (c >= 55296 && c <= 56319 && n < u) {
        var s = e.charCodeAt(n++);
        (s & 64512) == 56320 ? c = ((c & 1023) << 10) + (s & 1023) + 65536 : n--;
      }
      f = "\\" + c.toString(16).toUpperCase() + " ";
    } else
      r.escapeEverything ? WR.test(i) ? f = "\\" + i : f = "\\" + c.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(i) ? f = "\\" + c.toString(16).toUpperCase() + " " : i == "\\" || !l && (i == '"' && a == i || i == "'" && a == i) || l && qR.test(i) ? f = "\\" + i : f = i;
    h += f;
  }
  return l && (/^-[-\d]/.test(h) ? h = "\\-" + h.slice(1) : /\d/.test(d) && (h = "\\3" + d + " " + h.slice(1))), h = h.replace(HR, function(o, y, m) {
    return y && y.length % 2 ? o : (y || "") + m;
  }), !l && r.wrap ? a + h + a : h;
};
nb.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
nb.version = "3.0.0";
var ib = nb;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = h(ib), a = vi, l = h(ka), d = lr;
  function h(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function n(s, o) {
    for (var y = 0; y < o.length; y++) {
      var m = o[y];
      m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(s, m.key, m);
    }
  }
  function u(s, o, y) {
    return o && n(s.prototype, o), Object.defineProperty(s, "prototype", { writable: !1 }), s;
  }
  function i(s, o) {
    s.prototype = Object.create(o.prototype), s.prototype.constructor = s, c(s, o);
  }
  function c(s, o) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, g) {
      return m.__proto__ = g, m;
    }, c(s, o);
  }
  var f = /* @__PURE__ */ function(s) {
    i(o, s);
    function o(m) {
      var g;
      return g = s.call(this, m) || this, g.type = d.CLASS, g._constructed = !0, g;
    }
    var y = o.prototype;
    return y.valueToString = function() {
      return "." + s.prototype.valueToString.call(this);
    }, u(o, [{
      key: "value",
      get: function() {
        return this._value;
      },
      set: function(g) {
        if (this._constructed) {
          var b = (0, r.default)(g, {
            isIdentifier: !0
          });
          b !== g ? ((0, a.ensureObject)(this, "raws"), this.raws.value = b) : this.raws && delete this.raws.value;
        }
        this._value = g;
      }
    }]), o;
  }(l.default);
  e.default = f, t.exports = e.default;
})(d1, d1.exports);
var QT = d1.exports, p1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(ka), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.COMMENT, f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(p1, p1.exports);
var ZT = p1.exports, h1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(ka), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(f) {
      var s;
      return s = u.call(this, f) || this, s.type = a.ID, s;
    }
    var c = i.prototype;
    return c.valueToString = function() {
      return "#" + u.prototype.valueToString.call(this);
    }, i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(h1, h1.exports);
var eA = h1.exports, m1 = { exports: {} }, y1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = d(ib), a = vi, l = d(ka);
  function d(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function h(f, s) {
    for (var o = 0; o < s.length; o++) {
      var y = s[o];
      y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(f, y.key, y);
    }
  }
  function n(f, s, o) {
    return s && h(f.prototype, s), Object.defineProperty(f, "prototype", { writable: !1 }), f;
  }
  function u(f, s) {
    f.prototype = Object.create(s.prototype), f.prototype.constructor = f, i(f, s);
  }
  function i(f, s) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(y, m) {
      return y.__proto__ = m, y;
    }, i(f, s);
  }
  var c = /* @__PURE__ */ function(f) {
    u(s, f);
    function s() {
      return f.apply(this, arguments) || this;
    }
    var o = s.prototype;
    return o.qualifiedName = function(m) {
      return this.namespace ? this.namespaceString + "|" + m : m;
    }, o.valueToString = function() {
      return this.qualifiedName(f.prototype.valueToString.call(this));
    }, n(s, [{
      key: "namespace",
      get: function() {
        return this._namespace;
      },
      set: function(m) {
        if (m === !0 || m === "*" || m === "&") {
          this._namespace = m, this.raws && delete this.raws.namespace;
          return;
        }
        var g = (0, r.default)(m, {
          isIdentifier: !0
        });
        this._namespace = m, g !== m ? ((0, a.ensureObject)(this, "raws"), this.raws.namespace = g) : this.raws && delete this.raws.namespace;
      }
    }, {
      key: "ns",
      get: function() {
        return this._namespace;
      },
      set: function(m) {
        this.namespace = m;
      }
    }, {
      key: "namespaceString",
      get: function() {
        if (this.namespace) {
          var m = this.stringifyProperty("namespace");
          return m === !0 ? "" : m;
        } else
          return "";
      }
    }]), s;
  }(l.default);
  e.default = c, t.exports = e.default;
})(y1, y1.exports);
var sb = y1.exports;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(sb), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.TAG, f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(m1, m1.exports);
var tA = m1.exports, b1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(ka), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.STRING, f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(b1, b1.exports);
var rA = b1.exports, g1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(rb), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(f) {
      var s;
      return s = u.call(this, f) || this, s.type = a.PSEUDO, s;
    }
    var c = i.prototype;
    return c.toString = function() {
      var s = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), s, this.rawSpaceAfter].join("");
    }, i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(g1, g1.exports);
var nA = g1.exports, ab = {}, ob = GR;
function GR(t, e) {
  if (zh("noDeprecation"))
    return t;
  var r = !1;
  function a() {
    if (!r) {
      if (zh("throwDeprecation"))
        throw new Error(e);
      zh("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0;
    }
    return t.apply(this, arguments);
  }
  return a;
}
function zh(t) {
  try {
    if (!jt.localStorage) return !1;
  } catch {
    return !1;
  }
  var e = jt.localStorage[t];
  return e == null ? !1 : String(e).toLowerCase() === "true";
}
(function(t) {
  t.__esModule = !0, t.default = void 0, t.unescapeValue = g;
  var e = h(ib), r = h(tb), a = h(sb), l = lr, d;
  function h(O) {
    return O && O.__esModule ? O : { default: O };
  }
  function n(O, D) {
    for (var $ = 0; $ < D.length; $++) {
      var I = D[$];
      I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(O, I.key, I);
    }
  }
  function u(O, D, $) {
    return D && n(O.prototype, D), Object.defineProperty(O, "prototype", { writable: !1 }), O;
  }
  function i(O, D) {
    O.prototype = Object.create(D.prototype), O.prototype.constructor = O, c(O, D);
  }
  function c(O, D) {
    return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(I, k) {
      return I.__proto__ = k, I;
    }, c(O, D);
  }
  var f = ob, s = /^('|")([^]*)\1$/, o = f(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), y = f(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), m = f(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function g(O) {
    var D = !1, $ = null, I = O, k = I.match(s);
    return k && ($ = k[1], I = k[2]), I = (0, r.default)(I), I !== O && (D = !0), {
      deprecatedUsage: D,
      unescaped: I,
      quoteMark: $
    };
  }
  function b(O) {
    if (O.quoteMark !== void 0 || O.value === void 0)
      return O;
    m();
    var D = g(O.value), $ = D.quoteMark, I = D.unescaped;
    return O.raws || (O.raws = {}), O.raws.value === void 0 && (O.raws.value = O.value), O.value = I, O.quoteMark = $, O;
  }
  var v = /* @__PURE__ */ function(O) {
    i(D, O);
    function D(I) {
      var k;
      return I === void 0 && (I = {}), k = O.call(this, b(I)) || this, k.type = l.ATTRIBUTE, k.raws = k.raws || {}, Object.defineProperty(k.raws, "unquoted", {
        get: f(function() {
          return k.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: f(function() {
          return k.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      }), k._constructed = !0, k;
    }
    var $ = D.prototype;
    return $.getQuotedValue = function(k) {
      k === void 0 && (k = {});
      var L = this._determineQuoteMark(k), M = T[L], x = (0, e.default)(this._value, M);
      return x;
    }, $._determineQuoteMark = function(k) {
      return k.smart ? this.smartQuoteMark(k) : this.preferredQuoteMark(k);
    }, $.setValue = function(k, L) {
      L === void 0 && (L = {}), this._value = k, this._quoteMark = this._determineQuoteMark(L), this._syncRawValue();
    }, $.smartQuoteMark = function(k) {
      var L = this.value, M = L.replace(/[^']/g, "").length, x = L.replace(/[^"]/g, "").length;
      if (M + x === 0) {
        var _ = (0, e.default)(L, {
          isIdentifier: !0
        });
        if (_ === L)
          return D.NO_QUOTE;
        var S = this.preferredQuoteMark(k);
        if (S === D.NO_QUOTE) {
          var C = this.quoteMark || k.quoteMark || D.DOUBLE_QUOTE, R = T[C], H = (0, e.default)(L, R);
          if (H.length < _.length)
            return C;
        }
        return S;
      } else return x === M ? this.preferredQuoteMark(k) : x < M ? D.DOUBLE_QUOTE : D.SINGLE_QUOTE;
    }, $.preferredQuoteMark = function(k) {
      var L = k.preferCurrentQuoteMark ? this.quoteMark : k.quoteMark;
      return L === void 0 && (L = k.preferCurrentQuoteMark ? k.quoteMark : this.quoteMark), L === void 0 && (L = D.DOUBLE_QUOTE), L;
    }, $._syncRawValue = function() {
      var k = (0, e.default)(this._value, T[this.quoteMark]);
      k === this._value ? this.raws && delete this.raws.value : this.raws.value = k;
    }, $._handleEscapes = function(k, L) {
      if (this._constructed) {
        var M = (0, e.default)(L, {
          isIdentifier: !0
        });
        M !== L ? this.raws[k] = M : delete this.raws[k];
      }
    }, $._spacesFor = function(k) {
      var L = {
        before: "",
        after: ""
      }, M = this.spaces[k] || {}, x = this.raws.spaces && this.raws.spaces[k] || {};
      return Object.assign(L, M, x);
    }, $._stringFor = function(k, L, M) {
      L === void 0 && (L = k), M === void 0 && (M = E);
      var x = this._spacesFor(L);
      return M(this.stringifyProperty(k), x);
    }, $.offsetOf = function(k) {
      var L = 1, M = this._spacesFor("attribute");
      if (L += M.before.length, k === "namespace" || k === "ns")
        return this.namespace ? L : -1;
      if (k === "attributeNS" || (L += this.namespaceString.length, this.namespace && (L += 1), k === "attribute"))
        return L;
      L += this.stringifyProperty("attribute").length, L += M.after.length;
      var x = this._spacesFor("operator");
      L += x.before.length;
      var _ = this.stringifyProperty("operator");
      if (k === "operator")
        return _ ? L : -1;
      L += _.length, L += x.after.length;
      var S = this._spacesFor("value");
      L += S.before.length;
      var C = this.stringifyProperty("value");
      if (k === "value")
        return C ? L : -1;
      L += C.length, L += S.after.length;
      var R = this._spacesFor("insensitive");
      return L += R.before.length, k === "insensitive" && this.insensitive ? L : -1;
    }, $.toString = function() {
      var k = this, L = [this.rawSpaceBefore, "["];
      return L.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (L.push(this._stringFor("operator")), L.push(this._stringFor("value")), L.push(this._stringFor("insensitiveFlag", "insensitive", function(M, x) {
        return M.length > 0 && !k.quoted && x.before.length === 0 && !(k.spaces.value && k.spaces.value.after) && (x.before = " "), E(M, x);
      }))), L.push("]"), L.push(this.rawSpaceAfter), L.join("");
    }, u(D, [{
      key: "quoted",
      get: function() {
        var k = this.quoteMark;
        return k === "'" || k === '"';
      },
      set: function(k) {
        y();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */
    }, {
      key: "quoteMark",
      get: function() {
        return this._quoteMark;
      },
      set: function(k) {
        if (!this._constructed) {
          this._quoteMark = k;
          return;
        }
        this._quoteMark !== k && (this._quoteMark = k, this._syncRawValue());
      }
    }, {
      key: "qualifiedAttribute",
      get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function() {
        return this._value;
      },
      set: (
        /**
         * Before 3.0, the value had to be set to an escaped value including any wrapped
         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
         * is unescaped during parsing and any quote marks are removed.
         *
         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
         * a deprecation warning is raised when the new value contains any characters that would
         * require escaping (including if it contains wrapped quotes).
         *
         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
         * how the new value is quoted.
         */
        function(k) {
          if (this._constructed) {
            var L = g(k), M = L.deprecatedUsage, x = L.unescaped, _ = L.quoteMark;
            if (M && o(), x === this._value && _ === this._quoteMark)
              return;
            this._value = x, this._quoteMark = _, this._syncRawValue();
          } else
            this._value = k;
        }
      )
    }, {
      key: "insensitive",
      get: function() {
        return this._insensitive;
      },
      set: function(k) {
        k || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = k;
      }
    }, {
      key: "attribute",
      get: function() {
        return this._attribute;
      },
      set: function(k) {
        this._handleEscapes("attribute", k), this._attribute = k;
      }
    }]), D;
  }(a.default);
  t.default = v, v.NO_QUOTE = null, v.SINGLE_QUOTE = "'", v.DOUBLE_QUOTE = '"';
  var T = (d = {
    "'": {
      quotes: "single",
      wrap: !0
    },
    '"': {
      quotes: "double",
      wrap: !0
    }
  }, d[null] = {
    isIdentifier: !0
  }, d);
  function E(O, D) {
    return "" + D.before + O + D.after;
  }
})(ab);
var v1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(sb), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.UNIVERSAL, f.value = "*", f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(v1, v1.exports);
var iA = v1.exports, E1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(ka), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.COMBINATOR, f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(E1, E1.exports);
var sA = E1.exports, _1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = l(ka), a = lr;
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function d(u, i) {
    u.prototype = Object.create(i.prototype), u.prototype.constructor = u, h(u, i);
  }
  function h(u, i) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, s) {
      return f.__proto__ = s, f;
    }, h(u, i);
  }
  var n = /* @__PURE__ */ function(u) {
    d(i, u);
    function i(c) {
      var f;
      return f = u.call(this, c) || this, f.type = a.NESTING, f.value = "&", f;
    }
    return i;
  }(r.default);
  e.default = n, t.exports = e.default;
})(_1, _1.exports);
var aA = _1.exports, S1 = { exports: {} };
(function(t, e) {
  e.__esModule = !0, e.default = r;
  function r(a) {
    return a.sort(function(l, d) {
      return l - d;
    });
  }
  t.exports = e.default;
})(S1, S1.exports);
var zR = S1.exports, oA = {}, Dt = {};
Dt.__esModule = !0;
Dt.word = Dt.tilde = Dt.tab = Dt.str = Dt.space = Dt.slash = Dt.singleQuote = Dt.semicolon = Dt.plus = Dt.pipe = Dt.openSquare = Dt.openParenthesis = Dt.newline = Dt.greaterThan = Dt.feed = Dt.equals = Dt.doubleQuote = Dt.dollar = Dt.cr = Dt.comment = Dt.comma = Dt.combinator = Dt.colon = Dt.closeSquare = Dt.closeParenthesis = Dt.caret = Dt.bang = Dt.backslash = Dt.at = Dt.asterisk = Dt.ampersand = void 0;
var KR = 38;
Dt.ampersand = KR;
var YR = 42;
Dt.asterisk = YR;
var XR = 64;
Dt.at = XR;
var JR = 44;
Dt.comma = JR;
var QR = 58;
Dt.colon = QR;
var ZR = 59;
Dt.semicolon = ZR;
var eM = 40;
Dt.openParenthesis = eM;
var tM = 41;
Dt.closeParenthesis = tM;
var rM = 91;
Dt.openSquare = rM;
var nM = 93;
Dt.closeSquare = nM;
var iM = 36;
Dt.dollar = iM;
var sM = 126;
Dt.tilde = sM;
var aM = 94;
Dt.caret = aM;
var oM = 43;
Dt.plus = oM;
var lM = 61;
Dt.equals = lM;
var uM = 124;
Dt.pipe = uM;
var cM = 62;
Dt.greaterThan = cM;
var fM = 32;
Dt.space = fM;
var lA = 39;
Dt.singleQuote = lA;
var dM = 34;
Dt.doubleQuote = dM;
var pM = 47;
Dt.slash = pM;
var hM = 33;
Dt.bang = hM;
var mM = 92;
Dt.backslash = mM;
var yM = 13;
Dt.cr = yM;
var bM = 12;
Dt.feed = bM;
var gM = 10;
Dt.newline = gM;
var vM = 9;
Dt.tab = vM;
var EM = lA;
Dt.str = EM;
var _M = -1;
Dt.comment = _M;
var SM = -2;
Dt.word = SM;
var wM = -3;
Dt.combinator = wM;
(function(t) {
  t.__esModule = !0, t.FIELDS = void 0, t.default = y;
  var e = d(Dt), r, a;
  function l(m) {
    if (typeof WeakMap != "function") return null;
    var g = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
    return (l = function(T) {
      return T ? b : g;
    })(m);
  }
  function d(m, g) {
    if (m && m.__esModule)
      return m;
    if (m === null || typeof m != "object" && typeof m != "function")
      return { default: m };
    var b = l(g);
    if (b && b.has(m))
      return b.get(m);
    var v = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var E in m)
      if (E !== "default" && Object.prototype.hasOwnProperty.call(m, E)) {
        var O = T ? Object.getOwnPropertyDescriptor(m, E) : null;
        O && (O.get || O.set) ? Object.defineProperty(v, E, O) : v[E] = m[E];
      }
    return v.default = m, b && b.set(m, v), v;
  }
  for (var h = (r = {}, r[e.tab] = !0, r[e.newline] = !0, r[e.cr] = !0, r[e.feed] = !0, r), n = (a = {}, a[e.space] = !0, a[e.tab] = !0, a[e.newline] = !0, a[e.cr] = !0, a[e.feed] = !0, a[e.ampersand] = !0, a[e.asterisk] = !0, a[e.bang] = !0, a[e.comma] = !0, a[e.colon] = !0, a[e.semicolon] = !0, a[e.openParenthesis] = !0, a[e.closeParenthesis] = !0, a[e.openSquare] = !0, a[e.closeSquare] = !0, a[e.singleQuote] = !0, a[e.doubleQuote] = !0, a[e.plus] = !0, a[e.pipe] = !0, a[e.tilde] = !0, a[e.greaterThan] = !0, a[e.equals] = !0, a[e.dollar] = !0, a[e.caret] = !0, a[e.slash] = !0, a), u = {}, i = "0123456789abcdefABCDEF", c = 0; c < i.length; c++)
    u[i.charCodeAt(c)] = !0;
  function f(m, g) {
    var b = g, v;
    do {
      if (v = m.charCodeAt(b), n[v])
        return b - 1;
      v === e.backslash ? b = s(m, b) + 1 : b++;
    } while (b < m.length);
    return b - 1;
  }
  function s(m, g) {
    var b = g, v = m.charCodeAt(b + 1);
    if (!h[v]) if (u[v]) {
      var T = 0;
      do
        b++, T++, v = m.charCodeAt(b + 1);
      while (u[v] && T < 6);
      T < 6 && v === e.space && b++;
    } else
      b++;
    return b;
  }
  var o = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  t.FIELDS = o;
  function y(m) {
    var g = [], b = m.css.valueOf(), v = b, T = v.length, E = -1, O = 1, D = 0, $ = 0, I, k, L, M, x, _, S, C, R, H, z, U, P;
    function W(B, Q) {
      if (m.safe)
        b += Q, R = b.length - 1;
      else
        throw m.error("Unclosed " + B, O, D - E, D);
    }
    for (; D < T; ) {
      switch (I = b.charCodeAt(D), I === e.newline && (E = D, O += 1), I) {
        case e.space:
        case e.tab:
        case e.newline:
        case e.cr:
        case e.feed:
          R = D;
          do
            R += 1, I = b.charCodeAt(R), I === e.newline && (E = R, O += 1);
          while (I === e.space || I === e.newline || I === e.tab || I === e.cr || I === e.feed);
          P = e.space, M = O, L = R - E - 1, $ = R;
          break;
        case e.plus:
        case e.greaterThan:
        case e.tilde:
        case e.pipe:
          R = D;
          do
            R += 1, I = b.charCodeAt(R);
          while (I === e.plus || I === e.greaterThan || I === e.tilde || I === e.pipe);
          P = e.combinator, M = O, L = D - E, $ = R;
          break;
        case e.asterisk:
        case e.ampersand:
        case e.bang:
        case e.comma:
        case e.equals:
        case e.dollar:
        case e.caret:
        case e.openSquare:
        case e.closeSquare:
        case e.colon:
        case e.semicolon:
        case e.openParenthesis:
        case e.closeParenthesis:
          R = D, P = I, M = O, L = D - E, $ = R + 1;
          break;
        case e.singleQuote:
        case e.doubleQuote:
          U = I === e.singleQuote ? "'" : '"', R = D;
          do
            for (x = !1, R = b.indexOf(U, R + 1), R === -1 && W("quote", U), _ = R; b.charCodeAt(_ - 1) === e.backslash; )
              _ -= 1, x = !x;
          while (x);
          P = e.str, M = O, L = D - E, $ = R + 1;
          break;
        default:
          I === e.slash && b.charCodeAt(D + 1) === e.asterisk ? (R = b.indexOf("*/", D + 2) + 1, R === 0 && W("comment", "*/"), k = b.slice(D, R + 1), C = k.split(`
`), S = C.length - 1, S > 0 ? (H = O + S, z = R - C[S].length) : (H = O, z = E), P = e.comment, O = H, M = H, L = R - z) : I === e.slash ? (R = D, P = I, M = O, L = D - E, $ = R + 1) : (R = f(b, D), P = e.word, M = O, L = R - E), $ = R + 1;
          break;
      }
      g.push([
        P,
        // [0] Token type
        O,
        // [1] Starting line
        D - E,
        // [2] Starting column
        M,
        // [3] Ending line
        L,
        // [4] Ending column
        D,
        // [5] Start position / Source index
        $
        // [6] End position
      ]), z && (E = z, z = null), D = $;
    }
    return g;
  }
})(oA);
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = $(XT), a = $(JT), l = $(QT), d = $(ZT), h = $(eA), n = $(tA), u = $(rA), i = $(nA), c = D(ab), f = $(iA), s = $(sA), o = $(aA), y = $(zR), m = D(oA), g = D(Dt), b = D(lr), v = vi, T, E;
  function O(W) {
    if (typeof WeakMap != "function") return null;
    var B = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap();
    return (O = function(re) {
      return re ? Q : B;
    })(W);
  }
  function D(W, B) {
    if (W && W.__esModule)
      return W;
    if (W === null || typeof W != "object" && typeof W != "function")
      return { default: W };
    var Q = O(B);
    if (Q && Q.has(W))
      return Q.get(W);
    var J = {}, re = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var G in W)
      if (G !== "default" && Object.prototype.hasOwnProperty.call(W, G)) {
        var N = re ? Object.getOwnPropertyDescriptor(W, G) : null;
        N && (N.get || N.set) ? Object.defineProperty(J, G, N) : J[G] = W[G];
      }
    return J.default = W, Q && Q.set(W, J), J;
  }
  function $(W) {
    return W && W.__esModule ? W : { default: W };
  }
  function I(W, B) {
    for (var Q = 0; Q < B.length; Q++) {
      var J = B[Q];
      J.enumerable = J.enumerable || !1, J.configurable = !0, "value" in J && (J.writable = !0), Object.defineProperty(W, J.key, J);
    }
  }
  function k(W, B, Q) {
    return B && I(W.prototype, B), Object.defineProperty(W, "prototype", { writable: !1 }), W;
  }
  var L = (T = {}, T[g.space] = !0, T[g.cr] = !0, T[g.feed] = !0, T[g.newline] = !0, T[g.tab] = !0, T), M = Object.assign({}, L, (E = {}, E[g.comment] = !0, E));
  function x(W) {
    return {
      line: W[m.FIELDS.START_LINE],
      column: W[m.FIELDS.START_COL]
    };
  }
  function _(W) {
    return {
      line: W[m.FIELDS.END_LINE],
      column: W[m.FIELDS.END_COL]
    };
  }
  function S(W, B, Q, J) {
    return {
      start: {
        line: W,
        column: B
      },
      end: {
        line: Q,
        column: J
      }
    };
  }
  function C(W) {
    return S(W[m.FIELDS.START_LINE], W[m.FIELDS.START_COL], W[m.FIELDS.END_LINE], W[m.FIELDS.END_COL]);
  }
  function R(W, B) {
    if (W)
      return S(W[m.FIELDS.START_LINE], W[m.FIELDS.START_COL], B[m.FIELDS.END_LINE], B[m.FIELDS.END_COL]);
  }
  function H(W, B) {
    var Q = W[B];
    if (typeof Q == "string")
      return Q.indexOf("\\") !== -1 && ((0, v.ensureObject)(W, "raws"), W[B] = (0, v.unesc)(Q), W.raws[B] === void 0 && (W.raws[B] = Q)), W;
  }
  function z(W, B) {
    for (var Q = -1, J = []; (Q = W.indexOf(B, Q + 1)) !== -1; )
      J.push(Q);
    return J;
  }
  function U() {
    var W = Array.prototype.concat.apply([], arguments);
    return W.filter(function(B, Q) {
      return Q === W.indexOf(B);
    });
  }
  var P = /* @__PURE__ */ function() {
    function W(Q, J) {
      J === void 0 && (J = {}), this.rule = Q, this.options = Object.assign({
        lossy: !1,
        safe: !1
      }, J), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, m.default)({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var re = R(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new r.default({
        source: re
      }), this.root.errorGenerator = this._errorGenerator();
      var G = new a.default({
        source: {
          start: {
            line: 1,
            column: 1
          }
        },
        sourceIndex: 0
      });
      this.root.append(G), this.current = G, this.loop();
    }
    var B = W.prototype;
    return B._errorGenerator = function() {
      var J = this;
      return function(re, G) {
        return typeof J.rule == "string" ? new Error(re) : J.rule.error(re, G);
      };
    }, B.attribute = function() {
      var J = [], re = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[m.FIELDS.TYPE] !== g.closeSquare; )
        J.push(this.currToken), this.position++;
      if (this.currToken[m.FIELDS.TYPE] !== g.closeSquare)
        return this.expected("closing square bracket", this.currToken[m.FIELDS.START_POS]);
      var G = J.length, N = {
        source: S(re[1], re[2], this.currToken[3], this.currToken[4]),
        sourceIndex: re[m.FIELDS.START_POS]
      };
      if (G === 1 && !~[g.word].indexOf(J[0][m.FIELDS.TYPE]))
        return this.expected("attribute", J[0][m.FIELDS.START_POS]);
      for (var V = 0, F = "", X = "", K = null, ie = !1; V < G; ) {
        var fe = J[V], _e = this.content(fe), Ae = J[V + 1];
        switch (fe[m.FIELDS.TYPE]) {
          case g.space:
            if (ie = !0, this.options.lossy)
              break;
            if (K) {
              (0, v.ensureObject)(N, "spaces", K);
              var ce = N.spaces[K].after || "";
              N.spaces[K].after = ce + _e;
              var ee = (0, v.getProp)(N, "raws", "spaces", K, "after") || null;
              ee && (N.raws.spaces[K].after = ee + _e);
            } else
              F = F + _e, X = X + _e;
            break;
          case g.asterisk:
            if (Ae[m.FIELDS.TYPE] === g.equals)
              N.operator = _e, K = "operator";
            else if ((!N.namespace || K === "namespace" && !ie) && Ae) {
              F && ((0, v.ensureObject)(N, "spaces", "attribute"), N.spaces.attribute.before = F, F = ""), X && ((0, v.ensureObject)(N, "raws", "spaces", "attribute"), N.raws.spaces.attribute.before = F, X = ""), N.namespace = (N.namespace || "") + _e;
              var ae = (0, v.getProp)(N, "raws", "namespace") || null;
              ae && (N.raws.namespace += _e), K = "namespace";
            }
            ie = !1;
            break;
          case g.dollar:
            if (K === "value") {
              var oe = (0, v.getProp)(N, "raws", "value");
              N.value += "$", oe && (N.raws.value = oe + "$");
              break;
            }
          case g.caret:
            Ae[m.FIELDS.TYPE] === g.equals && (N.operator = _e, K = "operator"), ie = !1;
            break;
          case g.combinator:
            if (_e === "~" && Ae[m.FIELDS.TYPE] === g.equals && (N.operator = _e, K = "operator"), _e !== "|") {
              ie = !1;
              break;
            }
            Ae[m.FIELDS.TYPE] === g.equals ? (N.operator = _e, K = "operator") : !N.namespace && !N.attribute && (N.namespace = !0), ie = !1;
            break;
          case g.word:
            if (Ae && this.content(Ae) === "|" && J[V + 2] && J[V + 2][m.FIELDS.TYPE] !== g.equals && // this look-ahead probably fails with comment nodes involved.
            !N.operator && !N.namespace)
              N.namespace = _e, K = "namespace";
            else if (!N.attribute || K === "attribute" && !ie) {
              F && ((0, v.ensureObject)(N, "spaces", "attribute"), N.spaces.attribute.before = F, F = ""), X && ((0, v.ensureObject)(N, "raws", "spaces", "attribute"), N.raws.spaces.attribute.before = X, X = ""), N.attribute = (N.attribute || "") + _e;
              var me = (0, v.getProp)(N, "raws", "attribute") || null;
              me && (N.raws.attribute += _e), K = "attribute";
            } else if (!N.value && N.value !== "" || K === "value" && !(ie || N.quoteMark)) {
              var ye = (0, v.unesc)(_e), we = (0, v.getProp)(N, "raws", "value") || "", ge = N.value || "";
              N.value = ge + ye, N.quoteMark = null, (ye !== _e || we) && ((0, v.ensureObject)(N, "raws"), N.raws.value = (we || ge) + _e), K = "value";
            } else {
              var se = _e === "i" || _e === "I";
              (N.value || N.value === "") && (N.quoteMark || ie) ? (N.insensitive = se, (!se || _e === "I") && ((0, v.ensureObject)(N, "raws"), N.raws.insensitiveFlag = _e), K = "insensitive", F && ((0, v.ensureObject)(N, "spaces", "insensitive"), N.spaces.insensitive.before = F, F = ""), X && ((0, v.ensureObject)(N, "raws", "spaces", "insensitive"), N.raws.spaces.insensitive.before = X, X = "")) : (N.value || N.value === "") && (K = "value", N.value += _e, N.raws.value && (N.raws.value += _e));
            }
            ie = !1;
            break;
          case g.str:
            if (!N.attribute || !N.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: fe[m.FIELDS.START_POS]
              });
            var be = (0, c.unescapeValue)(_e), Ie = be.unescaped, Oe = be.quoteMark;
            N.value = Ie, N.quoteMark = Oe, K = "value", (0, v.ensureObject)(N, "raws"), N.raws.value = _e, ie = !1;
            break;
          case g.equals:
            if (!N.attribute)
              return this.expected("attribute", fe[m.FIELDS.START_POS], _e);
            if (N.value)
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: fe[m.FIELDS.START_POS]
              });
            N.operator = N.operator ? N.operator + _e : _e, K = "operator", ie = !1;
            break;
          case g.comment:
            if (K)
              if (ie || Ae && Ae[m.FIELDS.TYPE] === g.space || K === "insensitive") {
                var Be = (0, v.getProp)(N, "spaces", K, "after") || "", Fe = (0, v.getProp)(N, "raws", "spaces", K, "after") || Be;
                (0, v.ensureObject)(N, "raws", "spaces", K), N.raws.spaces[K].after = Fe + _e;
              } else {
                var ue = N[K] || "", te = (0, v.getProp)(N, "raws", K) || ue;
                (0, v.ensureObject)(N, "raws"), N.raws[K] = te + _e;
              }
            else
              X = X + _e;
            break;
          default:
            return this.error('Unexpected "' + _e + '" found.', {
              index: fe[m.FIELDS.START_POS]
            });
        }
        V++;
      }
      H(N, "attribute"), H(N, "namespace"), this.newNode(new c.default(N)), this.position++;
    }, B.parseWhitespaceEquivalentTokens = function(J) {
      J < 0 && (J = this.tokens.length);
      var re = this.position, G = [], N = "", V = void 0;
      do
        if (L[this.currToken[m.FIELDS.TYPE]])
          this.options.lossy || (N += this.content());
        else if (this.currToken[m.FIELDS.TYPE] === g.comment) {
          var F = {};
          N && (F.before = N, N = ""), V = new d.default({
            value: this.content(),
            source: C(this.currToken),
            sourceIndex: this.currToken[m.FIELDS.START_POS],
            spaces: F
          }), G.push(V);
        }
      while (++this.position < J);
      if (N) {
        if (V)
          V.spaces.after = N;
        else if (!this.options.lossy) {
          var X = this.tokens[re], K = this.tokens[this.position - 1];
          G.push(new u.default({
            value: "",
            source: S(X[m.FIELDS.START_LINE], X[m.FIELDS.START_COL], K[m.FIELDS.END_LINE], K[m.FIELDS.END_COL]),
            sourceIndex: X[m.FIELDS.START_POS],
            spaces: {
              before: N,
              after: ""
            }
          }));
        }
      }
      return G;
    }, B.convertWhitespaceNodesToSpace = function(J, re) {
      var G = this;
      re === void 0 && (re = !1);
      var N = "", V = "";
      J.forEach(function(X) {
        var K = G.lossySpace(X.spaces.before, re), ie = G.lossySpace(X.rawSpaceBefore, re);
        N += K + G.lossySpace(X.spaces.after, re && K.length === 0), V += K + X.value + G.lossySpace(X.rawSpaceAfter, re && ie.length === 0);
      }), V === N && (V = void 0);
      var F = {
        space: N,
        rawSpace: V
      };
      return F;
    }, B.isNamedCombinator = function(J) {
      return J === void 0 && (J = this.position), this.tokens[J + 0] && this.tokens[J + 0][m.FIELDS.TYPE] === g.slash && this.tokens[J + 1] && this.tokens[J + 1][m.FIELDS.TYPE] === g.word && this.tokens[J + 2] && this.tokens[J + 2][m.FIELDS.TYPE] === g.slash;
    }, B.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var J = this.content(this.tokens[this.position + 1]), re = (0, v.unesc)(J).toLowerCase(), G = {};
        re !== J && (G.value = "/" + J + "/");
        var N = new s.default({
          value: "/" + re + "/",
          source: S(this.currToken[m.FIELDS.START_LINE], this.currToken[m.FIELDS.START_COL], this.tokens[this.position + 2][m.FIELDS.END_LINE], this.tokens[this.position + 2][m.FIELDS.END_COL]),
          sourceIndex: this.currToken[m.FIELDS.START_POS],
          raws: G
        });
        return this.position = this.position + 3, N;
      } else
        this.unexpected();
    }, B.combinator = function() {
      var J = this;
      if (this.content() === "|")
        return this.namespace();
      var re = this.locateNextMeaningfulToken(this.position);
      if (re < 0 || this.tokens[re][m.FIELDS.TYPE] === g.comma) {
        var G = this.parseWhitespaceEquivalentTokens(re);
        if (G.length > 0) {
          var N = this.current.last;
          if (N) {
            var V = this.convertWhitespaceNodesToSpace(G), F = V.space, X = V.rawSpace;
            X !== void 0 && (N.rawSpaceAfter += X), N.spaces.after += F;
          } else
            G.forEach(function(we) {
              return J.newNode(we);
            });
        }
        return;
      }
      var K = this.currToken, ie = void 0;
      re > this.position && (ie = this.parseWhitespaceEquivalentTokens(re));
      var fe;
      if (this.isNamedCombinator() ? fe = this.namedCombinator() : this.currToken[m.FIELDS.TYPE] === g.combinator ? (fe = new s.default({
        value: this.content(),
        source: C(this.currToken),
        sourceIndex: this.currToken[m.FIELDS.START_POS]
      }), this.position++) : L[this.currToken[m.FIELDS.TYPE]] || ie || this.unexpected(), fe) {
        if (ie) {
          var _e = this.convertWhitespaceNodesToSpace(ie), Ae = _e.space, ce = _e.rawSpace;
          fe.spaces.before = Ae, fe.rawSpaceBefore = ce;
        }
      } else {
        var ee = this.convertWhitespaceNodesToSpace(ie, !0), ae = ee.space, oe = ee.rawSpace;
        oe || (oe = ae);
        var me = {}, ye = {
          spaces: {}
        };
        ae.endsWith(" ") && oe.endsWith(" ") ? (me.before = ae.slice(0, ae.length - 1), ye.spaces.before = oe.slice(0, oe.length - 1)) : ae.startsWith(" ") && oe.startsWith(" ") ? (me.after = ae.slice(1), ye.spaces.after = oe.slice(1)) : ye.value = oe, fe = new s.default({
          value: " ",
          source: R(K, this.tokens[this.position - 1]),
          sourceIndex: K[m.FIELDS.START_POS],
          spaces: me,
          raws: ye
        });
      }
      return this.currToken && this.currToken[m.FIELDS.TYPE] === g.space && (fe.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(fe);
    }, B.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var J = new a.default({
        source: {
          start: x(this.tokens[this.position + 1])
        },
        sourceIndex: this.tokens[this.position + 1][m.FIELDS.START_POS]
      });
      this.current.parent.append(J), this.current = J, this.position++;
    }, B.comment = function() {
      var J = this.currToken;
      this.newNode(new d.default({
        value: this.content(),
        source: C(J),
        sourceIndex: J[m.FIELDS.START_POS]
      })), this.position++;
    }, B.error = function(J, re) {
      throw this.root.error(J, re);
    }, B.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[m.FIELDS.START_POS]
      });
    }, B.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[m.FIELDS.START_POS]);
    }, B.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[m.FIELDS.START_POS]);
    }, B.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[m.FIELDS.START_POS]);
    }, B.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[m.FIELDS.START_POS]);
    }, B.namespace = function() {
      var J = this.prevToken && this.content(this.prevToken) || !0;
      if (this.nextToken[m.FIELDS.TYPE] === g.word)
        return this.position++, this.word(J);
      if (this.nextToken[m.FIELDS.TYPE] === g.asterisk)
        return this.position++, this.universal(J);
      this.unexpectedPipe();
    }, B.nesting = function() {
      if (this.nextToken) {
        var J = this.content(this.nextToken);
        if (J === "|") {
          this.position++;
          return;
        }
      }
      var re = this.currToken;
      this.newNode(new o.default({
        value: this.content(),
        source: C(re),
        sourceIndex: re[m.FIELDS.START_POS]
      })), this.position++;
    }, B.parentheses = function() {
      var J = this.current.last, re = 1;
      if (this.position++, J && J.type === b.PSEUDO) {
        var G = new a.default({
          source: {
            start: x(this.tokens[this.position])
          },
          sourceIndex: this.tokens[this.position][m.FIELDS.START_POS]
        }), N = this.current;
        for (J.append(G), this.current = G; this.position < this.tokens.length && re; )
          this.currToken[m.FIELDS.TYPE] === g.openParenthesis && re++, this.currToken[m.FIELDS.TYPE] === g.closeParenthesis && re--, re ? this.parse() : (this.current.source.end = _(this.currToken), this.current.parent.source.end = _(this.currToken), this.position++);
        this.current = N;
      } else {
        for (var V = this.currToken, F = "(", X; this.position < this.tokens.length && re; )
          this.currToken[m.FIELDS.TYPE] === g.openParenthesis && re++, this.currToken[m.FIELDS.TYPE] === g.closeParenthesis && re--, X = this.currToken, F += this.parseParenthesisToken(this.currToken), this.position++;
        J ? J.appendToPropertyAndEscape("value", F, F) : this.newNode(new u.default({
          value: F,
          source: S(V[m.FIELDS.START_LINE], V[m.FIELDS.START_COL], X[m.FIELDS.END_LINE], X[m.FIELDS.END_COL]),
          sourceIndex: V[m.FIELDS.START_POS]
        }));
      }
      if (re)
        return this.expected("closing parenthesis", this.currToken[m.FIELDS.START_POS]);
    }, B.pseudo = function() {
      for (var J = this, re = "", G = this.currToken; this.currToken && this.currToken[m.FIELDS.TYPE] === g.colon; )
        re += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[m.FIELDS.TYPE] === g.word)
        this.splitWord(!1, function(N, V) {
          re += N, J.newNode(new i.default({
            value: re,
            source: R(G, J.currToken),
            sourceIndex: G[m.FIELDS.START_POS]
          })), V > 1 && J.nextToken && J.nextToken[m.FIELDS.TYPE] === g.openParenthesis && J.error("Misplaced parenthesis.", {
            index: J.nextToken[m.FIELDS.START_POS]
          });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[m.FIELDS.START_POS]);
    }, B.space = function() {
      var J = this.content();
      this.position === 0 || this.prevToken[m.FIELDS.TYPE] === g.comma || this.prevToken[m.FIELDS.TYPE] === g.openParenthesis || this.current.nodes.every(function(re) {
        return re.type === "comment";
      }) ? (this.spaces = this.optionalSpace(J), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[m.FIELDS.TYPE] === g.comma || this.nextToken[m.FIELDS.TYPE] === g.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(J), this.position++) : this.combinator();
    }, B.string = function() {
      var J = this.currToken;
      this.newNode(new u.default({
        value: this.content(),
        source: C(J),
        sourceIndex: J[m.FIELDS.START_POS]
      })), this.position++;
    }, B.universal = function(J) {
      var re = this.nextToken;
      if (re && this.content(re) === "|")
        return this.position++, this.namespace();
      var G = this.currToken;
      this.newNode(new f.default({
        value: this.content(),
        source: C(G),
        sourceIndex: G[m.FIELDS.START_POS]
      }), J), this.position++;
    }, B.splitWord = function(J, re) {
      for (var G = this, N = this.nextToken, V = this.content(); N && ~[g.dollar, g.caret, g.equals, g.word].indexOf(N[m.FIELDS.TYPE]); ) {
        this.position++;
        var F = this.content();
        if (V += F, F.lastIndexOf("\\") === F.length - 1) {
          var X = this.nextToken;
          X && X[m.FIELDS.TYPE] === g.space && (V += this.requiredSpace(this.content(X)), this.position++);
        }
        N = this.nextToken;
      }
      var K = z(V, ".").filter(function(Ae) {
        var ce = V[Ae - 1] === "\\", ee = /^\d+\.\d+%$/.test(V);
        return !ce && !ee;
      }), ie = z(V, "#").filter(function(Ae) {
        return V[Ae - 1] !== "\\";
      }), fe = z(V, "#{");
      fe.length && (ie = ie.filter(function(Ae) {
        return !~fe.indexOf(Ae);
      }));
      var _e = (0, y.default)(U([0].concat(K, ie)));
      _e.forEach(function(Ae, ce) {
        var ee = _e[ce + 1] || V.length, ae = V.slice(Ae, ee);
        if (ce === 0 && re)
          return re.call(G, ae, _e.length);
        var oe, me = G.currToken, ye = me[m.FIELDS.START_POS] + _e[ce], we = S(me[1], me[2] + Ae, me[3], me[2] + (ee - 1));
        if (~K.indexOf(Ae)) {
          var ge = {
            value: ae.slice(1),
            source: we,
            sourceIndex: ye
          };
          oe = new l.default(H(ge, "value"));
        } else if (~ie.indexOf(Ae)) {
          var se = {
            value: ae.slice(1),
            source: we,
            sourceIndex: ye
          };
          oe = new h.default(H(se, "value"));
        } else {
          var be = {
            value: ae,
            source: we,
            sourceIndex: ye
          };
          H(be, "value"), oe = new n.default(be);
        }
        G.newNode(oe, J), J = null;
      }), this.position++;
    }, B.word = function(J) {
      var re = this.nextToken;
      return re && this.content(re) === "|" ? (this.position++, this.namespace()) : this.splitWord(J);
    }, B.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.current._inferEndPosition(), this.root;
    }, B.parse = function(J) {
      switch (this.currToken[m.FIELDS.TYPE]) {
        case g.space:
          this.space();
          break;
        case g.comment:
          this.comment();
          break;
        case g.openParenthesis:
          this.parentheses();
          break;
        case g.closeParenthesis:
          J && this.missingParenthesis();
          break;
        case g.openSquare:
          this.attribute();
          break;
        case g.dollar:
        case g.caret:
        case g.equals:
        case g.word:
          this.word();
          break;
        case g.colon:
          this.pseudo();
          break;
        case g.comma:
          this.comma();
          break;
        case g.asterisk:
          this.universal();
          break;
        case g.ampersand:
          this.nesting();
          break;
        case g.slash:
        case g.combinator:
          this.combinator();
          break;
        case g.str:
          this.string();
          break;
        case g.closeSquare:
          this.missingSquareBracket();
        case g.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, B.expected = function(J, re, G) {
      if (Array.isArray(J)) {
        var N = J.pop();
        J = J.join(", ") + " or " + N;
      }
      var V = /^[aeiou]/.test(J[0]) ? "an" : "a";
      return G ? this.error("Expected " + V + " " + J + ', found "' + G + '" instead.', {
        index: re
      }) : this.error("Expected " + V + " " + J + ".", {
        index: re
      });
    }, B.requiredSpace = function(J) {
      return this.options.lossy ? " " : J;
    }, B.optionalSpace = function(J) {
      return this.options.lossy ? "" : J;
    }, B.lossySpace = function(J, re) {
      return this.options.lossy ? re ? " " : "" : J;
    }, B.parseParenthesisToken = function(J) {
      var re = this.content(J);
      return J[m.FIELDS.TYPE] === g.space ? this.requiredSpace(re) : re;
    }, B.newNode = function(J, re) {
      return re && (/^ +$/.test(re) && (this.options.lossy || (this.spaces = (this.spaces || "") + re), re = !0), J.namespace = re, H(J, "namespace")), this.spaces && (J.spaces.before = this.spaces, this.spaces = ""), this.current.append(J);
    }, B.content = function(J) {
      return J === void 0 && (J = this.currToken), this.css.slice(J[m.FIELDS.START_POS], J[m.FIELDS.END_POS]);
    }, B.locateNextMeaningfulToken = function(J) {
      J === void 0 && (J = this.position + 1);
      for (var re = J; re < this.tokens.length; )
        if (M[this.tokens[re][m.FIELDS.TYPE]]) {
          re++;
          continue;
        } else
          return re;
      return -1;
    }, k(W, [{
      key: "currToken",
      get: function() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function() {
        return this.tokens[this.position - 1];
      }
    }]), W;
  }();
  e.default = P, t.exports = e.default;
})(n1, n1.exports);
var xM = n1.exports;
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = a(xM);
  function a(d) {
    return d && d.__esModule ? d : { default: d };
  }
  var l = /* @__PURE__ */ function() {
    function d(n, u) {
      this.func = n || function() {
      }, this.funcRes = null, this.options = u;
    }
    var h = d.prototype;
    return h._shouldUpdateSelector = function(u, i) {
      i === void 0 && (i = {});
      var c = Object.assign({}, this.options, i);
      return c.updateSelector === !1 ? !1 : typeof u != "string";
    }, h._isLossy = function(u) {
      u === void 0 && (u = {});
      var i = Object.assign({}, this.options, u);
      return i.lossless === !1;
    }, h._root = function(u, i) {
      i === void 0 && (i = {});
      var c = new r.default(u, this._parseOptions(i));
      return c.root;
    }, h._parseOptions = function(u) {
      return {
        lossy: this._isLossy(u)
      };
    }, h._run = function(u, i) {
      var c = this;
      return i === void 0 && (i = {}), new Promise(function(f, s) {
        try {
          var o = c._root(u, i);
          Promise.resolve(c.func(o)).then(function(y) {
            var m = void 0;
            return c._shouldUpdateSelector(u, i) && (m = o.toString(), u.selector = m), {
              transform: y,
              root: o,
              string: m
            };
          }).then(f, s);
        } catch (y) {
          s(y);
          return;
        }
      });
    }, h._runSync = function(u, i) {
      i === void 0 && (i = {});
      var c = this._root(u, i), f = this.func(c);
      if (f && typeof f.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var s = void 0;
      return i.updateSelector && typeof u != "string" && (s = c.toString(), u.selector = s), {
        transform: f,
        root: c,
        string: s
      };
    }, h.ast = function(u, i) {
      return this._run(u, i).then(function(c) {
        return c.root;
      });
    }, h.astSync = function(u, i) {
      return this._runSync(u, i).root;
    }, h.transform = function(u, i) {
      return this._run(u, i).then(function(c) {
        return c.transform;
      });
    }, h.transformSync = function(u, i) {
      return this._runSync(u, i).transform;
    }, h.process = function(u, i) {
      return this._run(u, i).then(function(c) {
        return c.string || c.root.toString();
      });
    }, h.processSync = function(u, i) {
      var c = this._runSync(u, i);
      return c.string || c.root.toString();
    }, d;
  }();
  e.default = l, t.exports = e.default;
})(r1, r1.exports);
var TM = r1.exports, uA = {}, Br = {};
Br.__esModule = !0;
Br.universal = Br.tag = Br.string = Br.selector = Br.root = Br.pseudo = Br.nesting = Br.id = Br.comment = Br.combinator = Br.className = Br.attribute = void 0;
var AM = Wi(ab), PM = Wi(QT), CM = Wi(sA), IM = Wi(ZT), OM = Wi(eA), kM = Wi(aA), DM = Wi(nA), NM = Wi(XT), RM = Wi(JT), MM = Wi(rA), LM = Wi(tA), jM = Wi(iA);
function Wi(t) {
  return t && t.__esModule ? t : { default: t };
}
var FM = function(e) {
  return new AM.default(e);
};
Br.attribute = FM;
var BM = function(e) {
  return new PM.default(e);
};
Br.className = BM;
var $M = function(e) {
  return new CM.default(e);
};
Br.combinator = $M;
var UM = function(e) {
  return new IM.default(e);
};
Br.comment = UM;
var VM = function(e) {
  return new OM.default(e);
};
Br.id = VM;
var WM = function(e) {
  return new kM.default(e);
};
Br.nesting = WM;
var qM = function(e) {
  return new DM.default(e);
};
Br.pseudo = qM;
var HM = function(e) {
  return new NM.default(e);
};
Br.root = HM;
var GM = function(e) {
  return new RM.default(e);
};
Br.selector = GM;
var zM = function(e) {
  return new MM.default(e);
};
Br.string = zM;
var KM = function(e) {
  return new LM.default(e);
};
Br.tag = KM;
var YM = function(e) {
  return new jM.default(e);
};
Br.universal = YM;
var Tr = {};
Tr.__esModule = !0;
Tr.isComment = Tr.isCombinator = Tr.isClassName = Tr.isAttribute = void 0;
Tr.isContainer = o9;
Tr.isIdentifier = void 0;
Tr.isNamespace = l9;
Tr.isNesting = void 0;
Tr.isNode = lb;
Tr.isPseudo = void 0;
Tr.isPseudoClass = a9;
Tr.isPseudoElement = dA;
Tr.isUniversal = Tr.isTag = Tr.isString = Tr.isSelector = Tr.isRoot = void 0;
var zr = lr, ci, XM = (ci = {}, ci[zr.ATTRIBUTE] = !0, ci[zr.CLASS] = !0, ci[zr.COMBINATOR] = !0, ci[zr.COMMENT] = !0, ci[zr.ID] = !0, ci[zr.NESTING] = !0, ci[zr.PSEUDO] = !0, ci[zr.ROOT] = !0, ci[zr.SELECTOR] = !0, ci[zr.STRING] = !0, ci[zr.TAG] = !0, ci[zr.UNIVERSAL] = !0, ci);
function lb(t) {
  return typeof t == "object" && XM[t.type];
}
function qi(t, e) {
  return lb(e) && e.type === t;
}
var cA = qi.bind(null, zr.ATTRIBUTE);
Tr.isAttribute = cA;
var JM = qi.bind(null, zr.CLASS);
Tr.isClassName = JM;
var QM = qi.bind(null, zr.COMBINATOR);
Tr.isCombinator = QM;
var ZM = qi.bind(null, zr.COMMENT);
Tr.isComment = ZM;
var e9 = qi.bind(null, zr.ID);
Tr.isIdentifier = e9;
var t9 = qi.bind(null, zr.NESTING);
Tr.isNesting = t9;
var ub = qi.bind(null, zr.PSEUDO);
Tr.isPseudo = ub;
var r9 = qi.bind(null, zr.ROOT);
Tr.isRoot = r9;
var n9 = qi.bind(null, zr.SELECTOR);
Tr.isSelector = n9;
var i9 = qi.bind(null, zr.STRING);
Tr.isString = i9;
var fA = qi.bind(null, zr.TAG);
Tr.isTag = fA;
var s9 = qi.bind(null, zr.UNIVERSAL);
Tr.isUniversal = s9;
function dA(t) {
  return ub(t) && t.value && (t.value.startsWith("::") || t.value.toLowerCase() === ":before" || t.value.toLowerCase() === ":after" || t.value.toLowerCase() === ":first-letter" || t.value.toLowerCase() === ":first-line");
}
function a9(t) {
  return ub(t) && !dA(t);
}
function o9(t) {
  return !!(lb(t) && t.walk);
}
function l9(t) {
  return cA(t) || fA(t);
}
(function(t) {
  t.__esModule = !0;
  var e = lr;
  Object.keys(e).forEach(function(l) {
    l === "default" || l === "__esModule" || l in t && t[l] === e[l] || (t[l] = e[l]);
  });
  var r = Br;
  Object.keys(r).forEach(function(l) {
    l === "default" || l === "__esModule" || l in t && t[l] === r[l] || (t[l] = r[l]);
  });
  var a = Tr;
  Object.keys(a).forEach(function(l) {
    l === "default" || l === "__esModule" || l in t && t[l] === a[l] || (t[l] = a[l]);
  });
})(uA);
(function(t, e) {
  e.__esModule = !0, e.default = void 0;
  var r = h(TM), a = d(uA);
  function l(i) {
    if (typeof WeakMap != "function") return null;
    var c = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
    return (l = function(o) {
      return o ? f : c;
    })(i);
  }
  function d(i, c) {
    if (i && i.__esModule)
      return i;
    if (i === null || typeof i != "object" && typeof i != "function")
      return { default: i };
    var f = l(c);
    if (f && f.has(i))
      return f.get(i);
    var s = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var y in i)
      if (y !== "default" && Object.prototype.hasOwnProperty.call(i, y)) {
        var m = o ? Object.getOwnPropertyDescriptor(i, y) : null;
        m && (m.get || m.set) ? Object.defineProperty(s, y, m) : s[y] = i[y];
      }
    return s.default = i, f && f.set(i, s), s;
  }
  function h(i) {
    return i && i.__esModule ? i : { default: i };
  }
  var n = function(c) {
    return new r.default(c);
  };
  Object.assign(n, a), delete n.__esModule;
  var u = n;
  e.default = u, t.exports = e.default;
})(t1, t1.exports);
var ua = t1.exports, Qu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(Vi), r = /* @__PURE__ */ a(Al);
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l(d) {
    return [
      "fontSize",
      "outline"
    ].includes(d) ? (h) => (typeof h == "function" && (h = h({})), Array.isArray(h) && (h = h[0]), h) : d === "fontFamily" ? (h) => {
      typeof h == "function" && (h = h({}));
      let n = Array.isArray(h) && (0, r.default)(h[1]) ? h[0] : h;
      return Array.isArray(n) ? n.join(", ") : n;
    } : [
      "boxShadow",
      "transitionProperty",
      "transitionDuration",
      "transitionDelay",
      "transitionTimingFunction",
      "backgroundImage",
      "backgroundSize",
      "backgroundColor",
      "cursor",
      "animation"
    ].includes(d) ? (h) => (typeof h == "function" && (h = h({})), Array.isArray(h) && (h = h.join(", ")), h) : [
      "gridTemplateColumns",
      "gridTemplateRows",
      "objectPosition"
    ].includes(d) ? (h) => (typeof h == "function" && (h = h({})), typeof h == "string" && (h = e.default.list.comma(h).join(" ")), h) : (h, n = {}) => (typeof h == "function" && (h = h(n)), h);
  }
})(Qu);
var cb = {}, fb = { exports: {} };
const { Rule: pA, AtRule: u9 } = Vi;
let hA = ua;
function w1(t, e) {
  let r;
  try {
    hA((a) => {
      r = a;
    }).processSync(t);
  } catch (a) {
    throw t.includes(":") ? e ? e.error("Missed semicolon") : a : e ? e.error(a.message) : a;
  }
  return r.at(0);
}
function mA(t, e) {
  let r = !1;
  return t.each((a) => {
    if (a.type === "nesting") {
      let l = e.clone({});
      a.value !== "&" ? a.replaceWith(
        w1(a.value.replace("&", l.toString()))
      ) : a.replaceWith(l), r = !0;
    } else "nodes" in a && a.nodes && mA(a, e) && (r = !0);
  }), r;
}
function yA(t, e) {
  let r = [];
  return t.selectors.forEach((a) => {
    let l = w1(a, t);
    e.selectors.forEach((d) => {
      if (!d)
        return;
      let h = w1(d, e);
      mA(h, l) || (h.prepend(hA.combinator({ value: " " })), h.prepend(l.clone({}))), r.push(h.toString());
    });
  }), r;
}
function Gc(t, e) {
  let r = t.prev();
  for (e.after(t); r && r.type === "comment"; ) {
    let a = r.prev();
    e.after(r), r = a;
  }
  return t;
}
function c9(t) {
  return function e(r, a, l, d = l) {
    let h = [];
    if (a.each((n) => {
      n.type === "rule" && l ? d && (n.selectors = yA(r, n)) : n.type === "atrule" && n.nodes ? t[n.name] ? e(r, n, d) : a[db] !== !1 && h.push(n) : h.push(n);
    }), l && h.length) {
      let n = r.clone({ nodes: [] });
      for (let u of h)
        n.append(u);
      a.prepend(n);
    }
  };
}
function Kh(t, e, r) {
  let a = new pA({
    selector: t,
    nodes: []
  });
  return a.append(e), r.after(a), a;
}
function e_(t, e) {
  let r = {};
  for (let a of t)
    r[a] = !0;
  if (e)
    for (let a of e)
      r[a.replace(/^@/, "")] = !0;
  return r;
}
function f9(t) {
  t = t.trim();
  let e = t.match(/^\((.*)\)$/);
  if (!e)
    return { type: "basic", selector: t };
  let r = e[1].match(/^(with(?:out)?):(.+)$/);
  if (r) {
    let a = r[1] === "with", l = Object.fromEntries(
      r[2].trim().split(/\s+/).map((h) => [h, !0])
    );
    if (a && l.all)
      return { type: "noop" };
    let d = (h) => !!l[h];
    return l.all ? d = () => !0 : a && (d = (h) => h === "all" ? !1 : !l[h]), {
      type: "withrules",
      escapes: d
    };
  }
  return { type: "unknown" };
}
function d9(t) {
  let e = [], r = t.parent;
  for (; r && r instanceof u9; )
    e.push(r), r = r.parent;
  return e;
}
function p9(t) {
  let e = t[bA];
  if (!e)
    t.after(t.nodes);
  else {
    let r = t.nodes, a, l = -1, d, h, n, u = d9(t);
    if (u.forEach((i, c) => {
      if (e(i.name))
        a = i, l = c, h = n;
      else {
        let f = n;
        n = i.clone({ nodes: [] }), f && n.append(f), d = d || n;
      }
    }), a ? h ? (d.append(r), a.after(h)) : a.after(r) : t.after(r), t.next() && a) {
      let i;
      u.slice(0, l + 1).forEach((c, f, s) => {
        let o = i;
        i = c.clone({ nodes: [] }), o && i.append(o);
        let y = [], g = (s[f - 1] || t).next();
        for (; g; )
          y.push(g), g = g.next();
        i.append(y);
      }), i && (h || r[r.length - 1]).after(i);
    }
  }
  t.remove();
}
const db = Symbol("rootRuleMergeSel"), bA = Symbol("rootRuleEscapes");
function h9(t) {
  let { params: e } = t, { type: r, selector: a, escapes: l } = f9(e);
  if (r === "unknown")
    throw t.error(
      `Unknown @${t.name} parameter ${JSON.stringify(e)}`
    );
  if (r === "basic" && a) {
    let d = new pA({ selector: a, nodes: t.nodes });
    t.removeAll(), t.append(d);
  }
  t[bA] = l, t[db] = l ? !l("all") : r === "noop";
}
const Yh = Symbol("hasRootRule");
fb.exports = (t = {}) => {
  let e = e_(
    ["media", "supports", "layer", "container"],
    t.bubble
  ), r = c9(e), a = e_(
    [
      "document",
      "font-face",
      "keyframes",
      "-webkit-keyframes",
      "-moz-keyframes"
    ],
    t.unwrap
  ), l = (t.rootRuleName || "at-root").replace(/^@/, ""), d = t.preserveEmpty;
  return {
    postcssPlugin: "postcss-nested",
    Once(h) {
      h.walkAtRules(l, (n) => {
        h9(n), h[Yh] = !0;
      });
    },
    Rule(h) {
      let n = !1, u = h, i = !1, c = [];
      h.each((f) => {
        f.type === "rule" ? (c.length && (u = Kh(h.selector, c, u), c = []), i = !0, n = !0, f.selectors = yA(h, f), u = Gc(f, u)) : f.type === "atrule" ? (c.length && (u = Kh(h.selector, c, u), c = []), f.name === l ? (n = !0, r(h, f, !0, f[db]), u = Gc(f, u)) : e[f.name] ? (i = !0, n = !0, r(h, f, !0), u = Gc(f, u)) : a[f.name] ? (i = !0, n = !0, r(h, f, !1), u = Gc(f, u)) : i && c.push(f)) : f.type === "decl" && i && c.push(f);
      }), c.length && (u = Kh(h.selector, c, u)), n && d !== !0 && (h.raws.semicolon = !0, h.nodes.length === 0 && h.remove());
    },
    RootExit(h) {
      h[Yh] && (h.walkAtRules(l, p9), h[Yh] = !1);
    }
  };
};
fb.exports.postcss = !0;
var m9 = fb.exports, t_ = /-(\w|$)/g, r_ = function(e, r) {
  return r.toUpperCase();
}, y9 = function(e) {
  return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(t_, r_) : e.replace(t_, r_);
}, b9 = y9;
let g9 = b9, v9 = {
  boxFlex: !0,
  boxFlexGroup: !0,
  columnCount: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  strokeDashoffset: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
function Xh(t) {
  return typeof t.nodes > "u" ? !0 : pb(t);
}
function pb(t) {
  let e, r = {};
  return t.each((a) => {
    if (a.type === "atrule")
      e = "@" + a.name, a.params && (e += " " + a.params), typeof r[e] > "u" ? r[e] = Xh(a) : Array.isArray(r[e]) ? r[e].push(Xh(a)) : r[e] = [r[e], Xh(a)];
    else if (a.type === "rule") {
      let l = pb(a);
      if (r[a.selector])
        for (let d in l)
          r[a.selector][d] = l[d];
      else
        r[a.selector] = l;
    } else if (a.type === "decl") {
      a.prop[0] === "-" && a.prop[1] === "-" || a.parent && a.parent.selector === ":export" ? e = a.prop : e = g9(a.prop);
      let l = a.value;
      !isNaN(a.value) && v9[e] && (l = parseFloat(a.value)), a.important && (l += " !important"), typeof r[e] > "u" ? r[e] = l : Array.isArray(r[e]) ? r[e].push(l) : r[e] = [r[e], l];
    }
  }), r;
}
var gA = pb;
let Cu = Vi, n_ = /\s*!important\s*$/i, E9 = {
  "box-flex": !0,
  "box-flex-group": !0,
  "column-count": !0,
  flex: !0,
  "flex-grow": !0,
  "flex-positive": !0,
  "flex-shrink": !0,
  "flex-negative": !0,
  "font-weight": !0,
  "line-clamp": !0,
  "line-height": !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  "tab-size": !0,
  widows: !0,
  "z-index": !0,
  zoom: !0,
  "fill-opacity": !0,
  "stroke-dashoffset": !0,
  "stroke-opacity": !0,
  "stroke-width": !0
};
function _9(t) {
  return t.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function i_(t, e, r) {
  r === !1 || r === null || (e.startsWith("--") || (e = _9(e)), typeof r == "number" && (r === 0 || E9[e] ? r = r.toString() : r += "px"), e === "css-float" && (e = "float"), n_.test(r) ? (r = r.replace(n_, ""), t.push(Cu.decl({ prop: e, value: r, important: !0 }))) : t.push(Cu.decl({ prop: e, value: r })));
}
function s_(t, e, r) {
  let a = Cu.atRule({ name: e[1], params: e[3] || "" });
  typeof r == "object" && (a.nodes = [], hb(r, a)), t.push(a);
}
function hb(t, e) {
  let r, a, l;
  for (r in t)
    if (a = t[r], !(a === null || typeof a > "u"))
      if (r[0] === "@") {
        let d = r.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
        if (Array.isArray(a))
          for (let h of a)
            s_(e, d, h);
        else
          s_(e, d, a);
      } else if (Array.isArray(a))
        for (let d of a)
          i_(e, r, d);
      else typeof a == "object" ? (l = Cu.rule({ selector: r }), hb(a, l), e.push(l)) : i_(e, r, a);
}
var mb = function(t) {
  let e = Cu.root();
  return hb(t, e), e;
};
let S9 = gA;
var vA = function(e) {
  return console && console.warn && e.warnings().forEach((r) => {
    let a = r.plugin || "PostCSS";
    console.warn(a + ": " + r.text);
  }), S9(e.root);
};
let w9 = Vi, x9 = vA, T9 = mb;
var A9 = function(e) {
  let r = w9(e);
  return async (a) => {
    let l = await r.process(a, {
      parser: T9,
      from: void 0
    });
    return x9(l);
  };
};
let P9 = Vi, C9 = vA, I9 = mb;
var O9 = function(t) {
  let e = P9(t);
  return (r) => {
    let a = e.process(r, { parser: I9, from: void 0 });
    return C9(a);
  };
};
let k9 = gA, D9 = mb, N9 = A9, R9 = O9;
var M9 = {
  objectify: k9,
  parse: D9,
  async: N9,
  sync: R9
};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return d;
    }
  });
  const e = /* @__PURE__ */ l(Vi), r = /* @__PURE__ */ l(m9), a = /* @__PURE__ */ l(M9);
  function l(h) {
    return h && h.__esModule ? h : {
      default: h
    };
  }
  function d(h) {
    return Array.isArray(h) ? h.flatMap((n) => (0, e.default)([
      (0, r.default)({
        bubble: [
          "screen"
        ]
      })
    ]).process(n, {
      parser: a.default
    }).root.nodes) : d([
      h
    ]);
  }
})(cb);
var Gd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(
    t,
    /**
    * @template {string | import('postcss-selector-parser').Root} T
    *
    * Prefix all classes in the selector with the given prefix
    *
    * It can take either a string or a selector AST and will return the same type
    *
    * @param {string} prefix
    * @param {T} selector
    * @param {boolean} prependNegative
    * @returns {T}
    */
    "default",
    {
      enumerable: !0,
      get: function() {
        return a;
      }
    }
  );
  const e = /* @__PURE__ */ r(ua);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function a(l, d, h = !1) {
    if (l === "")
      return d;
    let n = typeof d == "string" ? (0, e.default)().astSync(d) : d;
    return n.walkClasses((u) => {
      let i = u.value, c = h && i.startsWith("-");
      u.value = c ? `-${l}${i.slice(1)}` : `${l}${i}`;
    }), typeof d == "string" ? n.toString() : n;
  }
})(Gd);
var Pl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(ua), r = /* @__PURE__ */ a(Bd);
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l(d) {
    var h;
    let n = e.default.className();
    n.value = d;
    var u;
    return (0, r.default)((u = n == null || (h = n.raws) === null || h === void 0 ? void 0 : h.value) !== null && u !== void 0 ? u : n.value);
  }
})(Pl);
var yb = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(u, i) {
    for (var c in i) Object.defineProperty(u, c, {
      enumerable: !0,
      get: i[c]
    });
  }
  e(t, {
    asClass: function() {
      return d;
    },
    default: function() {
      return h;
    },
    formatClass: function() {
      return n;
    }
  });
  const r = /* @__PURE__ */ l(Pl), a = /* @__PURE__ */ l(Bd);
  function l(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function d(u) {
    return (0, a.default)(`.${(0, r.default)(u)}`);
  }
  function h(u, i) {
    return d(n(u, i));
  }
  function n(u, i) {
    return i === "DEFAULT" ? u : i === "-" || i === "-DEFAULT" ? `-${u}` : i.startsWith("-") ? `-${u}${i}` : i.startsWith("/") ? `${u}${i}` : `${u}-${i}`;
  }
})(yb);
var EA = {}, _A = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ r(Qu);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function a(l, d = [
    [
      l,
      [
        l
      ]
    ]
  ], { filterDefault: h = !1, ...n } = {}) {
    let u = (0, e.default)(l);
    return function({ matchUtilities: i, theme: c }) {
      for (let s of d) {
        let o = Array.isArray(s[0]) ? s : [
          s
        ];
        var f;
        i(o.reduce((y, [m, g]) => Object.assign(y, {
          [m]: (b) => g.reduce((v, T) => Array.isArray(T) ? Object.assign(v, {
            [T[0]]: T[1]
          }) : Object.assign(v, {
            [T]: u(b)
          }), {})
        }), {}), {
          ...n,
          values: h ? Object.fromEntries(Object.entries((f = c(l)) !== null && f !== void 0 ? f : {}).filter(([y]) => y !== "DEFAULT")) : c(l)
        });
      }
    };
  }
})(_A);
var zd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    return r = Array.isArray(r) ? r : [
      r
    ], r.map((a) => {
      let l = a.values.map((d) => d.raw !== void 0 ? d.raw : [
        d.min && `(min-width: ${d.min})`,
        d.max && `(max-width: ${d.max})`
      ].filter(Boolean).join(" and "));
      return a.not ? `not all and ${l}` : l;
    }).join(", ");
  }
})(zd);
var SA = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return f;
    }
  });
  const e = /* @__PURE__ */ new Set([
    "normal",
    "reverse",
    "alternate",
    "alternate-reverse"
  ]), r = /* @__PURE__ */ new Set([
    "running",
    "paused"
  ]), a = /* @__PURE__ */ new Set([
    "none",
    "forwards",
    "backwards",
    "both"
  ]), l = /* @__PURE__ */ new Set([
    "infinite"
  ]), d = /* @__PURE__ */ new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
  ]), h = [
    "cubic-bezier",
    "steps"
  ], n = /\,(?![^(]*\))/g, u = /\ +(?![^(]*\))/g, i = /^(-?[\d.]+m?s)$/, c = /^(\d+)$/;
  function f(s) {
    return s.split(n).map((y) => {
      let m = y.trim(), g = {
        value: m
      }, b = m.split(u), v = /* @__PURE__ */ new Set();
      for (let T of b)
        !v.has("DIRECTIONS") && e.has(T) ? (g.direction = T, v.add("DIRECTIONS")) : !v.has("PLAY_STATES") && r.has(T) ? (g.playState = T, v.add("PLAY_STATES")) : !v.has("FILL_MODES") && a.has(T) ? (g.fillMode = T, v.add("FILL_MODES")) : !v.has("ITERATION_COUNTS") && (l.has(T) || c.test(T)) ? (g.iterationCount = T, v.add("ITERATION_COUNTS")) : !v.has("TIMING_FUNCTION") && d.has(T) || !v.has("TIMING_FUNCTION") && h.some((E) => T.startsWith(`${E}(`)) ? (g.timingFunction = T, v.add("TIMING_FUNCTION")) : !v.has("DURATION") && i.test(T) ? (g.duration = T, v.add("DURATION")) : !v.has("DELAY") && i.test(T) ? (g.delay = T, v.add("DELAY")) : v.has("NAME") ? (g.unknown || (g.unknown = []), g.unknown.push(T)) : (g.name = T, v.add("NAME"));
      return g;
    });
  }
})(SA);
var wA = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  const e = (a) => Object.assign({}, ...Object.entries(a ?? {}).flatMap(([l, d]) => typeof d == "object" ? Object.entries(e(d)).map(([h, n]) => ({
    [l + (h === "DEFAULT" ? "" : `-${h}`)]: n
  })) : [
    {
      [`${l}`]: d
    }
  ])), r = e;
})(wA);
const L9 = "tailwindcss", j9 = "3.3.2", F9 = "A utility-first CSS framework for rapidly building custom user interfaces.", B9 = "MIT", $9 = "lib/index.js", U9 = "types/index.d.ts", V9 = "https://github.com/tailwindlabs/tailwindcss.git", W9 = "https://github.com/tailwindlabs/tailwindcss/issues", q9 = "https://tailwindcss.com", H9 = {
  tailwind: "lib/cli.js",
  tailwindcss: "lib/cli.js"
}, G9 = {
  engine: "stable"
}, z9 = {
  prebuild: "npm run generate && rimraf lib",
  build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`,
  postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
  "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
  style: "eslint .",
  pretest: "npm run generate",
  test: "jest",
  "test:integrations": "npm run test --prefix ./integrations",
  "install:integrations": "node scripts/install-integrations.js",
  "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
  "generate:types": "node -r @swc/register scripts/generate-types.js",
  generate: "npm run generate:plugin-list && npm run generate:types",
  "release-channel": "node ./scripts/release-channel.js",
  "release-notes": "node ./scripts/release-notes.js",
  prepublishOnly: "npm install --force && npm run build"
}, K9 = [
  "src/*",
  "cli/*",
  "lib/*",
  "peers/*",
  "scripts/*.js",
  "stubs/*",
  "nesting/*",
  "types/**/*",
  "*.d.ts",
  "*.css",
  "*.js"
], Y9 = {
  "@swc/cli": "^0.1.62",
  "@swc/core": "^1.3.55",
  "@swc/jest": "^0.2.26",
  "@swc/register": "^0.1.10",
  autoprefixer: "^10.4.14",
  browserslist: "^4.21.5",
  concurrently: "^8.0.1",
  cssnano: "^6.0.0",
  esbuild: "^0.17.18",
  eslint: "^8.39.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-prettier": "^4.2.1",
  jest: "^29.5.0",
  "jest-diff": "^29.5.0",
  lightningcss: "1.18.0",
  prettier: "^2.8.8",
  rimraf: "^5.0.0",
  "source-map-js": "^1.0.2",
  turbo: "^1.9.3"
}, X9 = {
  "@alloc/quick-lru": "^5.2.0",
  arg: "^5.0.2",
  chokidar: "^3.5.3",
  didyoumean: "^1.2.2",
  dlv: "^1.1.3",
  "fast-glob": "^3.2.12",
  "glob-parent": "^6.0.2",
  "is-glob": "^4.0.3",
  jiti: "^1.18.2",
  lilconfig: "^2.1.0",
  micromatch: "^4.0.5",
  "normalize-path": "^3.0.0",
  "object-hash": "^3.0.0",
  picocolors: "^1.0.0",
  postcss: "^8.4.23",
  "postcss-import": "^15.1.0",
  "postcss-js": "^4.0.1",
  "postcss-load-config": "^4.0.1",
  "postcss-nested": "^6.0.1",
  "postcss-selector-parser": "^6.0.11",
  "postcss-value-parser": "^4.2.0",
  resolve: "^1.22.2",
  sucrase: "^3.32.0"
}, J9 = [
  "> 1%",
  "not edge <= 18",
  "not ie 11",
  "not op_mini all"
], Q9 = {
  testTimeout: 3e4,
  setupFilesAfterEnv: [
    "<rootDir>/jest/customMatchers.js"
  ],
  testPathIgnorePatterns: [
    "/node_modules/",
    "/integrations/",
    "/standalone-cli/",
    "\\.test\\.skip\\.js$"
  ],
  transformIgnorePatterns: [
    "node_modules/(?!lightningcss)"
  ],
  transform: {
    "\\.js$": "@swc/jest",
    "\\.ts$": "@swc/jest"
  }
}, Z9 = {
  node: ">=14.0.0"
}, xA = {
  name: L9,
  version: j9,
  description: F9,
  license: B9,
  main: $9,
  types: U9,
  repository: V9,
  bugs: W9,
  homepage: q9,
  bin: H9,
  tailwindcss: G9,
  scripts: z9,
  files: K9,
  devDependencies: Y9,
  dependencies: X9,
  browserslist: J9,
  jest: Q9,
  engines: Z9
};
var Kd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(n, u) {
    for (var i in u) Object.defineProperty(n, i, {
      enumerable: !0,
      get: u[i]
    });
  }
  e(t, {
    normalizeScreens: function() {
      return r;
    },
    isScreenSortable: function() {
      return a;
    },
    compareScreens: function() {
      return l;
    },
    toScreen: function() {
      return d;
    }
  });
  function r(n, u = !0) {
    return Array.isArray(n) ? n.map((i) => {
      if (u && Array.isArray(i))
        throw new Error("The tuple syntax is not supported for `screens`.");
      if (typeof i == "string")
        return {
          name: i.toString(),
          not: !1,
          values: [
            {
              min: i,
              max: void 0
            }
          ]
        };
      let [c, f] = i;
      return c = c.toString(), typeof f == "string" ? {
        name: c,
        not: !1,
        values: [
          {
            min: f,
            max: void 0
          }
        ]
      } : Array.isArray(f) ? {
        name: c,
        not: !1,
        values: f.map((s) => h(s))
      } : {
        name: c,
        not: !1,
        values: [
          h(f)
        ]
      };
    }) : r(Object.entries(n ?? {}), !1);
  }
  function a(n) {
    return n.values.length !== 1 ? {
      result: !1,
      reason: "multiple-values"
    } : n.values[0].raw !== void 0 ? {
      result: !1,
      reason: "raw-values"
    } : n.values[0].min !== void 0 && n.values[0].max !== void 0 ? {
      result: !1,
      reason: "min-and-max"
    } : {
      result: !0,
      reason: null
    };
  }
  function l(n, u, i) {
    let c = d(u, n), f = d(i, n), s = a(c), o = a(f);
    if (s.reason === "multiple-values" || o.reason === "multiple-values")
      throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    if (s.reason === "raw-values" || o.reason === "raw-values")
      throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    if (s.reason === "min-and-max" || o.reason === "min-and-max")
      throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    let { min: y, max: m } = c.values[0], { min: g, max: b } = f.values[0];
    u.not && ([y, m] = [
      m,
      y
    ]), i.not && ([g, b] = [
      b,
      g
    ]), y = y === void 0 ? y : parseFloat(y), m = m === void 0 ? m : parseFloat(m), g = g === void 0 ? g : parseFloat(g), b = b === void 0 ? b : parseFloat(b);
    let [v, T] = n === "min" ? [
      y,
      g
    ] : [
      b,
      m
    ];
    return v - T;
  }
  function d(n, u) {
    return typeof n == "object" ? n : {
      name: "arbitrary-screen",
      values: [
        {
          [u]: n
        }
      ]
    };
  }
  function h({ "min-width": n, min: u = n, max: i, raw: c } = {}) {
    return {
      min: u,
      max: i,
      raw: c
    };
  }
})(Kd);
var TA = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "removeAlphaVariables", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, a) {
    r.walkDecls((l) => {
      if (a.includes(l.prop)) {
        l.remove();
        return;
      }
      for (let d of a)
        l.value.includes(`/ var(${d})`) && (l.value = l.value.replace(`/ var(${d})`, ""));
    });
  }
})(TA);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(_, S) {
    for (var C in S) Object.defineProperty(_, C, {
      enumerable: !0,
      get: S[C]
    });
  }
  e(t, {
    variantPlugins: function() {
      return I;
    },
    corePlugins: function() {
      return x;
    }
  });
  const r = /* @__PURE__ */ O(oi), a = /* @__PURE__ */ $(Qr), l = /* @__PURE__ */ O(Vi), d = /* @__PURE__ */ O(_A), h = /* @__PURE__ */ O(zd), n = /* @__PURE__ */ O(Pl), u = /* @__PURE__ */ O(SA), i = /* @__PURE__ */ O(wA), c = /* @__PURE__ */ $(zu), f = /* @__PURE__ */ O(Hy), s = /* @__PURE__ */ O(Al), o = /* @__PURE__ */ O(Qu), y = xA, m = /* @__PURE__ */ O(as), g = Kd, b = qy, v = TA, T = Vs, E = Ku;
  function O(_) {
    return _ && _.__esModule ? _ : {
      default: _
    };
  }
  function D(_) {
    if (typeof WeakMap != "function") return null;
    var S = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
    return (D = function(R) {
      return R ? C : S;
    })(_);
  }
  function $(_, S) {
    if (_ && _.__esModule)
      return _;
    if (_ === null || typeof _ != "object" && typeof _ != "function")
      return {
        default: _
      };
    var C = D(S);
    if (C && C.has(_))
      return C.get(_);
    var R = {}, H = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var z in _)
      if (z !== "default" && Object.prototype.hasOwnProperty.call(_, z)) {
        var U = H ? Object.getOwnPropertyDescriptor(_, z) : null;
        U && (U.get || U.set) ? Object.defineProperty(R, z, U) : R[z] = _[z];
      }
    return R.default = _, C && C.set(_, R), R;
  }
  let I = {
    pseudoElementVariants: ({ addVariant: _ }) => {
      _("first-letter", "&::first-letter"), _("first-line", "&::first-line"), _("marker", [
        ({ container: S }) => ((0, v.removeAlphaVariables)(S, [
          "--tw-text-opacity"
        ]), "& *::marker"),
        ({ container: S }) => ((0, v.removeAlphaVariables)(S, [
          "--tw-text-opacity"
        ]), "&::marker")
      ]), _("selection", [
        "& *::selection",
        "&::selection"
      ]), _("file", "&::file-selector-button"), _("placeholder", "&::placeholder"), _("backdrop", "&::backdrop"), _("before", ({ container: S }) => (S.walkRules((C) => {
        let R = !1;
        C.walkDecls("content", () => {
          R = !0;
        }), R || C.prepend(l.default.decl({
          prop: "content",
          value: "var(--tw-content)"
        }));
      }), "&::before")), _("after", ({ container: S }) => (S.walkRules((C) => {
        let R = !1;
        C.walkDecls("content", () => {
          R = !0;
        }), R || C.prepend(l.default.decl({
          prop: "content",
          value: "var(--tw-content)"
        }));
      }), "&::after"));
    },
    pseudoClassVariants: ({ addVariant: _, matchVariant: S, config: C }) => {
      let R = [
        // Positional
        [
          "first",
          "&:first-child"
        ],
        [
          "last",
          "&:last-child"
        ],
        [
          "only",
          "&:only-child"
        ],
        [
          "odd",
          "&:nth-child(odd)"
        ],
        [
          "even",
          "&:nth-child(even)"
        ],
        "first-of-type",
        "last-of-type",
        "only-of-type",
        // State
        [
          "visited",
          ({ container: z }) => ((0, v.removeAlphaVariables)(z, [
            "--tw-text-opacity",
            "--tw-border-opacity",
            "--tw-bg-opacity"
          ]), "&:visited")
        ],
        "target",
        [
          "open",
          "&[open]"
        ],
        // Forms
        "default",
        "checked",
        "indeterminate",
        "placeholder-shown",
        "autofill",
        "optional",
        "required",
        "valid",
        "invalid",
        "in-range",
        "out-of-range",
        "read-only",
        // Content
        "empty",
        // Interactive
        "focus-within",
        [
          "hover",
          (0, T.flagEnabled)(C(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
        ],
        "focus",
        "focus-visible",
        "active",
        "enabled",
        "disabled"
      ].map((z) => Array.isArray(z) ? z : [
        z,
        `&:${z}`
      ]);
      for (let [z, U] of R)
        _(z, (P) => typeof U == "function" ? U(P) : U);
      let H = {
        group: (z, { modifier: U }) => U ? [
          `:merge(.group\\/${(0, n.default)(U)})`,
          " &"
        ] : [
          ":merge(.group)",
          " &"
        ],
        peer: (z, { modifier: U }) => U ? [
          `:merge(.peer\\/${(0, n.default)(U)})`,
          " ~ &"
        ] : [
          ":merge(.peer)",
          " ~ &"
        ]
      };
      for (let [z, U] of Object.entries(H))
        S(z, (P = "", W) => {
          let B = (0, E.normalize)(typeof P == "function" ? P(W) : P);
          B.includes("&") || (B = "&" + B);
          let [Q, J] = U("", W), re = null, G = null, N = 0;
          for (let V = 0; V < B.length; ++V) {
            let F = B[V];
            F === "&" ? re = V : F === "'" || F === '"' ? N += 1 : re !== null && F === " " && !N && (G = V);
          }
          return re !== null && G === null && (G = B.length), B.slice(0, re) + Q + B.slice(re + 1, G) + J + B.slice(G);
        }, {
          values: Object.fromEntries(R)
        });
    },
    directionVariants: ({ addVariant: _ }) => {
      _("ltr", ':is([dir="ltr"] &)'), _("rtl", ':is([dir="rtl"] &)');
    },
    reducedMotionVariants: ({ addVariant: _ }) => {
      _("motion-safe", "@media (prefers-reduced-motion: no-preference)"), _("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config: _, addVariant: S }) => {
      let [C, R = ".dark"] = [].concat(_("darkMode", "media"));
      C === !1 && (C = "media", m.default.warn("darkmode-false", [
        "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
        "Change `darkMode` to `media` or remove it entirely.",
        "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
      ])), C === "class" ? S("dark", `:is(${R} &)`) : C === "media" && S("dark", "@media (prefers-color-scheme: dark)");
    },
    printVariant: ({ addVariant: _ }) => {
      _("print", "@media print");
    },
    screenVariants: ({ theme: _, addVariant: S, matchVariant: C }) => {
      var R;
      let H = (R = _("screens")) !== null && R !== void 0 ? R : {}, z = Object.values(H).every((K) => typeof K == "string"), U = (0, g.normalizeScreens)(_("screens")), P = /* @__PURE__ */ new Set([]);
      function W(K) {
        var ie, fe;
        return (fe = (ie = K.match(/(\D+)$/)) === null || ie === void 0 ? void 0 : ie[1]) !== null && fe !== void 0 ? fe : "(none)";
      }
      function B(K) {
        K !== void 0 && P.add(W(K));
      }
      function Q(K) {
        return B(K), P.size === 1;
      }
      for (const K of U)
        for (const ie of K.values)
          B(ie.min), B(ie.max);
      let J = P.size <= 1;
      function re(K) {
        return Object.fromEntries(U.filter((ie) => (0, g.isScreenSortable)(ie).result).map((ie) => {
          let { min: fe, max: _e } = ie.values[0];
          if (_e !== void 0)
            return ie;
          if (fe !== void 0)
            return {
              ...ie,
              not: !ie.not
            };
        }).map((ie) => [
          ie.name,
          ie
        ]));
      }
      function G(K) {
        return (ie, fe) => (0, g.compareScreens)(K, ie.value, fe.value);
      }
      let N = G("max"), V = G("min");
      function F(K) {
        return (ie) => {
          if (z)
            if (J) {
              if (typeof ie == "string" && !Q(ie))
                return m.default.warn("minmax-have-mixed-units", [
                  "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                ]), [];
            } else return m.default.warn("mixed-screen-units", [
              "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
            ]), [];
          else return m.default.warn("complex-screen-config", [
            "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
          ]), [];
          return [
            `@media ${(0, h.default)((0, g.toScreen)(ie, K))}`
          ];
        };
      }
      C("max", F("max"), {
        sort: N,
        values: z ? re() : {}
      });
      let X = "min-screens";
      for (let K of U)
        S(K.name, `@media ${(0, h.default)(K)}`, {
          id: X,
          sort: z && J ? V : void 0,
          value: K
        });
      C("min", F("min"), {
        id: X,
        sort: V
      });
    },
    supportsVariants: ({ matchVariant: _, theme: S }) => {
      var C;
      _("supports", (R = "") => {
        let H = (0, E.normalize)(R), z = /^\w*\s*\(/.test(H);
        return H = z ? H.replace(/\b(and|or|not)\b/g, " $1 ") : H, z ? `@supports ${H}` : (H.includes(":") || (H = `${H}: var(--tw)`), H.startsWith("(") && H.endsWith(")") || (H = `(${H})`), `@supports ${H}`);
      }, {
        values: (C = S("supports")) !== null && C !== void 0 ? C : {}
      });
    },
    ariaVariants: ({ matchVariant: _, theme: S }) => {
      var C;
      _("aria", (z) => `&[aria-${(0, E.normalize)(z)}]`, {
        values: (C = S("aria")) !== null && C !== void 0 ? C : {}
      });
      var R;
      _("group-aria", (z, { modifier: U }) => U ? `:merge(.group\\/${U})[aria-${(0, E.normalize)(z)}] &` : `:merge(.group)[aria-${(0, E.normalize)(z)}] &`, {
        values: (R = S("aria")) !== null && R !== void 0 ? R : {}
      });
      var H;
      _("peer-aria", (z, { modifier: U }) => U ? `:merge(.peer\\/${U})[aria-${(0, E.normalize)(z)}] ~ &` : `:merge(.peer)[aria-${(0, E.normalize)(z)}] ~ &`, {
        values: (H = S("aria")) !== null && H !== void 0 ? H : {}
      });
    },
    dataVariants: ({ matchVariant: _, theme: S }) => {
      var C;
      _("data", (z) => `&[data-${(0, E.normalize)(z)}]`, {
        values: (C = S("data")) !== null && C !== void 0 ? C : {}
      });
      var R;
      _("group-data", (z, { modifier: U }) => U ? `:merge(.group\\/${U})[data-${(0, E.normalize)(z)}] &` : `:merge(.group)[data-${(0, E.normalize)(z)}] &`, {
        values: (R = S("data")) !== null && R !== void 0 ? R : {}
      });
      var H;
      _("peer-data", (z, { modifier: U }) => U ? `:merge(.peer\\/${U})[data-${(0, E.normalize)(z)}] ~ &` : `:merge(.peer)[data-${(0, E.normalize)(z)}] ~ &`, {
        values: (H = S("data")) !== null && H !== void 0 ? H : {}
      });
    },
    orientationVariants: ({ addVariant: _ }) => {
      _("portrait", "@media (orientation: portrait)"), _("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant: _ }) => {
      _("contrast-more", "@media (prefers-contrast: more)"), _("contrast-less", "@media (prefers-contrast: less)");
    }
  }, k = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
  ].join(" "), L = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
  ].join(" "), M = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
  ].join(" "), x = {
    preflight: ({ addBase: _ }) => {
      let S = l.default.parse(r.default.readFileSync(a.join(__dirname, "./css/preflight.css"), "utf8"));
      _([
        l.default.comment({
          text: `! tailwindcss v${y.version} | MIT License | https://tailwindcss.com`
        }),
        ...S.nodes
      ]);
    },
    container: /* @__PURE__ */ (() => {
      function _(C = []) {
        return C.flatMap((R) => R.values.map((H) => H.min)).filter((R) => R !== void 0);
      }
      function S(C, R, H) {
        if (typeof H > "u")
          return [];
        if (!(typeof H == "object" && H !== null))
          return [
            {
              screen: "DEFAULT",
              minWidth: 0,
              padding: H
            }
          ];
        let z = [];
        H.DEFAULT && z.push({
          screen: "DEFAULT",
          minWidth: 0,
          padding: H.DEFAULT
        });
        for (let U of C)
          for (let P of R)
            for (let { min: W } of P.values)
              W === U && z.push({
                minWidth: U,
                padding: H[P.name]
              });
        return z;
      }
      return function({ addComponents: C, theme: R }) {
        let H = (0, g.normalizeScreens)(R("container.screens", R("screens"))), z = _(H), U = S(z, H, R("container.padding")), P = (B) => {
          let Q = U.find((J) => J.minWidth === B);
          return Q ? {
            paddingRight: Q.padding,
            paddingLeft: Q.padding
          } : {};
        }, W = Array.from(new Set(z.slice().sort((B, Q) => parseInt(B) - parseInt(Q)))).map((B) => ({
          [`@media (min-width: ${B})`]: {
            ".container": {
              "max-width": B,
              ...P(B)
            }
          }
        }));
        C([
          {
            ".container": Object.assign({
              width: "100%"
            }, R("container.center", !1) ? {
              marginRight: "auto",
              marginLeft: "auto"
            } : {}, P(0))
          },
          ...W
        ]);
      };
    })(),
    accessibility: ({ addUtilities: _ }) => {
      _({
        ".sr-only": {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        ".not-sr-only": {
          position: "static",
          width: "auto",
          height: "auto",
          padding: "0",
          margin: "0",
          overflow: "visible",
          clip: "auto",
          whiteSpace: "normal"
        }
      });
    },
    pointerEvents: ({ addUtilities: _ }) => {
      _({
        ".pointer-events-none": {
          "pointer-events": "none"
        },
        ".pointer-events-auto": {
          "pointer-events": "auto"
        }
      });
    },
    visibility: ({ addUtilities: _ }) => {
      _({
        ".visible": {
          visibility: "visible"
        },
        ".invisible": {
          visibility: "hidden"
        },
        ".collapse": {
          visibility: "collapse"
        }
      });
    },
    position: ({ addUtilities: _ }) => {
      _({
        ".static": {
          position: "static"
        },
        ".fixed": {
          position: "fixed"
        },
        ".absolute": {
          position: "absolute"
        },
        ".relative": {
          position: "relative"
        },
        ".sticky": {
          position: "sticky"
        }
      });
    },
    inset: (0, d.default)("inset", [
      [
        "inset",
        [
          "inset"
        ]
      ],
      [
        [
          "inset-x",
          [
            "left",
            "right"
          ]
        ],
        [
          "inset-y",
          [
            "top",
            "bottom"
          ]
        ]
      ],
      [
        [
          "start",
          [
            "inset-inline-start"
          ]
        ],
        [
          "end",
          [
            "inset-inline-end"
          ]
        ],
        [
          "top",
          [
            "top"
          ]
        ],
        [
          "right",
          [
            "right"
          ]
        ],
        [
          "bottom",
          [
            "bottom"
          ]
        ],
        [
          "left",
          [
            "left"
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    isolation: ({ addUtilities: _ }) => {
      _({
        ".isolate": {
          isolation: "isolate"
        },
        ".isolation-auto": {
          isolation: "auto"
        }
      });
    },
    zIndex: (0, d.default)("zIndex", [
      [
        "z",
        [
          "zIndex"
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    order: (0, d.default)("order", void 0, {
      supportsNegativeValues: !0
    }),
    gridColumn: (0, d.default)("gridColumn", [
      [
        "col",
        [
          "gridColumn"
        ]
      ]
    ]),
    gridColumnStart: (0, d.default)("gridColumnStart", [
      [
        "col-start",
        [
          "gridColumnStart"
        ]
      ]
    ]),
    gridColumnEnd: (0, d.default)("gridColumnEnd", [
      [
        "col-end",
        [
          "gridColumnEnd"
        ]
      ]
    ]),
    gridRow: (0, d.default)("gridRow", [
      [
        "row",
        [
          "gridRow"
        ]
      ]
    ]),
    gridRowStart: (0, d.default)("gridRowStart", [
      [
        "row-start",
        [
          "gridRowStart"
        ]
      ]
    ]),
    gridRowEnd: (0, d.default)("gridRowEnd", [
      [
        "row-end",
        [
          "gridRowEnd"
        ]
      ]
    ]),
    float: ({ addUtilities: _ }) => {
      _({
        ".float-right": {
          float: "right"
        },
        ".float-left": {
          float: "left"
        },
        ".float-none": {
          float: "none"
        }
      });
    },
    clear: ({ addUtilities: _ }) => {
      _({
        ".clear-left": {
          clear: "left"
        },
        ".clear-right": {
          clear: "right"
        },
        ".clear-both": {
          clear: "both"
        },
        ".clear-none": {
          clear: "none"
        }
      });
    },
    margin: (0, d.default)("margin", [
      [
        "m",
        [
          "margin"
        ]
      ],
      [
        [
          "mx",
          [
            "margin-left",
            "margin-right"
          ]
        ],
        [
          "my",
          [
            "margin-top",
            "margin-bottom"
          ]
        ]
      ],
      [
        [
          "ms",
          [
            "margin-inline-start"
          ]
        ],
        [
          "me",
          [
            "margin-inline-end"
          ]
        ],
        [
          "mt",
          [
            "margin-top"
          ]
        ],
        [
          "mr",
          [
            "margin-right"
          ]
        ],
        [
          "mb",
          [
            "margin-bottom"
          ]
        ],
        [
          "ml",
          [
            "margin-left"
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    boxSizing: ({ addUtilities: _ }) => {
      _({
        ".box-border": {
          "box-sizing": "border-box"
        },
        ".box-content": {
          "box-sizing": "content-box"
        }
      });
    },
    lineClamp: ({ matchUtilities: _, addUtilities: S, theme: C }) => {
      _({
        "line-clamp": (R) => ({
          overflow: "hidden",
          display: "-webkit-box",
          "-webkit-box-orient": "vertical",
          "-webkit-line-clamp": `${R}`
        })
      }, {
        values: C("lineClamp")
      }), S({
        ".line-clamp-none": {
          overflow: "visible",
          display: "block",
          "-webkit-box-orient": "horizontal",
          "-webkit-line-clamp": "none"
        }
      });
    },
    display: ({ addUtilities: _ }) => {
      _({
        ".block": {
          display: "block"
        },
        ".inline-block": {
          display: "inline-block"
        },
        ".inline": {
          display: "inline"
        },
        ".flex": {
          display: "flex"
        },
        ".inline-flex": {
          display: "inline-flex"
        },
        ".table": {
          display: "table"
        },
        ".inline-table": {
          display: "inline-table"
        },
        ".table-caption": {
          display: "table-caption"
        },
        ".table-cell": {
          display: "table-cell"
        },
        ".table-column": {
          display: "table-column"
        },
        ".table-column-group": {
          display: "table-column-group"
        },
        ".table-footer-group": {
          display: "table-footer-group"
        },
        ".table-header-group": {
          display: "table-header-group"
        },
        ".table-row-group": {
          display: "table-row-group"
        },
        ".table-row": {
          display: "table-row"
        },
        ".flow-root": {
          display: "flow-root"
        },
        ".grid": {
          display: "grid"
        },
        ".inline-grid": {
          display: "inline-grid"
        },
        ".contents": {
          display: "contents"
        },
        ".list-item": {
          display: "list-item"
        },
        ".hidden": {
          display: "none"
        }
      });
    },
    aspectRatio: (0, d.default)("aspectRatio", [
      [
        "aspect",
        [
          "aspect-ratio"
        ]
      ]
    ]),
    height: (0, d.default)("height", [
      [
        "h",
        [
          "height"
        ]
      ]
    ]),
    maxHeight: (0, d.default)("maxHeight", [
      [
        "max-h",
        [
          "maxHeight"
        ]
      ]
    ]),
    minHeight: (0, d.default)("minHeight", [
      [
        "min-h",
        [
          "minHeight"
        ]
      ]
    ]),
    width: (0, d.default)("width", [
      [
        "w",
        [
          "width"
        ]
      ]
    ]),
    minWidth: (0, d.default)("minWidth", [
      [
        "min-w",
        [
          "minWidth"
        ]
      ]
    ]),
    maxWidth: (0, d.default)("maxWidth", [
      [
        "max-w",
        [
          "maxWidth"
        ]
      ]
    ]),
    flex: (0, d.default)("flex"),
    flexShrink: (0, d.default)("flexShrink", [
      [
        "flex-shrink",
        [
          "flex-shrink"
        ]
      ],
      [
        "shrink",
        [
          "flex-shrink"
        ]
      ]
    ]),
    flexGrow: (0, d.default)("flexGrow", [
      [
        "flex-grow",
        [
          "flex-grow"
        ]
      ],
      [
        "grow",
        [
          "flex-grow"
        ]
      ]
    ]),
    flexBasis: (0, d.default)("flexBasis", [
      [
        "basis",
        [
          "flex-basis"
        ]
      ]
    ]),
    tableLayout: ({ addUtilities: _ }) => {
      _({
        ".table-auto": {
          "table-layout": "auto"
        },
        ".table-fixed": {
          "table-layout": "fixed"
        }
      });
    },
    captionSide: ({ addUtilities: _ }) => {
      _({
        ".caption-top": {
          "caption-side": "top"
        },
        ".caption-bottom": {
          "caption-side": "bottom"
        }
      });
    },
    borderCollapse: ({ addUtilities: _ }) => {
      _({
        ".border-collapse": {
          "border-collapse": "collapse"
        },
        ".border-separate": {
          "border-collapse": "separate"
        }
      });
    },
    borderSpacing: ({ addDefaults: _, matchUtilities: S, theme: C }) => {
      _("border-spacing", {
        "--tw-border-spacing-x": 0,
        "--tw-border-spacing-y": 0
      }), S({
        "border-spacing": (R) => ({
          "--tw-border-spacing-x": R,
          "--tw-border-spacing-y": R,
          "@defaults border-spacing": {},
          "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
        }),
        "border-spacing-x": (R) => ({
          "--tw-border-spacing-x": R,
          "@defaults border-spacing": {},
          "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
        }),
        "border-spacing-y": (R) => ({
          "--tw-border-spacing-y": R,
          "@defaults border-spacing": {},
          "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
        })
      }, {
        values: C("borderSpacing")
      });
    },
    transformOrigin: (0, d.default)("transformOrigin", [
      [
        "origin",
        [
          "transformOrigin"
        ]
      ]
    ]),
    translate: (0, d.default)("translate", [
      [
        [
          "translate-x",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-translate-x",
            [
              "transform",
              k
            ]
          ]
        ],
        [
          "translate-y",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-translate-y",
            [
              "transform",
              k
            ]
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    rotate: (0, d.default)("rotate", [
      [
        "rotate",
        [
          [
            "@defaults transform",
            {}
          ],
          "--tw-rotate",
          [
            "transform",
            k
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    skew: (0, d.default)("skew", [
      [
        [
          "skew-x",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-skew-x",
            [
              "transform",
              k
            ]
          ]
        ],
        [
          "skew-y",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-skew-y",
            [
              "transform",
              k
            ]
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    scale: (0, d.default)("scale", [
      [
        "scale",
        [
          [
            "@defaults transform",
            {}
          ],
          "--tw-scale-x",
          "--tw-scale-y",
          [
            "transform",
            k
          ]
        ]
      ],
      [
        [
          "scale-x",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            [
              "transform",
              k
            ]
          ]
        ],
        [
          "scale-y",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-y",
            [
              "transform",
              k
            ]
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    transform: ({ addDefaults: _, addUtilities: S }) => {
      _("transform", {
        "--tw-translate-x": "0",
        "--tw-translate-y": "0",
        "--tw-rotate": "0",
        "--tw-skew-x": "0",
        "--tw-skew-y": "0",
        "--tw-scale-x": "1",
        "--tw-scale-y": "1"
      }), S({
        ".transform": {
          "@defaults transform": {},
          transform: k
        },
        ".transform-cpu": {
          transform: k
        },
        ".transform-gpu": {
          transform: k.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
        },
        ".transform-none": {
          transform: "none"
        }
      });
    },
    animation: ({ matchUtilities: _, theme: S, config: C }) => {
      let R = (U) => `${C("prefix")}${(0, n.default)(U)}`;
      var H;
      let z = Object.fromEntries(Object.entries((H = S("keyframes")) !== null && H !== void 0 ? H : {}).map(([U, P]) => [
        U,
        {
          [`@keyframes ${R(U)}`]: P
        }
      ]));
      _({
        animate: (U) => {
          let P = (0, u.default)(U);
          return [
            ...P.flatMap((W) => z[W.name]),
            {
              animation: P.map(({ name: W, value: B }) => W === void 0 || z[W] === void 0 ? B : B.replace(W, R(W))).join(", ")
            }
          ];
        }
      }, {
        values: S("animation")
      });
    },
    cursor: (0, d.default)("cursor"),
    touchAction: ({ addDefaults: _, addUtilities: S }) => {
      _("touch-action", {
        "--tw-pan-x": " ",
        "--tw-pan-y": " ",
        "--tw-pinch-zoom": " "
      });
      let C = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
      S({
        ".touch-auto": {
          "touch-action": "auto"
        },
        ".touch-none": {
          "touch-action": "none"
        },
        ".touch-pan-x": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-x",
          "touch-action": C
        },
        ".touch-pan-left": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-left",
          "touch-action": C
        },
        ".touch-pan-right": {
          "@defaults touch-action": {},
          "--tw-pan-x": "pan-right",
          "touch-action": C
        },
        ".touch-pan-y": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-y",
          "touch-action": C
        },
        ".touch-pan-up": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-up",
          "touch-action": C
        },
        ".touch-pan-down": {
          "@defaults touch-action": {},
          "--tw-pan-y": "pan-down",
          "touch-action": C
        },
        ".touch-pinch-zoom": {
          "@defaults touch-action": {},
          "--tw-pinch-zoom": "pinch-zoom",
          "touch-action": C
        },
        ".touch-manipulation": {
          "touch-action": "manipulation"
        }
      });
    },
    userSelect: ({ addUtilities: _ }) => {
      _({
        ".select-none": {
          "user-select": "none"
        },
        ".select-text": {
          "user-select": "text"
        },
        ".select-all": {
          "user-select": "all"
        },
        ".select-auto": {
          "user-select": "auto"
        }
      });
    },
    resize: ({ addUtilities: _ }) => {
      _({
        ".resize-none": {
          resize: "none"
        },
        ".resize-y": {
          resize: "vertical"
        },
        ".resize-x": {
          resize: "horizontal"
        },
        ".resize": {
          resize: "both"
        }
      });
    },
    scrollSnapType: ({ addDefaults: _, addUtilities: S }) => {
      _("scroll-snap-type", {
        "--tw-scroll-snap-strictness": "proximity"
      }), S({
        ".snap-none": {
          "scroll-snap-type": "none"
        },
        ".snap-x": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
        },
        ".snap-y": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
        },
        ".snap-both": {
          "@defaults scroll-snap-type": {},
          "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
        },
        ".snap-mandatory": {
          "--tw-scroll-snap-strictness": "mandatory"
        },
        ".snap-proximity": {
          "--tw-scroll-snap-strictness": "proximity"
        }
      });
    },
    scrollSnapAlign: ({ addUtilities: _ }) => {
      _({
        ".snap-start": {
          "scroll-snap-align": "start"
        },
        ".snap-end": {
          "scroll-snap-align": "end"
        },
        ".snap-center": {
          "scroll-snap-align": "center"
        },
        ".snap-align-none": {
          "scroll-snap-align": "none"
        }
      });
    },
    scrollSnapStop: ({ addUtilities: _ }) => {
      _({
        ".snap-normal": {
          "scroll-snap-stop": "normal"
        },
        ".snap-always": {
          "scroll-snap-stop": "always"
        }
      });
    },
    scrollMargin: (0, d.default)("scrollMargin", [
      [
        "scroll-m",
        [
          "scroll-margin"
        ]
      ],
      [
        [
          "scroll-mx",
          [
            "scroll-margin-left",
            "scroll-margin-right"
          ]
        ],
        [
          "scroll-my",
          [
            "scroll-margin-top",
            "scroll-margin-bottom"
          ]
        ]
      ],
      [
        [
          "scroll-ms",
          [
            "scroll-margin-inline-start"
          ]
        ],
        [
          "scroll-me",
          [
            "scroll-margin-inline-end"
          ]
        ],
        [
          "scroll-mt",
          [
            "scroll-margin-top"
          ]
        ],
        [
          "scroll-mr",
          [
            "scroll-margin-right"
          ]
        ],
        [
          "scroll-mb",
          [
            "scroll-margin-bottom"
          ]
        ],
        [
          "scroll-ml",
          [
            "scroll-margin-left"
          ]
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    scrollPadding: (0, d.default)("scrollPadding", [
      [
        "scroll-p",
        [
          "scroll-padding"
        ]
      ],
      [
        [
          "scroll-px",
          [
            "scroll-padding-left",
            "scroll-padding-right"
          ]
        ],
        [
          "scroll-py",
          [
            "scroll-padding-top",
            "scroll-padding-bottom"
          ]
        ]
      ],
      [
        [
          "scroll-ps",
          [
            "scroll-padding-inline-start"
          ]
        ],
        [
          "scroll-pe",
          [
            "scroll-padding-inline-end"
          ]
        ],
        [
          "scroll-pt",
          [
            "scroll-padding-top"
          ]
        ],
        [
          "scroll-pr",
          [
            "scroll-padding-right"
          ]
        ],
        [
          "scroll-pb",
          [
            "scroll-padding-bottom"
          ]
        ],
        [
          "scroll-pl",
          [
            "scroll-padding-left"
          ]
        ]
      ]
    ]),
    listStylePosition: ({ addUtilities: _ }) => {
      _({
        ".list-inside": {
          "list-style-position": "inside"
        },
        ".list-outside": {
          "list-style-position": "outside"
        }
      });
    },
    listStyleType: (0, d.default)("listStyleType", [
      [
        "list",
        [
          "listStyleType"
        ]
      ]
    ]),
    listStyleImage: (0, d.default)("listStyleImage", [
      [
        "list-image",
        [
          "listStyleImage"
        ]
      ]
    ]),
    appearance: ({ addUtilities: _ }) => {
      _({
        ".appearance-none": {
          appearance: "none"
        }
      });
    },
    columns: (0, d.default)("columns", [
      [
        "columns",
        [
          "columns"
        ]
      ]
    ]),
    breakBefore: ({ addUtilities: _ }) => {
      _({
        ".break-before-auto": {
          "break-before": "auto"
        },
        ".break-before-avoid": {
          "break-before": "avoid"
        },
        ".break-before-all": {
          "break-before": "all"
        },
        ".break-before-avoid-page": {
          "break-before": "avoid-page"
        },
        ".break-before-page": {
          "break-before": "page"
        },
        ".break-before-left": {
          "break-before": "left"
        },
        ".break-before-right": {
          "break-before": "right"
        },
        ".break-before-column": {
          "break-before": "column"
        }
      });
    },
    breakInside: ({ addUtilities: _ }) => {
      _({
        ".break-inside-auto": {
          "break-inside": "auto"
        },
        ".break-inside-avoid": {
          "break-inside": "avoid"
        },
        ".break-inside-avoid-page": {
          "break-inside": "avoid-page"
        },
        ".break-inside-avoid-column": {
          "break-inside": "avoid-column"
        }
      });
    },
    breakAfter: ({ addUtilities: _ }) => {
      _({
        ".break-after-auto": {
          "break-after": "auto"
        },
        ".break-after-avoid": {
          "break-after": "avoid"
        },
        ".break-after-all": {
          "break-after": "all"
        },
        ".break-after-avoid-page": {
          "break-after": "avoid-page"
        },
        ".break-after-page": {
          "break-after": "page"
        },
        ".break-after-left": {
          "break-after": "left"
        },
        ".break-after-right": {
          "break-after": "right"
        },
        ".break-after-column": {
          "break-after": "column"
        }
      });
    },
    gridAutoColumns: (0, d.default)("gridAutoColumns", [
      [
        "auto-cols",
        [
          "gridAutoColumns"
        ]
      ]
    ]),
    gridAutoFlow: ({ addUtilities: _ }) => {
      _({
        ".grid-flow-row": {
          gridAutoFlow: "row"
        },
        ".grid-flow-col": {
          gridAutoFlow: "column"
        },
        ".grid-flow-dense": {
          gridAutoFlow: "dense"
        },
        ".grid-flow-row-dense": {
          gridAutoFlow: "row dense"
        },
        ".grid-flow-col-dense": {
          gridAutoFlow: "column dense"
        }
      });
    },
    gridAutoRows: (0, d.default)("gridAutoRows", [
      [
        "auto-rows",
        [
          "gridAutoRows"
        ]
      ]
    ]),
    gridTemplateColumns: (0, d.default)("gridTemplateColumns", [
      [
        "grid-cols",
        [
          "gridTemplateColumns"
        ]
      ]
    ]),
    gridTemplateRows: (0, d.default)("gridTemplateRows", [
      [
        "grid-rows",
        [
          "gridTemplateRows"
        ]
      ]
    ]),
    flexDirection: ({ addUtilities: _ }) => {
      _({
        ".flex-row": {
          "flex-direction": "row"
        },
        ".flex-row-reverse": {
          "flex-direction": "row-reverse"
        },
        ".flex-col": {
          "flex-direction": "column"
        },
        ".flex-col-reverse": {
          "flex-direction": "column-reverse"
        }
      });
    },
    flexWrap: ({ addUtilities: _ }) => {
      _({
        ".flex-wrap": {
          "flex-wrap": "wrap"
        },
        ".flex-wrap-reverse": {
          "flex-wrap": "wrap-reverse"
        },
        ".flex-nowrap": {
          "flex-wrap": "nowrap"
        }
      });
    },
    placeContent: ({ addUtilities: _ }) => {
      _({
        ".place-content-center": {
          "place-content": "center"
        },
        ".place-content-start": {
          "place-content": "start"
        },
        ".place-content-end": {
          "place-content": "end"
        },
        ".place-content-between": {
          "place-content": "space-between"
        },
        ".place-content-around": {
          "place-content": "space-around"
        },
        ".place-content-evenly": {
          "place-content": "space-evenly"
        },
        ".place-content-baseline": {
          "place-content": "baseline"
        },
        ".place-content-stretch": {
          "place-content": "stretch"
        }
      });
    },
    placeItems: ({ addUtilities: _ }) => {
      _({
        ".place-items-start": {
          "place-items": "start"
        },
        ".place-items-end": {
          "place-items": "end"
        },
        ".place-items-center": {
          "place-items": "center"
        },
        ".place-items-baseline": {
          "place-items": "baseline"
        },
        ".place-items-stretch": {
          "place-items": "stretch"
        }
      });
    },
    alignContent: ({ addUtilities: _ }) => {
      _({
        ".content-normal": {
          "align-content": "normal"
        },
        ".content-center": {
          "align-content": "center"
        },
        ".content-start": {
          "align-content": "flex-start"
        },
        ".content-end": {
          "align-content": "flex-end"
        },
        ".content-between": {
          "align-content": "space-between"
        },
        ".content-around": {
          "align-content": "space-around"
        },
        ".content-evenly": {
          "align-content": "space-evenly"
        },
        ".content-baseline": {
          "align-content": "baseline"
        },
        ".content-stretch": {
          "align-content": "stretch"
        }
      });
    },
    alignItems: ({ addUtilities: _ }) => {
      _({
        ".items-start": {
          "align-items": "flex-start"
        },
        ".items-end": {
          "align-items": "flex-end"
        },
        ".items-center": {
          "align-items": "center"
        },
        ".items-baseline": {
          "align-items": "baseline"
        },
        ".items-stretch": {
          "align-items": "stretch"
        }
      });
    },
    justifyContent: ({ addUtilities: _ }) => {
      _({
        ".justify-normal": {
          "justify-content": "normal"
        },
        ".justify-start": {
          "justify-content": "flex-start"
        },
        ".justify-end": {
          "justify-content": "flex-end"
        },
        ".justify-center": {
          "justify-content": "center"
        },
        ".justify-between": {
          "justify-content": "space-between"
        },
        ".justify-around": {
          "justify-content": "space-around"
        },
        ".justify-evenly": {
          "justify-content": "space-evenly"
        },
        ".justify-stretch": {
          "justify-content": "stretch"
        }
      });
    },
    justifyItems: ({ addUtilities: _ }) => {
      _({
        ".justify-items-start": {
          "justify-items": "start"
        },
        ".justify-items-end": {
          "justify-items": "end"
        },
        ".justify-items-center": {
          "justify-items": "center"
        },
        ".justify-items-stretch": {
          "justify-items": "stretch"
        }
      });
    },
    gap: (0, d.default)("gap", [
      [
        "gap",
        [
          "gap"
        ]
      ],
      [
        [
          "gap-x",
          [
            "columnGap"
          ]
        ],
        [
          "gap-y",
          [
            "rowGap"
          ]
        ]
      ]
    ]),
    space: ({ matchUtilities: _, addUtilities: S, theme: C }) => {
      _({
        "space-x": (R) => (R = R === "0" ? "0px" : R, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "0",
            "margin-right": `calc(${R} * var(--tw-space-x-reverse))`,
            "margin-left": `calc(${R} * calc(1 - var(--tw-space-x-reverse)))`
          }
        }),
        "space-y": (R) => (R = R === "0" ? "0px" : R, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "0",
            "margin-top": `calc(${R} * calc(1 - var(--tw-space-y-reverse)))`,
            "margin-bottom": `calc(${R} * var(--tw-space-y-reverse))`
          }
        })
      }, {
        values: C("space"),
        supportsNegativeValues: !0
      }), S({
        ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "--tw-space-y-reverse": "1"
        },
        ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "--tw-space-x-reverse": "1"
        }
      });
    },
    divideWidth: ({ matchUtilities: _, addUtilities: S, theme: C }) => {
      _({
        "divide-x": (R) => (R = R === "0" ? "0px" : R, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "0",
            "border-right-width": `calc(${R} * var(--tw-divide-x-reverse))`,
            "border-left-width": `calc(${R} * calc(1 - var(--tw-divide-x-reverse)))`
          }
        }),
        "divide-y": (R) => (R = R === "0" ? "0px" : R, {
          "& > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "0",
            "border-top-width": `calc(${R} * calc(1 - var(--tw-divide-y-reverse)))`,
            "border-bottom-width": `calc(${R} * var(--tw-divide-y-reverse))`
          }
        })
      }, {
        values: C("divideWidth"),
        type: [
          "line-width",
          "length",
          "any"
        ]
      }), S({
        ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-y-reverse": "1"
        },
        ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
          "@defaults border-width": {},
          "--tw-divide-x-reverse": "1"
        }
      });
    },
    divideStyle: ({ addUtilities: _ }) => {
      _({
        ".divide-solid > :not([hidden]) ~ :not([hidden])": {
          "border-style": "solid"
        },
        ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
          "border-style": "dashed"
        },
        ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
          "border-style": "dotted"
        },
        ".divide-double > :not([hidden]) ~ :not([hidden])": {
          "border-style": "double"
        },
        ".divide-none > :not([hidden]) ~ :not([hidden])": {
          "border-style": "none"
        }
      });
    },
    divideColor: ({ matchUtilities: _, theme: S, corePlugins: C }) => {
      _({
        divide: (R) => C("divideOpacity") ? {
          "& > :not([hidden]) ~ :not([hidden])": (0, c.default)({
            color: R,
            property: "border-color",
            variable: "--tw-divide-opacity"
          })
        } : {
          "& > :not([hidden]) ~ :not([hidden])": {
            "border-color": (0, f.default)(R)
          }
        }
      }, {
        values: (({ DEFAULT: R, ...H }) => H)((0, i.default)(S("divideColor"))),
        type: [
          "color",
          "any"
        ]
      });
    },
    divideOpacity: ({ matchUtilities: _, theme: S }) => {
      _({
        "divide-opacity": (C) => ({
          "& > :not([hidden]) ~ :not([hidden])": {
            "--tw-divide-opacity": C
          }
        })
      }, {
        values: S("divideOpacity")
      });
    },
    placeSelf: ({ addUtilities: _ }) => {
      _({
        ".place-self-auto": {
          "place-self": "auto"
        },
        ".place-self-start": {
          "place-self": "start"
        },
        ".place-self-end": {
          "place-self": "end"
        },
        ".place-self-center": {
          "place-self": "center"
        },
        ".place-self-stretch": {
          "place-self": "stretch"
        }
      });
    },
    alignSelf: ({ addUtilities: _ }) => {
      _({
        ".self-auto": {
          "align-self": "auto"
        },
        ".self-start": {
          "align-self": "flex-start"
        },
        ".self-end": {
          "align-self": "flex-end"
        },
        ".self-center": {
          "align-self": "center"
        },
        ".self-stretch": {
          "align-self": "stretch"
        },
        ".self-baseline": {
          "align-self": "baseline"
        }
      });
    },
    justifySelf: ({ addUtilities: _ }) => {
      _({
        ".justify-self-auto": {
          "justify-self": "auto"
        },
        ".justify-self-start": {
          "justify-self": "start"
        },
        ".justify-self-end": {
          "justify-self": "end"
        },
        ".justify-self-center": {
          "justify-self": "center"
        },
        ".justify-self-stretch": {
          "justify-self": "stretch"
        }
      });
    },
    overflow: ({ addUtilities: _ }) => {
      _({
        ".overflow-auto": {
          overflow: "auto"
        },
        ".overflow-hidden": {
          overflow: "hidden"
        },
        ".overflow-clip": {
          overflow: "clip"
        },
        ".overflow-visible": {
          overflow: "visible"
        },
        ".overflow-scroll": {
          overflow: "scroll"
        },
        ".overflow-x-auto": {
          "overflow-x": "auto"
        },
        ".overflow-y-auto": {
          "overflow-y": "auto"
        },
        ".overflow-x-hidden": {
          "overflow-x": "hidden"
        },
        ".overflow-y-hidden": {
          "overflow-y": "hidden"
        },
        ".overflow-x-clip": {
          "overflow-x": "clip"
        },
        ".overflow-y-clip": {
          "overflow-y": "clip"
        },
        ".overflow-x-visible": {
          "overflow-x": "visible"
        },
        ".overflow-y-visible": {
          "overflow-y": "visible"
        },
        ".overflow-x-scroll": {
          "overflow-x": "scroll"
        },
        ".overflow-y-scroll": {
          "overflow-y": "scroll"
        }
      });
    },
    overscrollBehavior: ({ addUtilities: _ }) => {
      _({
        ".overscroll-auto": {
          "overscroll-behavior": "auto"
        },
        ".overscroll-contain": {
          "overscroll-behavior": "contain"
        },
        ".overscroll-none": {
          "overscroll-behavior": "none"
        },
        ".overscroll-y-auto": {
          "overscroll-behavior-y": "auto"
        },
        ".overscroll-y-contain": {
          "overscroll-behavior-y": "contain"
        },
        ".overscroll-y-none": {
          "overscroll-behavior-y": "none"
        },
        ".overscroll-x-auto": {
          "overscroll-behavior-x": "auto"
        },
        ".overscroll-x-contain": {
          "overscroll-behavior-x": "contain"
        },
        ".overscroll-x-none": {
          "overscroll-behavior-x": "none"
        }
      });
    },
    scrollBehavior: ({ addUtilities: _ }) => {
      _({
        ".scroll-auto": {
          "scroll-behavior": "auto"
        },
        ".scroll-smooth": {
          "scroll-behavior": "smooth"
        }
      });
    },
    textOverflow: ({ addUtilities: _ }) => {
      _({
        ".truncate": {
          overflow: "hidden",
          "text-overflow": "ellipsis",
          "white-space": "nowrap"
        },
        ".overflow-ellipsis": {
          "text-overflow": "ellipsis"
        },
        ".text-ellipsis": {
          "text-overflow": "ellipsis"
        },
        ".text-clip": {
          "text-overflow": "clip"
        }
      });
    },
    hyphens: ({ addUtilities: _ }) => {
      _({
        ".hyphens-none": {
          hyphens: "none"
        },
        ".hyphens-manual": {
          hyphens: "manual"
        },
        ".hyphens-auto": {
          hyphens: "auto"
        }
      });
    },
    whitespace: ({ addUtilities: _ }) => {
      _({
        ".whitespace-normal": {
          "white-space": "normal"
        },
        ".whitespace-nowrap": {
          "white-space": "nowrap"
        },
        ".whitespace-pre": {
          "white-space": "pre"
        },
        ".whitespace-pre-line": {
          "white-space": "pre-line"
        },
        ".whitespace-pre-wrap": {
          "white-space": "pre-wrap"
        },
        ".whitespace-break-spaces": {
          "white-space": "break-spaces"
        }
      });
    },
    wordBreak: ({ addUtilities: _ }) => {
      _({
        ".break-normal": {
          "overflow-wrap": "normal",
          "word-break": "normal"
        },
        ".break-words": {
          "overflow-wrap": "break-word"
        },
        ".break-all": {
          "word-break": "break-all"
        },
        ".break-keep": {
          "word-break": "keep-all"
        }
      });
    },
    borderRadius: (0, d.default)("borderRadius", [
      [
        "rounded",
        [
          "border-radius"
        ]
      ],
      [
        [
          "rounded-s",
          [
            "border-start-start-radius",
            "border-end-start-radius"
          ]
        ],
        [
          "rounded-e",
          [
            "border-start-end-radius",
            "border-end-end-radius"
          ]
        ],
        [
          "rounded-t",
          [
            "border-top-left-radius",
            "border-top-right-radius"
          ]
        ],
        [
          "rounded-r",
          [
            "border-top-right-radius",
            "border-bottom-right-radius"
          ]
        ],
        [
          "rounded-b",
          [
            "border-bottom-right-radius",
            "border-bottom-left-radius"
          ]
        ],
        [
          "rounded-l",
          [
            "border-top-left-radius",
            "border-bottom-left-radius"
          ]
        ]
      ],
      [
        [
          "rounded-ss",
          [
            "border-start-start-radius"
          ]
        ],
        [
          "rounded-se",
          [
            "border-start-end-radius"
          ]
        ],
        [
          "rounded-ee",
          [
            "border-end-end-radius"
          ]
        ],
        [
          "rounded-es",
          [
            "border-end-start-radius"
          ]
        ],
        [
          "rounded-tl",
          [
            "border-top-left-radius"
          ]
        ],
        [
          "rounded-tr",
          [
            "border-top-right-radius"
          ]
        ],
        [
          "rounded-br",
          [
            "border-bottom-right-radius"
          ]
        ],
        [
          "rounded-bl",
          [
            "border-bottom-left-radius"
          ]
        ]
      ]
    ]),
    borderWidth: (0, d.default)("borderWidth", [
      [
        "border",
        [
          [
            "@defaults border-width",
            {}
          ],
          "border-width"
        ]
      ],
      [
        [
          "border-x",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-left-width",
            "border-right-width"
          ]
        ],
        [
          "border-y",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-top-width",
            "border-bottom-width"
          ]
        ]
      ],
      [
        [
          "border-s",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-inline-start-width"
          ]
        ],
        [
          "border-e",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-inline-end-width"
          ]
        ],
        [
          "border-t",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-top-width"
          ]
        ],
        [
          "border-r",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-right-width"
          ]
        ],
        [
          "border-b",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-bottom-width"
          ]
        ],
        [
          "border-l",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-left-width"
          ]
        ]
      ]
    ], {
      type: [
        "line-width",
        "length"
      ]
    }),
    borderStyle: ({ addUtilities: _ }) => {
      _({
        ".border-solid": {
          "border-style": "solid"
        },
        ".border-dashed": {
          "border-style": "dashed"
        },
        ".border-dotted": {
          "border-style": "dotted"
        },
        ".border-double": {
          "border-style": "double"
        },
        ".border-hidden": {
          "border-style": "hidden"
        },
        ".border-none": {
          "border-style": "none"
        }
      });
    },
    borderColor: ({ matchUtilities: _, theme: S, corePlugins: C }) => {
      _({
        border: (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-color": (0, f.default)(R)
        }
      }, {
        values: (({ DEFAULT: R, ...H }) => H)((0, i.default)(S("borderColor"))),
        type: [
          "color",
          "any"
        ]
      }), _({
        "border-x": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: [
            "border-left-color",
            "border-right-color"
          ],
          variable: "--tw-border-opacity"
        }) : {
          "border-left-color": (0, f.default)(R),
          "border-right-color": (0, f.default)(R)
        },
        "border-y": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: [
            "border-top-color",
            "border-bottom-color"
          ],
          variable: "--tw-border-opacity"
        }) : {
          "border-top-color": (0, f.default)(R),
          "border-bottom-color": (0, f.default)(R)
        }
      }, {
        values: (({ DEFAULT: R, ...H }) => H)((0, i.default)(S("borderColor"))),
        type: [
          "color",
          "any"
        ]
      }), _({
        "border-s": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-inline-start-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-inline-start-color": (0, f.default)(R)
        },
        "border-e": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-inline-end-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-inline-end-color": (0, f.default)(R)
        },
        "border-t": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-top-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-top-color": (0, f.default)(R)
        },
        "border-r": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-right-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-right-color": (0, f.default)(R)
        },
        "border-b": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-bottom-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-bottom-color": (0, f.default)(R)
        },
        "border-l": (R) => C("borderOpacity") ? (0, c.default)({
          color: R,
          property: "border-left-color",
          variable: "--tw-border-opacity"
        }) : {
          "border-left-color": (0, f.default)(R)
        }
      }, {
        values: (({ DEFAULT: R, ...H }) => H)((0, i.default)(S("borderColor"))),
        type: [
          "color",
          "any"
        ]
      });
    },
    borderOpacity: (0, d.default)("borderOpacity", [
      [
        "border-opacity",
        [
          "--tw-border-opacity"
        ]
      ]
    ]),
    backgroundColor: ({ matchUtilities: _, theme: S, corePlugins: C }) => {
      _({
        bg: (R) => C("backgroundOpacity") ? (0, c.default)({
          color: R,
          property: "background-color",
          variable: "--tw-bg-opacity"
        }) : {
          "background-color": (0, f.default)(R)
        }
      }, {
        values: (0, i.default)(S("backgroundColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    backgroundOpacity: (0, d.default)("backgroundOpacity", [
      [
        "bg-opacity",
        [
          "--tw-bg-opacity"
        ]
      ]
    ]),
    backgroundImage: (0, d.default)("backgroundImage", [
      [
        "bg",
        [
          "background-image"
        ]
      ]
    ], {
      type: [
        "lookup",
        "image",
        "url"
      ]
    }),
    gradientColorStops: /* @__PURE__ */ (() => {
      function _(S) {
        return (0, c.withAlphaValue)(S, 0, "rgb(255 255 255 / 0)");
      }
      return function({ matchUtilities: S, theme: C, addDefaults: R }) {
        R("gradient-color-stops", {
          "--tw-gradient-from-position": " ",
          "--tw-gradient-via-position": " ",
          "--tw-gradient-to-position": " "
        });
        let H = {
          values: (0, i.default)(C("gradientColorStops")),
          type: [
            "color",
            "any"
          ]
        }, z = {
          values: C("gradientColorStopPositions"),
          type: [
            "length",
            "percentage"
          ]
        };
        S({
          from: (U) => {
            let P = _(U);
            return {
              "@defaults gradient-color-stops": {},
              "--tw-gradient-from": `${(0, f.default)(U)} var(--tw-gradient-from-position)`,
              "--tw-gradient-to": `${P} var(--tw-gradient-to-position)`,
              "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
            };
          }
        }, H), S({
          from: (U) => ({
            "--tw-gradient-from-position": U
          })
        }, z), S({
          via: (U) => {
            let P = _(U);
            return {
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${P}  var(--tw-gradient-to-position)`,
              "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, f.default)(U)} var(--tw-gradient-via-position), var(--tw-gradient-to)`
            };
          }
        }, H), S({
          via: (U) => ({
            "--tw-gradient-via-position": U
          })
        }, z), S({
          to: (U) => ({
            "@defaults gradient-color-stops": {},
            "--tw-gradient-to": `${(0, f.default)(U)} var(--tw-gradient-to-position)`
          })
        }, H), S({
          to: (U) => ({
            "--tw-gradient-to-position": U
          })
        }, z);
      };
    })(),
    boxDecorationBreak: ({ addUtilities: _ }) => {
      _({
        ".decoration-slice": {
          "box-decoration-break": "slice"
        },
        ".decoration-clone": {
          "box-decoration-break": "clone"
        },
        ".box-decoration-slice": {
          "box-decoration-break": "slice"
        },
        ".box-decoration-clone": {
          "box-decoration-break": "clone"
        }
      });
    },
    backgroundSize: (0, d.default)("backgroundSize", [
      [
        "bg",
        [
          "background-size"
        ]
      ]
    ], {
      type: [
        "lookup",
        "length",
        "percentage",
        "size"
      ]
    }),
    backgroundAttachment: ({ addUtilities: _ }) => {
      _({
        ".bg-fixed": {
          "background-attachment": "fixed"
        },
        ".bg-local": {
          "background-attachment": "local"
        },
        ".bg-scroll": {
          "background-attachment": "scroll"
        }
      });
    },
    backgroundClip: ({ addUtilities: _ }) => {
      _({
        ".bg-clip-border": {
          "background-clip": "border-box"
        },
        ".bg-clip-padding": {
          "background-clip": "padding-box"
        },
        ".bg-clip-content": {
          "background-clip": "content-box"
        },
        ".bg-clip-text": {
          "background-clip": "text"
        }
      });
    },
    backgroundPosition: (0, d.default)("backgroundPosition", [
      [
        "bg",
        [
          "background-position"
        ]
      ]
    ], {
      type: [
        "lookup",
        [
          "position",
          {
            preferOnConflict: !0
          }
        ]
      ]
    }),
    backgroundRepeat: ({ addUtilities: _ }) => {
      _({
        ".bg-repeat": {
          "background-repeat": "repeat"
        },
        ".bg-no-repeat": {
          "background-repeat": "no-repeat"
        },
        ".bg-repeat-x": {
          "background-repeat": "repeat-x"
        },
        ".bg-repeat-y": {
          "background-repeat": "repeat-y"
        },
        ".bg-repeat-round": {
          "background-repeat": "round"
        },
        ".bg-repeat-space": {
          "background-repeat": "space"
        }
      });
    },
    backgroundOrigin: ({ addUtilities: _ }) => {
      _({
        ".bg-origin-border": {
          "background-origin": "border-box"
        },
        ".bg-origin-padding": {
          "background-origin": "padding-box"
        },
        ".bg-origin-content": {
          "background-origin": "content-box"
        }
      });
    },
    fill: ({ matchUtilities: _, theme: S }) => {
      _({
        fill: (C) => ({
          fill: (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("fill")),
        type: [
          "color",
          "any"
        ]
      });
    },
    stroke: ({ matchUtilities: _, theme: S }) => {
      _({
        stroke: (C) => ({
          stroke: (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("stroke")),
        type: [
          "color",
          "url",
          "any"
        ]
      });
    },
    strokeWidth: (0, d.default)("strokeWidth", [
      [
        "stroke",
        [
          "stroke-width"
        ]
      ]
    ], {
      type: [
        "length",
        "number",
        "percentage"
      ]
    }),
    objectFit: ({ addUtilities: _ }) => {
      _({
        ".object-contain": {
          "object-fit": "contain"
        },
        ".object-cover": {
          "object-fit": "cover"
        },
        ".object-fill": {
          "object-fit": "fill"
        },
        ".object-none": {
          "object-fit": "none"
        },
        ".object-scale-down": {
          "object-fit": "scale-down"
        }
      });
    },
    objectPosition: (0, d.default)("objectPosition", [
      [
        "object",
        [
          "object-position"
        ]
      ]
    ]),
    padding: (0, d.default)("padding", [
      [
        "p",
        [
          "padding"
        ]
      ],
      [
        [
          "px",
          [
            "padding-left",
            "padding-right"
          ]
        ],
        [
          "py",
          [
            "padding-top",
            "padding-bottom"
          ]
        ]
      ],
      [
        [
          "ps",
          [
            "padding-inline-start"
          ]
        ],
        [
          "pe",
          [
            "padding-inline-end"
          ]
        ],
        [
          "pt",
          [
            "padding-top"
          ]
        ],
        [
          "pr",
          [
            "padding-right"
          ]
        ],
        [
          "pb",
          [
            "padding-bottom"
          ]
        ],
        [
          "pl",
          [
            "padding-left"
          ]
        ]
      ]
    ]),
    textAlign: ({ addUtilities: _ }) => {
      _({
        ".text-left": {
          "text-align": "left"
        },
        ".text-center": {
          "text-align": "center"
        },
        ".text-right": {
          "text-align": "right"
        },
        ".text-justify": {
          "text-align": "justify"
        },
        ".text-start": {
          "text-align": "start"
        },
        ".text-end": {
          "text-align": "end"
        }
      });
    },
    textIndent: (0, d.default)("textIndent", [
      [
        "indent",
        [
          "text-indent"
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    verticalAlign: ({ addUtilities: _, matchUtilities: S }) => {
      _({
        ".align-baseline": {
          "vertical-align": "baseline"
        },
        ".align-top": {
          "vertical-align": "top"
        },
        ".align-middle": {
          "vertical-align": "middle"
        },
        ".align-bottom": {
          "vertical-align": "bottom"
        },
        ".align-text-top": {
          "vertical-align": "text-top"
        },
        ".align-text-bottom": {
          "vertical-align": "text-bottom"
        },
        ".align-sub": {
          "vertical-align": "sub"
        },
        ".align-super": {
          "vertical-align": "super"
        }
      }), S({
        align: (C) => ({
          "vertical-align": C
        })
      });
    },
    fontFamily: ({ matchUtilities: _, theme: S }) => {
      _({
        font: (C) => {
          let [R, H = {}] = Array.isArray(C) && (0, s.default)(C[1]) ? C : [
            C
          ], { fontFeatureSettings: z, fontVariationSettings: U } = H;
          return {
            "font-family": Array.isArray(R) ? R.join(", ") : R,
            ...z === void 0 ? {} : {
              "font-feature-settings": z
            },
            ...U === void 0 ? {} : {
              "font-variation-settings": U
            }
          };
        }
      }, {
        values: S("fontFamily"),
        type: [
          "lookup",
          "generic-name",
          "family-name"
        ]
      });
    },
    fontSize: ({ matchUtilities: _, theme: S }) => {
      _({
        text: (C, { modifier: R }) => {
          let [H, z] = Array.isArray(C) ? C : [
            C
          ];
          if (R)
            return {
              "font-size": H,
              "line-height": R
            };
          let { lineHeight: U, letterSpacing: P, fontWeight: W } = (0, s.default)(z) ? z : {
            lineHeight: z
          };
          return {
            "font-size": H,
            ...U === void 0 ? {} : {
              "line-height": U
            },
            ...P === void 0 ? {} : {
              "letter-spacing": P
            },
            ...W === void 0 ? {} : {
              "font-weight": W
            }
          };
        }
      }, {
        values: S("fontSize"),
        modifiers: S("lineHeight"),
        type: [
          "absolute-size",
          "relative-size",
          "length",
          "percentage"
        ]
      });
    },
    fontWeight: (0, d.default)("fontWeight", [
      [
        "font",
        [
          "fontWeight"
        ]
      ]
    ], {
      type: [
        "lookup",
        "number",
        "any"
      ]
    }),
    textTransform: ({ addUtilities: _ }) => {
      _({
        ".uppercase": {
          "text-transform": "uppercase"
        },
        ".lowercase": {
          "text-transform": "lowercase"
        },
        ".capitalize": {
          "text-transform": "capitalize"
        },
        ".normal-case": {
          "text-transform": "none"
        }
      });
    },
    fontStyle: ({ addUtilities: _ }) => {
      _({
        ".italic": {
          "font-style": "italic"
        },
        ".not-italic": {
          "font-style": "normal"
        }
      });
    },
    fontVariantNumeric: ({ addDefaults: _, addUtilities: S }) => {
      let C = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
      _("font-variant-numeric", {
        "--tw-ordinal": " ",
        "--tw-slashed-zero": " ",
        "--tw-numeric-figure": " ",
        "--tw-numeric-spacing": " ",
        "--tw-numeric-fraction": " "
      }), S({
        ".normal-nums": {
          "font-variant-numeric": "normal"
        },
        ".ordinal": {
          "@defaults font-variant-numeric": {},
          "--tw-ordinal": "ordinal",
          "font-variant-numeric": C
        },
        ".slashed-zero": {
          "@defaults font-variant-numeric": {},
          "--tw-slashed-zero": "slashed-zero",
          "font-variant-numeric": C
        },
        ".lining-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "lining-nums",
          "font-variant-numeric": C
        },
        ".oldstyle-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-figure": "oldstyle-nums",
          "font-variant-numeric": C
        },
        ".proportional-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "proportional-nums",
          "font-variant-numeric": C
        },
        ".tabular-nums": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-spacing": "tabular-nums",
          "font-variant-numeric": C
        },
        ".diagonal-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "diagonal-fractions",
          "font-variant-numeric": C
        },
        ".stacked-fractions": {
          "@defaults font-variant-numeric": {},
          "--tw-numeric-fraction": "stacked-fractions",
          "font-variant-numeric": C
        }
      });
    },
    lineHeight: (0, d.default)("lineHeight", [
      [
        "leading",
        [
          "lineHeight"
        ]
      ]
    ]),
    letterSpacing: (0, d.default)("letterSpacing", [
      [
        "tracking",
        [
          "letterSpacing"
        ]
      ]
    ], {
      supportsNegativeValues: !0
    }),
    textColor: ({ matchUtilities: _, theme: S, corePlugins: C }) => {
      _({
        text: (R) => C("textOpacity") ? (0, c.default)({
          color: R,
          property: "color",
          variable: "--tw-text-opacity"
        }) : {
          color: (0, f.default)(R)
        }
      }, {
        values: (0, i.default)(S("textColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    textOpacity: (0, d.default)("textOpacity", [
      [
        "text-opacity",
        [
          "--tw-text-opacity"
        ]
      ]
    ]),
    textDecoration: ({ addUtilities: _ }) => {
      _({
        ".underline": {
          "text-decoration-line": "underline"
        },
        ".overline": {
          "text-decoration-line": "overline"
        },
        ".line-through": {
          "text-decoration-line": "line-through"
        },
        ".no-underline": {
          "text-decoration-line": "none"
        }
      });
    },
    textDecorationColor: ({ matchUtilities: _, theme: S }) => {
      _({
        decoration: (C) => ({
          "text-decoration-color": (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("textDecorationColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    textDecorationStyle: ({ addUtilities: _ }) => {
      _({
        ".decoration-solid": {
          "text-decoration-style": "solid"
        },
        ".decoration-double": {
          "text-decoration-style": "double"
        },
        ".decoration-dotted": {
          "text-decoration-style": "dotted"
        },
        ".decoration-dashed": {
          "text-decoration-style": "dashed"
        },
        ".decoration-wavy": {
          "text-decoration-style": "wavy"
        }
      });
    },
    textDecorationThickness: (0, d.default)("textDecorationThickness", [
      [
        "decoration",
        [
          "text-decoration-thickness"
        ]
      ]
    ], {
      type: [
        "length",
        "percentage"
      ]
    }),
    textUnderlineOffset: (0, d.default)("textUnderlineOffset", [
      [
        "underline-offset",
        [
          "text-underline-offset"
        ]
      ]
    ], {
      type: [
        "length",
        "percentage",
        "any"
      ]
    }),
    fontSmoothing: ({ addUtilities: _ }) => {
      _({
        ".antialiased": {
          "-webkit-font-smoothing": "antialiased",
          "-moz-osx-font-smoothing": "grayscale"
        },
        ".subpixel-antialiased": {
          "-webkit-font-smoothing": "auto",
          "-moz-osx-font-smoothing": "auto"
        }
      });
    },
    placeholderColor: ({ matchUtilities: _, theme: S, corePlugins: C }) => {
      _({
        placeholder: (R) => C("placeholderOpacity") ? {
          "&::placeholder": (0, c.default)({
            color: R,
            property: "color",
            variable: "--tw-placeholder-opacity"
          })
        } : {
          "&::placeholder": {
            color: (0, f.default)(R)
          }
        }
      }, {
        values: (0, i.default)(S("placeholderColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    placeholderOpacity: ({ matchUtilities: _, theme: S }) => {
      _({
        "placeholder-opacity": (C) => ({
          "&::placeholder": {
            "--tw-placeholder-opacity": C
          }
        })
      }, {
        values: S("placeholderOpacity")
      });
    },
    caretColor: ({ matchUtilities: _, theme: S }) => {
      _({
        caret: (C) => ({
          "caret-color": (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("caretColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    accentColor: ({ matchUtilities: _, theme: S }) => {
      _({
        accent: (C) => ({
          "accent-color": (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("accentColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    opacity: (0, d.default)("opacity", [
      [
        "opacity",
        [
          "opacity"
        ]
      ]
    ]),
    backgroundBlendMode: ({ addUtilities: _ }) => {
      _({
        ".bg-blend-normal": {
          "background-blend-mode": "normal"
        },
        ".bg-blend-multiply": {
          "background-blend-mode": "multiply"
        },
        ".bg-blend-screen": {
          "background-blend-mode": "screen"
        },
        ".bg-blend-overlay": {
          "background-blend-mode": "overlay"
        },
        ".bg-blend-darken": {
          "background-blend-mode": "darken"
        },
        ".bg-blend-lighten": {
          "background-blend-mode": "lighten"
        },
        ".bg-blend-color-dodge": {
          "background-blend-mode": "color-dodge"
        },
        ".bg-blend-color-burn": {
          "background-blend-mode": "color-burn"
        },
        ".bg-blend-hard-light": {
          "background-blend-mode": "hard-light"
        },
        ".bg-blend-soft-light": {
          "background-blend-mode": "soft-light"
        },
        ".bg-blend-difference": {
          "background-blend-mode": "difference"
        },
        ".bg-blend-exclusion": {
          "background-blend-mode": "exclusion"
        },
        ".bg-blend-hue": {
          "background-blend-mode": "hue"
        },
        ".bg-blend-saturation": {
          "background-blend-mode": "saturation"
        },
        ".bg-blend-color": {
          "background-blend-mode": "color"
        },
        ".bg-blend-luminosity": {
          "background-blend-mode": "luminosity"
        }
      });
    },
    mixBlendMode: ({ addUtilities: _ }) => {
      _({
        ".mix-blend-normal": {
          "mix-blend-mode": "normal"
        },
        ".mix-blend-multiply": {
          "mix-blend-mode": "multiply"
        },
        ".mix-blend-screen": {
          "mix-blend-mode": "screen"
        },
        ".mix-blend-overlay": {
          "mix-blend-mode": "overlay"
        },
        ".mix-blend-darken": {
          "mix-blend-mode": "darken"
        },
        ".mix-blend-lighten": {
          "mix-blend-mode": "lighten"
        },
        ".mix-blend-color-dodge": {
          "mix-blend-mode": "color-dodge"
        },
        ".mix-blend-color-burn": {
          "mix-blend-mode": "color-burn"
        },
        ".mix-blend-hard-light": {
          "mix-blend-mode": "hard-light"
        },
        ".mix-blend-soft-light": {
          "mix-blend-mode": "soft-light"
        },
        ".mix-blend-difference": {
          "mix-blend-mode": "difference"
        },
        ".mix-blend-exclusion": {
          "mix-blend-mode": "exclusion"
        },
        ".mix-blend-hue": {
          "mix-blend-mode": "hue"
        },
        ".mix-blend-saturation": {
          "mix-blend-mode": "saturation"
        },
        ".mix-blend-color": {
          "mix-blend-mode": "color"
        },
        ".mix-blend-luminosity": {
          "mix-blend-mode": "luminosity"
        },
        ".mix-blend-plus-lighter": {
          "mix-blend-mode": "plus-lighter"
        }
      });
    },
    boxShadow: (() => {
      let _ = (0, o.default)("boxShadow"), S = [
        "var(--tw-ring-offset-shadow, 0 0 #0000)",
        "var(--tw-ring-shadow, 0 0 #0000)",
        "var(--tw-shadow)"
      ].join(", ");
      return function({ matchUtilities: C, addDefaults: R, theme: H }) {
        R(" box-shadow", {
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        }), C({
          shadow: (z) => {
            z = _(z);
            let U = (0, b.parseBoxShadowValue)(z);
            for (let P of U)
              P.valid && (P.color = "var(--tw-shadow-color)");
            return {
              "@defaults box-shadow": {},
              "--tw-shadow": z === "none" ? "0 0 #0000" : z,
              "--tw-shadow-colored": z === "none" ? "0 0 #0000" : (0, b.formatBoxShadowValue)(U),
              "box-shadow": S
            };
          }
        }, {
          values: H("boxShadow"),
          type: [
            "shadow"
          ]
        });
      };
    })(),
    boxShadowColor: ({ matchUtilities: _, theme: S }) => {
      _({
        shadow: (C) => ({
          "--tw-shadow-color": (0, f.default)(C),
          "--tw-shadow": "var(--tw-shadow-colored)"
        })
      }, {
        values: (0, i.default)(S("boxShadowColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    outlineStyle: ({ addUtilities: _ }) => {
      _({
        ".outline-none": {
          outline: "2px solid transparent",
          "outline-offset": "2px"
        },
        ".outline": {
          "outline-style": "solid"
        },
        ".outline-dashed": {
          "outline-style": "dashed"
        },
        ".outline-dotted": {
          "outline-style": "dotted"
        },
        ".outline-double": {
          "outline-style": "double"
        }
      });
    },
    outlineWidth: (0, d.default)("outlineWidth", [
      [
        "outline",
        [
          "outline-width"
        ]
      ]
    ], {
      type: [
        "length",
        "number",
        "percentage"
      ]
    }),
    outlineOffset: (0, d.default)("outlineOffset", [
      [
        "outline-offset",
        [
          "outline-offset"
        ]
      ]
    ], {
      type: [
        "length",
        "number",
        "percentage",
        "any"
      ],
      supportsNegativeValues: !0
    }),
    outlineColor: ({ matchUtilities: _, theme: S }) => {
      _({
        outline: (C) => ({
          "outline-color": (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("outlineColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    ringWidth: ({ matchUtilities: _, addDefaults: S, addUtilities: C, theme: R, config: H }) => {
      let z = (() => {
        var U, P;
        if ((0, T.flagEnabled)(H(), "respectDefaultRingColorOpacity"))
          return R("ringColor.DEFAULT");
        let W = R("ringOpacity.DEFAULT", "0.5");
        return !((U = R("ringColor")) === null || U === void 0) && U.DEFAULT ? (0, c.withAlphaValue)((P = R("ringColor")) === null || P === void 0 ? void 0 : P.DEFAULT, W, `rgb(147 197 253 / ${W})`) : `rgb(147 197 253 / ${W})`;
      })();
      S("ring-width", {
        "--tw-ring-inset": " ",
        "--tw-ring-offset-width": R("ringOffsetWidth.DEFAULT", "0px"),
        "--tw-ring-offset-color": R("ringOffsetColor.DEFAULT", "#fff"),
        "--tw-ring-color": z,
        "--tw-ring-offset-shadow": "0 0 #0000",
        "--tw-ring-shadow": "0 0 #0000",
        "--tw-shadow": "0 0 #0000",
        "--tw-shadow-colored": "0 0 #0000"
      }), _({
        ring: (U) => ({
          "@defaults ring-width": {},
          "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
          "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${U} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
          "box-shadow": [
            "var(--tw-ring-offset-shadow)",
            "var(--tw-ring-shadow)",
            "var(--tw-shadow, 0 0 #0000)"
          ].join(", ")
        })
      }, {
        values: R("ringWidth"),
        type: "length"
      }), C({
        ".ring-inset": {
          "@defaults ring-width": {},
          "--tw-ring-inset": "inset"
        }
      });
    },
    ringColor: ({ matchUtilities: _, theme: S, corePlugins: C }) => {
      _({
        ring: (R) => C("ringOpacity") ? (0, c.default)({
          color: R,
          property: "--tw-ring-color",
          variable: "--tw-ring-opacity"
        }) : {
          "--tw-ring-color": (0, f.default)(R)
        }
      }, {
        values: Object.fromEntries(Object.entries((0, i.default)(S("ringColor"))).filter(([R]) => R !== "DEFAULT")),
        type: [
          "color",
          "any"
        ]
      });
    },
    ringOpacity: (_) => {
      let { config: S } = _;
      return (0, d.default)("ringOpacity", [
        [
          "ring-opacity",
          [
            "--tw-ring-opacity"
          ]
        ]
      ], {
        filterDefault: !(0, T.flagEnabled)(S(), "respectDefaultRingColorOpacity")
      })(_);
    },
    ringOffsetWidth: (0, d.default)("ringOffsetWidth", [
      [
        "ring-offset",
        [
          "--tw-ring-offset-width"
        ]
      ]
    ], {
      type: "length"
    }),
    ringOffsetColor: ({ matchUtilities: _, theme: S }) => {
      _({
        "ring-offset": (C) => ({
          "--tw-ring-offset-color": (0, f.default)(C)
        })
      }, {
        values: (0, i.default)(S("ringOffsetColor")),
        type: [
          "color",
          "any"
        ]
      });
    },
    blur: ({ matchUtilities: _, theme: S }) => {
      _({
        blur: (C) => ({
          "--tw-blur": `blur(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("blur")
      });
    },
    brightness: ({ matchUtilities: _, theme: S }) => {
      _({
        brightness: (C) => ({
          "--tw-brightness": `brightness(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("brightness")
      });
    },
    contrast: ({ matchUtilities: _, theme: S }) => {
      _({
        contrast: (C) => ({
          "--tw-contrast": `contrast(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("contrast")
      });
    },
    dropShadow: ({ matchUtilities: _, theme: S }) => {
      _({
        "drop-shadow": (C) => ({
          "--tw-drop-shadow": Array.isArray(C) ? C.map((R) => `drop-shadow(${R})`).join(" ") : `drop-shadow(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("dropShadow")
      });
    },
    grayscale: ({ matchUtilities: _, theme: S }) => {
      _({
        grayscale: (C) => ({
          "--tw-grayscale": `grayscale(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("grayscale")
      });
    },
    hueRotate: ({ matchUtilities: _, theme: S }) => {
      _({
        "hue-rotate": (C) => ({
          "--tw-hue-rotate": `hue-rotate(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("hueRotate"),
        supportsNegativeValues: !0
      });
    },
    invert: ({ matchUtilities: _, theme: S }) => {
      _({
        invert: (C) => ({
          "--tw-invert": `invert(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("invert")
      });
    },
    saturate: ({ matchUtilities: _, theme: S }) => {
      _({
        saturate: (C) => ({
          "--tw-saturate": `saturate(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("saturate")
      });
    },
    sepia: ({ matchUtilities: _, theme: S }) => {
      _({
        sepia: (C) => ({
          "--tw-sepia": `sepia(${C})`,
          "@defaults filter": {},
          filter: L
        })
      }, {
        values: S("sepia")
      });
    },
    filter: ({ addDefaults: _, addUtilities: S }) => {
      _("filter", {
        "--tw-blur": " ",
        "--tw-brightness": " ",
        "--tw-contrast": " ",
        "--tw-grayscale": " ",
        "--tw-hue-rotate": " ",
        "--tw-invert": " ",
        "--tw-saturate": " ",
        "--tw-sepia": " ",
        "--tw-drop-shadow": " "
      }), S({
        ".filter": {
          "@defaults filter": {},
          filter: L
        },
        ".filter-none": {
          filter: "none"
        }
      });
    },
    backdropBlur: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-blur": (C) => ({
          "--tw-backdrop-blur": `blur(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropBlur")
      });
    },
    backdropBrightness: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-brightness": (C) => ({
          "--tw-backdrop-brightness": `brightness(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropBrightness")
      });
    },
    backdropContrast: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-contrast": (C) => ({
          "--tw-backdrop-contrast": `contrast(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropContrast")
      });
    },
    backdropGrayscale: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-grayscale": (C) => ({
          "--tw-backdrop-grayscale": `grayscale(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropGrayscale")
      });
    },
    backdropHueRotate: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-hue-rotate": (C) => ({
          "--tw-backdrop-hue-rotate": `hue-rotate(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropHueRotate"),
        supportsNegativeValues: !0
      });
    },
    backdropInvert: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-invert": (C) => ({
          "--tw-backdrop-invert": `invert(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropInvert")
      });
    },
    backdropOpacity: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-opacity": (C) => ({
          "--tw-backdrop-opacity": `opacity(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropOpacity")
      });
    },
    backdropSaturate: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-saturate": (C) => ({
          "--tw-backdrop-saturate": `saturate(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropSaturate")
      });
    },
    backdropSepia: ({ matchUtilities: _, theme: S }) => {
      _({
        "backdrop-sepia": (C) => ({
          "--tw-backdrop-sepia": `sepia(${C})`,
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        })
      }, {
        values: S("backdropSepia")
      });
    },
    backdropFilter: ({ addDefaults: _, addUtilities: S }) => {
      _("backdrop-filter", {
        "--tw-backdrop-blur": " ",
        "--tw-backdrop-brightness": " ",
        "--tw-backdrop-contrast": " ",
        "--tw-backdrop-grayscale": " ",
        "--tw-backdrop-hue-rotate": " ",
        "--tw-backdrop-invert": " ",
        "--tw-backdrop-opacity": " ",
        "--tw-backdrop-saturate": " ",
        "--tw-backdrop-sepia": " "
      }), S({
        ".backdrop-filter": {
          "@defaults backdrop-filter": {},
          "backdrop-filter": M
        },
        ".backdrop-filter-none": {
          "backdrop-filter": "none"
        }
      });
    },
    transitionProperty: ({ matchUtilities: _, theme: S }) => {
      let C = S("transitionTimingFunction.DEFAULT"), R = S("transitionDuration.DEFAULT");
      _({
        transition: (H) => ({
          "transition-property": H,
          ...H === "none" ? {} : {
            "transition-timing-function": C,
            "transition-duration": R
          }
        })
      }, {
        values: S("transitionProperty")
      });
    },
    transitionDelay: (0, d.default)("transitionDelay", [
      [
        "delay",
        [
          "transitionDelay"
        ]
      ]
    ]),
    transitionDuration: (0, d.default)("transitionDuration", [
      [
        "duration",
        [
          "transitionDuration"
        ]
      ]
    ], {
      filterDefault: !0
    }),
    transitionTimingFunction: (0, d.default)("transitionTimingFunction", [
      [
        "ease",
        [
          "transitionTimingFunction"
        ]
      ]
    ], {
      filterDefault: !0
    }),
    willChange: (0, d.default)("willChange", [
      [
        "will-change",
        [
          "will-change"
        ]
      ]
    ]),
    content: (0, d.default)("content", [
      [
        "content",
        [
          "--tw-content",
          [
            "content",
            "var(--tw-content)"
          ]
        ]
      ]
    ])
  };
})(EA);
var mo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(s, o) {
    for (var y in o) Object.defineProperty(s, y, {
      enumerable: !0,
      get: o[y]
    });
  }
  e(t, {
    env: function() {
      return l;
    },
    contextMap: function() {
      return d;
    },
    configContextMap: function() {
      return h;
    },
    contextSourcesMap: function() {
      return n;
    },
    sourceHashMap: function() {
      return u;
    },
    NOT_ON_DEMAND: function() {
      return i;
    },
    NONE: function() {
      return c;
    },
    resolveDebug: function() {
      return f;
    }
  });
  const r = /* @__PURE__ */ a(xA);
  function a(s) {
    return s && s.__esModule ? s : {
      default: s
    };
  }
  const l = typeof Ze < "u" ? {
    NODE_ENV: Ze.env.NODE_ENV,
    DEBUG: f(Ze.env.DEBUG),
    ENGINE: r.default.tailwindcss.engine
  } : {
    NODE_ENV: "production",
    DEBUG: !1,
    ENGINE: r.default.tailwindcss.engine
  }, d = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), i = new String("*"), c = Symbol("__NONE__");
  function f(s) {
    if (s === void 0)
      return !1;
    if (s === "true" || s === "1")
      return !0;
    if (s === "false" || s === "0")
      return !1;
    if (s === "*")
      return !0;
    let o = s.split(",").map((y) => y.split(":")[0]);
    return o.includes("-tailwindcss") ? !1 : !!o.includes("tailwindcss");
  }
})(mo);
var bb = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(
    t,
    // Arbitrary values must contain balanced brackets (), [] and {}. Escaped
    // values don't count, and brackets inside quotes also don't count.
    //
    // E.g.: w-[this-is]w-[weird-and-invalid]
    // E.g.: w-[this-is\\]w-\\[weird-but-valid]
    // E.g.: content-['this-is-also-valid]-weirdly-enough']
    "default",
    {
      enumerable: !0,
      get: function() {
        return l;
      }
    }
  );
  let e = /* @__PURE__ */ new Map([
    [
      "{",
      "}"
    ],
    [
      "[",
      "]"
    ],
    [
      "(",
      ")"
    ]
  ]), r = new Map(Array.from(e.entries()).map(([d, h]) => [
    h,
    d
  ])), a = /* @__PURE__ */ new Set([
    '"',
    "'",
    "`"
  ]);
  function l(d) {
    let h = [], n = !1;
    for (let u = 0; u < d.length; u++) {
      let i = d[u];
      if (i === ":" && !n && h.length === 0)
        return !1;
      if (a.has(i) && d[u - 1] !== "\\" && (n = !n), !n && d[u - 1] !== "\\") {
        if (e.has(i))
          h.push(i);
        else if (r.has(i)) {
          let c = r.get(i);
          if (h.length <= 0 || h.pop() !== c)
            return !1;
        }
      }
    }
    return !(h.length > 0);
  }
})(bb);
var Jh = {}, gb = {}, Yd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "movePseudos", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  let e = {
    "::after": [
      "terminal",
      "jumpable"
    ],
    "::backdrop": [
      "terminal"
    ],
    "::before": [
      "terminal",
      "jumpable"
    ],
    "::cue": [
      "terminal"
    ],
    "::cue-region": [
      "terminal"
    ],
    "::first-letter": [
      "terminal",
      "jumpable"
    ],
    "::first-line": [
      "terminal",
      "jumpable"
    ],
    "::grammar-error": [
      "terminal"
    ],
    "::marker": [
      "terminal"
    ],
    "::part": [
      "terminal",
      "actionable"
    ],
    "::placeholder": [
      "terminal"
    ],
    "::selection": [
      "terminal"
    ],
    "::slotted": [
      "terminal"
    ],
    "::spelling-error": [
      "terminal"
    ],
    "::target-text": [
      "terminal"
    ],
    // other
    "::file-selector-button": [
      "terminal",
      "actionable"
    ],
    "::-webkit-progress-bar": [
      "terminal",
      "actionable"
    ],
    // Webkit scroll bar pseudo elements can be combined with user-action pseudo classes
    "::-webkit-scrollbar": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-button": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-thumb": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-track": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-track-piece": [
      "terminal",
      "actionable"
    ],
    "::-webkit-scrollbar-corner": [
      "terminal",
      "actionable"
    ],
    "::-webkit-resizer": [
      "terminal",
      "actionable"
    ],
    // Note: As a rule, double colons (::) should be used instead of a single colon
    // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
    // this distinction was not present in older versions of the W3C spec, most
    // browsers support both syntaxes for the original pseudo-elements.
    ":after": [
      "terminal",
      "jumpable"
    ],
    ":before": [
      "terminal",
      "jumpable"
    ],
    ":first-letter": [
      "terminal",
      "jumpable"
    ],
    ":first-line": [
      "terminal",
      "jumpable"
    ],
    // The default value is used when the pseudo-element is not recognized
    // Because it's not recognized, we don't know if it's terminal or not
    // So we assume it can't be moved AND can have user-action pseudo classes attached to it
    __default__: [
      "actionable"
    ]
  };
  function r(u) {
    let [i] = a(u);
    return i.forEach(([c, f]) => c.removeChild(f)), u.nodes.push(...i.map(([, c]) => c)), u;
  }
  function a(u) {
    let i = [], c = null;
    for (let s of u.nodes)
      if (s.type === "combinator")
        i = i.filter(([, o]) => n(o).includes("jumpable")), c = null;
      else if (s.type === "pseudo") {
        d(s) ? (c = s, i.push([
          u,
          s,
          null
        ])) : c && h(s, c) ? i.push([
          u,
          s,
          c
        ]) : c = null;
        var f;
        for (let o of (f = s.nodes) !== null && f !== void 0 ? f : []) {
          let [y, m] = a(o);
          c = m || c, i.push(...y);
        }
      }
    return [
      i,
      c
    ];
  }
  function l(u) {
    return u.value.startsWith("::") || e[u.value] !== void 0;
  }
  function d(u) {
    return l(u) && n(u).includes("terminal");
  }
  function h(u, i) {
    return u.type !== "pseudo" || l(u) ? !1 : n(i).includes("actionable");
  }
  function n(u) {
    var i;
    return (i = e[u.value]) !== null && i !== void 0 ? i : e.__default__;
  }
})(Yd);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(m, g) {
    for (var b in g) Object.defineProperty(m, b, {
      enumerable: !0,
      get: g[b]
    });
  }
  e(t, {
    formatVariantSelector: function() {
      return i;
    },
    eliminateIrrelevantSelectors: function() {
      return s;
    },
    finalizeSelector: function() {
      return o;
    },
    handleMergePseudo: function() {
      return y;
    }
  });
  const r = /* @__PURE__ */ n(ua), a = /* @__PURE__ */ n(tb), l = /* @__PURE__ */ n(Pl), d = /* @__PURE__ */ n(Gd), h = Yd;
  function n(m) {
    return m && m.__esModule ? m : {
      default: m
    };
  }
  let u = ":merge";
  function i(m, { context: g, candidate: b }) {
    var v;
    let T = (v = g == null ? void 0 : g.tailwindConfig.prefix) !== null && v !== void 0 ? v : "", E = m.map((D) => {
      let $ = (0, r.default)().astSync(D.format);
      return {
        ...D,
        ast: D.isArbitraryVariant ? $ : (0, d.default)(T, $)
      };
    }), O = r.default.root({
      nodes: [
        r.default.selector({
          nodes: [
            r.default.className({
              value: (0, l.default)(b)
            })
          ]
        })
      ]
    });
    for (let { ast: D } of E)
      [O, D] = y(O, D), D.walkNesting(($) => $.replaceWith(...O.nodes[0].nodes)), O = D;
    return O;
  }
  function c(m) {
    let g = [];
    for (; m.prev() && m.prev().type !== "combinator"; )
      m = m.prev();
    for (; m && m.type !== "combinator"; )
      g.push(m), m = m.next();
    return g;
  }
  function f(m) {
    return m.sort((g, b) => g.type === "tag" && b.type === "class" ? -1 : g.type === "class" && b.type === "tag" ? 1 : g.type === "class" && b.type === "pseudo" && b.value.startsWith("::") ? -1 : g.type === "pseudo" && g.value.startsWith("::") && b.type === "class" ? 1 : m.index(g) - m.index(b)), m;
  }
  function s(m, g) {
    let b = !1;
    m.walk((v) => {
      if (v.type === "class" && v.value === g)
        return b = !0, !1;
    }), b || m.remove();
  }
  function o(m, g, { context: b, candidate: v, base: T }) {
    var E, O;
    let D = (O = b == null || (E = b.tailwindConfig) === null || E === void 0 ? void 0 : E.separator) !== null && O !== void 0 ? O : ":";
    T = T ?? v.split(new RegExp(`\\${D}(?![^[]*\\])`)).pop();
    let $ = (0, r.default)().astSync(m);
    $.walkClasses((M) => {
      M.raws && M.value.includes(T) && (M.raws.value = (0, l.default)((0, a.default)(M.raws.value)));
    }), $.each((M) => s(M, T));
    let I = Array.isArray(g) ? i(g, {
      context: b,
      candidate: v
    }) : g;
    if (I === null)
      return $.toString();
    let k = r.default.comment({
      value: "/*__simple__*/"
    }), L = r.default.comment({
      value: "/*__simple__*/"
    });
    return $.walkClasses((M) => {
      if (M.value !== T)
        return;
      let x = M.parent, _ = I.nodes[0].nodes;
      if (x.nodes.length === 1) {
        M.replaceWith(..._);
        return;
      }
      let S = c(M);
      x.insertBefore(S[0], k), x.insertAfter(S[S.length - 1], L);
      for (let R of _)
        x.insertBefore(S[0], R.clone());
      M.remove(), S = c(k);
      let C = x.index(k);
      x.nodes.splice(C, S.length, ...f(r.default.selector({
        nodes: S
      })).nodes), k.remove(), L.remove();
    }), $.walkPseudos((M) => {
      M.value === u && M.replaceWith(M.nodes);
    }), $.each((M) => (0, h.movePseudos)(M)), $.toString();
  }
  function y(m, g) {
    let b = [];
    return m.walkPseudos((v) => {
      v.value === u && b.push({
        pseudo: v,
        value: v.nodes[0].toString()
      });
    }), g.walkPseudos((v) => {
      if (v.value !== u)
        return;
      let T = v.nodes[0].toString(), E = b.find((I) => I.value === T);
      if (!E)
        return;
      let O = [], D = v.next();
      for (; D && D.type !== "combinator"; )
        O.push(D), D = D.next();
      let $ = D;
      E.pseudo.parent.insertAfter(E.pseudo, r.default.selector({
        nodes: O.map((I) => I.clone())
      })), v.remove(), O.forEach((I) => I.remove()), $ && $.type === "combinator" && $.remove();
    }), [
      m,
      g
    ];
  }
})(gb);
var vb = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "applyImportantSelector", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(ua), r = Yd;
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l(d, h) {
    let n = (0, e.default)().astSync(d);
    return n.each((u) => {
      u.nodes[0].type === "pseudo" && u.nodes[0].value === ":is" && u.nodes.every((c) => c.type !== "combinator") || (u.nodes = [
        e.default.pseudo({
          value: ":is",
          nodes: [
            u.clone()
          ]
        })
      ]), (0, r.movePseudos)(u);
    }), `${h} ${n.toString()}`;
  }
})(vb);
var a_;
function Eb() {
  return a_ || (a_ = 1, function(t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    function e(N, V) {
      for (var F in V) Object.defineProperty(N, F, {
        enumerable: !0,
        get: V[F]
      });
    }
    e(t, {
      getClassNameFromSelector: function() {
        return D;
      },
      resolveMatches: function() {
        return W;
      },
      generateRules: function() {
        return re;
      }
    });
    const r = /* @__PURE__ */ v(Vi), a = /* @__PURE__ */ v(ua), l = /* @__PURE__ */ v(cb), d = /* @__PURE__ */ v(Al), h = /* @__PURE__ */ v(Gd), n = Gu, u = /* @__PURE__ */ v(as), i = /* @__PURE__ */ E(mo), c = gb, f = yb, s = Ku, o = zb(), y = /* @__PURE__ */ v(bb), m = Yu, g = Vs, b = vb;
    function v(N) {
      return N && N.__esModule ? N : {
        default: N
      };
    }
    function T(N) {
      if (typeof WeakMap != "function") return null;
      var V = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap();
      return (T = function(X) {
        return X ? F : V;
      })(N);
    }
    function E(N, V) {
      if (N && N.__esModule)
        return N;
      if (N === null || typeof N != "object" && typeof N != "function")
        return {
          default: N
        };
      var F = T(V);
      if (F && F.has(N))
        return F.get(N);
      var X = {}, K = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var ie in N)
        if (ie !== "default" && Object.prototype.hasOwnProperty.call(N, ie)) {
          var fe = K ? Object.getOwnPropertyDescriptor(N, ie) : null;
          fe && (fe.get || fe.set) ? Object.defineProperty(X, ie, fe) : X[ie] = N[ie];
        }
      return X.default = N, F && F.set(N, X), X;
    }
    let O = (0, a.default)((N) => N.first.filter(({ type: V }) => V === "class").pop().value);
    function D(N) {
      return O.transformSync(N);
    }
    function* $(N) {
      let V = 1 / 0;
      for (; V >= 0; ) {
        let F, X = !1;
        if (V === 1 / 0 && N.endsWith("]")) {
          let fe = N.indexOf("[");
          N[fe - 1] === "-" ? F = fe - 1 : N[fe - 1] === "/" ? (F = fe - 1, X = !0) : F = -1;
        } else V === 1 / 0 && N.includes("/") ? (F = N.lastIndexOf("/"), X = !0) : F = N.lastIndexOf("-", V);
        if (F < 0)
          break;
        let K = N.slice(0, F), ie = N.slice(X ? F : F + 1);
        V = F - 1, !(K === "" || ie === "/") && (yield [
          K,
          ie
        ]);
      }
    }
    function I(N, V) {
      if (N.length === 0 || V.tailwindConfig.prefix === "")
        return N;
      for (let F of N) {
        let [X] = F;
        if (X.options.respectPrefix) {
          let K = r.default.root({
            nodes: [
              F[1].clone()
            ]
          }), ie = F[1].raws.tailwind.classCandidate;
          K.walkRules((fe) => {
            let _e = ie.startsWith("-");
            fe.selector = (0, h.default)(V.tailwindConfig.prefix, fe.selector, _e);
          }), F[1] = K.nodes[0];
        }
      }
      return N;
    }
    function k(N, V) {
      if (N.length === 0)
        return N;
      let F = [];
      for (let [X, K] of N) {
        let ie = r.default.root({
          nodes: [
            K.clone()
          ]
        });
        ie.walkRules((fe) => {
          let _e = (0, a.default)().astSync(fe.selector);
          _e.each((Ae) => (0, c.eliminateIrrelevantSelectors)(Ae, V)), (0, n.updateAllClasses)(_e, (Ae) => Ae === V ? `!${Ae}` : Ae), fe.selector = _e.toString(), fe.walkDecls((Ae) => Ae.important = !0);
        }), F.push([
          {
            ...X,
            important: !0
          },
          ie.nodes[0]
        ]);
      }
      return F;
    }
    function L(N, V, F) {
      if (V.length === 0)
        return V;
      let X = {
        modifier: null,
        value: i.NONE
      };
      {
        let [ie, ...fe] = (0, m.splitAtTopLevelOnly)(N, "/");
        if (fe.length > 1 && (ie = ie + "/" + fe.slice(0, -1).join("/"), fe = fe.slice(-1)), fe.length && !F.variantMap.has(N) && (N = ie, X.modifier = fe[0], !(0, g.flagEnabled)(F.tailwindConfig, "generalizedModifiers")))
          return [];
      }
      if (N.endsWith("]") && !N.startsWith("[")) {
        let ie = /(.)(-?)\[(.*)\]/g.exec(N);
        if (ie) {
          let [, fe, _e, Ae] = ie;
          if (fe === "@" && _e === "-") return [];
          if (fe !== "@" && _e === "") return [];
          N = N.replace(`${_e}[${Ae}]`, ""), X.value = Ae;
        }
      }
      if (G(N) && !F.variantMap.has(N)) {
        let ie = F.offsets.recordVariant(N), fe = (0, s.normalize)(N.slice(1, -1)), _e = (0, m.splitAtTopLevelOnly)(fe, ",");
        if (_e.length > 1)
          return [];
        if (!_e.every(o.isValidVariantFormatString))
          return [];
        let Ae = _e.map((ce, ee) => [
          F.offsets.applyParallelOffset(ie, ee),
          (0, o.parseVariant)(ce.trim())
        ]);
        F.variantMap.set(N, Ae);
      }
      if (F.variantMap.has(N)) {
        let ie = G(N), fe = F.variantMap.get(N).slice(), _e = [];
        for (let [Ae, ce] of V) {
          if (Ae.layer === "user")
            continue;
          let ee = r.default.root({
            nodes: [
              ce.clone()
            ]
          });
          for (let [ae, oe, me] of fe) {
            let ge = function() {
              ye.raws.neededBackup || (ye.raws.neededBackup = !0, ye.walkRules((Oe) => Oe.raws.originalSelector = Oe.selector));
            }, se = function(Oe) {
              return ge(), ye.each((Be) => {
                Be.type === "rule" && (Be.selectors = Be.selectors.map((Fe) => Oe({
                  get className() {
                    return D(Fe);
                  },
                  selector: Fe
                })));
              }), ye;
            }, ye = (me ?? ee).clone(), we = [], be = oe({
              // Public API
              get container() {
                return ge(), ye;
              },
              separator: F.tailwindConfig.separator,
              modifySelectors: se,
              // Private API for now
              wrap(Oe) {
                let Be = ye.nodes;
                ye.removeAll(), Oe.append(Be), ye.append(Oe);
              },
              format(Oe) {
                we.push({
                  format: Oe,
                  isArbitraryVariant: ie
                });
              },
              args: X
            });
            if (Array.isArray(be)) {
              for (let [Oe, Be] of be.entries())
                fe.push([
                  F.offsets.applyParallelOffset(ae, Oe),
                  Be,
                  // If the clone has been modified we have to pass that back
                  // though so each rule can use the modified container
                  ye.clone()
                ]);
              continue;
            }
            if (typeof be == "string" && we.push({
              format: be,
              isArbitraryVariant: ie
            }), be === null)
              continue;
            ye.raws.neededBackup && (delete ye.raws.neededBackup, ye.walkRules((Oe) => {
              let Be = Oe.raws.originalSelector;
              if (!Be || (delete Oe.raws.originalSelector, Be === Oe.selector)) return;
              let Fe = Oe.selector, ue = (0, a.default)((te) => {
                te.walkClasses((Y) => {
                  Y.value = `${N}${F.tailwindConfig.separator}${Y.value}`;
                });
              }).processSync(Be);
              we.push({
                format: Fe.replace(ue, "&"),
                isArbitraryVariant: ie
              }), Oe.selector = Be;
            })), ye.nodes[0].raws.tailwind = {
              ...ye.nodes[0].raws.tailwind,
              parentLayer: Ae.layer
            };
            var K;
            let Ie = [
              {
                ...Ae,
                sort: F.offsets.applyVariantOffset(Ae.sort, ae, Object.assign(X, F.variantOptions.get(N))),
                collectedFormats: ((K = Ae.collectedFormats) !== null && K !== void 0 ? K : []).concat(we)
              },
              ye.nodes[0]
            ];
            _e.push(Ie);
          }
        }
        return _e;
      }
      return [];
    }
    function M(N, V, F = {}) {
      return !(0, d.default)(N) && !Array.isArray(N) ? [
        [
          N
        ],
        F
      ] : Array.isArray(N) ? M(N[0], V, N[1]) : (V.has(N) || V.set(N, (0, l.default)(N)), [
        V.get(N),
        F
      ]);
    }
    const x = /^[a-z_-]/;
    function _(N) {
      return x.test(N);
    }
    function S(N) {
      if (!N.includes("://"))
        return !1;
      try {
        const V = new URL(N);
        return V.scheme !== "" && V.host !== "";
      } catch {
        return !1;
      }
    }
    function C(N) {
      let V = !0;
      return N.walkDecls((F) => {
        if (!R(F.prop, F.value))
          return V = !1, !1;
      }), V;
    }
    function R(N, V) {
      if (S(`${N}:${V}`))
        return !1;
      try {
        return r.default.parse(`a{${N}:${V}}`).toResult(), !0;
      } catch {
        return !1;
      }
    }
    function H(N, V) {
      var F;
      let [, X, K] = (F = N.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && F !== void 0 ? F : [];
      if (K === void 0 || !_(X) || !(0, y.default)(K))
        return null;
      let ie = (0, s.normalize)(K);
      return R(X, ie) ? [
        [
          {
            sort: V.offsets.arbitraryProperty(),
            layer: "utilities"
          },
          () => ({
            [(0, f.asClass)(N)]: {
              [X]: ie
            }
          })
        ]
      ] : null;
    }
    function* z(N, V) {
      V.candidateRuleMap.has(N) && (yield [
        V.candidateRuleMap.get(N),
        "DEFAULT"
      ]), yield* function* (_e) {
        _e !== null && (yield [
          _e,
          "DEFAULT"
        ]);
      }(H(N, V));
      let F = N, X = !1;
      const K = V.tailwindConfig.prefix, ie = K.length, fe = F.startsWith(K) || F.startsWith(`-${K}`);
      F[ie] === "-" && fe && (X = !0, F = K + F.slice(ie + 1)), X && V.candidateRuleMap.has(F) && (yield [
        V.candidateRuleMap.get(F),
        "-DEFAULT"
      ]);
      for (let [_e, Ae] of $(F))
        V.candidateRuleMap.has(_e) && (yield [
          V.candidateRuleMap.get(_e),
          X ? `-${Ae}` : Ae
        ]);
    }
    function U(N, V) {
      return N === i.NOT_ON_DEMAND ? [
        i.NOT_ON_DEMAND
      ] : (0, m.splitAtTopLevelOnly)(N, V);
    }
    function* P(N, V) {
      for (const K of N) {
        var F, X;
        K[1].raws.tailwind = {
          ...K[1].raws.tailwind,
          classCandidate: V,
          preserveSource: (X = (F = K[0].options) === null || F === void 0 ? void 0 : F.preserveSource) !== null && X !== void 0 ? X : !1
        }, yield K;
      }
    }
    function* W(N, V, F = N) {
      let X = V.tailwindConfig.separator, [K, ...ie] = U(N, X).reverse(), fe = !1;
      if (K.startsWith("!") && (fe = !0, K = K.slice(1)), (0, g.flagEnabled)(V.tailwindConfig, "variantGrouping") && K.startsWith("(") && K.endsWith(")")) {
        let oe = ie.slice().reverse().join(X);
        for (let me of (0, m.splitAtTopLevelOnly)(K.slice(1, -1), ","))
          yield* W(oe + X + me, V, F);
      }
      for (let oe of z(K, V)) {
        let me = [], ye = /* @__PURE__ */ new Map(), [we, ge] = oe, se = we.length === 1;
        for (let [be, Ie] of we) {
          let Oe = [];
          if (typeof Ie == "function")
            for (let Be of [].concat(Ie(ge, {
              isOnlyPlugin: se
            }))) {
              let [Fe, ue] = M(Be, V.postCssNodeCache);
              for (let te of Fe)
                Oe.push([
                  {
                    ...be,
                    options: {
                      ...be.options,
                      ...ue
                    }
                  },
                  te
                ]);
            }
          else if (ge === "DEFAULT" || ge === "-DEFAULT") {
            let Be = Ie, [Fe, ue] = M(Be, V.postCssNodeCache);
            for (let te of Fe)
              Oe.push([
                {
                  ...be,
                  options: {
                    ...be.options,
                    ...ue
                  }
                },
                te
              ]);
          }
          if (Oe.length > 0) {
            var _e, Ae, ce;
            let Be = Array.from((0, n.getMatchingTypes)((Ae = (_e = be.options) === null || _e === void 0 ? void 0 : _e.types) !== null && Ae !== void 0 ? Ae : [], ge, (ce = be.options) !== null && ce !== void 0 ? ce : {}, V.tailwindConfig)).map(([Fe, ue]) => ue);
            Be.length > 0 && ye.set(Oe, Be), me.push(Oe);
          }
        }
        if (G(ge)) {
          if (me.length > 1) {
            let Oe = function(Fe) {
              return Fe.length === 1 ? Fe[0] : Fe.find((ue) => {
                let te = ye.get(ue);
                return ue.some(([{ options: Y }, le]) => C(le) ? Y.types.some(({ type: Ee, preferOnConflict: Se }) => te.includes(Ee) && Se) : !1);
              });
            }, [be, Ie] = me.reduce((Fe, ue) => (ue.some(([{ options: Y }]) => Y.types.some(({ type: le }) => le === "any")) ? Fe[0].push(ue) : Fe[1].push(ue), Fe), [
              [],
              []
            ]);
            var ee;
            let Be = (ee = Oe(Ie)) !== null && ee !== void 0 ? ee : Oe(be);
            if (Be)
              me = [
                Be
              ];
            else {
              var ae;
              let Fe = me.map((te) => /* @__PURE__ */ new Set([
                ...(ae = ye.get(te)) !== null && ae !== void 0 ? ae : []
              ]));
              for (let te of Fe)
                for (let Y of te) {
                  let le = !1;
                  for (let Ee of Fe)
                    te !== Ee && Ee.has(Y) && (Ee.delete(Y), le = !0);
                  le && te.delete(Y);
                }
              let ue = [];
              for (let [te, Y] of Fe.entries())
                for (let le of Y) {
                  let Ee = me[te].map(([, Se]) => Se).flat().map((Se) => Se.toString().split(`
`).slice(1, -1).map((Pe) => Pe.trim()).map((Pe) => `      ${Pe}`).join(`
`)).join(`

`);
                  ue.push(`  Use \`${N.replace("[", `[${le}:`)}\` for \`${Ee.trim()}\``);
                  break;
                }
              u.default.warn([
                `The class \`${N}\` is ambiguous and matches multiple utilities.`,
                ...ue,
                `If this is content and not a class, replace it with \`${N.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          me = me.map((be) => be.filter((Ie) => C(Ie[1])));
        }
        me = me.flat(), me = Array.from(P(me, K)), me = I(me, V), fe && (me = k(me, K));
        for (let be of ie)
          me = L(be, me, V);
        for (let be of me)
          be[1].raws.tailwind = {
            ...be[1].raws.tailwind,
            candidate: N
          }, be = B(be, {
            context: V,
            candidate: N,
            original: F
          }), be !== null && (yield be);
      }
    }
    function B(N, { context: V, candidate: F, original: X }) {
      if (!N[0].collectedFormats)
        return N;
      let K = !0, ie;
      try {
        ie = (0, c.formatVariantSelector)(N[0].collectedFormats, {
          context: V,
          candidate: F
        });
      } catch {
        return null;
      }
      let fe = r.default.root({
        nodes: [
          N[1].clone()
        ]
      });
      return fe.walkRules((_e) => {
        if (!Q(_e))
          try {
            _e.selector = (0, c.finalizeSelector)(_e.selector, ie, {
              candidate: X,
              context: V
            });
          } catch {
            return K = !1, !1;
          }
      }), K ? (N[1] = fe.nodes[0], N) : null;
    }
    function Q(N) {
      return N.parent && N.parent.type === "atrule" && N.parent.name === "keyframes";
    }
    function J(N) {
      if (N === !0)
        return (V) => {
          Q(V) || V.walkDecls((F) => {
            F.parent.type === "rule" && !Q(F.parent) && (F.important = !0);
          });
        };
      if (typeof N == "string")
        return (V) => {
          Q(V) || (V.selectors = V.selectors.map((F) => (0, b.applyImportantSelector)(F, N)));
        };
    }
    function re(N, V) {
      let F = [], X = J(V.tailwindConfig.important);
      for (let ie of N) {
        if (V.notClassCache.has(ie))
          continue;
        if (V.candidateRuleCache.has(ie)) {
          F = F.concat(Array.from(V.candidateRuleCache.get(ie)));
          continue;
        }
        let fe = Array.from(W(ie, V));
        if (fe.length === 0) {
          V.notClassCache.add(ie);
          continue;
        }
        V.classCache.set(ie, fe);
        var K;
        let _e = (K = V.candidateRuleCache.get(ie)) !== null && K !== void 0 ? K : /* @__PURE__ */ new Set();
        V.candidateRuleCache.set(ie, _e);
        for (const Ae of fe) {
          let [{ sort: ce, options: ee }, ae] = Ae;
          if (ee.respectImportant && X) {
            let me = r.default.root({
              nodes: [
                ae.clone()
              ]
            });
            me.walkRules(X), ae = me.nodes[0];
          }
          let oe = [
            ce,
            ae
          ];
          _e.add(oe), V.ruleCache.add(oe), F.push(oe);
        }
      }
      return F;
    }
    function G(N) {
      return N.startsWith("[") && N.endsWith("]");
    }
  }(Jh)), Jh;
}
var AA = {}, or = {}, x1 = { exports: {} }, T1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(t, e) {
  var r = Ui, a = r.Buffer;
  function l(h, n) {
    for (var u in h)
      n[u] = h[u];
  }
  a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? t.exports = r : (l(r, e), e.Buffer = d);
  function d(h, n, u) {
    return a(h, n, u);
  }
  d.prototype = Object.create(a.prototype), l(a, d), d.from = function(h, n, u) {
    if (typeof h == "number")
      throw new TypeError("Argument must not be a number");
    return a(h, n, u);
  }, d.alloc = function(h, n, u) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    var i = a(h);
    return n !== void 0 ? typeof u == "string" ? i.fill(n, u) : i.fill(n) : i.fill(0), i;
  }, d.allocUnsafe = function(h) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    return a(h);
  }, d.allocUnsafeSlow = function(h) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(h);
  };
})(T1, T1.exports);
var cr = T1.exports, Qh = 65536, eL = 4294967295;
function tL() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var rL = cr.Buffer, zf = jt.crypto || jt.msCrypto;
zf && zf.getRandomValues ? x1.exports = nL : x1.exports = tL;
function nL(t, e) {
  if (t > eL) throw new RangeError("requested too many random bytes");
  var r = rL.allocUnsafe(t);
  if (t > 0)
    if (t > Qh)
      for (var a = 0; a < t; a += Qh)
        zf.getRandomValues(r.slice(a, a + Qh));
    else
      zf.getRandomValues(r);
  return typeof e == "function" ? Ze.nextTick(function() {
    e(null, r);
  }) : r;
}
var Cl = x1.exports, A1 = { exports: {} }, PA = po.EventEmitter, Zh, o_;
function iL() {
  if (o_) return Zh;
  o_ = 1;
  function t(y, m) {
    var g = Object.keys(y);
    if (Object.getOwnPropertySymbols) {
      var b = Object.getOwnPropertySymbols(y);
      m && (b = b.filter(function(v) {
        return Object.getOwnPropertyDescriptor(y, v).enumerable;
      })), g.push.apply(g, b);
    }
    return g;
  }
  function e(y) {
    for (var m = 1; m < arguments.length; m++) {
      var g = arguments[m] != null ? arguments[m] : {};
      m % 2 ? t(Object(g), !0).forEach(function(b) {
        r(y, b, g[b]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(y, Object.getOwnPropertyDescriptors(g)) : t(Object(g)).forEach(function(b) {
        Object.defineProperty(y, b, Object.getOwnPropertyDescriptor(g, b));
      });
    }
    return y;
  }
  function r(y, m, g) {
    return m = h(m), m in y ? Object.defineProperty(y, m, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : y[m] = g, y;
  }
  function a(y, m) {
    if (!(y instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(y, m) {
    for (var g = 0; g < m.length; g++) {
      var b = m[g];
      b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(y, h(b.key), b);
    }
  }
  function d(y, m, g) {
    return m && l(y.prototype, m), Object.defineProperty(y, "prototype", { writable: !1 }), y;
  }
  function h(y) {
    var m = n(y, "string");
    return typeof m == "symbol" ? m : String(m);
  }
  function n(y, m) {
    if (typeof y != "object" || y === null) return y;
    var g = y[Symbol.toPrimitive];
    if (g !== void 0) {
      var b = g.call(y, m || "default");
      if (typeof b != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m === "string" ? String : Number)(y);
  }
  var u = Ui, i = u.Buffer, c = Rr, f = c.inspect, s = f && f.custom || "inspect";
  function o(y, m, g) {
    i.prototype.copy.call(y, m, g);
  }
  return Zh = /* @__PURE__ */ function() {
    function y() {
      a(this, y), this.head = null, this.tail = null, this.length = 0;
    }
    return d(y, [{
      key: "push",
      value: function(g) {
        var b = {
          data: g,
          next: null
        };
        this.length > 0 ? this.tail.next = b : this.head = b, this.tail = b, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(g) {
        var b = {
          data: g,
          next: this.head
        };
        this.length === 0 && (this.tail = b), this.head = b, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var g = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, g;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(g) {
        if (this.length === 0) return "";
        for (var b = this.head, v = "" + b.data; b = b.next; ) v += g + b.data;
        return v;
      }
    }, {
      key: "concat",
      value: function(g) {
        if (this.length === 0) return i.alloc(0);
        for (var b = i.allocUnsafe(g >>> 0), v = this.head, T = 0; v; )
          o(v.data, b, T), T += v.data.length, v = v.next;
        return b;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(g, b) {
        var v;
        return g < this.head.data.length ? (v = this.head.data.slice(0, g), this.head.data = this.head.data.slice(g)) : g === this.head.data.length ? v = this.shift() : v = b ? this._getString(g) : this._getBuffer(g), v;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(g) {
        var b = this.head, v = 1, T = b.data;
        for (g -= T.length; b = b.next; ) {
          var E = b.data, O = g > E.length ? E.length : g;
          if (O === E.length ? T += E : T += E.slice(0, g), g -= O, g === 0) {
            O === E.length ? (++v, b.next ? this.head = b.next : this.head = this.tail = null) : (this.head = b, b.data = E.slice(O));
            break;
          }
          ++v;
        }
        return this.length -= v, T;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(g) {
        var b = i.allocUnsafe(g), v = this.head, T = 1;
        for (v.data.copy(b), g -= v.data.length; v = v.next; ) {
          var E = v.data, O = g > E.length ? E.length : g;
          if (E.copy(b, b.length - g, 0, O), g -= O, g === 0) {
            O === E.length ? (++T, v.next ? this.head = v.next : this.head = this.tail = null) : (this.head = v, v.data = E.slice(O));
            break;
          }
          ++T;
        }
        return this.length -= T, b;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: s,
      value: function(g, b) {
        return f(this, e(e({}, b), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), y;
  }(), Zh;
}
function sL(t, e) {
  var r = this, a = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
  return a || l ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ze.nextTick(P1, this, t)) : Ze.nextTick(P1, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(d) {
    !e && d ? r._writableState ? r._writableState.errorEmitted ? Ze.nextTick(_f, r) : (r._writableState.errorEmitted = !0, Ze.nextTick(l_, r, d)) : Ze.nextTick(l_, r, d) : e ? (Ze.nextTick(_f, r), e(d)) : Ze.nextTick(_f, r);
  }), this);
}
function l_(t, e) {
  P1(t, e), _f(t);
}
function _f(t) {
  t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
}
function aL() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function P1(t, e) {
  t.emit("error", e);
}
function oL(t, e) {
  var r = t._readableState, a = t._writableState;
  r && r.autoDestroy || a && a.autoDestroy ? t.destroy(e) : t.emit("error", e);
}
var CA = {
  destroy: sL,
  undestroy: aL,
  errorOrDestroy: oL
}, yo = {};
function lL(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
}
var IA = {};
function Hi(t, e, r) {
  r || (r = Error);
  function a(d, h, n) {
    return typeof e == "string" ? e : e(d, h, n);
  }
  var l = /* @__PURE__ */ function(d) {
    lL(h, d);
    function h(n, u, i) {
      return d.call(this, a(n, u, i)) || this;
    }
    return h;
  }(r);
  l.prototype.name = r.name, l.prototype.code = t, IA[t] = l;
}
function u_(t, e) {
  if (Array.isArray(t)) {
    var r = t.length;
    return t = t.map(function(a) {
      return String(a);
    }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
  } else
    return "of ".concat(e, " ").concat(String(t));
}
function uL(t, e, r) {
  return t.substr(0, e.length) === e;
}
function cL(t, e, r) {
  return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
}
function fL(t, e, r) {
  return typeof r != "number" && (r = 0), r + e.length > t.length ? !1 : t.indexOf(e, r) !== -1;
}
Hi("ERR_INVALID_OPT_VALUE", function(t, e) {
  return 'The value "' + e + '" is invalid for option "' + t + '"';
}, TypeError);
Hi("ERR_INVALID_ARG_TYPE", function(t, e, r) {
  var a;
  typeof e == "string" && uL(e, "not ") ? (a = "must not be", e = e.replace(/^not /, "")) : a = "must be";
  var l;
  if (cL(t, " argument"))
    l = "The ".concat(t, " ").concat(a, " ").concat(u_(e, "type"));
  else {
    var d = fL(t, ".") ? "property" : "argument";
    l = 'The "'.concat(t, '" ').concat(d, " ").concat(a, " ").concat(u_(e, "type"));
  }
  return l += ". Received type ".concat(typeof r), l;
}, TypeError);
Hi("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Hi("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
  return "The " + t + " method is not implemented";
});
Hi("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Hi("ERR_STREAM_DESTROYED", function(t) {
  return "Cannot call " + t + " after a stream was destroyed";
});
Hi("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Hi("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Hi("ERR_STREAM_WRITE_AFTER_END", "write after end");
Hi("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Hi("ERR_UNKNOWN_ENCODING", function(t) {
  return "Unknown encoding: " + t;
}, TypeError);
Hi("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
yo.codes = IA;
var dL = yo.codes.ERR_INVALID_OPT_VALUE;
function pL(t, e, r) {
  return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
}
function hL(t, e, r, a) {
  var l = pL(e, a, r);
  if (l != null) {
    if (!(isFinite(l) && Math.floor(l) === l) || l < 0) {
      var d = a ? r : "highWaterMark";
      throw new dL(d, l);
    }
    return Math.floor(l);
  }
  return t.objectMode ? 16 : 16 * 1024;
}
var OA = {
  getHighWaterMark: hL
}, em, c_;
function kA() {
  if (c_) return em;
  c_ = 1, em = I;
  function t(G) {
    var N = this;
    this.next = null, this.entry = null, this.finish = function() {
      re(N, G);
    };
  }
  var e;
  I.WritableState = D;
  var r = {
    deprecate: ob
  }, a = PA, l = Ui.Buffer, d = (typeof jt < "u" ? jt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function h(G) {
    return l.from(G);
  }
  function n(G) {
    return l.isBuffer(G) || G instanceof d;
  }
  var u = CA, i = OA, c = i.getHighWaterMark, f = yo.codes, s = f.ERR_INVALID_ARG_TYPE, o = f.ERR_METHOD_NOT_IMPLEMENTED, y = f.ERR_MULTIPLE_CALLBACK, m = f.ERR_STREAM_CANNOT_PIPE, g = f.ERR_STREAM_DESTROYED, b = f.ERR_STREAM_NULL_VALUES, v = f.ERR_STREAM_WRITE_AFTER_END, T = f.ERR_UNKNOWN_ENCODING, E = u.errorOrDestroy;
  ir(I, a);
  function O() {
  }
  function D(G, N, V) {
    e = e || cl(), G = G || {}, typeof V != "boolean" && (V = N instanceof e), this.objectMode = !!G.objectMode, V && (this.objectMode = this.objectMode || !!G.writableObjectMode), this.highWaterMark = c(this, G, "writableHighWaterMark", V), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var F = G.decodeStrings === !1;
    this.decodeStrings = !F, this.defaultEncoding = G.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(X) {
      R(N, X);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = G.emitClose !== !1, this.autoDestroy = !!G.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  D.prototype.getBuffer = function() {
    for (var N = this.bufferedRequest, V = []; N; )
      V.push(N), N = N.next;
    return V;
  }, function() {
    try {
      Object.defineProperty(D.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var $;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? ($ = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, {
    value: function(N) {
      return $.call(this, N) ? !0 : this !== I ? !1 : N && N._writableState instanceof D;
    }
  })) : $ = function(N) {
    return N instanceof this;
  };
  function I(G) {
    e = e || cl();
    var N = this instanceof e;
    if (!N && !$.call(I, this)) return new I(G);
    this._writableState = new D(G, this, N), this.writable = !0, G && (typeof G.write == "function" && (this._write = G.write), typeof G.writev == "function" && (this._writev = G.writev), typeof G.destroy == "function" && (this._destroy = G.destroy), typeof G.final == "function" && (this._final = G.final)), a.call(this);
  }
  I.prototype.pipe = function() {
    E(this, new m());
  };
  function k(G, N) {
    var V = new v();
    E(G, V), Ze.nextTick(N, V);
  }
  function L(G, N, V, F) {
    var X;
    return V === null ? X = new b() : typeof V != "string" && !N.objectMode && (X = new s("chunk", ["string", "Buffer"], V)), X ? (E(G, X), Ze.nextTick(F, X), !1) : !0;
  }
  I.prototype.write = function(G, N, V) {
    var F = this._writableState, X = !1, K = !F.objectMode && n(G);
    return K && !l.isBuffer(G) && (G = h(G)), typeof N == "function" && (V = N, N = null), K ? N = "buffer" : N || (N = F.defaultEncoding), typeof V != "function" && (V = O), F.ending ? k(this, V) : (K || L(this, F, G, V)) && (F.pendingcb++, X = x(this, F, K, G, N, V)), X;
  }, I.prototype.cork = function() {
    this._writableState.corked++;
  }, I.prototype.uncork = function() {
    var G = this._writableState;
    G.corked && (G.corked--, !G.writing && !G.corked && !G.bufferProcessing && G.bufferedRequest && U(this, G));
  }, I.prototype.setDefaultEncoding = function(N) {
    if (typeof N == "string" && (N = N.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((N + "").toLowerCase()) > -1)) throw new T(N);
    return this._writableState.defaultEncoding = N, this;
  }, Object.defineProperty(I.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function M(G, N, V) {
    return !G.objectMode && G.decodeStrings !== !1 && typeof N == "string" && (N = l.from(N, V)), N;
  }
  Object.defineProperty(I.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function x(G, N, V, F, X, K) {
    if (!V) {
      var ie = M(N, F, X);
      F !== ie && (V = !0, X = "buffer", F = ie);
    }
    var fe = N.objectMode ? 1 : F.length;
    N.length += fe;
    var _e = N.length < N.highWaterMark;
    if (_e || (N.needDrain = !0), N.writing || N.corked) {
      var Ae = N.lastBufferedRequest;
      N.lastBufferedRequest = {
        chunk: F,
        encoding: X,
        isBuf: V,
        callback: K,
        next: null
      }, Ae ? Ae.next = N.lastBufferedRequest : N.bufferedRequest = N.lastBufferedRequest, N.bufferedRequestCount += 1;
    } else
      _(G, N, !1, fe, F, X, K);
    return _e;
  }
  function _(G, N, V, F, X, K, ie) {
    N.writelen = F, N.writecb = ie, N.writing = !0, N.sync = !0, N.destroyed ? N.onwrite(new g("write")) : V ? G._writev(X, N.onwrite) : G._write(X, K, N.onwrite), N.sync = !1;
  }
  function S(G, N, V, F, X) {
    --N.pendingcb, V ? (Ze.nextTick(X, F), Ze.nextTick(Q, G, N), G._writableState.errorEmitted = !0, E(G, F)) : (X(F), G._writableState.errorEmitted = !0, E(G, F), Q(G, N));
  }
  function C(G) {
    G.writing = !1, G.writecb = null, G.length -= G.writelen, G.writelen = 0;
  }
  function R(G, N) {
    var V = G._writableState, F = V.sync, X = V.writecb;
    if (typeof X != "function") throw new y();
    if (C(V), N) S(G, V, F, N, X);
    else {
      var K = P(V) || G.destroyed;
      !K && !V.corked && !V.bufferProcessing && V.bufferedRequest && U(G, V), F ? Ze.nextTick(H, G, V, K, X) : H(G, V, K, X);
    }
  }
  function H(G, N, V, F) {
    V || z(G, N), N.pendingcb--, F(), Q(G, N);
  }
  function z(G, N) {
    N.length === 0 && N.needDrain && (N.needDrain = !1, G.emit("drain"));
  }
  function U(G, N) {
    N.bufferProcessing = !0;
    var V = N.bufferedRequest;
    if (G._writev && V && V.next) {
      var F = N.bufferedRequestCount, X = new Array(F), K = N.corkedRequestsFree;
      K.entry = V;
      for (var ie = 0, fe = !0; V; )
        X[ie] = V, V.isBuf || (fe = !1), V = V.next, ie += 1;
      X.allBuffers = fe, _(G, N, !0, N.length, X, "", K.finish), N.pendingcb++, N.lastBufferedRequest = null, K.next ? (N.corkedRequestsFree = K.next, K.next = null) : N.corkedRequestsFree = new t(N), N.bufferedRequestCount = 0;
    } else {
      for (; V; ) {
        var _e = V.chunk, Ae = V.encoding, ce = V.callback, ee = N.objectMode ? 1 : _e.length;
        if (_(G, N, !1, ee, _e, Ae, ce), V = V.next, N.bufferedRequestCount--, N.writing)
          break;
      }
      V === null && (N.lastBufferedRequest = null);
    }
    N.bufferedRequest = V, N.bufferProcessing = !1;
  }
  I.prototype._write = function(G, N, V) {
    V(new o("_write()"));
  }, I.prototype._writev = null, I.prototype.end = function(G, N, V) {
    var F = this._writableState;
    return typeof G == "function" ? (V = G, G = null, N = null) : typeof N == "function" && (V = N, N = null), G != null && this.write(G, N), F.corked && (F.corked = 1, this.uncork()), F.ending || J(this, F, V), this;
  }, Object.defineProperty(I.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function P(G) {
    return G.ending && G.length === 0 && G.bufferedRequest === null && !G.finished && !G.writing;
  }
  function W(G, N) {
    G._final(function(V) {
      N.pendingcb--, V && E(G, V), N.prefinished = !0, G.emit("prefinish"), Q(G, N);
    });
  }
  function B(G, N) {
    !N.prefinished && !N.finalCalled && (typeof G._final == "function" && !N.destroyed ? (N.pendingcb++, N.finalCalled = !0, Ze.nextTick(W, G, N)) : (N.prefinished = !0, G.emit("prefinish")));
  }
  function Q(G, N) {
    var V = P(N);
    if (V && (B(G, N), N.pendingcb === 0 && (N.finished = !0, G.emit("finish"), N.autoDestroy))) {
      var F = G._readableState;
      (!F || F.autoDestroy && F.endEmitted) && G.destroy();
    }
    return V;
  }
  function J(G, N, V) {
    N.ending = !0, Q(G, N), V && (N.finished ? Ze.nextTick(V) : G.once("finish", V)), N.ended = !0, G.writable = !1;
  }
  function re(G, N, V) {
    var F = G.entry;
    for (G.entry = null; F; ) {
      var X = F.callback;
      N.pendingcb--, X(V), F = F.next;
    }
    N.corkedRequestsFree.next = G;
  }
  return Object.defineProperty(I.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(N) {
      this._writableState && (this._writableState.destroyed = N);
    }
  }), I.prototype.destroy = u.destroy, I.prototype._undestroy = u.undestroy, I.prototype._destroy = function(G, N) {
    N(G);
  }, em;
}
var tm, f_;
function cl() {
  if (f_) return tm;
  f_ = 1;
  var t = Object.keys || function(i) {
    var c = [];
    for (var f in i) c.push(f);
    return c;
  };
  tm = h;
  var e = NA(), r = kA();
  ir(h, e);
  for (var a = t(r.prototype), l = 0; l < a.length; l++) {
    var d = a[l];
    h.prototype[d] || (h.prototype[d] = r.prototype[d]);
  }
  function h(i) {
    if (!(this instanceof h)) return new h(i);
    e.call(this, i), r.call(this, i), this.allowHalfOpen = !0, i && (i.readable === !1 && (this.readable = !1), i.writable === !1 && (this.writable = !1), i.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", n)));
  }
  Object.defineProperty(h.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(h.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(h.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function n() {
    this._writableState.ended || Ze.nextTick(u, this);
  }
  function u(i) {
    i.end();
  }
  return Object.defineProperty(h.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(c) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = c, this._writableState.destroyed = c);
    }
  }), tm;
}
var Kf = {}, _b = cr.Buffer, d_ = _b.isEncoding || function(t) {
  switch (t = "" + t, t && t.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function mL(t) {
  if (!t) return "utf8";
  for (var e; ; )
    switch (t) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return t;
      default:
        if (e) return;
        t = ("" + t).toLowerCase(), e = !0;
    }
}
function yL(t) {
  var e = mL(t);
  if (typeof e != "string" && (_b.isEncoding === d_ || !d_(t))) throw new Error("Unknown encoding: " + t);
  return e || t;
}
Kf.StringDecoder = Zu;
function Zu(t) {
  this.encoding = yL(t);
  var e;
  switch (this.encoding) {
    case "utf16le":
      this.text = SL, this.end = wL, e = 4;
      break;
    case "utf8":
      this.fillLast = vL, e = 4;
      break;
    case "base64":
      this.text = xL, this.end = TL, e = 3;
      break;
    default:
      this.write = AL, this.end = PL;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = _b.allocUnsafe(e);
}
Zu.prototype.write = function(t) {
  if (t.length === 0) return "";
  var e, r;
  if (this.lastNeed) {
    if (e = this.fillLast(t), e === void 0) return "";
    r = this.lastNeed, this.lastNeed = 0;
  } else
    r = 0;
  return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
};
Zu.prototype.end = _L;
Zu.prototype.text = EL;
Zu.prototype.fillLast = function(t) {
  if (this.lastNeed <= t.length)
    return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
};
function rm(t) {
  return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
}
function bL(t, e, r) {
  var a = e.length - 1;
  if (a < r) return 0;
  var l = rm(e[a]);
  return l >= 0 ? (l > 0 && (t.lastNeed = l - 1), l) : --a < r || l === -2 ? 0 : (l = rm(e[a]), l >= 0 ? (l > 0 && (t.lastNeed = l - 2), l) : --a < r || l === -2 ? 0 : (l = rm(e[a]), l >= 0 ? (l > 0 && (l === 2 ? l = 0 : t.lastNeed = l - 3), l) : 0));
}
function gL(t, e, r) {
  if ((e[0] & 192) !== 128)
    return t.lastNeed = 0, "�";
  if (t.lastNeed > 1 && e.length > 1) {
    if ((e[1] & 192) !== 128)
      return t.lastNeed = 1, "�";
    if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
      return t.lastNeed = 2, "�";
  }
}
function vL(t) {
  var e = this.lastTotal - this.lastNeed, r = gL(this, t);
  if (r !== void 0) return r;
  if (this.lastNeed <= t.length)
    return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
}
function EL(t, e) {
  var r = bL(this, t, e);
  if (!this.lastNeed) return t.toString("utf8", e);
  this.lastTotal = r;
  var a = t.length - (r - this.lastNeed);
  return t.copy(this.lastChar, 0, a), t.toString("utf8", e, a);
}
function _L(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + "�" : e;
}
function SL(t, e) {
  if ((t.length - e) % 2 === 0) {
    var r = t.toString("utf16le", e);
    if (r) {
      var a = r.charCodeAt(r.length - 1);
      if (a >= 55296 && a <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
    }
    return r;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
}
function wL(t) {
  var e = t && t.length ? this.write(t) : "";
  if (this.lastNeed) {
    var r = this.lastTotal - this.lastNeed;
    return e + this.lastChar.toString("utf16le", 0, r);
  }
  return e;
}
function xL(t, e) {
  var r = (t.length - e) % 3;
  return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
}
function TL(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
}
function AL(t) {
  return t.toString(this.encoding);
}
function PL(t) {
  return t && t.length ? this.write(t) : "";
}
var p_ = yo.codes.ERR_STREAM_PREMATURE_CLOSE;
function CL(t) {
  var e = !1;
  return function() {
    if (!e) {
      e = !0;
      for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++)
        a[l] = arguments[l];
      t.apply(this, a);
    }
  };
}
function IL() {
}
function OL(t) {
  return t.setHeader && typeof t.abort == "function";
}
function DA(t, e, r) {
  if (typeof e == "function") return DA(t, null, e);
  e || (e = {}), r = CL(r || IL);
  var a = e.readable || e.readable !== !1 && t.readable, l = e.writable || e.writable !== !1 && t.writable, d = function() {
    t.writable || n();
  }, h = t._writableState && t._writableState.finished, n = function() {
    l = !1, h = !0, a || r.call(t);
  }, u = t._readableState && t._readableState.endEmitted, i = function() {
    a = !1, u = !0, l || r.call(t);
  }, c = function(y) {
    r.call(t, y);
  }, f = function() {
    var y;
    if (a && !u)
      return (!t._readableState || !t._readableState.ended) && (y = new p_()), r.call(t, y);
    if (l && !h)
      return (!t._writableState || !t._writableState.ended) && (y = new p_()), r.call(t, y);
  }, s = function() {
    t.req.on("finish", n);
  };
  return OL(t) ? (t.on("complete", n), t.on("abort", f), t.req ? s() : t.on("request", s)) : l && !t._writableState && (t.on("end", d), t.on("close", d)), t.on("end", i), t.on("finish", n), e.error !== !1 && t.on("error", c), t.on("close", f), function() {
    t.removeListener("complete", n), t.removeListener("abort", f), t.removeListener("request", s), t.req && t.req.removeListener("finish", n), t.removeListener("end", d), t.removeListener("close", d), t.removeListener("finish", n), t.removeListener("end", i), t.removeListener("error", c), t.removeListener("close", f);
  };
}
var Sb = DA, nm, h_;
function kL() {
  if (h_) return nm;
  h_ = 1;
  var t;
  function e(T, E, O) {
    return E = r(E), E in T ? Object.defineProperty(T, E, { value: O, enumerable: !0, configurable: !0, writable: !0 }) : T[E] = O, T;
  }
  function r(T) {
    var E = a(T, "string");
    return typeof E == "symbol" ? E : String(E);
  }
  function a(T, E) {
    if (typeof T != "object" || T === null) return T;
    var O = T[Symbol.toPrimitive];
    if (O !== void 0) {
      var D = O.call(T, E || "default");
      if (typeof D != "object") return D;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (E === "string" ? String : Number)(T);
  }
  var l = Sb, d = Symbol("lastResolve"), h = Symbol("lastReject"), n = Symbol("error"), u = Symbol("ended"), i = Symbol("lastPromise"), c = Symbol("handlePromise"), f = Symbol("stream");
  function s(T, E) {
    return {
      value: T,
      done: E
    };
  }
  function o(T) {
    var E = T[d];
    if (E !== null) {
      var O = T[f].read();
      O !== null && (T[i] = null, T[d] = null, T[h] = null, E(s(O, !1)));
    }
  }
  function y(T) {
    Ze.nextTick(o, T);
  }
  function m(T, E) {
    return function(O, D) {
      T.then(function() {
        if (E[u]) {
          O(s(void 0, !0));
          return;
        }
        E[c](O, D);
      }, D);
    };
  }
  var g = Object.getPrototypeOf(function() {
  }), b = Object.setPrototypeOf((t = {
    get stream() {
      return this[f];
    },
    next: function() {
      var E = this, O = this[n];
      if (O !== null)
        return Promise.reject(O);
      if (this[u])
        return Promise.resolve(s(void 0, !0));
      if (this[f].destroyed)
        return new Promise(function(k, L) {
          Ze.nextTick(function() {
            E[n] ? L(E[n]) : k(s(void 0, !0));
          });
        });
      var D = this[i], $;
      if (D)
        $ = new Promise(m(D, this));
      else {
        var I = this[f].read();
        if (I !== null)
          return Promise.resolve(s(I, !1));
        $ = new Promise(this[c]);
      }
      return this[i] = $, $;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var E = this;
    return new Promise(function(O, D) {
      E[f].destroy(null, function($) {
        if ($) {
          D($);
          return;
        }
        O(s(void 0, !0));
      });
    });
  }), t), g), v = function(E) {
    var O, D = Object.create(b, (O = {}, e(O, f, {
      value: E,
      writable: !0
    }), e(O, d, {
      value: null,
      writable: !0
    }), e(O, h, {
      value: null,
      writable: !0
    }), e(O, n, {
      value: null,
      writable: !0
    }), e(O, u, {
      value: E._readableState.endEmitted,
      writable: !0
    }), e(O, c, {
      value: function(I, k) {
        var L = D[f].read();
        L ? (D[i] = null, D[d] = null, D[h] = null, I(s(L, !1))) : (D[d] = I, D[h] = k);
      },
      writable: !0
    }), O));
    return D[i] = null, l(E, function($) {
      if ($ && $.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var I = D[h];
        I !== null && (D[i] = null, D[d] = null, D[h] = null, I($)), D[n] = $;
        return;
      }
      var k = D[d];
      k !== null && (D[i] = null, D[d] = null, D[h] = null, k(s(void 0, !0))), D[u] = !0;
    }), E.on("readable", y.bind(null, D)), D;
  };
  return nm = v, nm;
}
var im, m_;
function DL() {
  return m_ || (m_ = 1, im = function() {
    throw new Error("Readable.from is not available in the browser");
  }), im;
}
var sm, y_;
function NA() {
  if (y_) return sm;
  y_ = 1, sm = k;
  var t;
  k.ReadableState = I, po.EventEmitter;
  var e = function(ie, fe) {
    return ie.listeners(fe).length;
  }, r = PA, a = Ui.Buffer, l = (typeof jt < "u" ? jt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function d(K) {
    return a.from(K);
  }
  function h(K) {
    return a.isBuffer(K) || K instanceof l;
  }
  var n = Rr, u;
  n && n.debuglog ? u = n.debuglog("stream") : u = function() {
  };
  var i = iL(), c = CA, f = OA, s = f.getHighWaterMark, o = yo.codes, y = o.ERR_INVALID_ARG_TYPE, m = o.ERR_STREAM_PUSH_AFTER_EOF, g = o.ERR_METHOD_NOT_IMPLEMENTED, b = o.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, v, T, E;
  ir(k, r);
  var O = c.errorOrDestroy, D = ["error", "close", "destroy", "pause", "resume"];
  function $(K, ie, fe) {
    if (typeof K.prependListener == "function") return K.prependListener(ie, fe);
    !K._events || !K._events[ie] ? K.on(ie, fe) : Array.isArray(K._events[ie]) ? K._events[ie].unshift(fe) : K._events[ie] = [fe, K._events[ie]];
  }
  function I(K, ie, fe) {
    t = t || cl(), K = K || {}, typeof fe != "boolean" && (fe = ie instanceof t), this.objectMode = !!K.objectMode, fe && (this.objectMode = this.objectMode || !!K.readableObjectMode), this.highWaterMark = s(this, K, "readableHighWaterMark", fe), this.buffer = new i(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = K.emitClose !== !1, this.autoDestroy = !!K.autoDestroy, this.destroyed = !1, this.defaultEncoding = K.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, K.encoding && (v || (v = Kf.StringDecoder), this.decoder = new v(K.encoding), this.encoding = K.encoding);
  }
  function k(K) {
    if (t = t || cl(), !(this instanceof k)) return new k(K);
    var ie = this instanceof t;
    this._readableState = new I(K, this, ie), this.readable = !0, K && (typeof K.read == "function" && (this._read = K.read), typeof K.destroy == "function" && (this._destroy = K.destroy)), r.call(this);
  }
  Object.defineProperty(k.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(ie) {
      this._readableState && (this._readableState.destroyed = ie);
    }
  }), k.prototype.destroy = c.destroy, k.prototype._undestroy = c.undestroy, k.prototype._destroy = function(K, ie) {
    ie(K);
  }, k.prototype.push = function(K, ie) {
    var fe = this._readableState, _e;
    return fe.objectMode ? _e = !0 : typeof K == "string" && (ie = ie || fe.defaultEncoding, ie !== fe.encoding && (K = a.from(K, ie), ie = ""), _e = !0), L(this, K, ie, !1, _e);
  }, k.prototype.unshift = function(K) {
    return L(this, K, null, !0, !1);
  };
  function L(K, ie, fe, _e, Ae) {
    u("readableAddChunk", ie);
    var ce = K._readableState;
    if (ie === null)
      ce.reading = !1, R(K, ce);
    else {
      var ee;
      if (Ae || (ee = x(ce, ie)), ee)
        O(K, ee);
      else if (ce.objectMode || ie && ie.length > 0)
        if (typeof ie != "string" && !ce.objectMode && Object.getPrototypeOf(ie) !== a.prototype && (ie = d(ie)), _e)
          ce.endEmitted ? O(K, new b()) : M(K, ce, ie, !0);
        else if (ce.ended)
          O(K, new m());
        else {
          if (ce.destroyed)
            return !1;
          ce.reading = !1, ce.decoder && !fe ? (ie = ce.decoder.write(ie), ce.objectMode || ie.length !== 0 ? M(K, ce, ie, !1) : U(K, ce)) : M(K, ce, ie, !1);
        }
      else _e || (ce.reading = !1, U(K, ce));
    }
    return !ce.ended && (ce.length < ce.highWaterMark || ce.length === 0);
  }
  function M(K, ie, fe, _e) {
    ie.flowing && ie.length === 0 && !ie.sync ? (ie.awaitDrain = 0, K.emit("data", fe)) : (ie.length += ie.objectMode ? 1 : fe.length, _e ? ie.buffer.unshift(fe) : ie.buffer.push(fe), ie.needReadable && H(K)), U(K, ie);
  }
  function x(K, ie) {
    var fe;
    return !h(ie) && typeof ie != "string" && ie !== void 0 && !K.objectMode && (fe = new y("chunk", ["string", "Buffer", "Uint8Array"], ie)), fe;
  }
  k.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, k.prototype.setEncoding = function(K) {
    v || (v = Kf.StringDecoder);
    var ie = new v(K);
    this._readableState.decoder = ie, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var fe = this._readableState.buffer.head, _e = ""; fe !== null; )
      _e += ie.write(fe.data), fe = fe.next;
    return this._readableState.buffer.clear(), _e !== "" && this._readableState.buffer.push(_e), this._readableState.length = _e.length, this;
  };
  var _ = 1073741824;
  function S(K) {
    return K >= _ ? K = _ : (K--, K |= K >>> 1, K |= K >>> 2, K |= K >>> 4, K |= K >>> 8, K |= K >>> 16, K++), K;
  }
  function C(K, ie) {
    return K <= 0 || ie.length === 0 && ie.ended ? 0 : ie.objectMode ? 1 : K !== K ? ie.flowing && ie.length ? ie.buffer.head.data.length : ie.length : (K > ie.highWaterMark && (ie.highWaterMark = S(K)), K <= ie.length ? K : ie.ended ? ie.length : (ie.needReadable = !0, 0));
  }
  k.prototype.read = function(K) {
    u("read", K), K = parseInt(K, 10);
    var ie = this._readableState, fe = K;
    if (K !== 0 && (ie.emittedReadable = !1), K === 0 && ie.needReadable && ((ie.highWaterMark !== 0 ? ie.length >= ie.highWaterMark : ie.length > 0) || ie.ended))
      return u("read: emitReadable", ie.length, ie.ended), ie.length === 0 && ie.ended ? V(this) : H(this), null;
    if (K = C(K, ie), K === 0 && ie.ended)
      return ie.length === 0 && V(this), null;
    var _e = ie.needReadable;
    u("need readable", _e), (ie.length === 0 || ie.length - K < ie.highWaterMark) && (_e = !0, u("length less than watermark", _e)), ie.ended || ie.reading ? (_e = !1, u("reading or ended", _e)) : _e && (u("do read"), ie.reading = !0, ie.sync = !0, ie.length === 0 && (ie.needReadable = !0), this._read(ie.highWaterMark), ie.sync = !1, ie.reading || (K = C(fe, ie)));
    var Ae;
    return K > 0 ? Ae = N(K, ie) : Ae = null, Ae === null ? (ie.needReadable = ie.length <= ie.highWaterMark, K = 0) : (ie.length -= K, ie.awaitDrain = 0), ie.length === 0 && (ie.ended || (ie.needReadable = !0), fe !== K && ie.ended && V(this)), Ae !== null && this.emit("data", Ae), Ae;
  };
  function R(K, ie) {
    if (u("onEofChunk"), !ie.ended) {
      if (ie.decoder) {
        var fe = ie.decoder.end();
        fe && fe.length && (ie.buffer.push(fe), ie.length += ie.objectMode ? 1 : fe.length);
      }
      ie.ended = !0, ie.sync ? H(K) : (ie.needReadable = !1, ie.emittedReadable || (ie.emittedReadable = !0, z(K)));
    }
  }
  function H(K) {
    var ie = K._readableState;
    u("emitReadable", ie.needReadable, ie.emittedReadable), ie.needReadable = !1, ie.emittedReadable || (u("emitReadable", ie.flowing), ie.emittedReadable = !0, Ze.nextTick(z, K));
  }
  function z(K) {
    var ie = K._readableState;
    u("emitReadable_", ie.destroyed, ie.length, ie.ended), !ie.destroyed && (ie.length || ie.ended) && (K.emit("readable"), ie.emittedReadable = !1), ie.needReadable = !ie.flowing && !ie.ended && ie.length <= ie.highWaterMark, G(K);
  }
  function U(K, ie) {
    ie.readingMore || (ie.readingMore = !0, Ze.nextTick(P, K, ie));
  }
  function P(K, ie) {
    for (; !ie.reading && !ie.ended && (ie.length < ie.highWaterMark || ie.flowing && ie.length === 0); ) {
      var fe = ie.length;
      if (u("maybeReadMore read 0"), K.read(0), fe === ie.length)
        break;
    }
    ie.readingMore = !1;
  }
  k.prototype._read = function(K) {
    O(this, new g("_read()"));
  }, k.prototype.pipe = function(K, ie) {
    var fe = this, _e = this._readableState;
    switch (_e.pipesCount) {
      case 0:
        _e.pipes = K;
        break;
      case 1:
        _e.pipes = [_e.pipes, K];
        break;
      default:
        _e.pipes.push(K);
        break;
    }
    _e.pipesCount += 1, u("pipe count=%d opts=%j", _e.pipesCount, ie);
    var Ae = (!ie || ie.end !== !1) && K !== Ze.stdout && K !== Ze.stderr, ce = Ae ? ae : Ie;
    _e.endEmitted ? Ze.nextTick(ce) : fe.once("end", ce), K.on("unpipe", ee);
    function ee(Oe, Be) {
      u("onunpipe"), Oe === fe && Be && Be.hasUnpiped === !1 && (Be.hasUnpiped = !0, ye());
    }
    function ae() {
      u("onend"), K.end();
    }
    var oe = W(fe);
    K.on("drain", oe);
    var me = !1;
    function ye() {
      u("cleanup"), K.removeListener("close", se), K.removeListener("finish", be), K.removeListener("drain", oe), K.removeListener("error", ge), K.removeListener("unpipe", ee), fe.removeListener("end", ae), fe.removeListener("end", Ie), fe.removeListener("data", we), me = !0, _e.awaitDrain && (!K._writableState || K._writableState.needDrain) && oe();
    }
    fe.on("data", we);
    function we(Oe) {
      u("ondata");
      var Be = K.write(Oe);
      u("dest.write", Be), Be === !1 && ((_e.pipesCount === 1 && _e.pipes === K || _e.pipesCount > 1 && X(_e.pipes, K) !== -1) && !me && (u("false write response, pause", _e.awaitDrain), _e.awaitDrain++), fe.pause());
    }
    function ge(Oe) {
      u("onerror", Oe), Ie(), K.removeListener("error", ge), e(K, "error") === 0 && O(K, Oe);
    }
    $(K, "error", ge);
    function se() {
      K.removeListener("finish", be), Ie();
    }
    K.once("close", se);
    function be() {
      u("onfinish"), K.removeListener("close", se), Ie();
    }
    K.once("finish", be);
    function Ie() {
      u("unpipe"), fe.unpipe(K);
    }
    return K.emit("pipe", fe), _e.flowing || (u("pipe resume"), fe.resume()), K;
  };
  function W(K) {
    return function() {
      var fe = K._readableState;
      u("pipeOnDrain", fe.awaitDrain), fe.awaitDrain && fe.awaitDrain--, fe.awaitDrain === 0 && e(K, "data") && (fe.flowing = !0, G(K));
    };
  }
  k.prototype.unpipe = function(K) {
    var ie = this._readableState, fe = {
      hasUnpiped: !1
    };
    if (ie.pipesCount === 0) return this;
    if (ie.pipesCount === 1)
      return K && K !== ie.pipes ? this : (K || (K = ie.pipes), ie.pipes = null, ie.pipesCount = 0, ie.flowing = !1, K && K.emit("unpipe", this, fe), this);
    if (!K) {
      var _e = ie.pipes, Ae = ie.pipesCount;
      ie.pipes = null, ie.pipesCount = 0, ie.flowing = !1;
      for (var ce = 0; ce < Ae; ce++) _e[ce].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ee = X(ie.pipes, K);
    return ee === -1 ? this : (ie.pipes.splice(ee, 1), ie.pipesCount -= 1, ie.pipesCount === 1 && (ie.pipes = ie.pipes[0]), K.emit("unpipe", this, fe), this);
  }, k.prototype.on = function(K, ie) {
    var fe = r.prototype.on.call(this, K, ie), _e = this._readableState;
    return K === "data" ? (_e.readableListening = this.listenerCount("readable") > 0, _e.flowing !== !1 && this.resume()) : K === "readable" && !_e.endEmitted && !_e.readableListening && (_e.readableListening = _e.needReadable = !0, _e.flowing = !1, _e.emittedReadable = !1, u("on readable", _e.length, _e.reading), _e.length ? H(this) : _e.reading || Ze.nextTick(Q, this)), fe;
  }, k.prototype.addListener = k.prototype.on, k.prototype.removeListener = function(K, ie) {
    var fe = r.prototype.removeListener.call(this, K, ie);
    return K === "readable" && Ze.nextTick(B, this), fe;
  }, k.prototype.removeAllListeners = function(K) {
    var ie = r.prototype.removeAllListeners.apply(this, arguments);
    return (K === "readable" || K === void 0) && Ze.nextTick(B, this), ie;
  };
  function B(K) {
    var ie = K._readableState;
    ie.readableListening = K.listenerCount("readable") > 0, ie.resumeScheduled && !ie.paused ? ie.flowing = !0 : K.listenerCount("data") > 0 && K.resume();
  }
  function Q(K) {
    u("readable nexttick read 0"), K.read(0);
  }
  k.prototype.resume = function() {
    var K = this._readableState;
    return K.flowing || (u("resume"), K.flowing = !K.readableListening, J(this, K)), K.paused = !1, this;
  };
  function J(K, ie) {
    ie.resumeScheduled || (ie.resumeScheduled = !0, Ze.nextTick(re, K, ie));
  }
  function re(K, ie) {
    u("resume", ie.reading), ie.reading || K.read(0), ie.resumeScheduled = !1, K.emit("resume"), G(K), ie.flowing && !ie.reading && K.read(0);
  }
  k.prototype.pause = function() {
    return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function G(K) {
    var ie = K._readableState;
    for (u("flow", ie.flowing); ie.flowing && K.read() !== null; ) ;
  }
  k.prototype.wrap = function(K) {
    var ie = this, fe = this._readableState, _e = !1;
    K.on("end", function() {
      if (u("wrapped end"), fe.decoder && !fe.ended) {
        var ee = fe.decoder.end();
        ee && ee.length && ie.push(ee);
      }
      ie.push(null);
    }), K.on("data", function(ee) {
      if (u("wrapped data"), fe.decoder && (ee = fe.decoder.write(ee)), !(fe.objectMode && ee == null) && !(!fe.objectMode && (!ee || !ee.length))) {
        var ae = ie.push(ee);
        ae || (_e = !0, K.pause());
      }
    });
    for (var Ae in K)
      this[Ae] === void 0 && typeof K[Ae] == "function" && (this[Ae] = /* @__PURE__ */ function(ae) {
        return function() {
          return K[ae].apply(K, arguments);
        };
      }(Ae));
    for (var ce = 0; ce < D.length; ce++)
      K.on(D[ce], this.emit.bind(this, D[ce]));
    return this._read = function(ee) {
      u("wrapped _read", ee), _e && (_e = !1, K.resume());
    }, this;
  }, typeof Symbol == "function" && (k.prototype[Symbol.asyncIterator] = function() {
    return T === void 0 && (T = kL()), T(this);
  }), Object.defineProperty(k.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(k.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(k.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(ie) {
      this._readableState && (this._readableState.flowing = ie);
    }
  }), k._fromList = N, Object.defineProperty(k.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function N(K, ie) {
    if (ie.length === 0) return null;
    var fe;
    return ie.objectMode ? fe = ie.buffer.shift() : !K || K >= ie.length ? (ie.decoder ? fe = ie.buffer.join("") : ie.buffer.length === 1 ? fe = ie.buffer.first() : fe = ie.buffer.concat(ie.length), ie.buffer.clear()) : fe = ie.buffer.consume(K, ie.decoder), fe;
  }
  function V(K) {
    var ie = K._readableState;
    u("endReadable", ie.endEmitted), ie.endEmitted || (ie.ended = !0, Ze.nextTick(F, ie, K));
  }
  function F(K, ie) {
    if (u("endReadableNT", K.endEmitted, K.length), !K.endEmitted && K.length === 0 && (K.endEmitted = !0, ie.readable = !1, ie.emit("end"), K.autoDestroy)) {
      var fe = ie._writableState;
      (!fe || fe.autoDestroy && fe.finished) && ie.destroy();
    }
  }
  typeof Symbol == "function" && (k.from = function(K, ie) {
    return E === void 0 && (E = DL()), E(k, K, ie);
  });
  function X(K, ie) {
    for (var fe = 0, _e = K.length; fe < _e; fe++)
      if (K[fe] === ie) return fe;
    return -1;
  }
  return sm;
}
var RA = ra, Xd = yo.codes, NL = Xd.ERR_METHOD_NOT_IMPLEMENTED, RL = Xd.ERR_MULTIPLE_CALLBACK, ML = Xd.ERR_TRANSFORM_ALREADY_TRANSFORMING, LL = Xd.ERR_TRANSFORM_WITH_LENGTH_0, Jd = cl();
ir(ra, Jd);
function jL(t, e) {
  var r = this._transformState;
  r.transforming = !1;
  var a = r.writecb;
  if (a === null)
    return this.emit("error", new RL());
  r.writechunk = null, r.writecb = null, e != null && this.push(e), a(t);
  var l = this._readableState;
  l.reading = !1, (l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
}
function ra(t) {
  if (!(this instanceof ra)) return new ra(t);
  Jd.call(this, t), this._transformState = {
    afterTransform: jL.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", FL);
}
function FL() {
  var t = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
    b_(t, e, r);
  }) : b_(this, null, null);
}
ra.prototype.push = function(t, e) {
  return this._transformState.needTransform = !1, Jd.prototype.push.call(this, t, e);
};
ra.prototype._transform = function(t, e, r) {
  r(new NL("_transform()"));
};
ra.prototype._write = function(t, e, r) {
  var a = this._transformState;
  if (a.writecb = r, a.writechunk = t, a.writeencoding = e, !a.transforming) {
    var l = this._readableState;
    (a.needTransform || l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
  }
};
ra.prototype._read = function(t) {
  var e = this._transformState;
  e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
};
ra.prototype._destroy = function(t, e) {
  Jd.prototype._destroy.call(this, t, function(r) {
    e(r);
  });
};
function b_(t, e, r) {
  if (e) return t.emit("error", e);
  if (r != null && t.push(r), t._writableState.length) throw new LL();
  if (t._transformState.transforming) throw new ML();
  return t.push(null);
}
var BL = Iu, MA = RA;
ir(Iu, MA);
function Iu(t) {
  if (!(this instanceof Iu)) return new Iu(t);
  MA.call(this, t);
}
Iu.prototype._transform = function(t, e, r) {
  r(null, t);
};
var am;
function $L(t) {
  var e = !1;
  return function() {
    e || (e = !0, t.apply(void 0, arguments));
  };
}
var LA = yo.codes, UL = LA.ERR_MISSING_ARGS, VL = LA.ERR_STREAM_DESTROYED;
function g_(t) {
  if (t) throw t;
}
function WL(t) {
  return t.setHeader && typeof t.abort == "function";
}
function qL(t, e, r, a) {
  a = $L(a);
  var l = !1;
  t.on("close", function() {
    l = !0;
  }), am === void 0 && (am = Sb), am(t, {
    readable: e,
    writable: r
  }, function(h) {
    if (h) return a(h);
    l = !0, a();
  });
  var d = !1;
  return function(h) {
    if (!l && !d) {
      if (d = !0, WL(t)) return t.abort();
      if (typeof t.destroy == "function") return t.destroy();
      a(h || new VL("pipe"));
    }
  };
}
function v_(t) {
  t();
}
function HL(t, e) {
  return t.pipe(e);
}
function GL(t) {
  return !t.length || typeof t[t.length - 1] != "function" ? g_ : t.pop();
}
function zL() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  var a = GL(e);
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
    throw new UL("streams");
  var l, d = e.map(function(h, n) {
    var u = n < e.length - 1, i = n > 0;
    return qL(h, u, i, function(c) {
      l || (l = c), c && d.forEach(v_), !u && (d.forEach(v_), a(l));
    });
  });
  return e.reduce(HL);
}
var KL = zL;
(function(t, e) {
  e = t.exports = NA(), e.Stream = e, e.Readable = e, e.Writable = kA(), e.Duplex = cl(), e.Transform = RA, e.PassThrough = BL, e.finished = Sb, e.pipeline = KL;
})(A1, A1.exports);
var YL = A1.exports, Yf = cr.Buffer, jA = YL.Transform, XL = ir;
function JL(t, e) {
  if (!Yf.isBuffer(t) && typeof t != "string")
    throw new TypeError(e + " must be a string or a buffer");
}
function Da(t) {
  jA.call(this), this._block = Yf.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
XL(Da, jA);
Da.prototype._transform = function(t, e, r) {
  var a = null;
  try {
    this.update(t, e);
  } catch (l) {
    a = l;
  }
  r(a);
};
Da.prototype._flush = function(t) {
  var e = null;
  try {
    this.push(this.digest());
  } catch (r) {
    e = r;
  }
  t(e);
};
Da.prototype.update = function(t, e) {
  if (JL(t, "Data"), this._finalized) throw new Error("Digest already called");
  Yf.isBuffer(t) || (t = Yf.from(t, e));
  for (var r = this._block, a = 0; this._blockOffset + t.length - a >= this._blockSize; ) {
    for (var l = this._blockOffset; l < this._blockSize; ) r[l++] = t[a++];
    this._update(), this._blockOffset = 0;
  }
  for (; a < t.length; ) r[this._blockOffset++] = t[a++];
  for (var d = 0, h = t.length * 8; h > 0; ++d)
    this._length[d] += h, h = this._length[d] / 4294967296 | 0, h > 0 && (this._length[d] -= 4294967296 * h);
  return this;
};
Da.prototype._update = function() {
  throw new Error("_update is not implemented");
};
Da.prototype.digest = function(t) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var e = this._digest();
  t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
  for (var r = 0; r < 4; ++r) this._length[r] = 0;
  return e;
};
Da.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var FA = Da, QL = ir, BA = FA, ZL = cr.Buffer, ej = new Array(16);
function Qd() {
  BA.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
QL(Qd, BA);
Qd.prototype._update = function() {
  for (var t = ej, e = 0; e < 16; ++e) t[e] = this._block.readInt32LE(e * 4);
  var r = this._a, a = this._b, l = this._c, d = this._d;
  r = Kn(r, a, l, d, t[0], 3614090360, 7), d = Kn(d, r, a, l, t[1], 3905402710, 12), l = Kn(l, d, r, a, t[2], 606105819, 17), a = Kn(a, l, d, r, t[3], 3250441966, 22), r = Kn(r, a, l, d, t[4], 4118548399, 7), d = Kn(d, r, a, l, t[5], 1200080426, 12), l = Kn(l, d, r, a, t[6], 2821735955, 17), a = Kn(a, l, d, r, t[7], 4249261313, 22), r = Kn(r, a, l, d, t[8], 1770035416, 7), d = Kn(d, r, a, l, t[9], 2336552879, 12), l = Kn(l, d, r, a, t[10], 4294925233, 17), a = Kn(a, l, d, r, t[11], 2304563134, 22), r = Kn(r, a, l, d, t[12], 1804603682, 7), d = Kn(d, r, a, l, t[13], 4254626195, 12), l = Kn(l, d, r, a, t[14], 2792965006, 17), a = Kn(a, l, d, r, t[15], 1236535329, 22), r = Yn(r, a, l, d, t[1], 4129170786, 5), d = Yn(d, r, a, l, t[6], 3225465664, 9), l = Yn(l, d, r, a, t[11], 643717713, 14), a = Yn(a, l, d, r, t[0], 3921069994, 20), r = Yn(r, a, l, d, t[5], 3593408605, 5), d = Yn(d, r, a, l, t[10], 38016083, 9), l = Yn(l, d, r, a, t[15], 3634488961, 14), a = Yn(a, l, d, r, t[4], 3889429448, 20), r = Yn(r, a, l, d, t[9], 568446438, 5), d = Yn(d, r, a, l, t[14], 3275163606, 9), l = Yn(l, d, r, a, t[3], 4107603335, 14), a = Yn(a, l, d, r, t[8], 1163531501, 20), r = Yn(r, a, l, d, t[13], 2850285829, 5), d = Yn(d, r, a, l, t[2], 4243563512, 9), l = Yn(l, d, r, a, t[7], 1735328473, 14), a = Yn(a, l, d, r, t[12], 2368359562, 20), r = Xn(r, a, l, d, t[5], 4294588738, 4), d = Xn(d, r, a, l, t[8], 2272392833, 11), l = Xn(l, d, r, a, t[11], 1839030562, 16), a = Xn(a, l, d, r, t[14], 4259657740, 23), r = Xn(r, a, l, d, t[1], 2763975236, 4), d = Xn(d, r, a, l, t[4], 1272893353, 11), l = Xn(l, d, r, a, t[7], 4139469664, 16), a = Xn(a, l, d, r, t[10], 3200236656, 23), r = Xn(r, a, l, d, t[13], 681279174, 4), d = Xn(d, r, a, l, t[0], 3936430074, 11), l = Xn(l, d, r, a, t[3], 3572445317, 16), a = Xn(a, l, d, r, t[6], 76029189, 23), r = Xn(r, a, l, d, t[9], 3654602809, 4), d = Xn(d, r, a, l, t[12], 3873151461, 11), l = Xn(l, d, r, a, t[15], 530742520, 16), a = Xn(a, l, d, r, t[2], 3299628645, 23), r = Jn(r, a, l, d, t[0], 4096336452, 6), d = Jn(d, r, a, l, t[7], 1126891415, 10), l = Jn(l, d, r, a, t[14], 2878612391, 15), a = Jn(a, l, d, r, t[5], 4237533241, 21), r = Jn(r, a, l, d, t[12], 1700485571, 6), d = Jn(d, r, a, l, t[3], 2399980690, 10), l = Jn(l, d, r, a, t[10], 4293915773, 15), a = Jn(a, l, d, r, t[1], 2240044497, 21), r = Jn(r, a, l, d, t[8], 1873313359, 6), d = Jn(d, r, a, l, t[15], 4264355552, 10), l = Jn(l, d, r, a, t[6], 2734768916, 15), a = Jn(a, l, d, r, t[13], 1309151649, 21), r = Jn(r, a, l, d, t[4], 4149444226, 6), d = Jn(d, r, a, l, t[11], 3174756917, 10), l = Jn(l, d, r, a, t[2], 718787259, 15), a = Jn(a, l, d, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + a | 0, this._c = this._c + l | 0, this._d = this._d + d | 0;
};
Qd.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = ZL.allocUnsafe(16);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
};
function Zd(t, e) {
  return t << e | t >>> 32 - e;
}
function Kn(t, e, r, a, l, d, h) {
  return Zd(t + (e & r | ~e & a) + l + d | 0, h) + e | 0;
}
function Yn(t, e, r, a, l, d, h) {
  return Zd(t + (e & a | r & ~a) + l + d | 0, h) + e | 0;
}
function Xn(t, e, r, a, l, d, h) {
  return Zd(t + (e ^ r ^ a) + l + d | 0, h) + e | 0;
}
function Jn(t, e, r, a, l, d, h) {
  return Zd(t + (r ^ (e | ~a)) + l + d | 0, h) + e | 0;
}
var wb = Qd, om = Ui.Buffer, tj = ir, $A = FA, rj = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], Kl = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], Yl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], Xl = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], Jl = [0, 1518500249, 1859775393, 2400959708, 2840853838], Ql = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function ep() {
  $A.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
tj(ep, $A);
ep.prototype._update = function() {
  for (var t = rj, e = 0; e < 16; ++e) t[e] = this._block.readInt32LE(e * 4);
  for (var r = this._a | 0, a = this._b | 0, l = this._c | 0, d = this._d | 0, h = this._e | 0, n = this._a | 0, u = this._b | 0, i = this._c | 0, c = this._d | 0, f = this._e | 0, s = 0; s < 80; s += 1) {
    var o, y;
    s < 16 ? (o = E_(r, a, l, d, h, t[zl[s]], Jl[0], Yl[s]), y = x_(n, u, i, c, f, t[Kl[s]], Ql[0], Xl[s])) : s < 32 ? (o = __(r, a, l, d, h, t[zl[s]], Jl[1], Yl[s]), y = w_(n, u, i, c, f, t[Kl[s]], Ql[1], Xl[s])) : s < 48 ? (o = S_(r, a, l, d, h, t[zl[s]], Jl[2], Yl[s]), y = S_(n, u, i, c, f, t[Kl[s]], Ql[2], Xl[s])) : s < 64 ? (o = w_(r, a, l, d, h, t[zl[s]], Jl[3], Yl[s]), y = __(n, u, i, c, f, t[Kl[s]], Ql[3], Xl[s])) : (o = x_(r, a, l, d, h, t[zl[s]], Jl[4], Yl[s]), y = E_(n, u, i, c, f, t[Kl[s]], Ql[4], Xl[s])), r = h, h = d, d = so(l, 10), l = a, a = o, n = f, f = c, c = so(i, 10), i = u, u = y;
  }
  var m = this._b + l + c | 0;
  this._b = this._c + d + f | 0, this._c = this._d + h + n | 0, this._d = this._e + r + u | 0, this._e = this._a + a + i | 0, this._a = m;
};
ep.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = om.alloc ? om.alloc(20) : new om(20);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
};
function so(t, e) {
  return t << e | t >>> 32 - e;
}
function E_(t, e, r, a, l, d, h, n) {
  return so(t + (e ^ r ^ a) + d + h | 0, n) + l | 0;
}
function __(t, e, r, a, l, d, h, n) {
  return so(t + (e & r | ~e & a) + d + h | 0, n) + l | 0;
}
function S_(t, e, r, a, l, d, h, n) {
  return so(t + ((e | ~r) ^ a) + d + h | 0, n) + l | 0;
}
function w_(t, e, r, a, l, d, h, n) {
  return so(t + (e & a | r & ~a) + d + h | 0, n) + l | 0;
}
function x_(t, e, r, a, l, d, h, n) {
  return so(t + (e ^ (r | ~a)) + d + h | 0, n) + l | 0;
}
var xb = ep, UA = { exports: {} }, VA = cr.Buffer;
function tp(t, e) {
  this._block = VA.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
}
tp.prototype.update = function(t, e) {
  typeof t == "string" && (e = e || "utf8", t = VA.from(t, e));
  for (var r = this._block, a = this._blockSize, l = t.length, d = this._len, h = 0; h < l; ) {
    for (var n = d % a, u = Math.min(l - h, a - n), i = 0; i < u; i++)
      r[n + i] = t[h + i];
    d += u, h += u, d % a === 0 && this._update(r);
  }
  return this._len += l, this;
};
tp.prototype.digest = function(t) {
  var e = this._len % this._blockSize;
  this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var r = this._len * 8;
  if (r <= 4294967295)
    this._block.writeUInt32BE(r, this._blockSize - 4);
  else {
    var a = (r & 4294967295) >>> 0, l = (r - a) / 4294967296;
    this._block.writeUInt32BE(l, this._blockSize - 8), this._block.writeUInt32BE(a, this._blockSize - 4);
  }
  this._update(this._block);
  var d = this._hash();
  return t ? d.toString(t) : d;
};
tp.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Il = tp, nj = ir, WA = Il, ij = cr.Buffer, sj = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], aj = new Array(80);
function ec() {
  this.init(), this._w = aj, WA.call(this, 64, 56);
}
nj(ec, WA);
ec.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function oj(t) {
  return t << 5 | t >>> 27;
}
function lj(t) {
  return t << 30 | t >>> 2;
}
function uj(t, e, r, a) {
  return t === 0 ? e & r | ~e & a : t === 2 ? e & r | e & a | r & a : e ^ r ^ a;
}
ec.prototype._update = function(t) {
  for (var e = this._w, r = this._a | 0, a = this._b | 0, l = this._c | 0, d = this._d | 0, h = this._e | 0, n = 0; n < 16; ++n) e[n] = t.readInt32BE(n * 4);
  for (; n < 80; ++n) e[n] = e[n - 3] ^ e[n - 8] ^ e[n - 14] ^ e[n - 16];
  for (var u = 0; u < 80; ++u) {
    var i = ~~(u / 20), c = oj(r) + uj(i, a, l, d) + h + e[u] + sj[i] | 0;
    h = d, d = l, l = lj(a), a = r, r = c;
  }
  this._a = r + this._a | 0, this._b = a + this._b | 0, this._c = l + this._c | 0, this._d = d + this._d | 0, this._e = h + this._e | 0;
};
ec.prototype._hash = function() {
  var t = ij.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var cj = ec, fj = ir, qA = Il, dj = cr.Buffer, pj = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], hj = new Array(80);
function tc() {
  this.init(), this._w = hj, qA.call(this, 64, 56);
}
fj(tc, qA);
tc.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function mj(t) {
  return t << 1 | t >>> 31;
}
function yj(t) {
  return t << 5 | t >>> 27;
}
function bj(t) {
  return t << 30 | t >>> 2;
}
function gj(t, e, r, a) {
  return t === 0 ? e & r | ~e & a : t === 2 ? e & r | e & a | r & a : e ^ r ^ a;
}
tc.prototype._update = function(t) {
  for (var e = this._w, r = this._a | 0, a = this._b | 0, l = this._c | 0, d = this._d | 0, h = this._e | 0, n = 0; n < 16; ++n) e[n] = t.readInt32BE(n * 4);
  for (; n < 80; ++n) e[n] = mj(e[n - 3] ^ e[n - 8] ^ e[n - 14] ^ e[n - 16]);
  for (var u = 0; u < 80; ++u) {
    var i = ~~(u / 20), c = yj(r) + gj(i, a, l, d) + h + e[u] + pj[i] | 0;
    h = d, d = l, l = bj(a), a = r, r = c;
  }
  this._a = r + this._a | 0, this._b = a + this._b | 0, this._c = l + this._c | 0, this._d = d + this._d | 0, this._e = h + this._e | 0;
};
tc.prototype._hash = function() {
  var t = dj.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var vj = tc, Ej = ir, HA = Il, _j = cr.Buffer, Sj = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], wj = new Array(64);
function rc() {
  this.init(), this._w = wj, HA.call(this, 64, 56);
}
Ej(rc, HA);
rc.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function xj(t, e, r) {
  return r ^ t & (e ^ r);
}
function Tj(t, e, r) {
  return t & e | r & (t | e);
}
function Aj(t) {
  return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
}
function Pj(t) {
  return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
}
function Cj(t) {
  return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
}
function Ij(t) {
  return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
}
rc.prototype._update = function(t) {
  for (var e = this._w, r = this._a | 0, a = this._b | 0, l = this._c | 0, d = this._d | 0, h = this._e | 0, n = this._f | 0, u = this._g | 0, i = this._h | 0, c = 0; c < 16; ++c) e[c] = t.readInt32BE(c * 4);
  for (; c < 64; ++c) e[c] = Ij(e[c - 2]) + e[c - 7] + Cj(e[c - 15]) + e[c - 16] | 0;
  for (var f = 0; f < 64; ++f) {
    var s = i + Pj(h) + xj(h, n, u) + Sj[f] + e[f] | 0, o = Aj(r) + Tj(r, a, l) | 0;
    i = u, u = n, n = h, h = d + s | 0, d = l, l = a, a = r, r = s + o | 0;
  }
  this._a = r + this._a | 0, this._b = a + this._b | 0, this._c = l + this._c | 0, this._d = d + this._d | 0, this._e = h + this._e | 0, this._f = n + this._f | 0, this._g = u + this._g | 0, this._h = i + this._h | 0;
};
rc.prototype._hash = function() {
  var t = _j.allocUnsafe(32);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
};
var GA = rc, Oj = ir, kj = GA, Dj = Il, Nj = cr.Buffer, Rj = new Array(64);
function rp() {
  this.init(), this._w = Rj, Dj.call(this, 64, 56);
}
Oj(rp, kj);
rp.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
rp.prototype._hash = function() {
  var t = Nj.allocUnsafe(28);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
};
var Mj = rp, Lj = ir, zA = Il, jj = cr.Buffer, T_ = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], Fj = new Array(160);
function nc() {
  this.init(), this._w = Fj, zA.call(this, 128, 112);
}
Lj(nc, zA);
nc.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function A_(t, e, r) {
  return r ^ t & (e ^ r);
}
function P_(t, e, r) {
  return t & e | r & (t | e);
}
function C_(t, e) {
  return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
}
function I_(t, e) {
  return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
}
function Bj(t, e) {
  return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
}
function $j(t, e) {
  return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
}
function Uj(t, e) {
  return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
}
function Vj(t, e) {
  return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
}
function Dn(t, e) {
  return t >>> 0 < e >>> 0 ? 1 : 0;
}
nc.prototype._update = function(t) {
  for (var e = this._w, r = this._ah | 0, a = this._bh | 0, l = this._ch | 0, d = this._dh | 0, h = this._eh | 0, n = this._fh | 0, u = this._gh | 0, i = this._hh | 0, c = this._al | 0, f = this._bl | 0, s = this._cl | 0, o = this._dl | 0, y = this._el | 0, m = this._fl | 0, g = this._gl | 0, b = this._hl | 0, v = 0; v < 32; v += 2)
    e[v] = t.readInt32BE(v * 4), e[v + 1] = t.readInt32BE(v * 4 + 4);
  for (; v < 160; v += 2) {
    var T = e[v - 30], E = e[v - 15 * 2 + 1], O = Bj(T, E), D = $j(E, T);
    T = e[v - 2 * 2], E = e[v - 2 * 2 + 1];
    var $ = Uj(T, E), I = Vj(E, T), k = e[v - 7 * 2], L = e[v - 7 * 2 + 1], M = e[v - 16 * 2], x = e[v - 16 * 2 + 1], _ = D + L | 0, S = O + k + Dn(_, D) | 0;
    _ = _ + I | 0, S = S + $ + Dn(_, I) | 0, _ = _ + x | 0, S = S + M + Dn(_, x) | 0, e[v] = S, e[v + 1] = _;
  }
  for (var C = 0; C < 160; C += 2) {
    S = e[C], _ = e[C + 1];
    var R = P_(r, a, l), H = P_(c, f, s), z = C_(r, c), U = C_(c, r), P = I_(h, y), W = I_(y, h), B = T_[C], Q = T_[C + 1], J = A_(h, n, u), re = A_(y, m, g), G = b + W | 0, N = i + P + Dn(G, b) | 0;
    G = G + re | 0, N = N + J + Dn(G, re) | 0, G = G + Q | 0, N = N + B + Dn(G, Q) | 0, G = G + _ | 0, N = N + S + Dn(G, _) | 0;
    var V = U + H | 0, F = z + R + Dn(V, U) | 0;
    i = u, b = g, u = n, g = m, n = h, m = y, y = o + G | 0, h = d + N + Dn(y, o) | 0, d = l, o = s, l = a, s = f, a = r, f = c, c = G + V | 0, r = N + F + Dn(c, G) | 0;
  }
  this._al = this._al + c | 0, this._bl = this._bl + f | 0, this._cl = this._cl + s | 0, this._dl = this._dl + o | 0, this._el = this._el + y | 0, this._fl = this._fl + m | 0, this._gl = this._gl + g | 0, this._hl = this._hl + b | 0, this._ah = this._ah + r + Dn(this._al, c) | 0, this._bh = this._bh + a + Dn(this._bl, f) | 0, this._ch = this._ch + l + Dn(this._cl, s) | 0, this._dh = this._dh + d + Dn(this._dl, o) | 0, this._eh = this._eh + h + Dn(this._el, y) | 0, this._fh = this._fh + n + Dn(this._fl, m) | 0, this._gh = this._gh + u + Dn(this._gl, g) | 0, this._hh = this._hh + i + Dn(this._hl, b) | 0;
};
nc.prototype._hash = function() {
  var t = jj.allocUnsafe(64);
  function e(r, a, l) {
    t.writeInt32BE(r, l), t.writeInt32BE(a, l + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
};
var KA = nc, Wj = ir, qj = KA, Hj = Il, Gj = cr.Buffer, zj = new Array(160);
function np() {
  this.init(), this._w = zj, Hj.call(this, 128, 112);
}
Wj(np, qj);
np.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
np.prototype._hash = function() {
  var t = Gj.allocUnsafe(48);
  function e(r, a, l) {
    t.writeInt32BE(r, l), t.writeInt32BE(a, l + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
};
var Kj = np, bo = UA.exports = function(e) {
  e = e.toLowerCase();
  var r = bo[e];
  if (!r) throw new Error(e + " is not supported (we accept pull requests)");
  return new r();
};
bo.sha = cj;
bo.sha1 = vj;
bo.sha224 = Mj;
bo.sha256 = GA;
bo.sha384 = Kj;
bo.sha512 = KA;
var Tb = UA.exports, YA = cr.Buffer, XA = Rr.Transform, Yj = Kf.StringDecoder, Xj = ir;
function os(t) {
  XA.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
Xj(os, XA);
os.prototype.update = function(t, e, r) {
  typeof t == "string" && (t = YA.from(t, e));
  var a = this._update(t);
  return this.hashMode ? this : (r && (a = this._toString(a, r)), a);
};
os.prototype.setAutoPadding = function() {
};
os.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
os.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
os.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
os.prototype._transform = function(t, e, r) {
  var a;
  try {
    this.hashMode ? this._update(t) : this.push(this._update(t));
  } catch (l) {
    a = l;
  } finally {
    r(a);
  }
};
os.prototype._flush = function(t) {
  var e;
  try {
    this.push(this.__final());
  } catch (r) {
    e = r;
  }
  t(e);
};
os.prototype._finalOrDigest = function(t) {
  var e = this.__final() || YA.alloc(0);
  return t && (e = this._toString(e, t, !0)), e;
};
os.prototype._toString = function(t, e, r) {
  if (this._decoder || (this._decoder = new Yj(e), this._encoding = e), this._encoding !== e) throw new Error("can't switch encodings");
  var a = this._decoder.write(t);
  return r && (a += this._decoder.end()), a;
};
var Na = os, Jj = ir, Qj = wb, Zj = xb, eF = Tb, JA = Na;
function ip(t) {
  JA.call(this, "digest"), this._hash = t;
}
Jj(ip, JA);
ip.prototype._update = function(t) {
  this._hash.update(t);
};
ip.prototype._final = function() {
  return this._hash.digest();
};
var ic = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new Qj() : e === "rmd160" || e === "ripemd160" ? new Zj() : new ip(eF(e));
}, tF = ir, Ja = cr.Buffer, QA = Na, rF = Ja.alloc(128), Bo = 64;
function sp(t, e) {
  QA.call(this, "digest"), typeof e == "string" && (e = Ja.from(e)), this._alg = t, this._key = e, e.length > Bo ? e = t(e) : e.length < Bo && (e = Ja.concat([e, rF], Bo));
  for (var r = this._ipad = Ja.allocUnsafe(Bo), a = this._opad = Ja.allocUnsafe(Bo), l = 0; l < Bo; l++)
    r[l] = e[l] ^ 54, a[l] = e[l] ^ 92;
  this._hash = [r];
}
tF(sp, QA);
sp.prototype._update = function(t) {
  this._hash.push(t);
};
sp.prototype._final = function() {
  var t = this._alg(Ja.concat(this._hash));
  return this._alg(Ja.concat([this._opad, t]));
};
var nF = sp, iF = wb, ZA = function(t) {
  return new iF().update(t).digest();
}, sF = ir, aF = nF, eP = Na, ou = cr.Buffer, oF = ZA, C1 = xb, I1 = Tb, lF = ou.alloc(128);
function Ou(t, e) {
  eP.call(this, "digest"), typeof e == "string" && (e = ou.from(e));
  var r = t === "sha512" || t === "sha384" ? 128 : 64;
  if (this._alg = t, this._key = e, e.length > r) {
    var a = t === "rmd160" ? new C1() : I1(t);
    e = a.update(e).digest();
  } else e.length < r && (e = ou.concat([e, lF], r));
  for (var l = this._ipad = ou.allocUnsafe(r), d = this._opad = ou.allocUnsafe(r), h = 0; h < r; h++)
    l[h] = e[h] ^ 54, d[h] = e[h] ^ 92;
  this._hash = t === "rmd160" ? new C1() : I1(t), this._hash.update(l);
}
sF(Ou, eP);
Ou.prototype._update = function(t) {
  this._hash.update(t);
};
Ou.prototype._final = function() {
  var t = this._hash.digest(), e = this._alg === "rmd160" ? new C1() : I1(this._alg);
  return e.update(this._opad).update(t).digest();
};
var tP = function(e, r) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new Ou("rmd160", r) : e === "md5" ? new aF(oF, r) : new Ou(e, r);
};
const uF = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, cF = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, fF = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, dF = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, pF = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, hF = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, mF = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, yF = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, bF = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, gF = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, vF = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, rP = {
  sha224WithRSAEncryption: uF,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: cF,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: fF,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: dF,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: pF,
  sha224: hF,
  sha384: mF,
  sha512: yF,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: bF,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: gF,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: vF,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var EF = rP, ap = {}, _F = Math.pow(2, 30) - 1, nP = function(t, e) {
  if (typeof t != "number")
    throw new TypeError("Iterations not a number");
  if (t < 0)
    throw new TypeError("Bad iterations");
  if (typeof e != "number")
    throw new TypeError("Key length not a number");
  if (e < 0 || e > _F || e !== e)
    throw new TypeError("Bad key length");
}, Sf;
if (jt.process && jt.process.browser)
  Sf = "utf-8";
else if (jt.process && jt.process.version) {
  var SF = parseInt(Ze.version.split(".")[0].slice(1), 10);
  Sf = SF >= 6 ? "utf-8" : "binary";
} else
  Sf = "utf-8";
var iP = Sf, lm = cr.Buffer, sP = function(t, e, r) {
  if (lm.isBuffer(t))
    return t;
  if (typeof t == "string")
    return lm.from(t, e);
  if (ArrayBuffer.isView(t))
    return lm.from(t.buffer);
  throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
}, wF = ZA, xF = xb, TF = Tb, Qa = cr.Buffer, AF = nP, O_ = iP, k_ = sP, PF = Qa.alloc(128), wf = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function aP(t, e, r) {
  var a = CF(t), l = t === "sha512" || t === "sha384" ? 128 : 64;
  e.length > l ? e = a(e) : e.length < l && (e = Qa.concat([e, PF], l));
  for (var d = Qa.allocUnsafe(l + wf[t]), h = Qa.allocUnsafe(l + wf[t]), n = 0; n < l; n++)
    d[n] = e[n] ^ 54, h[n] = e[n] ^ 92;
  var u = Qa.allocUnsafe(l + r + 4);
  d.copy(u, 0, 0, l), this.ipad1 = u, this.ipad2 = d, this.opad = h, this.alg = t, this.blocksize = l, this.hash = a, this.size = wf[t];
}
aP.prototype.run = function(t, e) {
  t.copy(e, this.blocksize);
  var r = this.hash(e);
  return r.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function CF(t) {
  function e(a) {
    return TF(t).update(a).digest();
  }
  function r(a) {
    return new xF().update(a).digest();
  }
  return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? wF : e;
}
function IF(t, e, r, a, l) {
  AF(r, a), t = k_(t, O_, "Password"), e = k_(e, O_, "Salt"), l = l || "sha1";
  var d = new aP(l, t, e.length), h = Qa.allocUnsafe(a), n = Qa.allocUnsafe(e.length + 4);
  e.copy(n, 0, 0, e.length);
  for (var u = 0, i = wf[l], c = Math.ceil(a / i), f = 1; f <= c; f++) {
    n.writeUInt32BE(f, e.length);
    for (var s = d.run(n, d.ipad1), o = s, y = 1; y < r; y++) {
      o = d.run(o, d.ipad2);
      for (var m = 0; m < i; m++) s[m] ^= o[m];
    }
    s.copy(h, u), u += i;
  }
  return h;
}
var oP = IF, lP = cr.Buffer, OF = nP, D_ = iP, N_ = oP, R_ = sP, zc, bu = jt.crypto && jt.crypto.subtle, kF = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, um = [];
function DF(t) {
  if (jt.process && !jt.process.browser || !bu || !bu.importKey || !bu.deriveBits)
    return Promise.resolve(!1);
  if (um[t] !== void 0)
    return um[t];
  zc = zc || lP.alloc(8);
  var e = uP(zc, zc, 10, 128, t).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return um[t] = e, e;
}
var $a;
function O1() {
  return $a || (jt.process && jt.process.nextTick ? $a = jt.process.nextTick : jt.queueMicrotask ? $a = jt.queueMicrotask : jt.setImmediate ? $a = jt.setImmediate : $a = jt.setTimeout, $a);
}
function uP(t, e, r, a, l) {
  return bu.importKey(
    "raw",
    t,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(d) {
    return bu.deriveBits({
      name: "PBKDF2",
      salt: e,
      iterations: r,
      hash: {
        name: l
      }
    }, d, a << 3);
  }).then(function(d) {
    return lP.from(d);
  });
}
function NF(t, e) {
  t.then(function(r) {
    O1()(function() {
      e(null, r);
    });
  }, function(r) {
    O1()(function() {
      e(r);
    });
  });
}
var RF = function(t, e, r, a, l, d) {
  typeof l == "function" && (d = l, l = void 0), l = l || "sha1";
  var h = kF[l.toLowerCase()];
  if (!h || typeof jt.Promise != "function") {
    O1()(function() {
      var n;
      try {
        n = N_(t, e, r, a, l);
      } catch (u) {
        return d(u);
      }
      d(null, n);
    });
    return;
  }
  if (OF(r, a), t = R_(t, D_, "Password"), e = R_(e, D_, "Salt"), typeof d != "function") throw new Error("No callback provided to pbkdf2");
  NF(DF(h).then(function(n) {
    return n ? uP(t, e, r, a, h) : N_(t, e, r, a, l);
  }), d);
};
ap.pbkdf2 = RF;
ap.pbkdf2Sync = oP;
var rs = {}, Ol = {}, Ti = {};
Ti.readUInt32BE = function(e, r) {
  var a = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
  return a >>> 0;
};
Ti.writeUInt32BE = function(e, r, a) {
  e[0 + a] = r >>> 24, e[1 + a] = r >>> 16 & 255, e[2 + a] = r >>> 8 & 255, e[3 + a] = r & 255;
};
Ti.ip = function(e, r, a, l) {
  for (var d = 0, h = 0, n = 6; n >= 0; n -= 2) {
    for (var u = 0; u <= 24; u += 8)
      d <<= 1, d |= r >>> u + n & 1;
    for (var u = 0; u <= 24; u += 8)
      d <<= 1, d |= e >>> u + n & 1;
  }
  for (var n = 6; n >= 0; n -= 2) {
    for (var u = 1; u <= 25; u += 8)
      h <<= 1, h |= r >>> u + n & 1;
    for (var u = 1; u <= 25; u += 8)
      h <<= 1, h |= e >>> u + n & 1;
  }
  a[l + 0] = d >>> 0, a[l + 1] = h >>> 0;
};
Ti.rip = function(e, r, a, l) {
  for (var d = 0, h = 0, n = 0; n < 4; n++)
    for (var u = 24; u >= 0; u -= 8)
      d <<= 1, d |= r >>> u + n & 1, d <<= 1, d |= e >>> u + n & 1;
  for (var n = 4; n < 8; n++)
    for (var u = 24; u >= 0; u -= 8)
      h <<= 1, h |= r >>> u + n & 1, h <<= 1, h |= e >>> u + n & 1;
  a[l + 0] = d >>> 0, a[l + 1] = h >>> 0;
};
Ti.pc1 = function(e, r, a, l) {
  for (var d = 0, h = 0, n = 7; n >= 5; n--) {
    for (var u = 0; u <= 24; u += 8)
      d <<= 1, d |= r >> u + n & 1;
    for (var u = 0; u <= 24; u += 8)
      d <<= 1, d |= e >> u + n & 1;
  }
  for (var u = 0; u <= 24; u += 8)
    d <<= 1, d |= r >> u + n & 1;
  for (var n = 1; n <= 3; n++) {
    for (var u = 0; u <= 24; u += 8)
      h <<= 1, h |= r >> u + n & 1;
    for (var u = 0; u <= 24; u += 8)
      h <<= 1, h |= e >> u + n & 1;
  }
  for (var u = 0; u <= 24; u += 8)
    h <<= 1, h |= e >> u + n & 1;
  a[l + 0] = d >>> 0, a[l + 1] = h >>> 0;
};
Ti.r28shl = function(e, r) {
  return e << r & 268435455 | e >>> 28 - r;
};
var Kc = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
Ti.pc2 = function(e, r, a, l) {
  for (var d = 0, h = 0, n = Kc.length >>> 1, u = 0; u < n; u++)
    d <<= 1, d |= e >>> Kc[u] & 1;
  for (var u = n; u < Kc.length; u++)
    h <<= 1, h |= r >>> Kc[u] & 1;
  a[l + 0] = d >>> 0, a[l + 1] = h >>> 0;
};
Ti.expand = function(e, r, a) {
  var l = 0, d = 0;
  l = (e & 1) << 5 | e >>> 27;
  for (var h = 23; h >= 15; h -= 4)
    l <<= 6, l |= e >>> h & 63;
  for (var h = 11; h >= 3; h -= 4)
    d |= e >>> h & 63, d <<= 6;
  d |= (e & 31) << 1 | e >>> 31, r[a + 0] = l >>> 0, r[a + 1] = d >>> 0;
};
var M_ = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
Ti.substitute = function(e, r) {
  for (var a = 0, l = 0; l < 4; l++) {
    var d = e >>> 18 - l * 6 & 63, h = M_[l * 64 + d];
    a <<= 4, a |= h;
  }
  for (var l = 0; l < 4; l++) {
    var d = r >>> 18 - l * 6 & 63, h = M_[4 * 64 + l * 64 + d];
    a <<= 4, a |= h;
  }
  return a >>> 0;
};
var L_ = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
Ti.permute = function(e) {
  for (var r = 0, a = 0; a < L_.length; a++)
    r <<= 1, r |= e >>> L_[a] & 1;
  return r >>> 0;
};
Ti.padSplit = function(e, r, a) {
  for (var l = e.toString(2); l.length < r; )
    l = "0" + l;
  for (var d = [], h = 0; h < r; h += a)
    d.push(l.slice(h, h + a));
  return d.join(" ");
};
var Gi = cP;
function cP(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
cP.equal = function(e, r, a) {
  if (e != r)
    throw new Error(a || "Assertion failed: " + e + " != " + r);
};
var MF = Gi;
function zi(t) {
  this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== !1;
}
var Ab = zi;
zi.prototype._init = function() {
};
zi.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
zi.prototype._buffer = function(e, r) {
  for (var a = Math.min(this.buffer.length - this.bufferOff, e.length - r), l = 0; l < a; l++)
    this.buffer[this.bufferOff + l] = e[r + l];
  return this.bufferOff += a, a;
};
zi.prototype._flushBuffer = function(e, r) {
  return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
};
zi.prototype._updateEncrypt = function(e) {
  var r = 0, a = 0, l = (this.bufferOff + e.length) / this.blockSize | 0, d = new Array(l * this.blockSize);
  this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (a += this._flushBuffer(d, a)));
  for (var h = e.length - (e.length - r) % this.blockSize; r < h; r += this.blockSize)
    this._update(e, r, d, a), a += this.blockSize;
  for (; r < e.length; r++, this.bufferOff++)
    this.buffer[this.bufferOff] = e[r];
  return d;
};
zi.prototype._updateDecrypt = function(e) {
  for (var r = 0, a = 0, l = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, d = new Array(l * this.blockSize); l > 0; l--)
    r += this._buffer(e, r), a += this._flushBuffer(d, a);
  return r += this._buffer(e, r), d;
};
zi.prototype.final = function(e) {
  var r;
  e && (r = this.update(e));
  var a;
  return this.type === "encrypt" ? a = this._finalEncrypt() : a = this._finalDecrypt(), r ? r.concat(a) : a;
};
zi.prototype._pad = function(e, r) {
  if (r === 0)
    return !1;
  for (; r < e.length; )
    e[r++] = 0;
  return !0;
};
zi.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
zi.prototype._unpad = function(e) {
  return e;
};
zi.prototype._finalDecrypt = function() {
  MF.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var fP = Gi, LF = ir, Pn = Ti, dP = Ab;
function jF() {
  this.tmp = new Array(2), this.keys = null;
}
function Ms(t) {
  dP.call(this, t);
  var e = new jF();
  this._desState = e, this.deriveKeys(e, t.key);
}
LF(Ms, dP);
var pP = Ms;
Ms.create = function(e) {
  return new Ms(e);
};
var FF = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
Ms.prototype.deriveKeys = function(e, r) {
  e.keys = new Array(16 * 2), fP.equal(r.length, this.blockSize, "Invalid key length");
  var a = Pn.readUInt32BE(r, 0), l = Pn.readUInt32BE(r, 4);
  Pn.pc1(a, l, e.tmp, 0), a = e.tmp[0], l = e.tmp[1];
  for (var d = 0; d < e.keys.length; d += 2) {
    var h = FF[d >>> 1];
    a = Pn.r28shl(a, h), l = Pn.r28shl(l, h), Pn.pc2(a, l, e.keys, d);
  }
};
Ms.prototype._update = function(e, r, a, l) {
  var d = this._desState, h = Pn.readUInt32BE(e, r), n = Pn.readUInt32BE(e, r + 4);
  Pn.ip(h, n, d.tmp, 0), h = d.tmp[0], n = d.tmp[1], this.type === "encrypt" ? this._encrypt(d, h, n, d.tmp, 0) : this._decrypt(d, h, n, d.tmp, 0), h = d.tmp[0], n = d.tmp[1], Pn.writeUInt32BE(a, h, l), Pn.writeUInt32BE(a, n, l + 4);
};
Ms.prototype._pad = function(e, r) {
  if (this.padding === !1)
    return !1;
  for (var a = e.length - r, l = r; l < e.length; l++)
    e[l] = a;
  return !0;
};
Ms.prototype._unpad = function(e) {
  if (this.padding === !1)
    return e;
  for (var r = e[e.length - 1], a = e.length - r; a < e.length; a++)
    fP.equal(e[a], r);
  return e.slice(0, e.length - r);
};
Ms.prototype._encrypt = function(e, r, a, l, d) {
  for (var h = r, n = a, u = 0; u < e.keys.length; u += 2) {
    var i = e.keys[u], c = e.keys[u + 1];
    Pn.expand(n, e.tmp, 0), i ^= e.tmp[0], c ^= e.tmp[1];
    var f = Pn.substitute(i, c), s = Pn.permute(f), o = n;
    n = (h ^ s) >>> 0, h = o;
  }
  Pn.rip(n, h, l, d);
};
Ms.prototype._decrypt = function(e, r, a, l, d) {
  for (var h = a, n = r, u = e.keys.length - 2; u >= 0; u -= 2) {
    var i = e.keys[u], c = e.keys[u + 1];
    Pn.expand(h, e.tmp, 0), i ^= e.tmp[0], c ^= e.tmp[1];
    var f = Pn.substitute(i, c), s = Pn.permute(f), o = h;
    h = (n ^ s) >>> 0, n = o;
  }
  Pn.rip(h, n, l, d);
};
var hP = {}, BF = Gi, $F = ir, Xf = {};
function UF(t) {
  BF.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var e = 0; e < this.iv.length; e++)
    this.iv[e] = t[e];
}
function VF(t) {
  function e(d) {
    t.call(this, d), this._cbcInit();
  }
  $F(e, t);
  for (var r = Object.keys(Xf), a = 0; a < r.length; a++) {
    var l = r[a];
    e.prototype[l] = Xf[l];
  }
  return e.create = function(h) {
    return new e(h);
  }, e;
}
hP.instantiate = VF;
Xf._cbcInit = function() {
  var e = new UF(this.options.iv);
  this._cbcState = e;
};
Xf._update = function(e, r, a, l) {
  var d = this._cbcState, h = this.constructor.super_.prototype, n = d.iv;
  if (this.type === "encrypt") {
    for (var u = 0; u < this.blockSize; u++)
      n[u] ^= e[r + u];
    h._update.call(this, n, 0, a, l);
    for (var u = 0; u < this.blockSize; u++)
      n[u] = a[l + u];
  } else {
    h._update.call(this, e, r, a, l);
    for (var u = 0; u < this.blockSize; u++)
      a[l + u] ^= n[u];
    for (var u = 0; u < this.blockSize; u++)
      n[u] = e[r + u];
  }
};
var WF = Gi, qF = ir, mP = Ab, ya = pP;
function HF(t, e) {
  WF.equal(e.length, 24, "Invalid key length");
  var r = e.slice(0, 8), a = e.slice(8, 16), l = e.slice(16, 24);
  t === "encrypt" ? this.ciphers = [
    ya.create({ type: "encrypt", key: r }),
    ya.create({ type: "decrypt", key: a }),
    ya.create({ type: "encrypt", key: l })
  ] : this.ciphers = [
    ya.create({ type: "decrypt", key: l }),
    ya.create({ type: "encrypt", key: a }),
    ya.create({ type: "decrypt", key: r })
  ];
}
function ao(t) {
  mP.call(this, t);
  var e = new HF(this.type, this.options.key);
  this._edeState = e;
}
qF(ao, mP);
var GF = ao;
ao.create = function(e) {
  return new ao(e);
};
ao.prototype._update = function(e, r, a, l) {
  var d = this._edeState;
  d.ciphers[0]._update(e, r, a, l), d.ciphers[1]._update(a, l, a, l), d.ciphers[2]._update(a, l, a, l);
};
ao.prototype._pad = ya.prototype._pad;
ao.prototype._unpad = ya.prototype._unpad;
Ol.utils = Ti;
Ol.Cipher = Ab;
Ol.DES = pP;
Ol.CBC = hP;
Ol.EDE = GF;
var yP = Na, Ks = Ol, zF = ir, Ga = cr.Buffer, ku = {
  "des-ede3-cbc": Ks.CBC.instantiate(Ks.EDE),
  "des-ede3": Ks.EDE,
  "des-ede-cbc": Ks.CBC.instantiate(Ks.EDE),
  "des-ede": Ks.EDE,
  "des-cbc": Ks.CBC.instantiate(Ks.DES),
  "des-ecb": Ks.DES
};
ku.des = ku["des-cbc"];
ku.des3 = ku["des-ede3-cbc"];
var KF = op;
zF(op, yP);
function op(t) {
  yP.call(this);
  var e = t.mode.toLowerCase(), r = ku[e], a;
  t.decrypt ? a = "decrypt" : a = "encrypt";
  var l = t.key;
  Ga.isBuffer(l) || (l = Ga.from(l)), (e === "des-ede" || e === "des-ede-cbc") && (l = Ga.concat([l, l.slice(0, 8)]));
  var d = t.iv;
  Ga.isBuffer(d) || (d = Ga.from(d)), this._des = r.create({
    key: l,
    iv: d,
    type: a
  });
}
op.prototype._update = function(t) {
  return Ga.from(this._des.update(t));
};
op.prototype._final = function() {
  return Ga.from(this._des.final());
};
var wi = {}, Pb = {}, Cb = {};
Cb.encrypt = function(t, e) {
  return t._cipher.encryptBlock(e);
};
Cb.decrypt = function(t, e) {
  return t._cipher.decryptBlock(e);
};
var Ib = {}, sc = function(e, r) {
  for (var a = Math.min(e.length, r.length), l = new Gt(a), d = 0; d < a; ++d)
    l[d] = e[d] ^ r[d];
  return l;
}, bP = sc;
Ib.encrypt = function(t, e) {
  var r = bP(e, t._prev);
  return t._prev = t._cipher.encryptBlock(r), t._prev;
};
Ib.decrypt = function(t, e) {
  var r = t._prev;
  t._prev = e;
  var a = t._cipher.decryptBlock(e);
  return bP(a, r);
};
var gP = {}, lu = cr.Buffer, YF = sc;
function j_(t, e, r) {
  var a = e.length, l = YF(e, t._cache);
  return t._cache = t._cache.slice(a), t._prev = lu.concat([t._prev, r ? e : l]), l;
}
gP.encrypt = function(t, e, r) {
  for (var a = lu.allocUnsafe(0), l; e.length; )
    if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = lu.allocUnsafe(0)), t._cache.length <= e.length)
      l = t._cache.length, a = lu.concat([a, j_(t, e.slice(0, l), r)]), e = e.slice(l);
    else {
      a = lu.concat([a, j_(t, e, r)]);
      break;
    }
  return a;
};
var vP = {}, k1 = cr.Buffer;
function XF(t, e, r) {
  var a = t._cipher.encryptBlock(t._prev), l = a[0] ^ e;
  return t._prev = k1.concat([
    t._prev.slice(1),
    k1.from([r ? e : l])
  ]), l;
}
vP.encrypt = function(t, e, r) {
  for (var a = e.length, l = k1.allocUnsafe(a), d = -1; ++d < a; )
    l[d] = XF(t, e[d], r);
  return l;
};
var EP = {}, xf = cr.Buffer;
function JF(t, e, r) {
  for (var a, l = -1, d = 8, h = 0, n, u; ++l < d; )
    a = t._cipher.encryptBlock(t._prev), n = e & 1 << 7 - l ? 128 : 0, u = a[0] ^ n, h += (u & 128) >> l % 8, t._prev = QF(t._prev, r ? n : u);
  return h;
}
function QF(t, e) {
  var r = t.length, a = -1, l = xf.allocUnsafe(t.length);
  for (t = xf.concat([t, xf.from([e])]); ++a < r; )
    l[a] = t[a] << 1 | t[a + 1] >> 7;
  return l;
}
EP.encrypt = function(t, e, r) {
  for (var a = e.length, l = xf.allocUnsafe(a), d = -1; ++d < a; )
    l[d] = JF(t, e[d], r);
  return l;
};
var _P = {}, ZF = sc;
function eB(t) {
  return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
}
_P.encrypt = function(t, e) {
  for (; t._cache.length < e.length; )
    t._cache = Gt.concat([t._cache, eB(t)]);
  var r = t._cache.slice(0, e.length);
  return t._cache = t._cache.slice(e.length), ZF(e, r);
};
var D1 = {};
function tB(t) {
  for (var e = t.length, r; e--; )
    if (r = t.readUInt8(e), r === 255)
      t.writeUInt8(0, e);
    else {
      r++, t.writeUInt8(r, e);
      break;
    }
}
var SP = tB, rB = sc, F_ = cr.Buffer, nB = SP;
function iB(t) {
  var e = t._cipher.encryptBlockRaw(t._prev);
  return nB(t._prev), e;
}
var cm = 16;
D1.encrypt = function(t, e) {
  var r = Math.ceil(e.length / cm), a = t._cache.length;
  t._cache = F_.concat([
    t._cache,
    F_.allocUnsafe(r * cm)
  ]);
  for (var l = 0; l < r; l++) {
    var d = iB(t), h = a + l * cm;
    t._cache.writeUInt32BE(d[0], h + 0), t._cache.writeUInt32BE(d[1], h + 4), t._cache.writeUInt32BE(d[2], h + 8), t._cache.writeUInt32BE(d[3], h + 12);
  }
  var n = t._cache.slice(0, e.length);
  return t._cache = t._cache.slice(e.length), rB(e, n);
};
const sB = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aB = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, oB = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, wP = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: sB,
  aes192: aB,
  aes256: oB,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var lB = {
  ECB: Cb,
  CBC: Ib,
  CFB: gP,
  CFB8: vP,
  CFB1: EP,
  OFB: _P,
  CTR: D1,
  GCM: D1
}, Tf = wP;
for (var B_ in Tf)
  Tf[B_].module = lB[Tf[B_].mode];
var Ob = Tf, ac = {}, Jf = cr.Buffer;
function kb(t) {
  Jf.isBuffer(t) || (t = Jf.from(t));
  for (var e = t.length / 4 | 0, r = new Array(e), a = 0; a < e; a++)
    r[a] = t.readUInt32BE(a * 4);
  return r;
}
function fm(t) {
  for (var e = 0; e < t.length; t++)
    t[e] = 0;
}
function xP(t, e, r, a, l) {
  for (var d = r[0], h = r[1], n = r[2], u = r[3], i = t[0] ^ e[0], c = t[1] ^ e[1], f = t[2] ^ e[2], s = t[3] ^ e[3], o, y, m, g, b = 4, v = 1; v < l; v++)
    o = d[i >>> 24] ^ h[c >>> 16 & 255] ^ n[f >>> 8 & 255] ^ u[s & 255] ^ e[b++], y = d[c >>> 24] ^ h[f >>> 16 & 255] ^ n[s >>> 8 & 255] ^ u[i & 255] ^ e[b++], m = d[f >>> 24] ^ h[s >>> 16 & 255] ^ n[i >>> 8 & 255] ^ u[c & 255] ^ e[b++], g = d[s >>> 24] ^ h[i >>> 16 & 255] ^ n[c >>> 8 & 255] ^ u[f & 255] ^ e[b++], i = o, c = y, f = m, s = g;
  return o = (a[i >>> 24] << 24 | a[c >>> 16 & 255] << 16 | a[f >>> 8 & 255] << 8 | a[s & 255]) ^ e[b++], y = (a[c >>> 24] << 24 | a[f >>> 16 & 255] << 16 | a[s >>> 8 & 255] << 8 | a[i & 255]) ^ e[b++], m = (a[f >>> 24] << 24 | a[s >>> 16 & 255] << 16 | a[i >>> 8 & 255] << 8 | a[c & 255]) ^ e[b++], g = (a[s >>> 24] << 24 | a[i >>> 16 & 255] << 16 | a[c >>> 8 & 255] << 8 | a[f & 255]) ^ e[b++], o = o >>> 0, y = y >>> 0, m = m >>> 0, g = g >>> 0, [o, y, m, g];
}
var uB = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], yn = function() {
  for (var t = new Array(256), e = 0; e < 256; e++)
    e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
  for (var r = [], a = [], l = [[], [], [], []], d = [[], [], [], []], h = 0, n = 0, u = 0; u < 256; ++u) {
    var i = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4;
    i = i >>> 8 ^ i & 255 ^ 99, r[h] = i, a[i] = h;
    var c = t[h], f = t[c], s = t[f], o = t[i] * 257 ^ i * 16843008;
    l[0][h] = o << 24 | o >>> 8, l[1][h] = o << 16 | o >>> 16, l[2][h] = o << 8 | o >>> 24, l[3][h] = o, o = s * 16843009 ^ f * 65537 ^ c * 257 ^ h * 16843008, d[0][i] = o << 24 | o >>> 8, d[1][i] = o << 16 | o >>> 16, d[2][i] = o << 8 | o >>> 24, d[3][i] = o, h === 0 ? h = n = 1 : (h = c ^ t[t[t[s ^ c]]], n ^= t[t[n]]);
  }
  return {
    SBOX: r,
    INV_SBOX: a,
    SUB_MIX: l,
    INV_SUB_MIX: d
  };
}();
function $i(t) {
  this._key = kb(t), this._reset();
}
$i.blockSize = 4 * 4;
$i.keySize = 256 / 8;
$i.prototype.blockSize = $i.blockSize;
$i.prototype.keySize = $i.keySize;
$i.prototype._reset = function() {
  for (var t = this._key, e = t.length, r = e + 6, a = (r + 1) * 4, l = [], d = 0; d < e; d++)
    l[d] = t[d];
  for (d = e; d < a; d++) {
    var h = l[d - 1];
    d % e === 0 ? (h = h << 8 | h >>> 24, h = yn.SBOX[h >>> 24] << 24 | yn.SBOX[h >>> 16 & 255] << 16 | yn.SBOX[h >>> 8 & 255] << 8 | yn.SBOX[h & 255], h ^= uB[d / e | 0] << 24) : e > 6 && d % e === 4 && (h = yn.SBOX[h >>> 24] << 24 | yn.SBOX[h >>> 16 & 255] << 16 | yn.SBOX[h >>> 8 & 255] << 8 | yn.SBOX[h & 255]), l[d] = l[d - e] ^ h;
  }
  for (var n = [], u = 0; u < a; u++) {
    var i = a - u, c = l[i - (u % 4 ? 0 : 4)];
    u < 4 || i <= 4 ? n[u] = c : n[u] = yn.INV_SUB_MIX[0][yn.SBOX[c >>> 24]] ^ yn.INV_SUB_MIX[1][yn.SBOX[c >>> 16 & 255]] ^ yn.INV_SUB_MIX[2][yn.SBOX[c >>> 8 & 255]] ^ yn.INV_SUB_MIX[3][yn.SBOX[c & 255]];
  }
  this._nRounds = r, this._keySchedule = l, this._invKeySchedule = n;
};
$i.prototype.encryptBlockRaw = function(t) {
  return t = kb(t), xP(t, this._keySchedule, yn.SUB_MIX, yn.SBOX, this._nRounds);
};
$i.prototype.encryptBlock = function(t) {
  var e = this.encryptBlockRaw(t), r = Jf.allocUnsafe(16);
  return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
};
$i.prototype.decryptBlock = function(t) {
  t = kb(t);
  var e = t[1];
  t[1] = t[3], t[3] = e;
  var r = xP(t, this._invKeySchedule, yn.INV_SUB_MIX, yn.INV_SBOX, this._nRounds), a = Jf.allocUnsafe(16);
  return a.writeUInt32BE(r[0], 0), a.writeUInt32BE(r[3], 4), a.writeUInt32BE(r[2], 8), a.writeUInt32BE(r[1], 12), a;
};
$i.prototype.scrub = function() {
  fm(this._keySchedule), fm(this._invKeySchedule), fm(this._key);
};
ac.AES = $i;
var fl = cr.Buffer, cB = fl.alloc(16, 0);
function fB(t) {
  return [
    t.readUInt32BE(0),
    t.readUInt32BE(4),
    t.readUInt32BE(8),
    t.readUInt32BE(12)
  ];
}
function TP(t) {
  var e = fl.allocUnsafe(16);
  return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
}
function oc(t) {
  this.h = t, this.state = fl.alloc(16, 0), this.cache = fl.allocUnsafe(0);
}
oc.prototype.ghash = function(t) {
  for (var e = -1; ++e < t.length; )
    this.state[e] ^= t[e];
  this._multiply();
};
oc.prototype._multiply = function() {
  for (var t = fB(this.h), e = [0, 0, 0, 0], r, a, l, d = -1; ++d < 128; ) {
    for (a = (this.state[~~(d / 8)] & 1 << 7 - d % 8) !== 0, a && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), l = (t[3] & 1) !== 0, r = 3; r > 0; r--)
      t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
    t[0] = t[0] >>> 1, l && (t[0] = t[0] ^ 225 << 24);
  }
  this.state = TP(e);
};
oc.prototype.update = function(t) {
  this.cache = fl.concat([this.cache, t]);
  for (var e; this.cache.length >= 16; )
    e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
};
oc.prototype.final = function(t, e) {
  return this.cache.length && this.ghash(fl.concat([this.cache, cB], 16)), this.ghash(TP([0, t, 0, e])), this.state;
};
var dB = oc, pB = ac, di = cr.Buffer, AP = Na, hB = ir, PP = dB, mB = sc, yB = SP;
function bB(t, e) {
  var r = 0;
  t.length !== e.length && r++;
  for (var a = Math.min(t.length, e.length), l = 0; l < a; ++l)
    r += t[l] ^ e[l];
  return r;
}
function gB(t, e, r) {
  if (e.length === 12)
    return t._finID = di.concat([e, di.from([0, 0, 0, 1])]), di.concat([e, di.from([0, 0, 0, 2])]);
  var a = new PP(r), l = e.length, d = l % 16;
  a.update(e), d && (d = 16 - d, a.update(di.alloc(d, 0))), a.update(di.alloc(8, 0));
  var h = l * 8, n = di.alloc(8);
  n.writeUIntBE(h, 0, 8), a.update(n), t._finID = a.state;
  var u = di.from(t._finID);
  return yB(u), u;
}
function go(t, e, r, a) {
  AP.call(this);
  var l = di.alloc(4, 0);
  this._cipher = new pB.AES(e);
  var d = this._cipher.encryptBlock(l);
  this._ghash = new PP(d), r = gB(this, r, d), this._prev = di.from(r), this._cache = di.allocUnsafe(0), this._secCache = di.allocUnsafe(0), this._decrypt = a, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = !1;
}
hB(go, AP);
go.prototype._update = function(t) {
  if (!this._called && this._alen) {
    var e = 16 - this._alen % 16;
    e < 16 && (e = di.alloc(e, 0), this._ghash.update(e));
  }
  this._called = !0;
  var r = this._mode.encrypt(this, t);
  return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
};
go.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var t = mB(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && bB(t, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = t, this._cipher.scrub();
};
go.prototype.getAuthTag = function() {
  if (this._decrypt || !di.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
go.prototype.setAuthTag = function(e) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
go.prototype.setAAD = function(e) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var CP = go, vB = ac, dm = cr.Buffer, IP = Na, EB = ir;
function lp(t, e, r, a) {
  IP.call(this), this._cipher = new vB.AES(e), this._prev = dm.from(r), this._cache = dm.allocUnsafe(0), this._secCache = dm.allocUnsafe(0), this._decrypt = a, this._mode = t;
}
EB(lp, IP);
lp.prototype._update = function(t) {
  return this._mode.encrypt(this, t, this._decrypt);
};
lp.prototype._final = function() {
  this._cipher.scrub();
};
var OP = lp, Ua = cr.Buffer, _B = wb;
function SB(t, e, r, a) {
  if (Ua.isBuffer(t) || (t = Ua.from(t, "binary")), e && (Ua.isBuffer(e) || (e = Ua.from(e, "binary")), e.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var l = r / 8, d = Ua.alloc(l), h = Ua.alloc(a || 0), n = Ua.alloc(0); l > 0 || a > 0; ) {
    var u = new _B();
    u.update(n), u.update(t), e && u.update(e), n = u.digest();
    var i = 0;
    if (l > 0) {
      var c = d.length - l;
      i = Math.min(l, n.length), n.copy(d, c, 0, i), l -= i;
    }
    if (i < n.length && a > 0) {
      var f = h.length - a, s = Math.min(a, n.length - i);
      n.copy(h, f, i, i + s), a -= s;
    }
  }
  return n.fill(0), { key: d, iv: h };
}
var up = SB, kP = Ob, wB = CP, na = cr.Buffer, xB = OP, DP = Na, TB = ac, AB = up, PB = ir;
function lc(t, e, r) {
  DP.call(this), this._cache = new cp(), this._cipher = new TB.AES(e), this._prev = na.from(r), this._mode = t, this._autopadding = !0;
}
PB(lc, DP);
lc.prototype._update = function(t) {
  this._cache.add(t);
  for (var e, r, a = []; e = this._cache.get(); )
    r = this._mode.encrypt(this, e), a.push(r);
  return na.concat(a);
};
var CB = na.alloc(16, 16);
lc.prototype._final = function() {
  var t = this._cache.flush();
  if (this._autopadding)
    return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
  if (!t.equals(CB))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
lc.prototype.setAutoPadding = function(t) {
  return this._autopadding = !!t, this;
};
function cp() {
  this.cache = na.allocUnsafe(0);
}
cp.prototype.add = function(t) {
  this.cache = na.concat([this.cache, t]);
};
cp.prototype.get = function() {
  if (this.cache.length > 15) {
    var t = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), t;
  }
  return null;
};
cp.prototype.flush = function() {
  for (var t = 16 - this.cache.length, e = na.allocUnsafe(t), r = -1; ++r < t; )
    e.writeUInt8(t, r);
  return na.concat([this.cache, e]);
};
function NP(t, e, r) {
  var a = kP[t.toLowerCase()];
  if (!a) throw new TypeError("invalid suite type");
  if (typeof e == "string" && (e = na.from(e)), e.length !== a.key / 8) throw new TypeError("invalid key length " + e.length);
  if (typeof r == "string" && (r = na.from(r)), a.mode !== "GCM" && r.length !== a.iv) throw new TypeError("invalid iv length " + r.length);
  return a.type === "stream" ? new xB(a.module, e, r) : a.type === "auth" ? new wB(a.module, e, r) : new lc(a.module, e, r);
}
function IB(t, e) {
  var r = kP[t.toLowerCase()];
  if (!r) throw new TypeError("invalid suite type");
  var a = AB(e, !1, r.key, r.iv);
  return NP(t, a.key, a.iv);
}
Pb.createCipheriv = NP;
Pb.createCipher = IB;
var Db = {}, OB = CP, dl = cr.Buffer, RP = Ob, kB = OP, MP = Na, DB = ac, NB = up, RB = ir;
function uc(t, e, r) {
  MP.call(this), this._cache = new fp(), this._last = void 0, this._cipher = new DB.AES(e), this._prev = dl.from(r), this._mode = t, this._autopadding = !0;
}
RB(uc, MP);
uc.prototype._update = function(t) {
  this._cache.add(t);
  for (var e, r, a = []; e = this._cache.get(this._autopadding); )
    r = this._mode.decrypt(this, e), a.push(r);
  return dl.concat(a);
};
uc.prototype._final = function() {
  var t = this._cache.flush();
  if (this._autopadding)
    return MB(this._mode.decrypt(this, t));
  if (t)
    throw new Error("data not multiple of block length");
};
uc.prototype.setAutoPadding = function(t) {
  return this._autopadding = !!t, this;
};
function fp() {
  this.cache = dl.allocUnsafe(0);
}
fp.prototype.add = function(t) {
  this.cache = dl.concat([this.cache, t]);
};
fp.prototype.get = function(t) {
  var e;
  if (t) {
    if (this.cache.length > 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  } else if (this.cache.length >= 16)
    return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  return null;
};
fp.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function MB(t) {
  var e = t[15];
  if (e < 1 || e > 16)
    throw new Error("unable to decrypt data");
  for (var r = -1; ++r < e; )
    if (t[r + (16 - e)] !== e)
      throw new Error("unable to decrypt data");
  if (e !== 16)
    return t.slice(0, 16 - e);
}
function LP(t, e, r) {
  var a = RP[t.toLowerCase()];
  if (!a) throw new TypeError("invalid suite type");
  if (typeof r == "string" && (r = dl.from(r)), a.mode !== "GCM" && r.length !== a.iv) throw new TypeError("invalid iv length " + r.length);
  if (typeof e == "string" && (e = dl.from(e)), e.length !== a.key / 8) throw new TypeError("invalid key length " + e.length);
  return a.type === "stream" ? new kB(a.module, e, r, !0) : a.type === "auth" ? new OB(a.module, e, r, !0) : new uc(a.module, e, r);
}
function LB(t, e) {
  var r = RP[t.toLowerCase()];
  if (!r) throw new TypeError("invalid suite type");
  var a = NB(e, !1, r.key, r.iv);
  return LP(t, a.key, a.iv);
}
Db.createDecipher = LB;
Db.createDecipheriv = LP;
var jP = Pb, FP = Db, jB = wP;
function FB() {
  return Object.keys(jB);
}
wi.createCipher = wi.Cipher = jP.createCipher;
wi.createCipheriv = wi.Cipheriv = jP.createCipheriv;
wi.createDecipher = wi.Decipher = FP.createDecipher;
wi.createDecipheriv = wi.Decipheriv = FP.createDecipheriv;
wi.listCiphers = wi.getCiphers = FB;
var BP = {};
(function(t) {
  t["des-ecb"] = {
    key: 8,
    iv: 0
  }, t["des-cbc"] = t.des = {
    key: 8,
    iv: 8
  }, t["des-ede3-cbc"] = t.des3 = {
    key: 24,
    iv: 8
  }, t["des-ede3"] = {
    key: 24,
    iv: 0
  }, t["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, t["des-ede"] = {
    key: 16,
    iv: 0
  };
})(BP);
var $P = KF, Nb = wi, Ea = Ob, ea = BP, UP = up;
function BB(t, e) {
  t = t.toLowerCase();
  var r, a;
  if (Ea[t])
    r = Ea[t].key, a = Ea[t].iv;
  else if (ea[t])
    r = ea[t].key * 8, a = ea[t].iv;
  else
    throw new TypeError("invalid suite type");
  var l = UP(e, !1, r, a);
  return VP(t, l.key, l.iv);
}
function $B(t, e) {
  t = t.toLowerCase();
  var r, a;
  if (Ea[t])
    r = Ea[t].key, a = Ea[t].iv;
  else if (ea[t])
    r = ea[t].key * 8, a = ea[t].iv;
  else
    throw new TypeError("invalid suite type");
  var l = UP(e, !1, r, a);
  return WP(t, l.key, l.iv);
}
function VP(t, e, r) {
  if (t = t.toLowerCase(), Ea[t]) return Nb.createCipheriv(t, e, r);
  if (ea[t]) return new $P({ key: e, iv: r, mode: t });
  throw new TypeError("invalid suite type");
}
function WP(t, e, r) {
  if (t = t.toLowerCase(), Ea[t]) return Nb.createDecipheriv(t, e, r);
  if (ea[t]) return new $P({ key: e, iv: r, mode: t, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function UB() {
  return Object.keys(ea).concat(Nb.getCiphers());
}
rs.createCipher = rs.Cipher = BB;
rs.createCipheriv = rs.Cipheriv = VP;
rs.createDecipher = rs.Decipher = $B;
rs.createDecipheriv = rs.Decipheriv = WP;
rs.listCiphers = rs.getCiphers = UB;
var Va = {}, Rb = { exports: {} };
Rb.exports;
(function(t) {
  (function(e, r) {
    function a(M, x) {
      if (!M) throw new Error(x || "Assertion failed");
    }
    function l(M, x) {
      M.super_ = x;
      var _ = function() {
      };
      _.prototype = x.prototype, M.prototype = new _(), M.prototype.constructor = M;
    }
    function d(M, x, _) {
      if (d.isBN(M))
        return M;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && ((x === "le" || x === "be") && (_ = x, x = 10), this._init(M || 0, x || 10, _ || "be"));
    }
    typeof e == "object" ? e.exports = d : r.BN = d, d.BN = d, d.wordSize = 26;
    var h;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? h = window.Buffer : h = Rr.Buffer;
    } catch {
    }
    d.isBN = function(x) {
      return x instanceof d ? !0 : x !== null && typeof x == "object" && x.constructor.wordSize === d.wordSize && Array.isArray(x.words);
    }, d.max = function(x, _) {
      return x.cmp(_) > 0 ? x : _;
    }, d.min = function(x, _) {
      return x.cmp(_) < 0 ? x : _;
    }, d.prototype._init = function(x, _, S) {
      if (typeof x == "number")
        return this._initNumber(x, _, S);
      if (typeof x == "object")
        return this._initArray(x, _, S);
      _ === "hex" && (_ = 16), a(_ === (_ | 0) && _ >= 2 && _ <= 36), x = x.toString().replace(/\s+/g, "");
      var C = 0;
      x[0] === "-" && (C++, this.negative = 1), C < x.length && (_ === 16 ? this._parseHex(x, C, S) : (this._parseBase(x, _, C), S === "le" && this._initArray(this.toArray(), _, S)));
    }, d.prototype._initNumber = function(x, _, S) {
      x < 0 && (this.negative = 1, x = -x), x < 67108864 ? (this.words = [x & 67108863], this.length = 1) : x < 4503599627370496 ? (this.words = [
        x & 67108863,
        x / 67108864 & 67108863
      ], this.length = 2) : (a(x < 9007199254740992), this.words = [
        x & 67108863,
        x / 67108864 & 67108863,
        1
      ], this.length = 3), S === "le" && this._initArray(this.toArray(), _, S);
    }, d.prototype._initArray = function(x, _, S) {
      if (a(typeof x.length == "number"), x.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(x.length / 3), this.words = new Array(this.length);
      for (var C = 0; C < this.length; C++)
        this.words[C] = 0;
      var R, H, z = 0;
      if (S === "be")
        for (C = x.length - 1, R = 0; C >= 0; C -= 3)
          H = x[C] | x[C - 1] << 8 | x[C - 2] << 16, this.words[R] |= H << z & 67108863, this.words[R + 1] = H >>> 26 - z & 67108863, z += 24, z >= 26 && (z -= 26, R++);
      else if (S === "le")
        for (C = 0, R = 0; C < x.length; C += 3)
          H = x[C] | x[C + 1] << 8 | x[C + 2] << 16, this.words[R] |= H << z & 67108863, this.words[R + 1] = H >>> 26 - z & 67108863, z += 24, z >= 26 && (z -= 26, R++);
      return this.strip();
    };
    function n(M, x) {
      var _ = M.charCodeAt(x);
      return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15;
    }
    function u(M, x, _) {
      var S = n(M, _);
      return _ - 1 >= x && (S |= n(M, _ - 1) << 4), S;
    }
    d.prototype._parseHex = function(x, _, S) {
      this.length = Math.ceil((x.length - _) / 6), this.words = new Array(this.length);
      for (var C = 0; C < this.length; C++)
        this.words[C] = 0;
      var R = 0, H = 0, z;
      if (S === "be")
        for (C = x.length - 1; C >= _; C -= 2)
          z = u(x, _, C) << R, this.words[H] |= z & 67108863, R >= 18 ? (R -= 18, H += 1, this.words[H] |= z >>> 26) : R += 8;
      else {
        var U = x.length - _;
        for (C = U % 2 === 0 ? _ + 1 : _; C < x.length; C += 2)
          z = u(x, _, C) << R, this.words[H] |= z & 67108863, R >= 18 ? (R -= 18, H += 1, this.words[H] |= z >>> 26) : R += 8;
      }
      this.strip();
    };
    function i(M, x, _, S) {
      for (var C = 0, R = Math.min(M.length, _), H = x; H < R; H++) {
        var z = M.charCodeAt(H) - 48;
        C *= S, z >= 49 ? C += z - 49 + 10 : z >= 17 ? C += z - 17 + 10 : C += z;
      }
      return C;
    }
    d.prototype._parseBase = function(x, _, S) {
      this.words = [0], this.length = 1;
      for (var C = 0, R = 1; R <= 67108863; R *= _)
        C++;
      C--, R = R / _ | 0;
      for (var H = x.length - S, z = H % C, U = Math.min(H, H - z) + S, P = 0, W = S; W < U; W += C)
        P = i(x, W, W + C, _), this.imuln(R), this.words[0] + P < 67108864 ? this.words[0] += P : this._iaddn(P);
      if (z !== 0) {
        var B = 1;
        for (P = i(x, W, x.length, _), W = 0; W < z; W++)
          B *= _;
        this.imuln(B), this.words[0] + P < 67108864 ? this.words[0] += P : this._iaddn(P);
      }
      this.strip();
    }, d.prototype.copy = function(x) {
      x.words = new Array(this.length);
      for (var _ = 0; _ < this.length; _++)
        x.words[_] = this.words[_];
      x.length = this.length, x.negative = this.negative, x.red = this.red;
    }, d.prototype.clone = function() {
      var x = new d(null);
      return this.copy(x), x;
    }, d.prototype._expand = function(x) {
      for (; this.length < x; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, d.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var c = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], f = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], s = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(x, _) {
      x = x || 10, _ = _ | 0 || 1;
      var S;
      if (x === 16 || x === "hex") {
        S = "";
        for (var C = 0, R = 0, H = 0; H < this.length; H++) {
          var z = this.words[H], U = ((z << C | R) & 16777215).toString(16);
          R = z >>> 24 - C & 16777215, R !== 0 || H !== this.length - 1 ? S = c[6 - U.length] + U + S : S = U + S, C += 2, C >= 26 && (C -= 26, H--);
        }
        for (R !== 0 && (S = R.toString(16) + S); S.length % _ !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      if (x === (x | 0) && x >= 2 && x <= 36) {
        var P = f[x], W = s[x];
        S = "";
        var B = this.clone();
        for (B.negative = 0; !B.isZero(); ) {
          var Q = B.modn(W).toString(x);
          B = B.idivn(W), B.isZero() ? S = Q + S : S = c[P - Q.length] + Q + S;
        }
        for (this.isZero() && (S = "0" + S); S.length % _ !== 0; )
          S = "0" + S;
        return this.negative !== 0 && (S = "-" + S), S;
      }
      a(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var x = this.words[0];
      return this.length === 2 ? x += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? x += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -x : x;
    }, d.prototype.toJSON = function() {
      return this.toString(16);
    }, d.prototype.toBuffer = function(x, _) {
      return a(typeof h < "u"), this.toArrayLike(h, x, _);
    }, d.prototype.toArray = function(x, _) {
      return this.toArrayLike(Array, x, _);
    }, d.prototype.toArrayLike = function(x, _, S) {
      var C = this.byteLength(), R = S || Math.max(1, C);
      a(C <= R, "byte array longer than desired length"), a(R > 0, "Requested array length <= 0"), this.strip();
      var H = _ === "le", z = new x(R), U, P, W = this.clone();
      if (H) {
        for (P = 0; !W.isZero(); P++)
          U = W.andln(255), W.iushrn(8), z[P] = U;
        for (; P < R; P++)
          z[P] = 0;
      } else {
        for (P = 0; P < R - C; P++)
          z[P] = 0;
        for (P = 0; !W.isZero(); P++)
          U = W.andln(255), W.iushrn(8), z[R - P - 1] = U;
      }
      return z;
    }, Math.clz32 ? d.prototype._countBits = function(x) {
      return 32 - Math.clz32(x);
    } : d.prototype._countBits = function(x) {
      var _ = x, S = 0;
      return _ >= 4096 && (S += 13, _ >>>= 13), _ >= 64 && (S += 7, _ >>>= 7), _ >= 8 && (S += 4, _ >>>= 4), _ >= 2 && (S += 2, _ >>>= 2), S + _;
    }, d.prototype._zeroBits = function(x) {
      if (x === 0) return 26;
      var _ = x, S = 0;
      return _ & 8191 || (S += 13, _ >>>= 13), _ & 127 || (S += 7, _ >>>= 7), _ & 15 || (S += 4, _ >>>= 4), _ & 3 || (S += 2, _ >>>= 2), _ & 1 || S++, S;
    }, d.prototype.bitLength = function() {
      var x = this.words[this.length - 1], _ = this._countBits(x);
      return (this.length - 1) * 26 + _;
    };
    function o(M) {
      for (var x = new Array(M.bitLength()), _ = 0; _ < x.length; _++) {
        var S = _ / 26 | 0, C = _ % 26;
        x[_] = (M.words[S] & 1 << C) >>> C;
      }
      return x;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var x = 0, _ = 0; _ < this.length; _++) {
        var S = this._zeroBits(this.words[_]);
        if (x += S, S !== 26) break;
      }
      return x;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(x) {
      return this.negative !== 0 ? this.abs().inotn(x).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(x) {
      return this.testn(x - 1) ? this.notn(x).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(x) {
      for (; this.length < x.length; )
        this.words[this.length++] = 0;
      for (var _ = 0; _ < x.length; _++)
        this.words[_] = this.words[_] | x.words[_];
      return this.strip();
    }, d.prototype.ior = function(x) {
      return a((this.negative | x.negative) === 0), this.iuor(x);
    }, d.prototype.or = function(x) {
      return this.length > x.length ? this.clone().ior(x) : x.clone().ior(this);
    }, d.prototype.uor = function(x) {
      return this.length > x.length ? this.clone().iuor(x) : x.clone().iuor(this);
    }, d.prototype.iuand = function(x) {
      var _;
      this.length > x.length ? _ = x : _ = this;
      for (var S = 0; S < _.length; S++)
        this.words[S] = this.words[S] & x.words[S];
      return this.length = _.length, this.strip();
    }, d.prototype.iand = function(x) {
      return a((this.negative | x.negative) === 0), this.iuand(x);
    }, d.prototype.and = function(x) {
      return this.length > x.length ? this.clone().iand(x) : x.clone().iand(this);
    }, d.prototype.uand = function(x) {
      return this.length > x.length ? this.clone().iuand(x) : x.clone().iuand(this);
    }, d.prototype.iuxor = function(x) {
      var _, S;
      this.length > x.length ? (_ = this, S = x) : (_ = x, S = this);
      for (var C = 0; C < S.length; C++)
        this.words[C] = _.words[C] ^ S.words[C];
      if (this !== _)
        for (; C < _.length; C++)
          this.words[C] = _.words[C];
      return this.length = _.length, this.strip();
    }, d.prototype.ixor = function(x) {
      return a((this.negative | x.negative) === 0), this.iuxor(x);
    }, d.prototype.xor = function(x) {
      return this.length > x.length ? this.clone().ixor(x) : x.clone().ixor(this);
    }, d.prototype.uxor = function(x) {
      return this.length > x.length ? this.clone().iuxor(x) : x.clone().iuxor(this);
    }, d.prototype.inotn = function(x) {
      a(typeof x == "number" && x >= 0);
      var _ = Math.ceil(x / 26) | 0, S = x % 26;
      this._expand(_), S > 0 && _--;
      for (var C = 0; C < _; C++)
        this.words[C] = ~this.words[C] & 67108863;
      return S > 0 && (this.words[C] = ~this.words[C] & 67108863 >> 26 - S), this.strip();
    }, d.prototype.notn = function(x) {
      return this.clone().inotn(x);
    }, d.prototype.setn = function(x, _) {
      a(typeof x == "number" && x >= 0);
      var S = x / 26 | 0, C = x % 26;
      return this._expand(S + 1), _ ? this.words[S] = this.words[S] | 1 << C : this.words[S] = this.words[S] & ~(1 << C), this.strip();
    }, d.prototype.iadd = function(x) {
      var _;
      if (this.negative !== 0 && x.negative === 0)
        return this.negative = 0, _ = this.isub(x), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && x.negative !== 0)
        return x.negative = 0, _ = this.isub(x), x.negative = 1, _._normSign();
      var S, C;
      this.length > x.length ? (S = this, C = x) : (S = x, C = this);
      for (var R = 0, H = 0; H < C.length; H++)
        _ = (S.words[H] | 0) + (C.words[H] | 0) + R, this.words[H] = _ & 67108863, R = _ >>> 26;
      for (; R !== 0 && H < S.length; H++)
        _ = (S.words[H] | 0) + R, this.words[H] = _ & 67108863, R = _ >>> 26;
      if (this.length = S.length, R !== 0)
        this.words[this.length] = R, this.length++;
      else if (S !== this)
        for (; H < S.length; H++)
          this.words[H] = S.words[H];
      return this;
    }, d.prototype.add = function(x) {
      var _;
      return x.negative !== 0 && this.negative === 0 ? (x.negative = 0, _ = this.sub(x), x.negative ^= 1, _) : x.negative === 0 && this.negative !== 0 ? (this.negative = 0, _ = x.sub(this), this.negative = 1, _) : this.length > x.length ? this.clone().iadd(x) : x.clone().iadd(this);
    }, d.prototype.isub = function(x) {
      if (x.negative !== 0) {
        x.negative = 0;
        var _ = this.iadd(x);
        return x.negative = 1, _._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(x), this.negative = 1, this._normSign();
      var S = this.cmp(x);
      if (S === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var C, R;
      S > 0 ? (C = this, R = x) : (C = x, R = this);
      for (var H = 0, z = 0; z < R.length; z++)
        _ = (C.words[z] | 0) - (R.words[z] | 0) + H, H = _ >> 26, this.words[z] = _ & 67108863;
      for (; H !== 0 && z < C.length; z++)
        _ = (C.words[z] | 0) + H, H = _ >> 26, this.words[z] = _ & 67108863;
      if (H === 0 && z < C.length && C !== this)
        for (; z < C.length; z++)
          this.words[z] = C.words[z];
      return this.length = Math.max(this.length, z), C !== this && (this.negative = 1), this.strip();
    }, d.prototype.sub = function(x) {
      return this.clone().isub(x);
    };
    function y(M, x, _) {
      _.negative = x.negative ^ M.negative;
      var S = M.length + x.length | 0;
      _.length = S, S = S - 1 | 0;
      var C = M.words[0] | 0, R = x.words[0] | 0, H = C * R, z = H & 67108863, U = H / 67108864 | 0;
      _.words[0] = z;
      for (var P = 1; P < S; P++) {
        for (var W = U >>> 26, B = U & 67108863, Q = Math.min(P, x.length - 1), J = Math.max(0, P - M.length + 1); J <= Q; J++) {
          var re = P - J | 0;
          C = M.words[re] | 0, R = x.words[J] | 0, H = C * R + B, W += H / 67108864 | 0, B = H & 67108863;
        }
        _.words[P] = B | 0, U = W | 0;
      }
      return U !== 0 ? _.words[P] = U | 0 : _.length--, _.strip();
    }
    var m = function(x, _, S) {
      var C = x.words, R = _.words, H = S.words, z = 0, U, P, W, B = C[0] | 0, Q = B & 8191, J = B >>> 13, re = C[1] | 0, G = re & 8191, N = re >>> 13, V = C[2] | 0, F = V & 8191, X = V >>> 13, K = C[3] | 0, ie = K & 8191, fe = K >>> 13, _e = C[4] | 0, Ae = _e & 8191, ce = _e >>> 13, ee = C[5] | 0, ae = ee & 8191, oe = ee >>> 13, me = C[6] | 0, ye = me & 8191, we = me >>> 13, ge = C[7] | 0, se = ge & 8191, be = ge >>> 13, Ie = C[8] | 0, Oe = Ie & 8191, Be = Ie >>> 13, Fe = C[9] | 0, ue = Fe & 8191, te = Fe >>> 13, Y = R[0] | 0, le = Y & 8191, Ee = Y >>> 13, Se = R[1] | 0, Pe = Se & 8191, Ve = Se >>> 13, Xe = R[2] | 0, Ye = Xe & 8191, We = Xe >>> 13, et = R[3] | 0, De = et & 8191, Me = et >>> 13, Qe = R[4] | 0, He = Qe & 8191, st = Qe >>> 13, it = R[5] | 0, qe = it & 8191, rt = it >>> 13, bt = R[6] | 0, dt = bt & 8191, Je = bt >>> 13, mt = R[7] | 0, ut = mt & 8191, Et = mt >>> 13, Tt = R[8] | 0, St = Tt & 8191, Vt = Tt >>> 13, Kt = R[9] | 0, xt = Kt & 8191, Jt = Kt >>> 13;
      S.negative = x.negative ^ _.negative, S.length = 19, U = Math.imul(Q, le), P = Math.imul(Q, Ee), P = P + Math.imul(J, le) | 0, W = Math.imul(J, Ee);
      var Mt = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, U = Math.imul(G, le), P = Math.imul(G, Ee), P = P + Math.imul(N, le) | 0, W = Math.imul(N, Ee), U = U + Math.imul(Q, Pe) | 0, P = P + Math.imul(Q, Ve) | 0, P = P + Math.imul(J, Pe) | 0, W = W + Math.imul(J, Ve) | 0;
      var Bt = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, U = Math.imul(F, le), P = Math.imul(F, Ee), P = P + Math.imul(X, le) | 0, W = Math.imul(X, Ee), U = U + Math.imul(G, Pe) | 0, P = P + Math.imul(G, Ve) | 0, P = P + Math.imul(N, Pe) | 0, W = W + Math.imul(N, Ve) | 0, U = U + Math.imul(Q, Ye) | 0, P = P + Math.imul(Q, We) | 0, P = P + Math.imul(J, Ye) | 0, W = W + Math.imul(J, We) | 0;
      var It = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, U = Math.imul(ie, le), P = Math.imul(ie, Ee), P = P + Math.imul(fe, le) | 0, W = Math.imul(fe, Ee), U = U + Math.imul(F, Pe) | 0, P = P + Math.imul(F, Ve) | 0, P = P + Math.imul(X, Pe) | 0, W = W + Math.imul(X, Ve) | 0, U = U + Math.imul(G, Ye) | 0, P = P + Math.imul(G, We) | 0, P = P + Math.imul(N, Ye) | 0, W = W + Math.imul(N, We) | 0, U = U + Math.imul(Q, De) | 0, P = P + Math.imul(Q, Me) | 0, P = P + Math.imul(J, De) | 0, W = W + Math.imul(J, Me) | 0;
      var jr = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, U = Math.imul(Ae, le), P = Math.imul(Ae, Ee), P = P + Math.imul(ce, le) | 0, W = Math.imul(ce, Ee), U = U + Math.imul(ie, Pe) | 0, P = P + Math.imul(ie, Ve) | 0, P = P + Math.imul(fe, Pe) | 0, W = W + Math.imul(fe, Ve) | 0, U = U + Math.imul(F, Ye) | 0, P = P + Math.imul(F, We) | 0, P = P + Math.imul(X, Ye) | 0, W = W + Math.imul(X, We) | 0, U = U + Math.imul(G, De) | 0, P = P + Math.imul(G, Me) | 0, P = P + Math.imul(N, De) | 0, W = W + Math.imul(N, Me) | 0, U = U + Math.imul(Q, He) | 0, P = P + Math.imul(Q, st) | 0, P = P + Math.imul(J, He) | 0, W = W + Math.imul(J, st) | 0;
      var Cn = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, U = Math.imul(ae, le), P = Math.imul(ae, Ee), P = P + Math.imul(oe, le) | 0, W = Math.imul(oe, Ee), U = U + Math.imul(Ae, Pe) | 0, P = P + Math.imul(Ae, Ve) | 0, P = P + Math.imul(ce, Pe) | 0, W = W + Math.imul(ce, Ve) | 0, U = U + Math.imul(ie, Ye) | 0, P = P + Math.imul(ie, We) | 0, P = P + Math.imul(fe, Ye) | 0, W = W + Math.imul(fe, We) | 0, U = U + Math.imul(F, De) | 0, P = P + Math.imul(F, Me) | 0, P = P + Math.imul(X, De) | 0, W = W + Math.imul(X, Me) | 0, U = U + Math.imul(G, He) | 0, P = P + Math.imul(G, st) | 0, P = P + Math.imul(N, He) | 0, W = W + Math.imul(N, st) | 0, U = U + Math.imul(Q, qe) | 0, P = P + Math.imul(Q, rt) | 0, P = P + Math.imul(J, qe) | 0, W = W + Math.imul(J, rt) | 0;
      var an = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, U = Math.imul(ye, le), P = Math.imul(ye, Ee), P = P + Math.imul(we, le) | 0, W = Math.imul(we, Ee), U = U + Math.imul(ae, Pe) | 0, P = P + Math.imul(ae, Ve) | 0, P = P + Math.imul(oe, Pe) | 0, W = W + Math.imul(oe, Ve) | 0, U = U + Math.imul(Ae, Ye) | 0, P = P + Math.imul(Ae, We) | 0, P = P + Math.imul(ce, Ye) | 0, W = W + Math.imul(ce, We) | 0, U = U + Math.imul(ie, De) | 0, P = P + Math.imul(ie, Me) | 0, P = P + Math.imul(fe, De) | 0, W = W + Math.imul(fe, Me) | 0, U = U + Math.imul(F, He) | 0, P = P + Math.imul(F, st) | 0, P = P + Math.imul(X, He) | 0, W = W + Math.imul(X, st) | 0, U = U + Math.imul(G, qe) | 0, P = P + Math.imul(G, rt) | 0, P = P + Math.imul(N, qe) | 0, W = W + Math.imul(N, rt) | 0, U = U + Math.imul(Q, dt) | 0, P = P + Math.imul(Q, Je) | 0, P = P + Math.imul(J, dt) | 0, W = W + Math.imul(J, Je) | 0;
      var Fr = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, U = Math.imul(se, le), P = Math.imul(se, Ee), P = P + Math.imul(be, le) | 0, W = Math.imul(be, Ee), U = U + Math.imul(ye, Pe) | 0, P = P + Math.imul(ye, Ve) | 0, P = P + Math.imul(we, Pe) | 0, W = W + Math.imul(we, Ve) | 0, U = U + Math.imul(ae, Ye) | 0, P = P + Math.imul(ae, We) | 0, P = P + Math.imul(oe, Ye) | 0, W = W + Math.imul(oe, We) | 0, U = U + Math.imul(Ae, De) | 0, P = P + Math.imul(Ae, Me) | 0, P = P + Math.imul(ce, De) | 0, W = W + Math.imul(ce, Me) | 0, U = U + Math.imul(ie, He) | 0, P = P + Math.imul(ie, st) | 0, P = P + Math.imul(fe, He) | 0, W = W + Math.imul(fe, st) | 0, U = U + Math.imul(F, qe) | 0, P = P + Math.imul(F, rt) | 0, P = P + Math.imul(X, qe) | 0, W = W + Math.imul(X, rt) | 0, U = U + Math.imul(G, dt) | 0, P = P + Math.imul(G, Je) | 0, P = P + Math.imul(N, dt) | 0, W = W + Math.imul(N, Je) | 0, U = U + Math.imul(Q, ut) | 0, P = P + Math.imul(Q, Et) | 0, P = P + Math.imul(J, ut) | 0, W = W + Math.imul(J, Et) | 0;
      var En = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, U = Math.imul(Oe, le), P = Math.imul(Oe, Ee), P = P + Math.imul(Be, le) | 0, W = Math.imul(Be, Ee), U = U + Math.imul(se, Pe) | 0, P = P + Math.imul(se, Ve) | 0, P = P + Math.imul(be, Pe) | 0, W = W + Math.imul(be, Ve) | 0, U = U + Math.imul(ye, Ye) | 0, P = P + Math.imul(ye, We) | 0, P = P + Math.imul(we, Ye) | 0, W = W + Math.imul(we, We) | 0, U = U + Math.imul(ae, De) | 0, P = P + Math.imul(ae, Me) | 0, P = P + Math.imul(oe, De) | 0, W = W + Math.imul(oe, Me) | 0, U = U + Math.imul(Ae, He) | 0, P = P + Math.imul(Ae, st) | 0, P = P + Math.imul(ce, He) | 0, W = W + Math.imul(ce, st) | 0, U = U + Math.imul(ie, qe) | 0, P = P + Math.imul(ie, rt) | 0, P = P + Math.imul(fe, qe) | 0, W = W + Math.imul(fe, rt) | 0, U = U + Math.imul(F, dt) | 0, P = P + Math.imul(F, Je) | 0, P = P + Math.imul(X, dt) | 0, W = W + Math.imul(X, Je) | 0, U = U + Math.imul(G, ut) | 0, P = P + Math.imul(G, Et) | 0, P = P + Math.imul(N, ut) | 0, W = W + Math.imul(N, Et) | 0, U = U + Math.imul(Q, St) | 0, P = P + Math.imul(Q, Vt) | 0, P = P + Math.imul(J, St) | 0, W = W + Math.imul(J, Vt) | 0;
      var dn = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, U = Math.imul(ue, le), P = Math.imul(ue, Ee), P = P + Math.imul(te, le) | 0, W = Math.imul(te, Ee), U = U + Math.imul(Oe, Pe) | 0, P = P + Math.imul(Oe, Ve) | 0, P = P + Math.imul(Be, Pe) | 0, W = W + Math.imul(Be, Ve) | 0, U = U + Math.imul(se, Ye) | 0, P = P + Math.imul(se, We) | 0, P = P + Math.imul(be, Ye) | 0, W = W + Math.imul(be, We) | 0, U = U + Math.imul(ye, De) | 0, P = P + Math.imul(ye, Me) | 0, P = P + Math.imul(we, De) | 0, W = W + Math.imul(we, Me) | 0, U = U + Math.imul(ae, He) | 0, P = P + Math.imul(ae, st) | 0, P = P + Math.imul(oe, He) | 0, W = W + Math.imul(oe, st) | 0, U = U + Math.imul(Ae, qe) | 0, P = P + Math.imul(Ae, rt) | 0, P = P + Math.imul(ce, qe) | 0, W = W + Math.imul(ce, rt) | 0, U = U + Math.imul(ie, dt) | 0, P = P + Math.imul(ie, Je) | 0, P = P + Math.imul(fe, dt) | 0, W = W + Math.imul(fe, Je) | 0, U = U + Math.imul(F, ut) | 0, P = P + Math.imul(F, Et) | 0, P = P + Math.imul(X, ut) | 0, W = W + Math.imul(X, Et) | 0, U = U + Math.imul(G, St) | 0, P = P + Math.imul(G, Vt) | 0, P = P + Math.imul(N, St) | 0, W = W + Math.imul(N, Vt) | 0, U = U + Math.imul(Q, xt) | 0, P = P + Math.imul(Q, Jt) | 0, P = P + Math.imul(J, xt) | 0, W = W + Math.imul(J, Jt) | 0;
      var on = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, U = Math.imul(ue, Pe), P = Math.imul(ue, Ve), P = P + Math.imul(te, Pe) | 0, W = Math.imul(te, Ve), U = U + Math.imul(Oe, Ye) | 0, P = P + Math.imul(Oe, We) | 0, P = P + Math.imul(Be, Ye) | 0, W = W + Math.imul(Be, We) | 0, U = U + Math.imul(se, De) | 0, P = P + Math.imul(se, Me) | 0, P = P + Math.imul(be, De) | 0, W = W + Math.imul(be, Me) | 0, U = U + Math.imul(ye, He) | 0, P = P + Math.imul(ye, st) | 0, P = P + Math.imul(we, He) | 0, W = W + Math.imul(we, st) | 0, U = U + Math.imul(ae, qe) | 0, P = P + Math.imul(ae, rt) | 0, P = P + Math.imul(oe, qe) | 0, W = W + Math.imul(oe, rt) | 0, U = U + Math.imul(Ae, dt) | 0, P = P + Math.imul(Ae, Je) | 0, P = P + Math.imul(ce, dt) | 0, W = W + Math.imul(ce, Je) | 0, U = U + Math.imul(ie, ut) | 0, P = P + Math.imul(ie, Et) | 0, P = P + Math.imul(fe, ut) | 0, W = W + Math.imul(fe, Et) | 0, U = U + Math.imul(F, St) | 0, P = P + Math.imul(F, Vt) | 0, P = P + Math.imul(X, St) | 0, W = W + Math.imul(X, Vt) | 0, U = U + Math.imul(G, xt) | 0, P = P + Math.imul(G, Jt) | 0, P = P + Math.imul(N, xt) | 0, W = W + Math.imul(N, Jt) | 0;
      var vr = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, U = Math.imul(ue, Ye), P = Math.imul(ue, We), P = P + Math.imul(te, Ye) | 0, W = Math.imul(te, We), U = U + Math.imul(Oe, De) | 0, P = P + Math.imul(Oe, Me) | 0, P = P + Math.imul(Be, De) | 0, W = W + Math.imul(Be, Me) | 0, U = U + Math.imul(se, He) | 0, P = P + Math.imul(se, st) | 0, P = P + Math.imul(be, He) | 0, W = W + Math.imul(be, st) | 0, U = U + Math.imul(ye, qe) | 0, P = P + Math.imul(ye, rt) | 0, P = P + Math.imul(we, qe) | 0, W = W + Math.imul(we, rt) | 0, U = U + Math.imul(ae, dt) | 0, P = P + Math.imul(ae, Je) | 0, P = P + Math.imul(oe, dt) | 0, W = W + Math.imul(oe, Je) | 0, U = U + Math.imul(Ae, ut) | 0, P = P + Math.imul(Ae, Et) | 0, P = P + Math.imul(ce, ut) | 0, W = W + Math.imul(ce, Et) | 0, U = U + Math.imul(ie, St) | 0, P = P + Math.imul(ie, Vt) | 0, P = P + Math.imul(fe, St) | 0, W = W + Math.imul(fe, Vt) | 0, U = U + Math.imul(F, xt) | 0, P = P + Math.imul(F, Jt) | 0, P = P + Math.imul(X, xt) | 0, W = W + Math.imul(X, Jt) | 0;
      var Vn = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863, U = Math.imul(ue, De), P = Math.imul(ue, Me), P = P + Math.imul(te, De) | 0, W = Math.imul(te, Me), U = U + Math.imul(Oe, He) | 0, P = P + Math.imul(Oe, st) | 0, P = P + Math.imul(Be, He) | 0, W = W + Math.imul(Be, st) | 0, U = U + Math.imul(se, qe) | 0, P = P + Math.imul(se, rt) | 0, P = P + Math.imul(be, qe) | 0, W = W + Math.imul(be, rt) | 0, U = U + Math.imul(ye, dt) | 0, P = P + Math.imul(ye, Je) | 0, P = P + Math.imul(we, dt) | 0, W = W + Math.imul(we, Je) | 0, U = U + Math.imul(ae, ut) | 0, P = P + Math.imul(ae, Et) | 0, P = P + Math.imul(oe, ut) | 0, W = W + Math.imul(oe, Et) | 0, U = U + Math.imul(Ae, St) | 0, P = P + Math.imul(Ae, Vt) | 0, P = P + Math.imul(ce, St) | 0, W = W + Math.imul(ce, Vt) | 0, U = U + Math.imul(ie, xt) | 0, P = P + Math.imul(ie, Jt) | 0, P = P + Math.imul(fe, xt) | 0, W = W + Math.imul(fe, Jt) | 0;
      var Cr = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, U = Math.imul(ue, He), P = Math.imul(ue, st), P = P + Math.imul(te, He) | 0, W = Math.imul(te, st), U = U + Math.imul(Oe, qe) | 0, P = P + Math.imul(Oe, rt) | 0, P = P + Math.imul(Be, qe) | 0, W = W + Math.imul(Be, rt) | 0, U = U + Math.imul(se, dt) | 0, P = P + Math.imul(se, Je) | 0, P = P + Math.imul(be, dt) | 0, W = W + Math.imul(be, Je) | 0, U = U + Math.imul(ye, ut) | 0, P = P + Math.imul(ye, Et) | 0, P = P + Math.imul(we, ut) | 0, W = W + Math.imul(we, Et) | 0, U = U + Math.imul(ae, St) | 0, P = P + Math.imul(ae, Vt) | 0, P = P + Math.imul(oe, St) | 0, W = W + Math.imul(oe, Vt) | 0, U = U + Math.imul(Ae, xt) | 0, P = P + Math.imul(Ae, Jt) | 0, P = P + Math.imul(ce, xt) | 0, W = W + Math.imul(ce, Jt) | 0;
      var br = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, U = Math.imul(ue, qe), P = Math.imul(ue, rt), P = P + Math.imul(te, qe) | 0, W = Math.imul(te, rt), U = U + Math.imul(Oe, dt) | 0, P = P + Math.imul(Oe, Je) | 0, P = P + Math.imul(Be, dt) | 0, W = W + Math.imul(Be, Je) | 0, U = U + Math.imul(se, ut) | 0, P = P + Math.imul(se, Et) | 0, P = P + Math.imul(be, ut) | 0, W = W + Math.imul(be, Et) | 0, U = U + Math.imul(ye, St) | 0, P = P + Math.imul(ye, Vt) | 0, P = P + Math.imul(we, St) | 0, W = W + Math.imul(we, Vt) | 0, U = U + Math.imul(ae, xt) | 0, P = P + Math.imul(ae, Jt) | 0, P = P + Math.imul(oe, xt) | 0, W = W + Math.imul(oe, Jt) | 0;
      var _n = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, U = Math.imul(ue, dt), P = Math.imul(ue, Je), P = P + Math.imul(te, dt) | 0, W = Math.imul(te, Je), U = U + Math.imul(Oe, ut) | 0, P = P + Math.imul(Oe, Et) | 0, P = P + Math.imul(Be, ut) | 0, W = W + Math.imul(Be, Et) | 0, U = U + Math.imul(se, St) | 0, P = P + Math.imul(se, Vt) | 0, P = P + Math.imul(be, St) | 0, W = W + Math.imul(be, Vt) | 0, U = U + Math.imul(ye, xt) | 0, P = P + Math.imul(ye, Jt) | 0, P = P + Math.imul(we, xt) | 0, W = W + Math.imul(we, Jt) | 0;
      var In = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, U = Math.imul(ue, ut), P = Math.imul(ue, Et), P = P + Math.imul(te, ut) | 0, W = Math.imul(te, Et), U = U + Math.imul(Oe, St) | 0, P = P + Math.imul(Oe, Vt) | 0, P = P + Math.imul(Be, St) | 0, W = W + Math.imul(Be, Vt) | 0, U = U + Math.imul(se, xt) | 0, P = P + Math.imul(se, Jt) | 0, P = P + Math.imul(be, xt) | 0, W = W + Math.imul(be, Jt) | 0;
      var pn = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, U = Math.imul(ue, St), P = Math.imul(ue, Vt), P = P + Math.imul(te, St) | 0, W = Math.imul(te, Vt), U = U + Math.imul(Oe, xt) | 0, P = P + Math.imul(Oe, Jt) | 0, P = P + Math.imul(Be, xt) | 0, W = W + Math.imul(Be, Jt) | 0;
      var Dr = (z + U | 0) + ((P & 8191) << 13) | 0;
      z = (W + (P >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, U = Math.imul(ue, xt), P = Math.imul(ue, Jt), P = P + Math.imul(te, xt) | 0, W = Math.imul(te, Jt);
      var Wn = (z + U | 0) + ((P & 8191) << 13) | 0;
      return z = (W + (P >>> 13) | 0) + (Wn >>> 26) | 0, Wn &= 67108863, H[0] = Mt, H[1] = Bt, H[2] = It, H[3] = jr, H[4] = Cn, H[5] = an, H[6] = Fr, H[7] = En, H[8] = dn, H[9] = on, H[10] = vr, H[11] = Vn, H[12] = Cr, H[13] = br, H[14] = _n, H[15] = In, H[16] = pn, H[17] = Dr, H[18] = Wn, z !== 0 && (H[19] = z, S.length++), S;
    };
    Math.imul || (m = y);
    function g(M, x, _) {
      _.negative = x.negative ^ M.negative, _.length = M.length + x.length;
      for (var S = 0, C = 0, R = 0; R < _.length - 1; R++) {
        var H = C;
        C = 0;
        for (var z = S & 67108863, U = Math.min(R, x.length - 1), P = Math.max(0, R - M.length + 1); P <= U; P++) {
          var W = R - P, B = M.words[W] | 0, Q = x.words[P] | 0, J = B * Q, re = J & 67108863;
          H = H + (J / 67108864 | 0) | 0, re = re + z | 0, z = re & 67108863, H = H + (re >>> 26) | 0, C += H >>> 26, H &= 67108863;
        }
        _.words[R] = z, S = H, H = C;
      }
      return S !== 0 ? _.words[R] = S : _.length--, _.strip();
    }
    function b(M, x, _) {
      var S = new v();
      return S.mulp(M, x, _);
    }
    d.prototype.mulTo = function(x, _) {
      var S, C = this.length + x.length;
      return this.length === 10 && x.length === 10 ? S = m(this, x, _) : C < 63 ? S = y(this, x, _) : C < 1024 ? S = g(this, x, _) : S = b(this, x, _), S;
    };
    function v(M, x) {
      this.x = M, this.y = x;
    }
    v.prototype.makeRBT = function(x) {
      for (var _ = new Array(x), S = d.prototype._countBits(x) - 1, C = 0; C < x; C++)
        _[C] = this.revBin(C, S, x);
      return _;
    }, v.prototype.revBin = function(x, _, S) {
      if (x === 0 || x === S - 1) return x;
      for (var C = 0, R = 0; R < _; R++)
        C |= (x & 1) << _ - R - 1, x >>= 1;
      return C;
    }, v.prototype.permute = function(x, _, S, C, R, H) {
      for (var z = 0; z < H; z++)
        C[z] = _[x[z]], R[z] = S[x[z]];
    }, v.prototype.transform = function(x, _, S, C, R, H) {
      this.permute(H, x, _, S, C, R);
      for (var z = 1; z < R; z <<= 1)
        for (var U = z << 1, P = Math.cos(2 * Math.PI / U), W = Math.sin(2 * Math.PI / U), B = 0; B < R; B += U)
          for (var Q = P, J = W, re = 0; re < z; re++) {
            var G = S[B + re], N = C[B + re], V = S[B + re + z], F = C[B + re + z], X = Q * V - J * F;
            F = Q * F + J * V, V = X, S[B + re] = G + V, C[B + re] = N + F, S[B + re + z] = G - V, C[B + re + z] = N - F, re !== U && (X = P * Q - W * J, J = P * J + W * Q, Q = X);
          }
    }, v.prototype.guessLen13b = function(x, _) {
      var S = Math.max(_, x) | 1, C = S & 1, R = 0;
      for (S = S / 2 | 0; S; S = S >>> 1)
        R++;
      return 1 << R + 1 + C;
    }, v.prototype.conjugate = function(x, _, S) {
      if (!(S <= 1))
        for (var C = 0; C < S / 2; C++) {
          var R = x[C];
          x[C] = x[S - C - 1], x[S - C - 1] = R, R = _[C], _[C] = -_[S - C - 1], _[S - C - 1] = -R;
        }
    }, v.prototype.normalize13b = function(x, _) {
      for (var S = 0, C = 0; C < _ / 2; C++) {
        var R = Math.round(x[2 * C + 1] / _) * 8192 + Math.round(x[2 * C] / _) + S;
        x[C] = R & 67108863, R < 67108864 ? S = 0 : S = R / 67108864 | 0;
      }
      return x;
    }, v.prototype.convert13b = function(x, _, S, C) {
      for (var R = 0, H = 0; H < _; H++)
        R = R + (x[H] | 0), S[2 * H] = R & 8191, R = R >>> 13, S[2 * H + 1] = R & 8191, R = R >>> 13;
      for (H = 2 * _; H < C; ++H)
        S[H] = 0;
      a(R === 0), a((R & -8192) === 0);
    }, v.prototype.stub = function(x) {
      for (var _ = new Array(x), S = 0; S < x; S++)
        _[S] = 0;
      return _;
    }, v.prototype.mulp = function(x, _, S) {
      var C = 2 * this.guessLen13b(x.length, _.length), R = this.makeRBT(C), H = this.stub(C), z = new Array(C), U = new Array(C), P = new Array(C), W = new Array(C), B = new Array(C), Q = new Array(C), J = S.words;
      J.length = C, this.convert13b(x.words, x.length, z, C), this.convert13b(_.words, _.length, W, C), this.transform(z, H, U, P, C, R), this.transform(W, H, B, Q, C, R);
      for (var re = 0; re < C; re++) {
        var G = U[re] * B[re] - P[re] * Q[re];
        P[re] = U[re] * Q[re] + P[re] * B[re], U[re] = G;
      }
      return this.conjugate(U, P, C), this.transform(U, P, J, H, C, R), this.conjugate(J, H, C), this.normalize13b(J, C), S.negative = x.negative ^ _.negative, S.length = x.length + _.length, S.strip();
    }, d.prototype.mul = function(x) {
      var _ = new d(null);
      return _.words = new Array(this.length + x.length), this.mulTo(x, _);
    }, d.prototype.mulf = function(x) {
      var _ = new d(null);
      return _.words = new Array(this.length + x.length), b(this, x, _);
    }, d.prototype.imul = function(x) {
      return this.clone().mulTo(x, this);
    }, d.prototype.imuln = function(x) {
      a(typeof x == "number"), a(x < 67108864);
      for (var _ = 0, S = 0; S < this.length; S++) {
        var C = (this.words[S] | 0) * x, R = (C & 67108863) + (_ & 67108863);
        _ >>= 26, _ += C / 67108864 | 0, _ += R >>> 26, this.words[S] = R & 67108863;
      }
      return _ !== 0 && (this.words[S] = _, this.length++), this;
    }, d.prototype.muln = function(x) {
      return this.clone().imuln(x);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(x) {
      var _ = o(x);
      if (_.length === 0) return new d(1);
      for (var S = this, C = 0; C < _.length && _[C] === 0; C++, S = S.sqr())
        ;
      if (++C < _.length)
        for (var R = S.sqr(); C < _.length; C++, R = R.sqr())
          _[C] !== 0 && (S = S.mul(R));
      return S;
    }, d.prototype.iushln = function(x) {
      a(typeof x == "number" && x >= 0);
      var _ = x % 26, S = (x - _) / 26, C = 67108863 >>> 26 - _ << 26 - _, R;
      if (_ !== 0) {
        var H = 0;
        for (R = 0; R < this.length; R++) {
          var z = this.words[R] & C, U = (this.words[R] | 0) - z << _;
          this.words[R] = U | H, H = z >>> 26 - _;
        }
        H && (this.words[R] = H, this.length++);
      }
      if (S !== 0) {
        for (R = this.length - 1; R >= 0; R--)
          this.words[R + S] = this.words[R];
        for (R = 0; R < S; R++)
          this.words[R] = 0;
        this.length += S;
      }
      return this.strip();
    }, d.prototype.ishln = function(x) {
      return a(this.negative === 0), this.iushln(x);
    }, d.prototype.iushrn = function(x, _, S) {
      a(typeof x == "number" && x >= 0);
      var C;
      _ ? C = (_ - _ % 26) / 26 : C = 0;
      var R = x % 26, H = Math.min((x - R) / 26, this.length), z = 67108863 ^ 67108863 >>> R << R, U = S;
      if (C -= H, C = Math.max(0, C), U) {
        for (var P = 0; P < H; P++)
          U.words[P] = this.words[P];
        U.length = H;
      }
      if (H !== 0) if (this.length > H)
        for (this.length -= H, P = 0; P < this.length; P++)
          this.words[P] = this.words[P + H];
      else
        this.words[0] = 0, this.length = 1;
      var W = 0;
      for (P = this.length - 1; P >= 0 && (W !== 0 || P >= C); P--) {
        var B = this.words[P] | 0;
        this.words[P] = W << 26 - R | B >>> R, W = B & z;
      }
      return U && W !== 0 && (U.words[U.length++] = W), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, d.prototype.ishrn = function(x, _, S) {
      return a(this.negative === 0), this.iushrn(x, _, S);
    }, d.prototype.shln = function(x) {
      return this.clone().ishln(x);
    }, d.prototype.ushln = function(x) {
      return this.clone().iushln(x);
    }, d.prototype.shrn = function(x) {
      return this.clone().ishrn(x);
    }, d.prototype.ushrn = function(x) {
      return this.clone().iushrn(x);
    }, d.prototype.testn = function(x) {
      a(typeof x == "number" && x >= 0);
      var _ = x % 26, S = (x - _) / 26, C = 1 << _;
      if (this.length <= S) return !1;
      var R = this.words[S];
      return !!(R & C);
    }, d.prototype.imaskn = function(x) {
      a(typeof x == "number" && x >= 0);
      var _ = x % 26, S = (x - _) / 26;
      if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= S)
        return this;
      if (_ !== 0 && S++, this.length = Math.min(S, this.length), _ !== 0) {
        var C = 67108863 ^ 67108863 >>> _ << _;
        this.words[this.length - 1] &= C;
      }
      return this.strip();
    }, d.prototype.maskn = function(x) {
      return this.clone().imaskn(x);
    }, d.prototype.iaddn = function(x) {
      return a(typeof x == "number"), a(x < 67108864), x < 0 ? this.isubn(-x) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < x ? (this.words[0] = x - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(x), this.negative = 1, this) : this._iaddn(x);
    }, d.prototype._iaddn = function(x) {
      this.words[0] += x;
      for (var _ = 0; _ < this.length && this.words[_] >= 67108864; _++)
        this.words[_] -= 67108864, _ === this.length - 1 ? this.words[_ + 1] = 1 : this.words[_ + 1]++;
      return this.length = Math.max(this.length, _ + 1), this;
    }, d.prototype.isubn = function(x) {
      if (a(typeof x == "number"), a(x < 67108864), x < 0) return this.iaddn(-x);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(x), this.negative = 1, this;
      if (this.words[0] -= x, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var _ = 0; _ < this.length && this.words[_] < 0; _++)
          this.words[_] += 67108864, this.words[_ + 1] -= 1;
      return this.strip();
    }, d.prototype.addn = function(x) {
      return this.clone().iaddn(x);
    }, d.prototype.subn = function(x) {
      return this.clone().isubn(x);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(x, _, S) {
      var C = x.length + S, R;
      this._expand(C);
      var H, z = 0;
      for (R = 0; R < x.length; R++) {
        H = (this.words[R + S] | 0) + z;
        var U = (x.words[R] | 0) * _;
        H -= U & 67108863, z = (H >> 26) - (U / 67108864 | 0), this.words[R + S] = H & 67108863;
      }
      for (; R < this.length - S; R++)
        H = (this.words[R + S] | 0) + z, z = H >> 26, this.words[R + S] = H & 67108863;
      if (z === 0) return this.strip();
      for (a(z === -1), z = 0, R = 0; R < this.length; R++)
        H = -(this.words[R] | 0) + z, z = H >> 26, this.words[R] = H & 67108863;
      return this.negative = 1, this.strip();
    }, d.prototype._wordDiv = function(x, _) {
      var S = this.length - x.length, C = this.clone(), R = x, H = R.words[R.length - 1] | 0, z = this._countBits(H);
      S = 26 - z, S !== 0 && (R = R.ushln(S), C.iushln(S), H = R.words[R.length - 1] | 0);
      var U = C.length - R.length, P;
      if (_ !== "mod") {
        P = new d(null), P.length = U + 1, P.words = new Array(P.length);
        for (var W = 0; W < P.length; W++)
          P.words[W] = 0;
      }
      var B = C.clone()._ishlnsubmul(R, 1, U);
      B.negative === 0 && (C = B, P && (P.words[U] = 1));
      for (var Q = U - 1; Q >= 0; Q--) {
        var J = (C.words[R.length + Q] | 0) * 67108864 + (C.words[R.length + Q - 1] | 0);
        for (J = Math.min(J / H | 0, 67108863), C._ishlnsubmul(R, J, Q); C.negative !== 0; )
          J--, C.negative = 0, C._ishlnsubmul(R, 1, Q), C.isZero() || (C.negative ^= 1);
        P && (P.words[Q] = J);
      }
      return P && P.strip(), C.strip(), _ !== "div" && S !== 0 && C.iushrn(S), {
        div: P || null,
        mod: C
      };
    }, d.prototype.divmod = function(x, _, S) {
      if (a(!x.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var C, R, H;
      return this.negative !== 0 && x.negative === 0 ? (H = this.neg().divmod(x, _), _ !== "mod" && (C = H.div.neg()), _ !== "div" && (R = H.mod.neg(), S && R.negative !== 0 && R.iadd(x)), {
        div: C,
        mod: R
      }) : this.negative === 0 && x.negative !== 0 ? (H = this.divmod(x.neg(), _), _ !== "mod" && (C = H.div.neg()), {
        div: C,
        mod: H.mod
      }) : this.negative & x.negative ? (H = this.neg().divmod(x.neg(), _), _ !== "div" && (R = H.mod.neg(), S && R.negative !== 0 && R.isub(x)), {
        div: H.div,
        mod: R
      }) : x.length > this.length || this.cmp(x) < 0 ? {
        div: new d(0),
        mod: this
      } : x.length === 1 ? _ === "div" ? {
        div: this.divn(x.words[0]),
        mod: null
      } : _ === "mod" ? {
        div: null,
        mod: new d(this.modn(x.words[0]))
      } : {
        div: this.divn(x.words[0]),
        mod: new d(this.modn(x.words[0]))
      } : this._wordDiv(x, _);
    }, d.prototype.div = function(x) {
      return this.divmod(x, "div", !1).div;
    }, d.prototype.mod = function(x) {
      return this.divmod(x, "mod", !1).mod;
    }, d.prototype.umod = function(x) {
      return this.divmod(x, "mod", !0).mod;
    }, d.prototype.divRound = function(x) {
      var _ = this.divmod(x);
      if (_.mod.isZero()) return _.div;
      var S = _.div.negative !== 0 ? _.mod.isub(x) : _.mod, C = x.ushrn(1), R = x.andln(1), H = S.cmp(C);
      return H < 0 || R === 1 && H === 0 ? _.div : _.div.negative !== 0 ? _.div.isubn(1) : _.div.iaddn(1);
    }, d.prototype.modn = function(x) {
      a(x <= 67108863);
      for (var _ = (1 << 26) % x, S = 0, C = this.length - 1; C >= 0; C--)
        S = (_ * S + (this.words[C] | 0)) % x;
      return S;
    }, d.prototype.idivn = function(x) {
      a(x <= 67108863);
      for (var _ = 0, S = this.length - 1; S >= 0; S--) {
        var C = (this.words[S] | 0) + _ * 67108864;
        this.words[S] = C / x | 0, _ = C % x;
      }
      return this.strip();
    }, d.prototype.divn = function(x) {
      return this.clone().idivn(x);
    }, d.prototype.egcd = function(x) {
      a(x.negative === 0), a(!x.isZero());
      var _ = this, S = x.clone();
      _.negative !== 0 ? _ = _.umod(x) : _ = _.clone();
      for (var C = new d(1), R = new d(0), H = new d(0), z = new d(1), U = 0; _.isEven() && S.isEven(); )
        _.iushrn(1), S.iushrn(1), ++U;
      for (var P = S.clone(), W = _.clone(); !_.isZero(); ) {
        for (var B = 0, Q = 1; !(_.words[0] & Q) && B < 26; ++B, Q <<= 1) ;
        if (B > 0)
          for (_.iushrn(B); B-- > 0; )
            (C.isOdd() || R.isOdd()) && (C.iadd(P), R.isub(W)), C.iushrn(1), R.iushrn(1);
        for (var J = 0, re = 1; !(S.words[0] & re) && J < 26; ++J, re <<= 1) ;
        if (J > 0)
          for (S.iushrn(J); J-- > 0; )
            (H.isOdd() || z.isOdd()) && (H.iadd(P), z.isub(W)), H.iushrn(1), z.iushrn(1);
        _.cmp(S) >= 0 ? (_.isub(S), C.isub(H), R.isub(z)) : (S.isub(_), H.isub(C), z.isub(R));
      }
      return {
        a: H,
        b: z,
        gcd: S.iushln(U)
      };
    }, d.prototype._invmp = function(x) {
      a(x.negative === 0), a(!x.isZero());
      var _ = this, S = x.clone();
      _.negative !== 0 ? _ = _.umod(x) : _ = _.clone();
      for (var C = new d(1), R = new d(0), H = S.clone(); _.cmpn(1) > 0 && S.cmpn(1) > 0; ) {
        for (var z = 0, U = 1; !(_.words[0] & U) && z < 26; ++z, U <<= 1) ;
        if (z > 0)
          for (_.iushrn(z); z-- > 0; )
            C.isOdd() && C.iadd(H), C.iushrn(1);
        for (var P = 0, W = 1; !(S.words[0] & W) && P < 26; ++P, W <<= 1) ;
        if (P > 0)
          for (S.iushrn(P); P-- > 0; )
            R.isOdd() && R.iadd(H), R.iushrn(1);
        _.cmp(S) >= 0 ? (_.isub(S), C.isub(R)) : (S.isub(_), R.isub(C));
      }
      var B;
      return _.cmpn(1) === 0 ? B = C : B = R, B.cmpn(0) < 0 && B.iadd(x), B;
    }, d.prototype.gcd = function(x) {
      if (this.isZero()) return x.abs();
      if (x.isZero()) return this.abs();
      var _ = this.clone(), S = x.clone();
      _.negative = 0, S.negative = 0;
      for (var C = 0; _.isEven() && S.isEven(); C++)
        _.iushrn(1), S.iushrn(1);
      do {
        for (; _.isEven(); )
          _.iushrn(1);
        for (; S.isEven(); )
          S.iushrn(1);
        var R = _.cmp(S);
        if (R < 0) {
          var H = _;
          _ = S, S = H;
        } else if (R === 0 || S.cmpn(1) === 0)
          break;
        _.isub(S);
      } while (!0);
      return S.iushln(C);
    }, d.prototype.invm = function(x) {
      return this.egcd(x).a.umod(x);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(x) {
      return this.words[0] & x;
    }, d.prototype.bincn = function(x) {
      a(typeof x == "number");
      var _ = x % 26, S = (x - _) / 26, C = 1 << _;
      if (this.length <= S)
        return this._expand(S + 1), this.words[S] |= C, this;
      for (var R = C, H = S; R !== 0 && H < this.length; H++) {
        var z = this.words[H] | 0;
        z += R, R = z >>> 26, z &= 67108863, this.words[H] = z;
      }
      return R !== 0 && (this.words[H] = R, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(x) {
      var _ = x < 0;
      if (this.negative !== 0 && !_) return -1;
      if (this.negative === 0 && _) return 1;
      this.strip();
      var S;
      if (this.length > 1)
        S = 1;
      else {
        _ && (x = -x), a(x <= 67108863, "Number is too big");
        var C = this.words[0] | 0;
        S = C === x ? 0 : C < x ? -1 : 1;
      }
      return this.negative !== 0 ? -S | 0 : S;
    }, d.prototype.cmp = function(x) {
      if (this.negative !== 0 && x.negative === 0) return -1;
      if (this.negative === 0 && x.negative !== 0) return 1;
      var _ = this.ucmp(x);
      return this.negative !== 0 ? -_ | 0 : _;
    }, d.prototype.ucmp = function(x) {
      if (this.length > x.length) return 1;
      if (this.length < x.length) return -1;
      for (var _ = 0, S = this.length - 1; S >= 0; S--) {
        var C = this.words[S] | 0, R = x.words[S] | 0;
        if (C !== R) {
          C < R ? _ = -1 : C > R && (_ = 1);
          break;
        }
      }
      return _;
    }, d.prototype.gtn = function(x) {
      return this.cmpn(x) === 1;
    }, d.prototype.gt = function(x) {
      return this.cmp(x) === 1;
    }, d.prototype.gten = function(x) {
      return this.cmpn(x) >= 0;
    }, d.prototype.gte = function(x) {
      return this.cmp(x) >= 0;
    }, d.prototype.ltn = function(x) {
      return this.cmpn(x) === -1;
    }, d.prototype.lt = function(x) {
      return this.cmp(x) === -1;
    }, d.prototype.lten = function(x) {
      return this.cmpn(x) <= 0;
    }, d.prototype.lte = function(x) {
      return this.cmp(x) <= 0;
    }, d.prototype.eqn = function(x) {
      return this.cmpn(x) === 0;
    }, d.prototype.eq = function(x) {
      return this.cmp(x) === 0;
    }, d.red = function(x) {
      return new k(x);
    }, d.prototype.toRed = function(x) {
      return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), x.convertTo(this)._forceRed(x);
    }, d.prototype.fromRed = function() {
      return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(x) {
      return this.red = x, this;
    }, d.prototype.forceRed = function(x) {
      return a(!this.red, "Already a number in reduction context"), this._forceRed(x);
    }, d.prototype.redAdd = function(x) {
      return a(this.red, "redAdd works only with red numbers"), this.red.add(this, x);
    }, d.prototype.redIAdd = function(x) {
      return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, x);
    }, d.prototype.redSub = function(x) {
      return a(this.red, "redSub works only with red numbers"), this.red.sub(this, x);
    }, d.prototype.redISub = function(x) {
      return a(this.red, "redISub works only with red numbers"), this.red.isub(this, x);
    }, d.prototype.redShl = function(x) {
      return a(this.red, "redShl works only with red numbers"), this.red.shl(this, x);
    }, d.prototype.redMul = function(x) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, x), this.red.mul(this, x);
    }, d.prototype.redIMul = function(x) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, x), this.red.imul(this, x);
    }, d.prototype.redSqr = function() {
      return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(x) {
      return a(this.red && !x.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, x);
    };
    var T = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function E(M, x) {
      this.name = M, this.p = new d(x, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    E.prototype._tmp = function() {
      var x = new d(null);
      return x.words = new Array(Math.ceil(this.n / 13)), x;
    }, E.prototype.ireduce = function(x) {
      var _ = x, S;
      do
        this.split(_, this.tmp), _ = this.imulK(_), _ = _.iadd(this.tmp), S = _.bitLength();
      while (S > this.n);
      var C = S < this.n ? -1 : _.ucmp(this.p);
      return C === 0 ? (_.words[0] = 0, _.length = 1) : C > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _;
    }, E.prototype.split = function(x, _) {
      x.iushrn(this.n, 0, _);
    }, E.prototype.imulK = function(x) {
      return x.imul(this.k);
    };
    function O() {
      E.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    l(O, E), O.prototype.split = function(x, _) {
      for (var S = 4194303, C = Math.min(x.length, 9), R = 0; R < C; R++)
        _.words[R] = x.words[R];
      if (_.length = C, x.length <= 9) {
        x.words[0] = 0, x.length = 1;
        return;
      }
      var H = x.words[9];
      for (_.words[_.length++] = H & S, R = 10; R < x.length; R++) {
        var z = x.words[R] | 0;
        x.words[R - 10] = (z & S) << 4 | H >>> 22, H = z;
      }
      H >>>= 22, x.words[R - 10] = H, H === 0 && x.length > 10 ? x.length -= 10 : x.length -= 9;
    }, O.prototype.imulK = function(x) {
      x.words[x.length] = 0, x.words[x.length + 1] = 0, x.length += 2;
      for (var _ = 0, S = 0; S < x.length; S++) {
        var C = x.words[S] | 0;
        _ += C * 977, x.words[S] = _ & 67108863, _ = C * 64 + (_ / 67108864 | 0);
      }
      return x.words[x.length - 1] === 0 && (x.length--, x.words[x.length - 1] === 0 && x.length--), x;
    };
    function D() {
      E.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    l(D, E);
    function $() {
      E.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    l($, E);
    function I() {
      E.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    l(I, E), I.prototype.imulK = function(x) {
      for (var _ = 0, S = 0; S < x.length; S++) {
        var C = (x.words[S] | 0) * 19 + _, R = C & 67108863;
        C >>>= 26, x.words[S] = R, _ = C;
      }
      return _ !== 0 && (x.words[x.length++] = _), x;
    }, d._prime = function(x) {
      if (T[x]) return T[x];
      var _;
      if (x === "k256")
        _ = new O();
      else if (x === "p224")
        _ = new D();
      else if (x === "p192")
        _ = new $();
      else if (x === "p25519")
        _ = new I();
      else
        throw new Error("Unknown prime " + x);
      return T[x] = _, _;
    };
    function k(M) {
      if (typeof M == "string") {
        var x = d._prime(M);
        this.m = x.p, this.prime = x;
      } else
        a(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
    }
    k.prototype._verify1 = function(x) {
      a(x.negative === 0, "red works only with positives"), a(x.red, "red works only with red numbers");
    }, k.prototype._verify2 = function(x, _) {
      a((x.negative | _.negative) === 0, "red works only with positives"), a(
        x.red && x.red === _.red,
        "red works only with red numbers"
      );
    }, k.prototype.imod = function(x) {
      return this.prime ? this.prime.ireduce(x)._forceRed(this) : x.umod(this.m)._forceRed(this);
    }, k.prototype.neg = function(x) {
      return x.isZero() ? x.clone() : this.m.sub(x)._forceRed(this);
    }, k.prototype.add = function(x, _) {
      this._verify2(x, _);
      var S = x.add(_);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S._forceRed(this);
    }, k.prototype.iadd = function(x, _) {
      this._verify2(x, _);
      var S = x.iadd(_);
      return S.cmp(this.m) >= 0 && S.isub(this.m), S;
    }, k.prototype.sub = function(x, _) {
      this._verify2(x, _);
      var S = x.sub(_);
      return S.cmpn(0) < 0 && S.iadd(this.m), S._forceRed(this);
    }, k.prototype.isub = function(x, _) {
      this._verify2(x, _);
      var S = x.isub(_);
      return S.cmpn(0) < 0 && S.iadd(this.m), S;
    }, k.prototype.shl = function(x, _) {
      return this._verify1(x), this.imod(x.ushln(_));
    }, k.prototype.imul = function(x, _) {
      return this._verify2(x, _), this.imod(x.imul(_));
    }, k.prototype.mul = function(x, _) {
      return this._verify2(x, _), this.imod(x.mul(_));
    }, k.prototype.isqr = function(x) {
      return this.imul(x, x.clone());
    }, k.prototype.sqr = function(x) {
      return this.mul(x, x);
    }, k.prototype.sqrt = function(x) {
      if (x.isZero()) return x.clone();
      var _ = this.m.andln(3);
      if (a(_ % 2 === 1), _ === 3) {
        var S = this.m.add(new d(1)).iushrn(2);
        return this.pow(x, S);
      }
      for (var C = this.m.subn(1), R = 0; !C.isZero() && C.andln(1) === 0; )
        R++, C.iushrn(1);
      a(!C.isZero());
      var H = new d(1).toRed(this), z = H.redNeg(), U = this.m.subn(1).iushrn(1), P = this.m.bitLength();
      for (P = new d(2 * P * P).toRed(this); this.pow(P, U).cmp(z) !== 0; )
        P.redIAdd(z);
      for (var W = this.pow(P, C), B = this.pow(x, C.addn(1).iushrn(1)), Q = this.pow(x, C), J = R; Q.cmp(H) !== 0; ) {
        for (var re = Q, G = 0; re.cmp(H) !== 0; G++)
          re = re.redSqr();
        a(G < J);
        var N = this.pow(W, new d(1).iushln(J - G - 1));
        B = B.redMul(N), W = N.redSqr(), Q = Q.redMul(W), J = G;
      }
      return B;
    }, k.prototype.invm = function(x) {
      var _ = x._invmp(this.m);
      return _.negative !== 0 ? (_.negative = 0, this.imod(_).redNeg()) : this.imod(_);
    }, k.prototype.pow = function(x, _) {
      if (_.isZero()) return new d(1).toRed(this);
      if (_.cmpn(1) === 0) return x.clone();
      var S = 4, C = new Array(1 << S);
      C[0] = new d(1).toRed(this), C[1] = x;
      for (var R = 2; R < C.length; R++)
        C[R] = this.mul(C[R - 1], x);
      var H = C[0], z = 0, U = 0, P = _.bitLength() % 26;
      for (P === 0 && (P = 26), R = _.length - 1; R >= 0; R--) {
        for (var W = _.words[R], B = P - 1; B >= 0; B--) {
          var Q = W >> B & 1;
          if (H !== C[0] && (H = this.sqr(H)), Q === 0 && z === 0) {
            U = 0;
            continue;
          }
          z <<= 1, z |= Q, U++, !(U !== S && (R !== 0 || B !== 0)) && (H = this.mul(H, C[z]), U = 0, z = 0);
        }
        P = 26;
      }
      return H;
    }, k.prototype.convertTo = function(x) {
      var _ = x.umod(this.m);
      return _ === x ? _.clone() : _;
    }, k.prototype.convertFrom = function(x) {
      var _ = x.clone();
      return _.red = null, _;
    }, d.mont = function(x) {
      return new L(x);
    };
    function L(M) {
      k.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    l(L, k), L.prototype.convertTo = function(x) {
      return this.imod(x.ushln(this.shift));
    }, L.prototype.convertFrom = function(x) {
      var _ = this.imod(x.mul(this.rinv));
      return _.red = null, _;
    }, L.prototype.imul = function(x, _) {
      if (x.isZero() || _.isZero())
        return x.words[0] = 0, x.length = 1, x;
      var S = x.imul(_), C = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), R = S.isub(C).iushrn(this.shift), H = R;
      return R.cmp(this.m) >= 0 ? H = R.isub(this.m) : R.cmpn(0) < 0 && (H = R.iadd(this.m)), H._forceRed(this);
    }, L.prototype.mul = function(x, _) {
      if (x.isZero() || _.isZero()) return new d(0)._forceRed(this);
      var S = x.mul(_), C = S.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), R = S.isub(C).iushrn(this.shift), H = R;
      return R.cmp(this.m) >= 0 ? H = R.isub(this.m) : R.cmpn(0) < 0 && (H = R.iadd(this.m)), H._forceRed(this);
    }, L.prototype.invm = function(x) {
      var _ = this.imod(x._invmp(this.m).mul(this.r2));
      return _._forceRed(this);
    };
  })(t, jt);
})(Rb);
var Gn = Rb.exports, Yc = { exports: {} }, $_;
function Mb() {
  if ($_) return Yc.exports;
  $_ = 1;
  var t;
  Yc.exports = function(l) {
    return t || (t = new e(null)), t.generate(l);
  };
  function e(a) {
    this.rand = a;
  }
  if (Yc.exports.Rand = e, e.prototype.generate = function(l) {
    return this._rand(l);
  }, e.prototype._rand = function(l) {
    if (this.rand.getBytes)
      return this.rand.getBytes(l);
    for (var d = new Uint8Array(l), h = 0; h < d.length; h++)
      d[h] = this.rand.getByte();
    return d;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function(l) {
      var d = new Uint8Array(l);
      return self.crypto.getRandomValues(d), d;
    } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function(l) {
      var d = new Uint8Array(l);
      return self.msCrypto.getRandomValues(d), d;
    } : typeof window == "object" && (e.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var r = Gb();
      if (typeof r.randomBytes != "function")
        throw new Error("Not supported");
      e.prototype._rand = function(l) {
        return r.randomBytes(l);
      };
    } catch {
    }
  return Yc.exports;
}
var pm, U_;
function qP() {
  if (U_) return pm;
  U_ = 1;
  var t = Gn, e = Mb();
  function r(a) {
    this.rand = a || new e.Rand();
  }
  return pm = r, r.create = function(l) {
    return new r(l);
  }, r.prototype._randbelow = function(l) {
    var d = l.bitLength(), h = Math.ceil(d / 8);
    do
      var n = new t(this.rand.generate(h));
    while (n.cmp(l) >= 0);
    return n;
  }, r.prototype._randrange = function(l, d) {
    var h = d.sub(l);
    return l.add(this._randbelow(h));
  }, r.prototype.test = function(l, d, h) {
    var n = l.bitLength(), u = t.mont(l), i = new t(1).toRed(u);
    d || (d = Math.max(1, n / 48 | 0));
    for (var c = l.subn(1), f = 0; !c.testn(f); f++)
      ;
    for (var s = l.shrn(f), o = c.toRed(u), y = !0; d > 0; d--) {
      var m = this._randrange(new t(2), c);
      h && h(m);
      var g = m.toRed(u).redPow(s);
      if (!(g.cmp(i) === 0 || g.cmp(o) === 0)) {
        for (var b = 1; b < f; b++) {
          if (g = g.redSqr(), g.cmp(i) === 0)
            return !1;
          if (g.cmp(o) === 0)
            break;
        }
        if (b === f)
          return !1;
      }
    }
    return y;
  }, r.prototype.getDivisor = function(l, d) {
    var h = l.bitLength(), n = t.mont(l), u = new t(1).toRed(n);
    d || (d = Math.max(1, h / 48 | 0));
    for (var i = l.subn(1), c = 0; !i.testn(c); c++)
      ;
    for (var f = l.shrn(c), s = i.toRed(n); d > 0; d--) {
      var o = this._randrange(new t(2), i), y = l.gcd(o);
      if (y.cmpn(1) !== 0)
        return y;
      var m = o.toRed(n).redPow(f);
      if (!(m.cmp(u) === 0 || m.cmp(s) === 0)) {
        for (var g = 1; g < c; g++) {
          if (m = m.redSqr(), m.cmp(u) === 0)
            return m.fromRed().subn(1).gcd(l);
          if (m.cmp(s) === 0)
            break;
        }
        if (g === c)
          return m = m.redSqr(), m.fromRed().subn(1).gcd(l);
      }
    }
    return !1;
  }, pm;
}
var hm, V_;
function HP() {
  if (V_) return hm;
  V_ = 1;
  var t = Cl;
  hm = g, g.simpleSieve = y, g.fermatTest = m;
  var e = Gn, r = new e(24), a = qP(), l = new a(), d = new e(1), h = new e(2), n = new e(5);
  new e(16), new e(8);
  var u = new e(10), i = new e(3);
  new e(7);
  var c = new e(11), f = new e(4);
  new e(12);
  var s = null;
  function o() {
    if (s !== null)
      return s;
    var b = 1048576, v = [];
    v[0] = 2;
    for (var T = 1, E = 3; E < b; E += 2) {
      for (var O = Math.ceil(Math.sqrt(E)), D = 0; D < T && v[D] <= O && E % v[D] !== 0; D++)
        ;
      T !== D && v[D] <= O || (v[T++] = E);
    }
    return s = v, v;
  }
  function y(b) {
    for (var v = o(), T = 0; T < v.length; T++)
      if (b.modn(v[T]) === 0)
        return b.cmpn(v[T]) === 0;
    return !0;
  }
  function m(b) {
    var v = e.mont(b);
    return h.toRed(v).redPow(b.subn(1)).fromRed().cmpn(1) === 0;
  }
  function g(b, v) {
    if (b < 16)
      return v === 2 || v === 5 ? new e([140, 123]) : new e([140, 39]);
    v = new e(v);
    for (var T, E; ; ) {
      for (T = new e(t(Math.ceil(b / 8))); T.bitLength() > b; )
        T.ishrn(1);
      if (T.isEven() && T.iadd(d), T.testn(1) || T.iadd(h), v.cmp(h)) {
        if (!v.cmp(n))
          for (; T.mod(u).cmp(i); )
            T.iadd(f);
      } else for (; T.mod(r).cmp(c); )
        T.iadd(f);
      if (E = T.shrn(1), y(E) && y(T) && m(E) && m(T) && l.test(E) && l.test(T))
        return T;
    }
  }
  return hm;
}
const VB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, WB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, qB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, HB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, GB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, zB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, KB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, YB = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, XB = {
  modp1: VB,
  modp2: WB,
  modp5: qB,
  modp14: HB,
  modp15: GB,
  modp16: zB,
  modp17: KB,
  modp18: YB
};
var mm, W_;
function JB() {
  if (W_) return mm;
  W_ = 1;
  var t = Gn, e = qP(), r = new e(), a = new t(24), l = new t(11), d = new t(10), h = new t(3), n = new t(7), u = HP(), i = Cl;
  mm = y;
  function c(g, b) {
    return b = b || "utf8", Gt.isBuffer(g) || (g = new Gt(g, b)), this._pub = new t(g), this;
  }
  function f(g, b) {
    return b = b || "utf8", Gt.isBuffer(g) || (g = new Gt(g, b)), this._priv = new t(g), this;
  }
  var s = {};
  function o(g, b) {
    var v = b.toString("hex"), T = [v, g.toString(16)].join("_");
    if (T in s)
      return s[T];
    var E = 0;
    if (g.isEven() || !u.simpleSieve || !u.fermatTest(g) || !r.test(g))
      return E += 1, v === "02" || v === "05" ? E += 8 : E += 4, s[T] = E, E;
    r.test(g.shrn(1)) || (E += 2);
    var O;
    switch (v) {
      case "02":
        g.mod(a).cmp(l) && (E += 8);
        break;
      case "05":
        O = g.mod(d), O.cmp(h) && O.cmp(n) && (E += 8);
        break;
      default:
        E += 4;
    }
    return s[T] = E, E;
  }
  function y(g, b, v) {
    this.setGenerator(b), this.__prime = new t(g), this._prime = t.mont(this.__prime), this._primeLen = g.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, v ? (this.setPublicKey = c, this.setPrivateKey = f) : this._primeCode = 8;
  }
  Object.defineProperty(y.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = o(this.__prime, this.__gen)), this._primeCode;
    }
  }), y.prototype.generateKeys = function() {
    return this._priv || (this._priv = new t(i(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, y.prototype.computeSecret = function(g) {
    g = new t(g), g = g.toRed(this._prime);
    var b = g.redPow(this._priv).fromRed(), v = new Gt(b.toArray()), T = this.getPrime();
    if (v.length < T.length) {
      var E = new Gt(T.length - v.length);
      E.fill(0), v = Gt.concat([E, v]);
    }
    return v;
  }, y.prototype.getPublicKey = function(b) {
    return m(this._pub, b);
  }, y.prototype.getPrivateKey = function(b) {
    return m(this._priv, b);
  }, y.prototype.getPrime = function(g) {
    return m(this.__prime, g);
  }, y.prototype.getGenerator = function(g) {
    return m(this._gen, g);
  }, y.prototype.setGenerator = function(g, b) {
    return b = b || "utf8", Gt.isBuffer(g) || (g = new Gt(g, b)), this.__gen = g, this._gen = new t(g), this;
  };
  function m(g, b) {
    var v = new Gt(g.toArray());
    return b ? v.toString(b) : v;
  }
  return mm;
}
var q_;
function QB() {
  if (q_) return Va;
  q_ = 1;
  var t = HP(), e = XB, r = JB();
  function a(h) {
    var n = new Gt(e[h].prime, "hex"), u = new Gt(e[h].gen, "hex");
    return new r(n, u);
  }
  var l = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function d(h, n, u, i) {
    return Gt.isBuffer(n) || l[n] === void 0 ? d(h, "binary", n, u) : (n = n || "binary", i = i || "binary", u = u || new Gt([2]), Gt.isBuffer(u) || (u = new Gt(u, i)), typeof h == "number" ? new r(t(h, u), u, !0) : (Gt.isBuffer(h) || (h = new Gt(h, n)), new r(h, u, !0)));
  }
  return Va.DiffieHellmanGroup = Va.createDiffieHellmanGroup = Va.getDiffieHellman = a, Va.createDiffieHellman = Va.DiffieHellman = d, Va;
}
var N1 = { exports: {} }, R1 = { exports: {} };
typeof Ze > "u" || !Ze.version || Ze.version.indexOf("v0.") === 0 || Ze.version.indexOf("v1.") === 0 && Ze.version.indexOf("v1.8.") !== 0 ? R1.exports = { nextTick: ZB } : R1.exports = Ze;
function ZB(t, e, r, a) {
  if (typeof t != "function")
    throw new TypeError('"callback" argument must be a function');
  var l = arguments.length, d, h;
  switch (l) {
    case 0:
    case 1:
      return Ze.nextTick(t);
    case 2:
      return Ze.nextTick(function() {
        t.call(null, e);
      });
    case 3:
      return Ze.nextTick(function() {
        t.call(null, e, r);
      });
    case 4:
      return Ze.nextTick(function() {
        t.call(null, e, r, a);
      });
    default:
      for (d = new Array(l - 1), h = 0; h < d.length; )
        d[h++] = arguments[h];
      return Ze.nextTick(function() {
        t.apply(null, d);
      });
  }
}
var dp = R1.exports, e$ = {}.toString, t$ = Array.isArray || function(t) {
  return e$.call(t) == "[object Array]";
}, GP = po.EventEmitter, M1 = { exports: {} };
(function(t, e) {
  var r = Ui, a = r.Buffer;
  function l(h, n) {
    for (var u in h)
      n[u] = h[u];
  }
  a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? t.exports = r : (l(r, e), e.Buffer = d);
  function d(h, n, u) {
    return a(h, n, u);
  }
  l(a, d), d.from = function(h, n, u) {
    if (typeof h == "number")
      throw new TypeError("Argument must not be a number");
    return a(h, n, u);
  }, d.alloc = function(h, n, u) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    var i = a(h);
    return n !== void 0 ? typeof u == "string" ? i.fill(n, u) : i.fill(n) : i.fill(0), i;
  }, d.allocUnsafe = function(h) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    return a(h);
  }, d.allocUnsafeSlow = function(h) {
    if (typeof h != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(h);
  };
})(M1, M1.exports);
var pp = M1.exports, vn = {};
function r$(t) {
  return Array.isArray ? Array.isArray(t) : hp(t) === "[object Array]";
}
vn.isArray = r$;
function n$(t) {
  return typeof t == "boolean";
}
vn.isBoolean = n$;
function i$(t) {
  return t === null;
}
vn.isNull = i$;
function s$(t) {
  return t == null;
}
vn.isNullOrUndefined = s$;
function a$(t) {
  return typeof t == "number";
}
vn.isNumber = a$;
function o$(t) {
  return typeof t == "string";
}
vn.isString = o$;
function l$(t) {
  return typeof t == "symbol";
}
vn.isSymbol = l$;
function u$(t) {
  return t === void 0;
}
vn.isUndefined = u$;
function c$(t) {
  return hp(t) === "[object RegExp]";
}
vn.isRegExp = c$;
function f$(t) {
  return typeof t == "object" && t !== null;
}
vn.isObject = f$;
function d$(t) {
  return hp(t) === "[object Date]";
}
vn.isDate = d$;
function p$(t) {
  return hp(t) === "[object Error]" || t instanceof Error;
}
vn.isError = p$;
function h$(t) {
  return typeof t == "function";
}
vn.isFunction = h$;
function m$(t) {
  return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || // ES6 symbol
  typeof t > "u";
}
vn.isPrimitive = m$;
vn.isBuffer = Ui.Buffer.isBuffer;
function hp(t) {
  return Object.prototype.toString.call(t);
}
var ym = { exports: {} }, H_;
function y$() {
  return H_ || (H_ = 1, function(t) {
    function e(d, h) {
      if (!(d instanceof h))
        throw new TypeError("Cannot call a class as a function");
    }
    var r = pp.Buffer, a = Rr;
    function l(d, h, n) {
      d.copy(h, n);
    }
    t.exports = function() {
      function d() {
        e(this, d), this.head = null, this.tail = null, this.length = 0;
      }
      return d.prototype.push = function(n) {
        var u = { data: n, next: null };
        this.length > 0 ? this.tail.next = u : this.head = u, this.tail = u, ++this.length;
      }, d.prototype.unshift = function(n) {
        var u = { data: n, next: this.head };
        this.length === 0 && (this.tail = u), this.head = u, ++this.length;
      }, d.prototype.shift = function() {
        if (this.length !== 0) {
          var n = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, n;
        }
      }, d.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, d.prototype.join = function(n) {
        if (this.length === 0) return "";
        for (var u = this.head, i = "" + u.data; u = u.next; )
          i += n + u.data;
        return i;
      }, d.prototype.concat = function(n) {
        if (this.length === 0) return r.alloc(0);
        for (var u = r.allocUnsafe(n >>> 0), i = this.head, c = 0; i; )
          l(i.data, u, c), c += i.data.length, i = i.next;
        return u;
      }, d;
    }(), a && a.inspect && a.inspect.custom && (t.exports.prototype[a.inspect.custom] = function() {
      var d = a.inspect({ length: this.length });
      return this.constructor.name + " " + d;
    });
  }(ym)), ym.exports;
}
var Xc = dp;
function b$(t, e) {
  var r = this, a = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed;
  return a || l ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Xc.nextTick(Jc, this, t)) : Xc.nextTick(Jc, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(d) {
    !e && d ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, Xc.nextTick(Jc, r, d)) : Xc.nextTick(Jc, r, d) : e && e(d);
  }), this);
}
function g$() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function Jc(t, e) {
  t.emit("error", e);
}
var zP = {
  destroy: b$,
  undestroy: g$
}, bm, G_;
function KP() {
  if (G_) return bm;
  G_ = 1;
  var t = dp;
  bm = m;
  function e(H) {
    var z = this;
    this.next = null, this.entry = null, this.finish = function() {
      R(z, H);
    };
  }
  var r = !Ze.browser && ["v0.10", "v0.9."].indexOf(Ze.version.slice(0, 5)) > -1 ? setImmediate : t.nextTick, a;
  m.WritableState = o;
  var l = Object.create(vn);
  l.inherits = ir;
  var d = {
    deprecate: ob
  }, h = GP, n = pp.Buffer, u = (typeof jt < "u" ? jt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function i(H) {
    return n.from(H);
  }
  function c(H) {
    return n.isBuffer(H) || H instanceof u;
  }
  var f = zP;
  l.inherits(m, h);
  function s() {
  }
  function o(H, z) {
    a = a || pl(), H = H || {};
    var U = z instanceof a;
    this.objectMode = !!H.objectMode, U && (this.objectMode = this.objectMode || !!H.writableObjectMode);
    var P = H.highWaterMark, W = H.writableHighWaterMark, B = this.objectMode ? 16 : 16 * 1024;
    P || P === 0 ? this.highWaterMark = P : U && (W || W === 0) ? this.highWaterMark = W : this.highWaterMark = B, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Q = H.decodeStrings === !1;
    this.decodeStrings = !Q, this.defaultEncoding = H.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(J) {
      $(z, J);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  o.prototype.getBuffer = function() {
    for (var z = this.bufferedRequest, U = []; z; )
      U.push(z), z = z.next;
    return U;
  }, function() {
    try {
      Object.defineProperty(o.prototype, "buffer", {
        get: d.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var y;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (y = Function.prototype[Symbol.hasInstance], Object.defineProperty(m, Symbol.hasInstance, {
    value: function(H) {
      return y.call(this, H) ? !0 : this !== m ? !1 : H && H._writableState instanceof o;
    }
  })) : y = function(H) {
    return H instanceof this;
  };
  function m(H) {
    if (a = a || pl(), !y.call(m, this) && !(this instanceof a))
      return new m(H);
    this._writableState = new o(H, this), this.writable = !0, H && (typeof H.write == "function" && (this._write = H.write), typeof H.writev == "function" && (this._writev = H.writev), typeof H.destroy == "function" && (this._destroy = H.destroy), typeof H.final == "function" && (this._final = H.final)), h.call(this);
  }
  m.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function g(H, z) {
    var U = new Error("write after end");
    H.emit("error", U), t.nextTick(z, U);
  }
  function b(H, z, U, P) {
    var W = !0, B = !1;
    return U === null ? B = new TypeError("May not write null values to stream") : typeof U != "string" && U !== void 0 && !z.objectMode && (B = new TypeError("Invalid non-string/buffer chunk")), B && (H.emit("error", B), t.nextTick(P, B), W = !1), W;
  }
  m.prototype.write = function(H, z, U) {
    var P = this._writableState, W = !1, B = !P.objectMode && c(H);
    return B && !n.isBuffer(H) && (H = i(H)), typeof z == "function" && (U = z, z = null), B ? z = "buffer" : z || (z = P.defaultEncoding), typeof U != "function" && (U = s), P.ended ? g(this, U) : (B || b(this, P, H, U)) && (P.pendingcb++, W = T(this, P, B, H, z, U)), W;
  }, m.prototype.cork = function() {
    var H = this._writableState;
    H.corked++;
  }, m.prototype.uncork = function() {
    var H = this._writableState;
    H.corked && (H.corked--, !H.writing && !H.corked && !H.bufferProcessing && H.bufferedRequest && L(this, H));
  }, m.prototype.setDefaultEncoding = function(z) {
    if (typeof z == "string" && (z = z.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((z + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + z);
    return this._writableState.defaultEncoding = z, this;
  };
  function v(H, z, U) {
    return !H.objectMode && H.decodeStrings !== !1 && typeof z == "string" && (z = n.from(z, U)), z;
  }
  Object.defineProperty(m.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function T(H, z, U, P, W, B) {
    if (!U) {
      var Q = v(z, P, W);
      P !== Q && (U = !0, W = "buffer", P = Q);
    }
    var J = z.objectMode ? 1 : P.length;
    z.length += J;
    var re = z.length < z.highWaterMark;
    if (re || (z.needDrain = !0), z.writing || z.corked) {
      var G = z.lastBufferedRequest;
      z.lastBufferedRequest = {
        chunk: P,
        encoding: W,
        isBuf: U,
        callback: B,
        next: null
      }, G ? G.next = z.lastBufferedRequest : z.bufferedRequest = z.lastBufferedRequest, z.bufferedRequestCount += 1;
    } else
      E(H, z, !1, J, P, W, B);
    return re;
  }
  function E(H, z, U, P, W, B, Q) {
    z.writelen = P, z.writecb = Q, z.writing = !0, z.sync = !0, U ? H._writev(W, z.onwrite) : H._write(W, B, z.onwrite), z.sync = !1;
  }
  function O(H, z, U, P, W) {
    --z.pendingcb, U ? (t.nextTick(W, P), t.nextTick(S, H, z), H._writableState.errorEmitted = !0, H.emit("error", P)) : (W(P), H._writableState.errorEmitted = !0, H.emit("error", P), S(H, z));
  }
  function D(H) {
    H.writing = !1, H.writecb = null, H.length -= H.writelen, H.writelen = 0;
  }
  function $(H, z) {
    var U = H._writableState, P = U.sync, W = U.writecb;
    if (D(U), z) O(H, U, P, z, W);
    else {
      var B = M(U);
      !B && !U.corked && !U.bufferProcessing && U.bufferedRequest && L(H, U), P ? r(I, H, U, B, W) : I(H, U, B, W);
    }
  }
  function I(H, z, U, P) {
    U || k(H, z), z.pendingcb--, P(), S(H, z);
  }
  function k(H, z) {
    z.length === 0 && z.needDrain && (z.needDrain = !1, H.emit("drain"));
  }
  function L(H, z) {
    z.bufferProcessing = !0;
    var U = z.bufferedRequest;
    if (H._writev && U && U.next) {
      var P = z.bufferedRequestCount, W = new Array(P), B = z.corkedRequestsFree;
      B.entry = U;
      for (var Q = 0, J = !0; U; )
        W[Q] = U, U.isBuf || (J = !1), U = U.next, Q += 1;
      W.allBuffers = J, E(H, z, !0, z.length, W, "", B.finish), z.pendingcb++, z.lastBufferedRequest = null, B.next ? (z.corkedRequestsFree = B.next, B.next = null) : z.corkedRequestsFree = new e(z), z.bufferedRequestCount = 0;
    } else {
      for (; U; ) {
        var re = U.chunk, G = U.encoding, N = U.callback, V = z.objectMode ? 1 : re.length;
        if (E(H, z, !1, V, re, G, N), U = U.next, z.bufferedRequestCount--, z.writing)
          break;
      }
      U === null && (z.lastBufferedRequest = null);
    }
    z.bufferedRequest = U, z.bufferProcessing = !1;
  }
  m.prototype._write = function(H, z, U) {
    U(new Error("_write() is not implemented"));
  }, m.prototype._writev = null, m.prototype.end = function(H, z, U) {
    var P = this._writableState;
    typeof H == "function" ? (U = H, H = null, z = null) : typeof z == "function" && (U = z, z = null), H != null && this.write(H, z), P.corked && (P.corked = 1, this.uncork()), P.ending || C(this, P, U);
  };
  function M(H) {
    return H.ending && H.length === 0 && H.bufferedRequest === null && !H.finished && !H.writing;
  }
  function x(H, z) {
    H._final(function(U) {
      z.pendingcb--, U && H.emit("error", U), z.prefinished = !0, H.emit("prefinish"), S(H, z);
    });
  }
  function _(H, z) {
    !z.prefinished && !z.finalCalled && (typeof H._final == "function" ? (z.pendingcb++, z.finalCalled = !0, t.nextTick(x, H, z)) : (z.prefinished = !0, H.emit("prefinish")));
  }
  function S(H, z) {
    var U = M(z);
    return U && (_(H, z), z.pendingcb === 0 && (z.finished = !0, H.emit("finish"))), U;
  }
  function C(H, z, U) {
    z.ending = !0, S(H, z), U && (z.finished ? t.nextTick(U) : H.once("finish", U)), z.ended = !0, H.writable = !1;
  }
  function R(H, z, U) {
    var P = H.entry;
    for (H.entry = null; P; ) {
      var W = P.callback;
      z.pendingcb--, W(U), P = P.next;
    }
    z.corkedRequestsFree.next = H;
  }
  return Object.defineProperty(m.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(H) {
      this._writableState && (this._writableState.destroyed = H);
    }
  }), m.prototype.destroy = f.destroy, m.prototype._undestroy = f.undestroy, m.prototype._destroy = function(H, z) {
    this.end(), z(H);
  }, bm;
}
var gm, z_;
function pl() {
  if (z_) return gm;
  z_ = 1;
  var t = dp, e = Object.keys || function(f) {
    var s = [];
    for (var o in f)
      s.push(o);
    return s;
  };
  gm = u;
  var r = Object.create(vn);
  r.inherits = ir;
  var a = YP(), l = KP();
  r.inherits(u, a);
  for (var d = e(l.prototype), h = 0; h < d.length; h++) {
    var n = d[h];
    u.prototype[n] || (u.prototype[n] = l.prototype[n]);
  }
  function u(f) {
    if (!(this instanceof u)) return new u(f);
    a.call(this, f), l.call(this, f), f && f.readable === !1 && (this.readable = !1), f && f.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, f && f.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", i);
  }
  Object.defineProperty(u.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function i() {
    this.allowHalfOpen || this._writableState.ended || t.nextTick(c, this);
  }
  function c(f) {
    f.end();
  }
  return Object.defineProperty(u.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(f) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = f, this._writableState.destroyed = f);
    }
  }), u.prototype._destroy = function(f, s) {
    this.push(null), this.end(), t.nextTick(s, f);
  }, gm;
}
var vm = {}, K_;
function Y_() {
  if (K_) return vm;
  K_ = 1;
  var t = pp.Buffer, e = t.isEncoding || function(b) {
    switch (b = "" + b, b && b.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function r(b) {
    if (!b) return "utf8";
    for (var v; ; )
      switch (b) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return b;
        default:
          if (v) return;
          b = ("" + b).toLowerCase(), v = !0;
      }
  }
  function a(b) {
    var v = r(b);
    if (typeof v != "string" && (t.isEncoding === e || !e(b))) throw new Error("Unknown encoding: " + b);
    return v || b;
  }
  vm.StringDecoder = l;
  function l(b) {
    this.encoding = a(b);
    var v;
    switch (this.encoding) {
      case "utf16le":
        this.text = f, this.end = s, v = 4;
        break;
      case "utf8":
        this.fillLast = u, v = 4;
        break;
      case "base64":
        this.text = o, this.end = y, v = 3;
        break;
      default:
        this.write = m, this.end = g;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(v);
  }
  l.prototype.write = function(b) {
    if (b.length === 0) return "";
    var v, T;
    if (this.lastNeed) {
      if (v = this.fillLast(b), v === void 0) return "";
      T = this.lastNeed, this.lastNeed = 0;
    } else
      T = 0;
    return T < b.length ? v ? v + this.text(b, T) : this.text(b, T) : v || "";
  }, l.prototype.end = c, l.prototype.text = i, l.prototype.fillLast = function(b) {
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
  };
  function d(b) {
    return b <= 127 ? 0 : b >> 5 === 6 ? 2 : b >> 4 === 14 ? 3 : b >> 3 === 30 ? 4 : b >> 6 === 2 ? -1 : -2;
  }
  function h(b, v, T) {
    var E = v.length - 1;
    if (E < T) return 0;
    var O = d(v[E]);
    return O >= 0 ? (O > 0 && (b.lastNeed = O - 1), O) : --E < T || O === -2 ? 0 : (O = d(v[E]), O >= 0 ? (O > 0 && (b.lastNeed = O - 2), O) : --E < T || O === -2 ? 0 : (O = d(v[E]), O >= 0 ? (O > 0 && (O === 2 ? O = 0 : b.lastNeed = O - 3), O) : 0));
  }
  function n(b, v, T) {
    if ((v[0] & 192) !== 128)
      return b.lastNeed = 0, "�";
    if (b.lastNeed > 1 && v.length > 1) {
      if ((v[1] & 192) !== 128)
        return b.lastNeed = 1, "�";
      if (b.lastNeed > 2 && v.length > 2 && (v[2] & 192) !== 128)
        return b.lastNeed = 2, "�";
    }
  }
  function u(b) {
    var v = this.lastTotal - this.lastNeed, T = n(this, b);
    if (T !== void 0) return T;
    if (this.lastNeed <= b.length)
      return b.copy(this.lastChar, v, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    b.copy(this.lastChar, v, 0, b.length), this.lastNeed -= b.length;
  }
  function i(b, v) {
    var T = h(this, b, v);
    if (!this.lastNeed) return b.toString("utf8", v);
    this.lastTotal = T;
    var E = b.length - (T - this.lastNeed);
    return b.copy(this.lastChar, 0, E), b.toString("utf8", v, E);
  }
  function c(b) {
    var v = b && b.length ? this.write(b) : "";
    return this.lastNeed ? v + "�" : v;
  }
  function f(b, v) {
    if ((b.length - v) % 2 === 0) {
      var T = b.toString("utf16le", v);
      if (T) {
        var E = T.charCodeAt(T.length - 1);
        if (E >= 55296 && E <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], T.slice(0, -1);
      }
      return T;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", v, b.length - 1);
  }
  function s(b) {
    var v = b && b.length ? this.write(b) : "";
    if (this.lastNeed) {
      var T = this.lastTotal - this.lastNeed;
      return v + this.lastChar.toString("utf16le", 0, T);
    }
    return v;
  }
  function o(b, v) {
    var T = (b.length - v) % 3;
    return T === 0 ? b.toString("base64", v) : (this.lastNeed = 3 - T, this.lastTotal = 3, T === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", v, b.length - T));
  }
  function y(b) {
    var v = b && b.length ? this.write(b) : "";
    return this.lastNeed ? v + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : v;
  }
  function m(b) {
    return b.toString(this.encoding);
  }
  function g(b) {
    return b && b.length ? this.write(b) : "";
  }
  return vm;
}
var Em, X_;
function YP() {
  if (X_) return Em;
  X_ = 1;
  var t = dp;
  Em = v;
  var e = t$, r;
  v.ReadableState = b, po.EventEmitter;
  var a = function(N, V) {
    return N.listeners(V).length;
  }, l = GP, d = pp.Buffer, h = (typeof jt < "u" ? jt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function n(N) {
    return d.from(N);
  }
  function u(N) {
    return d.isBuffer(N) || N instanceof h;
  }
  var i = Object.create(vn);
  i.inherits = ir;
  var c = Rr, f = void 0;
  c && c.debuglog ? f = c.debuglog("stream") : f = function() {
  };
  var s = y$(), o = zP, y;
  i.inherits(v, l);
  var m = ["error", "close", "destroy", "pause", "resume"];
  function g(N, V, F) {
    if (typeof N.prependListener == "function") return N.prependListener(V, F);
    !N._events || !N._events[V] ? N.on(V, F) : e(N._events[V]) ? N._events[V].unshift(F) : N._events[V] = [F, N._events[V]];
  }
  function b(N, V) {
    r = r || pl(), N = N || {};
    var F = V instanceof r;
    this.objectMode = !!N.objectMode, F && (this.objectMode = this.objectMode || !!N.readableObjectMode);
    var X = N.highWaterMark, K = N.readableHighWaterMark, ie = this.objectMode ? 16 : 16 * 1024;
    X || X === 0 ? this.highWaterMark = X : F && (K || K === 0) ? this.highWaterMark = K : this.highWaterMark = ie, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new s(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = N.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, N.encoding && (y || (y = Y_().StringDecoder), this.decoder = new y(N.encoding), this.encoding = N.encoding);
  }
  function v(N) {
    if (r = r || pl(), !(this instanceof v)) return new v(N);
    this._readableState = new b(N, this), this.readable = !0, N && (typeof N.read == "function" && (this._read = N.read), typeof N.destroy == "function" && (this._destroy = N.destroy)), l.call(this);
  }
  Object.defineProperty(v.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(N) {
      this._readableState && (this._readableState.destroyed = N);
    }
  }), v.prototype.destroy = o.destroy, v.prototype._undestroy = o.undestroy, v.prototype._destroy = function(N, V) {
    this.push(null), V(N);
  }, v.prototype.push = function(N, V) {
    var F = this._readableState, X;
    return F.objectMode ? X = !0 : typeof N == "string" && (V = V || F.defaultEncoding, V !== F.encoding && (N = d.from(N, V), V = ""), X = !0), T(this, N, V, !1, X);
  }, v.prototype.unshift = function(N) {
    return T(this, N, null, !0, !1);
  };
  function T(N, V, F, X, K) {
    var ie = N._readableState;
    if (V === null)
      ie.reading = !1, L(N, ie);
    else {
      var fe;
      K || (fe = O(ie, V)), fe ? N.emit("error", fe) : ie.objectMode || V && V.length > 0 ? (typeof V != "string" && !ie.objectMode && Object.getPrototypeOf(V) !== d.prototype && (V = n(V)), X ? ie.endEmitted ? N.emit("error", new Error("stream.unshift() after end event")) : E(N, ie, V, !0) : ie.ended ? N.emit("error", new Error("stream.push() after EOF")) : (ie.reading = !1, ie.decoder && !F ? (V = ie.decoder.write(V), ie.objectMode || V.length !== 0 ? E(N, ie, V, !1) : _(N, ie)) : E(N, ie, V, !1))) : X || (ie.reading = !1);
    }
    return D(ie);
  }
  function E(N, V, F, X) {
    V.flowing && V.length === 0 && !V.sync ? (N.emit("data", F), N.read(0)) : (V.length += V.objectMode ? 1 : F.length, X ? V.buffer.unshift(F) : V.buffer.push(F), V.needReadable && M(N)), _(N, V);
  }
  function O(N, V) {
    var F;
    return !u(V) && typeof V != "string" && V !== void 0 && !N.objectMode && (F = new TypeError("Invalid non-string/buffer chunk")), F;
  }
  function D(N) {
    return !N.ended && (N.needReadable || N.length < N.highWaterMark || N.length === 0);
  }
  v.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, v.prototype.setEncoding = function(N) {
    return y || (y = Y_().StringDecoder), this._readableState.decoder = new y(N), this._readableState.encoding = N, this;
  };
  var $ = 8388608;
  function I(N) {
    return N >= $ ? N = $ : (N--, N |= N >>> 1, N |= N >>> 2, N |= N >>> 4, N |= N >>> 8, N |= N >>> 16, N++), N;
  }
  function k(N, V) {
    return N <= 0 || V.length === 0 && V.ended ? 0 : V.objectMode ? 1 : N !== N ? V.flowing && V.length ? V.buffer.head.data.length : V.length : (N > V.highWaterMark && (V.highWaterMark = I(N)), N <= V.length ? N : V.ended ? V.length : (V.needReadable = !0, 0));
  }
  v.prototype.read = function(N) {
    f("read", N), N = parseInt(N, 10);
    var V = this._readableState, F = N;
    if (N !== 0 && (V.emittedReadable = !1), N === 0 && V.needReadable && (V.length >= V.highWaterMark || V.ended))
      return f("read: emitReadable", V.length, V.ended), V.length === 0 && V.ended ? J(this) : M(this), null;
    if (N = k(N, V), N === 0 && V.ended)
      return V.length === 0 && J(this), null;
    var X = V.needReadable;
    f("need readable", X), (V.length === 0 || V.length - N < V.highWaterMark) && (X = !0, f("length less than watermark", X)), V.ended || V.reading ? (X = !1, f("reading or ended", X)) : X && (f("do read"), V.reading = !0, V.sync = !0, V.length === 0 && (V.needReadable = !0), this._read(V.highWaterMark), V.sync = !1, V.reading || (N = k(F, V)));
    var K;
    return N > 0 ? K = P(N, V) : K = null, K === null ? (V.needReadable = !0, N = 0) : V.length -= N, V.length === 0 && (V.ended || (V.needReadable = !0), F !== N && V.ended && J(this)), K !== null && this.emit("data", K), K;
  };
  function L(N, V) {
    if (!V.ended) {
      if (V.decoder) {
        var F = V.decoder.end();
        F && F.length && (V.buffer.push(F), V.length += V.objectMode ? 1 : F.length);
      }
      V.ended = !0, M(N);
    }
  }
  function M(N) {
    var V = N._readableState;
    V.needReadable = !1, V.emittedReadable || (f("emitReadable", V.flowing), V.emittedReadable = !0, V.sync ? t.nextTick(x, N) : x(N));
  }
  function x(N) {
    f("emit readable"), N.emit("readable"), U(N);
  }
  function _(N, V) {
    V.readingMore || (V.readingMore = !0, t.nextTick(S, N, V));
  }
  function S(N, V) {
    for (var F = V.length; !V.reading && !V.flowing && !V.ended && V.length < V.highWaterMark && (f("maybeReadMore read 0"), N.read(0), F !== V.length); )
      F = V.length;
    V.readingMore = !1;
  }
  v.prototype._read = function(N) {
    this.emit("error", new Error("_read() is not implemented"));
  }, v.prototype.pipe = function(N, V) {
    var F = this, X = this._readableState;
    switch (X.pipesCount) {
      case 0:
        X.pipes = N;
        break;
      case 1:
        X.pipes = [X.pipes, N];
        break;
      default:
        X.pipes.push(N);
        break;
    }
    X.pipesCount += 1, f("pipe count=%d opts=%j", X.pipesCount, V);
    var K = (!V || V.end !== !1) && N !== Ze.stdout && N !== Ze.stderr, ie = K ? _e : ge;
    X.endEmitted ? t.nextTick(ie) : F.once("end", ie), N.on("unpipe", fe);
    function fe(se, be) {
      f("onunpipe"), se === F && be && be.hasUnpiped === !1 && (be.hasUnpiped = !0, ee());
    }
    function _e() {
      f("onend"), N.end();
    }
    var Ae = C(F);
    N.on("drain", Ae);
    var ce = !1;
    function ee() {
      f("cleanup"), N.removeListener("close", ye), N.removeListener("finish", we), N.removeListener("drain", Ae), N.removeListener("error", me), N.removeListener("unpipe", fe), F.removeListener("end", _e), F.removeListener("end", ge), F.removeListener("data", oe), ce = !0, X.awaitDrain && (!N._writableState || N._writableState.needDrain) && Ae();
    }
    var ae = !1;
    F.on("data", oe);
    function oe(se) {
      f("ondata"), ae = !1;
      var be = N.write(se);
      be === !1 && !ae && ((X.pipesCount === 1 && X.pipes === N || X.pipesCount > 1 && G(X.pipes, N) !== -1) && !ce && (f("false write response, pause", X.awaitDrain), X.awaitDrain++, ae = !0), F.pause());
    }
    function me(se) {
      f("onerror", se), ge(), N.removeListener("error", me), a(N, "error") === 0 && N.emit("error", se);
    }
    g(N, "error", me);
    function ye() {
      N.removeListener("finish", we), ge();
    }
    N.once("close", ye);
    function we() {
      f("onfinish"), N.removeListener("close", ye), ge();
    }
    N.once("finish", we);
    function ge() {
      f("unpipe"), F.unpipe(N);
    }
    return N.emit("pipe", F), X.flowing || (f("pipe resume"), F.resume()), N;
  };
  function C(N) {
    return function() {
      var V = N._readableState;
      f("pipeOnDrain", V.awaitDrain), V.awaitDrain && V.awaitDrain--, V.awaitDrain === 0 && a(N, "data") && (V.flowing = !0, U(N));
    };
  }
  v.prototype.unpipe = function(N) {
    var V = this._readableState, F = { hasUnpiped: !1 };
    if (V.pipesCount === 0) return this;
    if (V.pipesCount === 1)
      return N && N !== V.pipes ? this : (N || (N = V.pipes), V.pipes = null, V.pipesCount = 0, V.flowing = !1, N && N.emit("unpipe", this, F), this);
    if (!N) {
      var X = V.pipes, K = V.pipesCount;
      V.pipes = null, V.pipesCount = 0, V.flowing = !1;
      for (var ie = 0; ie < K; ie++)
        X[ie].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var fe = G(V.pipes, N);
    return fe === -1 ? this : (V.pipes.splice(fe, 1), V.pipesCount -= 1, V.pipesCount === 1 && (V.pipes = V.pipes[0]), N.emit("unpipe", this, F), this);
  }, v.prototype.on = function(N, V) {
    var F = l.prototype.on.call(this, N, V);
    if (N === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (N === "readable") {
      var X = this._readableState;
      !X.endEmitted && !X.readableListening && (X.readableListening = X.needReadable = !0, X.emittedReadable = !1, X.reading ? X.length && M(this) : t.nextTick(R, this));
    }
    return F;
  }, v.prototype.addListener = v.prototype.on;
  function R(N) {
    f("readable nexttick read 0"), N.read(0);
  }
  v.prototype.resume = function() {
    var N = this._readableState;
    return N.flowing || (f("resume"), N.flowing = !0, H(this, N)), this;
  };
  function H(N, V) {
    V.resumeScheduled || (V.resumeScheduled = !0, t.nextTick(z, N, V));
  }
  function z(N, V) {
    V.reading || (f("resume read 0"), N.read(0)), V.resumeScheduled = !1, V.awaitDrain = 0, N.emit("resume"), U(N), V.flowing && !V.reading && N.read(0);
  }
  v.prototype.pause = function() {
    return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function U(N) {
    var V = N._readableState;
    for (f("flow", V.flowing); V.flowing && N.read() !== null; )
      ;
  }
  v.prototype.wrap = function(N) {
    var V = this, F = this._readableState, X = !1;
    N.on("end", function() {
      if (f("wrapped end"), F.decoder && !F.ended) {
        var fe = F.decoder.end();
        fe && fe.length && V.push(fe);
      }
      V.push(null);
    }), N.on("data", function(fe) {
      if (f("wrapped data"), F.decoder && (fe = F.decoder.write(fe)), !(F.objectMode && fe == null) && !(!F.objectMode && (!fe || !fe.length))) {
        var _e = V.push(fe);
        _e || (X = !0, N.pause());
      }
    });
    for (var K in N)
      this[K] === void 0 && typeof N[K] == "function" && (this[K] = /* @__PURE__ */ function(fe) {
        return function() {
          return N[fe].apply(N, arguments);
        };
      }(K));
    for (var ie = 0; ie < m.length; ie++)
      N.on(m[ie], this.emit.bind(this, m[ie]));
    return this._read = function(fe) {
      f("wrapped _read", fe), X && (X = !1, N.resume());
    }, this;
  }, Object.defineProperty(v.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), v._fromList = P;
  function P(N, V) {
    if (V.length === 0) return null;
    var F;
    return V.objectMode ? F = V.buffer.shift() : !N || N >= V.length ? (V.decoder ? F = V.buffer.join("") : V.buffer.length === 1 ? F = V.buffer.head.data : F = V.buffer.concat(V.length), V.buffer.clear()) : F = W(N, V.buffer, V.decoder), F;
  }
  function W(N, V, F) {
    var X;
    return N < V.head.data.length ? (X = V.head.data.slice(0, N), V.head.data = V.head.data.slice(N)) : N === V.head.data.length ? X = V.shift() : X = F ? B(N, V) : Q(N, V), X;
  }
  function B(N, V) {
    var F = V.head, X = 1, K = F.data;
    for (N -= K.length; F = F.next; ) {
      var ie = F.data, fe = N > ie.length ? ie.length : N;
      if (fe === ie.length ? K += ie : K += ie.slice(0, N), N -= fe, N === 0) {
        fe === ie.length ? (++X, F.next ? V.head = F.next : V.head = V.tail = null) : (V.head = F, F.data = ie.slice(fe));
        break;
      }
      ++X;
    }
    return V.length -= X, K;
  }
  function Q(N, V) {
    var F = d.allocUnsafe(N), X = V.head, K = 1;
    for (X.data.copy(F), N -= X.data.length; X = X.next; ) {
      var ie = X.data, fe = N > ie.length ? ie.length : N;
      if (ie.copy(F, F.length - N, 0, fe), N -= fe, N === 0) {
        fe === ie.length ? (++K, X.next ? V.head = X.next : V.head = V.tail = null) : (V.head = X, X.data = ie.slice(fe));
        break;
      }
      ++K;
    }
    return V.length -= K, F;
  }
  function J(N) {
    var V = N._readableState;
    if (V.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    V.endEmitted || (V.ended = !0, t.nextTick(re, V, N));
  }
  function re(N, V) {
    !N.endEmitted && N.length === 0 && (N.endEmitted = !0, V.readable = !1, V.emit("end"));
  }
  function G(N, V) {
    for (var F = 0, X = N.length; F < X; F++)
      if (N[F] === V) return F;
    return -1;
  }
  return Em;
}
var XP = ia, mp = pl(), JP = Object.create(vn);
JP.inherits = ir;
JP.inherits(ia, mp);
function v$(t, e) {
  var r = this._transformState;
  r.transforming = !1;
  var a = r.writecb;
  if (!a)
    return this.emit("error", new Error("write callback called multiple times"));
  r.writechunk = null, r.writecb = null, e != null && this.push(e), a(t);
  var l = this._readableState;
  l.reading = !1, (l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
}
function ia(t) {
  if (!(this instanceof ia)) return new ia(t);
  mp.call(this, t), this._transformState = {
    afterTransform: v$.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", E$);
}
function E$() {
  var t = this;
  typeof this._flush == "function" ? this._flush(function(e, r) {
    J_(t, e, r);
  }) : J_(this, null, null);
}
ia.prototype.push = function(t, e) {
  return this._transformState.needTransform = !1, mp.prototype.push.call(this, t, e);
};
ia.prototype._transform = function(t, e, r) {
  throw new Error("_transform() is not implemented");
};
ia.prototype._write = function(t, e, r) {
  var a = this._transformState;
  if (a.writecb = r, a.writechunk = t, a.writeencoding = e, !a.transforming) {
    var l = this._readableState;
    (a.needTransform || l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
  }
};
ia.prototype._read = function(t) {
  var e = this._transformState;
  e.writechunk !== null && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
};
ia.prototype._destroy = function(t, e) {
  var r = this;
  mp.prototype._destroy.call(this, t, function(a) {
    e(a), r.emit("close");
  });
};
function J_(t, e, r) {
  if (e) return t.emit("error", e);
  if (r != null && t.push(r), t._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (t._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return t.push(null);
}
var _$ = Du, QP = XP, ZP = Object.create(vn);
ZP.inherits = ir;
ZP.inherits(Du, QP);
function Du(t) {
  if (!(this instanceof Du)) return new Du(t);
  QP.call(this, t);
}
Du.prototype._transform = function(t, e, r) {
  r(null, t);
};
(function(t, e) {
  e = t.exports = YP(), e.Stream = e, e.Readable = e, e.Writable = KP(), e.Duplex = pl(), e.Transform = XP, e.PassThrough = _$;
})(N1, N1.exports);
var S$ = N1.exports, Zl = { exports: {} }, Lb = { exports: {} };
Lb.exports;
(function(t) {
  (function(e, r) {
    function a(_, S) {
      if (!_) throw new Error(S || "Assertion failed");
    }
    function l(_, S) {
      _.super_ = S;
      var C = function() {
      };
      C.prototype = S.prototype, _.prototype = new C(), _.prototype.constructor = _;
    }
    function d(_, S, C) {
      if (d.isBN(_))
        return _;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, _ !== null && ((S === "le" || S === "be") && (C = S, S = 10), this._init(_ || 0, S || 10, C || "be"));
    }
    typeof e == "object" ? e.exports = d : r.BN = d, d.BN = d, d.wordSize = 26;
    var h;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? h = window.Buffer : h = Rr.Buffer;
    } catch {
    }
    d.isBN = function(S) {
      return S instanceof d ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === d.wordSize && Array.isArray(S.words);
    }, d.max = function(S, C) {
      return S.cmp(C) > 0 ? S : C;
    }, d.min = function(S, C) {
      return S.cmp(C) < 0 ? S : C;
    }, d.prototype._init = function(S, C, R) {
      if (typeof S == "number")
        return this._initNumber(S, C, R);
      if (typeof S == "object")
        return this._initArray(S, C, R);
      C === "hex" && (C = 16), a(C === (C | 0) && C >= 2 && C <= 36), S = S.toString().replace(/\s+/g, "");
      var H = 0;
      S[0] === "-" && (H++, this.negative = 1), H < S.length && (C === 16 ? this._parseHex(S, H, R) : (this._parseBase(S, C, H), R === "le" && this._initArray(this.toArray(), C, R)));
    }, d.prototype._initNumber = function(S, C, R) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (a(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), R === "le" && this._initArray(this.toArray(), C, R);
    }, d.prototype._initArray = function(S, C, R) {
      if (a(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var H = 0; H < this.length; H++)
        this.words[H] = 0;
      var z, U, P = 0;
      if (R === "be")
        for (H = S.length - 1, z = 0; H >= 0; H -= 3)
          U = S[H] | S[H - 1] << 8 | S[H - 2] << 16, this.words[z] |= U << P & 67108863, this.words[z + 1] = U >>> 26 - P & 67108863, P += 24, P >= 26 && (P -= 26, z++);
      else if (R === "le")
        for (H = 0, z = 0; H < S.length; H += 3)
          U = S[H] | S[H + 1] << 8 | S[H + 2] << 16, this.words[z] |= U << P & 67108863, this.words[z + 1] = U >>> 26 - P & 67108863, P += 24, P >= 26 && (P -= 26, z++);
      return this._strip();
    };
    function n(_, S) {
      var C = _.charCodeAt(S);
      if (C >= 48 && C <= 57)
        return C - 48;
      if (C >= 65 && C <= 70)
        return C - 55;
      if (C >= 97 && C <= 102)
        return C - 87;
      a(!1, "Invalid character in " + _);
    }
    function u(_, S, C) {
      var R = n(_, C);
      return C - 1 >= S && (R |= n(_, C - 1) << 4), R;
    }
    d.prototype._parseHex = function(S, C, R) {
      this.length = Math.ceil((S.length - C) / 6), this.words = new Array(this.length);
      for (var H = 0; H < this.length; H++)
        this.words[H] = 0;
      var z = 0, U = 0, P;
      if (R === "be")
        for (H = S.length - 1; H >= C; H -= 2)
          P = u(S, C, H) << z, this.words[U] |= P & 67108863, z >= 18 ? (z -= 18, U += 1, this.words[U] |= P >>> 26) : z += 8;
      else {
        var W = S.length - C;
        for (H = W % 2 === 0 ? C + 1 : C; H < S.length; H += 2)
          P = u(S, C, H) << z, this.words[U] |= P & 67108863, z >= 18 ? (z -= 18, U += 1, this.words[U] |= P >>> 26) : z += 8;
      }
      this._strip();
    };
    function i(_, S, C, R) {
      for (var H = 0, z = 0, U = Math.min(_.length, C), P = S; P < U; P++) {
        var W = _.charCodeAt(P) - 48;
        H *= R, W >= 49 ? z = W - 49 + 10 : W >= 17 ? z = W - 17 + 10 : z = W, a(W >= 0 && z < R, "Invalid character"), H += z;
      }
      return H;
    }
    d.prototype._parseBase = function(S, C, R) {
      this.words = [0], this.length = 1;
      for (var H = 0, z = 1; z <= 67108863; z *= C)
        H++;
      H--, z = z / C | 0;
      for (var U = S.length - R, P = U % H, W = Math.min(U, U - P) + R, B = 0, Q = R; Q < W; Q += H)
        B = i(S, Q, Q + H, C), this.imuln(z), this.words[0] + B < 67108864 ? this.words[0] += B : this._iaddn(B);
      if (P !== 0) {
        var J = 1;
        for (B = i(S, Q, S.length, C), Q = 0; Q < P; Q++)
          J *= C;
        this.imuln(J), this.words[0] + B < 67108864 ? this.words[0] += B : this._iaddn(B);
      }
      this._strip();
    }, d.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var C = 0; C < this.length; C++)
        S.words[C] = this.words[C];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    };
    function c(_, S) {
      _.words = S.words, _.length = S.length, _.negative = S.negative, _.red = S.red;
    }
    if (d.prototype._move = function(S) {
      c(S, this);
    }, d.prototype.clone = function() {
      var S = new d(null);
      return this.copy(S), S;
    }, d.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, d.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, d.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        d.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
      } catch {
        d.prototype.inspect = f;
      }
    else
      d.prototype.inspect = f;
    function f() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var s = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], o = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], y = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    d.prototype.toString = function(S, C) {
      S = S || 10, C = C | 0 || 1;
      var R;
      if (S === 16 || S === "hex") {
        R = "";
        for (var H = 0, z = 0, U = 0; U < this.length; U++) {
          var P = this.words[U], W = ((P << H | z) & 16777215).toString(16);
          z = P >>> 24 - H & 16777215, H += 2, H >= 26 && (H -= 26, U--), z !== 0 || U !== this.length - 1 ? R = s[6 - W.length] + W + R : R = W + R;
        }
        for (z !== 0 && (R = z.toString(16) + R); R.length % C !== 0; )
          R = "0" + R;
        return this.negative !== 0 && (R = "-" + R), R;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var B = o[S], Q = y[S];
        R = "";
        var J = this.clone();
        for (J.negative = 0; !J.isZero(); ) {
          var re = J.modrn(Q).toString(S);
          J = J.idivn(Q), J.isZero() ? R = re + R : R = s[B - re.length] + re + R;
        }
        for (this.isZero() && (R = "0" + R); R.length % C !== 0; )
          R = "0" + R;
        return this.negative !== 0 && (R = "-" + R), R;
      }
      a(!1, "Base should be between 2 and 36");
    }, d.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, d.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, h && (d.prototype.toBuffer = function(S, C) {
      return this.toArrayLike(h, S, C);
    }), d.prototype.toArray = function(S, C) {
      return this.toArrayLike(Array, S, C);
    };
    var m = function(S, C) {
      return S.allocUnsafe ? S.allocUnsafe(C) : new S(C);
    };
    d.prototype.toArrayLike = function(S, C, R) {
      this._strip();
      var H = this.byteLength(), z = R || Math.max(1, H);
      a(H <= z, "byte array longer than desired length"), a(z > 0, "Requested array length <= 0");
      var U = m(S, z), P = C === "le" ? "LE" : "BE";
      return this["_toArrayLike" + P](U, H), U;
    }, d.prototype._toArrayLikeLE = function(S, C) {
      for (var R = 0, H = 0, z = 0, U = 0; z < this.length; z++) {
        var P = this.words[z] << U | H;
        S[R++] = P & 255, R < S.length && (S[R++] = P >> 8 & 255), R < S.length && (S[R++] = P >> 16 & 255), U === 6 ? (R < S.length && (S[R++] = P >> 24 & 255), H = 0, U = 0) : (H = P >>> 24, U += 2);
      }
      if (R < S.length)
        for (S[R++] = H; R < S.length; )
          S[R++] = 0;
    }, d.prototype._toArrayLikeBE = function(S, C) {
      for (var R = S.length - 1, H = 0, z = 0, U = 0; z < this.length; z++) {
        var P = this.words[z] << U | H;
        S[R--] = P & 255, R >= 0 && (S[R--] = P >> 8 & 255), R >= 0 && (S[R--] = P >> 16 & 255), U === 6 ? (R >= 0 && (S[R--] = P >> 24 & 255), H = 0, U = 0) : (H = P >>> 24, U += 2);
      }
      if (R >= 0)
        for (S[R--] = H; R >= 0; )
          S[R--] = 0;
    }, Math.clz32 ? d.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : d.prototype._countBits = function(S) {
      var C = S, R = 0;
      return C >= 4096 && (R += 13, C >>>= 13), C >= 64 && (R += 7, C >>>= 7), C >= 8 && (R += 4, C >>>= 4), C >= 2 && (R += 2, C >>>= 2), R + C;
    }, d.prototype._zeroBits = function(S) {
      if (S === 0) return 26;
      var C = S, R = 0;
      return C & 8191 || (R += 13, C >>>= 13), C & 127 || (R += 7, C >>>= 7), C & 15 || (R += 4, C >>>= 4), C & 3 || (R += 2, C >>>= 2), C & 1 || R++, R;
    }, d.prototype.bitLength = function() {
      var S = this.words[this.length - 1], C = this._countBits(S);
      return (this.length - 1) * 26 + C;
    };
    function g(_) {
      for (var S = new Array(_.bitLength()), C = 0; C < S.length; C++) {
        var R = C / 26 | 0, H = C % 26;
        S[C] = _.words[R] >>> H & 1;
      }
      return S;
    }
    d.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var S = 0, C = 0; C < this.length; C++) {
        var R = this._zeroBits(this.words[C]);
        if (S += R, R !== 26) break;
      }
      return S;
    }, d.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, d.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, d.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, d.prototype.isNeg = function() {
      return this.negative !== 0;
    }, d.prototype.neg = function() {
      return this.clone().ineg();
    }, d.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, d.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var C = 0; C < S.length; C++)
        this.words[C] = this.words[C] | S.words[C];
      return this._strip();
    }, d.prototype.ior = function(S) {
      return a((this.negative | S.negative) === 0), this.iuor(S);
    }, d.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, d.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, d.prototype.iuand = function(S) {
      var C;
      this.length > S.length ? C = S : C = this;
      for (var R = 0; R < C.length; R++)
        this.words[R] = this.words[R] & S.words[R];
      return this.length = C.length, this._strip();
    }, d.prototype.iand = function(S) {
      return a((this.negative | S.negative) === 0), this.iuand(S);
    }, d.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, d.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, d.prototype.iuxor = function(S) {
      var C, R;
      this.length > S.length ? (C = this, R = S) : (C = S, R = this);
      for (var H = 0; H < R.length; H++)
        this.words[H] = C.words[H] ^ R.words[H];
      if (this !== C)
        for (; H < C.length; H++)
          this.words[H] = C.words[H];
      return this.length = C.length, this._strip();
    }, d.prototype.ixor = function(S) {
      return a((this.negative | S.negative) === 0), this.iuxor(S);
    }, d.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, d.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, d.prototype.inotn = function(S) {
      a(typeof S == "number" && S >= 0);
      var C = Math.ceil(S / 26) | 0, R = S % 26;
      this._expand(C), R > 0 && C--;
      for (var H = 0; H < C; H++)
        this.words[H] = ~this.words[H] & 67108863;
      return R > 0 && (this.words[H] = ~this.words[H] & 67108863 >> 26 - R), this._strip();
    }, d.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, d.prototype.setn = function(S, C) {
      a(typeof S == "number" && S >= 0);
      var R = S / 26 | 0, H = S % 26;
      return this._expand(R + 1), C ? this.words[R] = this.words[R] | 1 << H : this.words[R] = this.words[R] & ~(1 << H), this._strip();
    }, d.prototype.iadd = function(S) {
      var C;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, C = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, C = this.isub(S), S.negative = 1, C._normSign();
      var R, H;
      this.length > S.length ? (R = this, H = S) : (R = S, H = this);
      for (var z = 0, U = 0; U < H.length; U++)
        C = (R.words[U] | 0) + (H.words[U] | 0) + z, this.words[U] = C & 67108863, z = C >>> 26;
      for (; z !== 0 && U < R.length; U++)
        C = (R.words[U] | 0) + z, this.words[U] = C & 67108863, z = C >>> 26;
      if (this.length = R.length, z !== 0)
        this.words[this.length] = z, this.length++;
      else if (R !== this)
        for (; U < R.length; U++)
          this.words[U] = R.words[U];
      return this;
    }, d.prototype.add = function(S) {
      var C;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, C = this.sub(S), S.negative ^= 1, C) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, C = S.sub(this), this.negative = 1, C) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, d.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var C = this.iadd(S);
        return S.negative = 1, C._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var R = this.cmp(S);
      if (R === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var H, z;
      R > 0 ? (H = this, z = S) : (H = S, z = this);
      for (var U = 0, P = 0; P < z.length; P++)
        C = (H.words[P] | 0) - (z.words[P] | 0) + U, U = C >> 26, this.words[P] = C & 67108863;
      for (; U !== 0 && P < H.length; P++)
        C = (H.words[P] | 0) + U, U = C >> 26, this.words[P] = C & 67108863;
      if (U === 0 && P < H.length && H !== this)
        for (; P < H.length; P++)
          this.words[P] = H.words[P];
      return this.length = Math.max(this.length, P), H !== this && (this.negative = 1), this._strip();
    }, d.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function b(_, S, C) {
      C.negative = S.negative ^ _.negative;
      var R = _.length + S.length | 0;
      C.length = R, R = R - 1 | 0;
      var H = _.words[0] | 0, z = S.words[0] | 0, U = H * z, P = U & 67108863, W = U / 67108864 | 0;
      C.words[0] = P;
      for (var B = 1; B < R; B++) {
        for (var Q = W >>> 26, J = W & 67108863, re = Math.min(B, S.length - 1), G = Math.max(0, B - _.length + 1); G <= re; G++) {
          var N = B - G | 0;
          H = _.words[N] | 0, z = S.words[G] | 0, U = H * z + J, Q += U / 67108864 | 0, J = U & 67108863;
        }
        C.words[B] = J | 0, W = Q | 0;
      }
      return W !== 0 ? C.words[B] = W | 0 : C.length--, C._strip();
    }
    var v = function(S, C, R) {
      var H = S.words, z = C.words, U = R.words, P = 0, W, B, Q, J = H[0] | 0, re = J & 8191, G = J >>> 13, N = H[1] | 0, V = N & 8191, F = N >>> 13, X = H[2] | 0, K = X & 8191, ie = X >>> 13, fe = H[3] | 0, _e = fe & 8191, Ae = fe >>> 13, ce = H[4] | 0, ee = ce & 8191, ae = ce >>> 13, oe = H[5] | 0, me = oe & 8191, ye = oe >>> 13, we = H[6] | 0, ge = we & 8191, se = we >>> 13, be = H[7] | 0, Ie = be & 8191, Oe = be >>> 13, Be = H[8] | 0, Fe = Be & 8191, ue = Be >>> 13, te = H[9] | 0, Y = te & 8191, le = te >>> 13, Ee = z[0] | 0, Se = Ee & 8191, Pe = Ee >>> 13, Ve = z[1] | 0, Xe = Ve & 8191, Ye = Ve >>> 13, We = z[2] | 0, et = We & 8191, De = We >>> 13, Me = z[3] | 0, Qe = Me & 8191, He = Me >>> 13, st = z[4] | 0, it = st & 8191, qe = st >>> 13, rt = z[5] | 0, bt = rt & 8191, dt = rt >>> 13, Je = z[6] | 0, mt = Je & 8191, ut = Je >>> 13, Et = z[7] | 0, Tt = Et & 8191, St = Et >>> 13, Vt = z[8] | 0, Kt = Vt & 8191, xt = Vt >>> 13, Jt = z[9] | 0, Mt = Jt & 8191, Bt = Jt >>> 13;
      R.negative = S.negative ^ C.negative, R.length = 19, W = Math.imul(re, Se), B = Math.imul(re, Pe), B = B + Math.imul(G, Se) | 0, Q = Math.imul(G, Pe);
      var It = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, W = Math.imul(V, Se), B = Math.imul(V, Pe), B = B + Math.imul(F, Se) | 0, Q = Math.imul(F, Pe), W = W + Math.imul(re, Xe) | 0, B = B + Math.imul(re, Ye) | 0, B = B + Math.imul(G, Xe) | 0, Q = Q + Math.imul(G, Ye) | 0;
      var jr = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, W = Math.imul(K, Se), B = Math.imul(K, Pe), B = B + Math.imul(ie, Se) | 0, Q = Math.imul(ie, Pe), W = W + Math.imul(V, Xe) | 0, B = B + Math.imul(V, Ye) | 0, B = B + Math.imul(F, Xe) | 0, Q = Q + Math.imul(F, Ye) | 0, W = W + Math.imul(re, et) | 0, B = B + Math.imul(re, De) | 0, B = B + Math.imul(G, et) | 0, Q = Q + Math.imul(G, De) | 0;
      var Cn = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, W = Math.imul(_e, Se), B = Math.imul(_e, Pe), B = B + Math.imul(Ae, Se) | 0, Q = Math.imul(Ae, Pe), W = W + Math.imul(K, Xe) | 0, B = B + Math.imul(K, Ye) | 0, B = B + Math.imul(ie, Xe) | 0, Q = Q + Math.imul(ie, Ye) | 0, W = W + Math.imul(V, et) | 0, B = B + Math.imul(V, De) | 0, B = B + Math.imul(F, et) | 0, Q = Q + Math.imul(F, De) | 0, W = W + Math.imul(re, Qe) | 0, B = B + Math.imul(re, He) | 0, B = B + Math.imul(G, Qe) | 0, Q = Q + Math.imul(G, He) | 0;
      var an = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, W = Math.imul(ee, Se), B = Math.imul(ee, Pe), B = B + Math.imul(ae, Se) | 0, Q = Math.imul(ae, Pe), W = W + Math.imul(_e, Xe) | 0, B = B + Math.imul(_e, Ye) | 0, B = B + Math.imul(Ae, Xe) | 0, Q = Q + Math.imul(Ae, Ye) | 0, W = W + Math.imul(K, et) | 0, B = B + Math.imul(K, De) | 0, B = B + Math.imul(ie, et) | 0, Q = Q + Math.imul(ie, De) | 0, W = W + Math.imul(V, Qe) | 0, B = B + Math.imul(V, He) | 0, B = B + Math.imul(F, Qe) | 0, Q = Q + Math.imul(F, He) | 0, W = W + Math.imul(re, it) | 0, B = B + Math.imul(re, qe) | 0, B = B + Math.imul(G, it) | 0, Q = Q + Math.imul(G, qe) | 0;
      var Fr = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, W = Math.imul(me, Se), B = Math.imul(me, Pe), B = B + Math.imul(ye, Se) | 0, Q = Math.imul(ye, Pe), W = W + Math.imul(ee, Xe) | 0, B = B + Math.imul(ee, Ye) | 0, B = B + Math.imul(ae, Xe) | 0, Q = Q + Math.imul(ae, Ye) | 0, W = W + Math.imul(_e, et) | 0, B = B + Math.imul(_e, De) | 0, B = B + Math.imul(Ae, et) | 0, Q = Q + Math.imul(Ae, De) | 0, W = W + Math.imul(K, Qe) | 0, B = B + Math.imul(K, He) | 0, B = B + Math.imul(ie, Qe) | 0, Q = Q + Math.imul(ie, He) | 0, W = W + Math.imul(V, it) | 0, B = B + Math.imul(V, qe) | 0, B = B + Math.imul(F, it) | 0, Q = Q + Math.imul(F, qe) | 0, W = W + Math.imul(re, bt) | 0, B = B + Math.imul(re, dt) | 0, B = B + Math.imul(G, bt) | 0, Q = Q + Math.imul(G, dt) | 0;
      var En = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, W = Math.imul(ge, Se), B = Math.imul(ge, Pe), B = B + Math.imul(se, Se) | 0, Q = Math.imul(se, Pe), W = W + Math.imul(me, Xe) | 0, B = B + Math.imul(me, Ye) | 0, B = B + Math.imul(ye, Xe) | 0, Q = Q + Math.imul(ye, Ye) | 0, W = W + Math.imul(ee, et) | 0, B = B + Math.imul(ee, De) | 0, B = B + Math.imul(ae, et) | 0, Q = Q + Math.imul(ae, De) | 0, W = W + Math.imul(_e, Qe) | 0, B = B + Math.imul(_e, He) | 0, B = B + Math.imul(Ae, Qe) | 0, Q = Q + Math.imul(Ae, He) | 0, W = W + Math.imul(K, it) | 0, B = B + Math.imul(K, qe) | 0, B = B + Math.imul(ie, it) | 0, Q = Q + Math.imul(ie, qe) | 0, W = W + Math.imul(V, bt) | 0, B = B + Math.imul(V, dt) | 0, B = B + Math.imul(F, bt) | 0, Q = Q + Math.imul(F, dt) | 0, W = W + Math.imul(re, mt) | 0, B = B + Math.imul(re, ut) | 0, B = B + Math.imul(G, mt) | 0, Q = Q + Math.imul(G, ut) | 0;
      var dn = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, W = Math.imul(Ie, Se), B = Math.imul(Ie, Pe), B = B + Math.imul(Oe, Se) | 0, Q = Math.imul(Oe, Pe), W = W + Math.imul(ge, Xe) | 0, B = B + Math.imul(ge, Ye) | 0, B = B + Math.imul(se, Xe) | 0, Q = Q + Math.imul(se, Ye) | 0, W = W + Math.imul(me, et) | 0, B = B + Math.imul(me, De) | 0, B = B + Math.imul(ye, et) | 0, Q = Q + Math.imul(ye, De) | 0, W = W + Math.imul(ee, Qe) | 0, B = B + Math.imul(ee, He) | 0, B = B + Math.imul(ae, Qe) | 0, Q = Q + Math.imul(ae, He) | 0, W = W + Math.imul(_e, it) | 0, B = B + Math.imul(_e, qe) | 0, B = B + Math.imul(Ae, it) | 0, Q = Q + Math.imul(Ae, qe) | 0, W = W + Math.imul(K, bt) | 0, B = B + Math.imul(K, dt) | 0, B = B + Math.imul(ie, bt) | 0, Q = Q + Math.imul(ie, dt) | 0, W = W + Math.imul(V, mt) | 0, B = B + Math.imul(V, ut) | 0, B = B + Math.imul(F, mt) | 0, Q = Q + Math.imul(F, ut) | 0, W = W + Math.imul(re, Tt) | 0, B = B + Math.imul(re, St) | 0, B = B + Math.imul(G, Tt) | 0, Q = Q + Math.imul(G, St) | 0;
      var on = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, W = Math.imul(Fe, Se), B = Math.imul(Fe, Pe), B = B + Math.imul(ue, Se) | 0, Q = Math.imul(ue, Pe), W = W + Math.imul(Ie, Xe) | 0, B = B + Math.imul(Ie, Ye) | 0, B = B + Math.imul(Oe, Xe) | 0, Q = Q + Math.imul(Oe, Ye) | 0, W = W + Math.imul(ge, et) | 0, B = B + Math.imul(ge, De) | 0, B = B + Math.imul(se, et) | 0, Q = Q + Math.imul(se, De) | 0, W = W + Math.imul(me, Qe) | 0, B = B + Math.imul(me, He) | 0, B = B + Math.imul(ye, Qe) | 0, Q = Q + Math.imul(ye, He) | 0, W = W + Math.imul(ee, it) | 0, B = B + Math.imul(ee, qe) | 0, B = B + Math.imul(ae, it) | 0, Q = Q + Math.imul(ae, qe) | 0, W = W + Math.imul(_e, bt) | 0, B = B + Math.imul(_e, dt) | 0, B = B + Math.imul(Ae, bt) | 0, Q = Q + Math.imul(Ae, dt) | 0, W = W + Math.imul(K, mt) | 0, B = B + Math.imul(K, ut) | 0, B = B + Math.imul(ie, mt) | 0, Q = Q + Math.imul(ie, ut) | 0, W = W + Math.imul(V, Tt) | 0, B = B + Math.imul(V, St) | 0, B = B + Math.imul(F, Tt) | 0, Q = Q + Math.imul(F, St) | 0, W = W + Math.imul(re, Kt) | 0, B = B + Math.imul(re, xt) | 0, B = B + Math.imul(G, Kt) | 0, Q = Q + Math.imul(G, xt) | 0;
      var vr = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, W = Math.imul(Y, Se), B = Math.imul(Y, Pe), B = B + Math.imul(le, Se) | 0, Q = Math.imul(le, Pe), W = W + Math.imul(Fe, Xe) | 0, B = B + Math.imul(Fe, Ye) | 0, B = B + Math.imul(ue, Xe) | 0, Q = Q + Math.imul(ue, Ye) | 0, W = W + Math.imul(Ie, et) | 0, B = B + Math.imul(Ie, De) | 0, B = B + Math.imul(Oe, et) | 0, Q = Q + Math.imul(Oe, De) | 0, W = W + Math.imul(ge, Qe) | 0, B = B + Math.imul(ge, He) | 0, B = B + Math.imul(se, Qe) | 0, Q = Q + Math.imul(se, He) | 0, W = W + Math.imul(me, it) | 0, B = B + Math.imul(me, qe) | 0, B = B + Math.imul(ye, it) | 0, Q = Q + Math.imul(ye, qe) | 0, W = W + Math.imul(ee, bt) | 0, B = B + Math.imul(ee, dt) | 0, B = B + Math.imul(ae, bt) | 0, Q = Q + Math.imul(ae, dt) | 0, W = W + Math.imul(_e, mt) | 0, B = B + Math.imul(_e, ut) | 0, B = B + Math.imul(Ae, mt) | 0, Q = Q + Math.imul(Ae, ut) | 0, W = W + Math.imul(K, Tt) | 0, B = B + Math.imul(K, St) | 0, B = B + Math.imul(ie, Tt) | 0, Q = Q + Math.imul(ie, St) | 0, W = W + Math.imul(V, Kt) | 0, B = B + Math.imul(V, xt) | 0, B = B + Math.imul(F, Kt) | 0, Q = Q + Math.imul(F, xt) | 0, W = W + Math.imul(re, Mt) | 0, B = B + Math.imul(re, Bt) | 0, B = B + Math.imul(G, Mt) | 0, Q = Q + Math.imul(G, Bt) | 0;
      var Vn = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863, W = Math.imul(Y, Xe), B = Math.imul(Y, Ye), B = B + Math.imul(le, Xe) | 0, Q = Math.imul(le, Ye), W = W + Math.imul(Fe, et) | 0, B = B + Math.imul(Fe, De) | 0, B = B + Math.imul(ue, et) | 0, Q = Q + Math.imul(ue, De) | 0, W = W + Math.imul(Ie, Qe) | 0, B = B + Math.imul(Ie, He) | 0, B = B + Math.imul(Oe, Qe) | 0, Q = Q + Math.imul(Oe, He) | 0, W = W + Math.imul(ge, it) | 0, B = B + Math.imul(ge, qe) | 0, B = B + Math.imul(se, it) | 0, Q = Q + Math.imul(se, qe) | 0, W = W + Math.imul(me, bt) | 0, B = B + Math.imul(me, dt) | 0, B = B + Math.imul(ye, bt) | 0, Q = Q + Math.imul(ye, dt) | 0, W = W + Math.imul(ee, mt) | 0, B = B + Math.imul(ee, ut) | 0, B = B + Math.imul(ae, mt) | 0, Q = Q + Math.imul(ae, ut) | 0, W = W + Math.imul(_e, Tt) | 0, B = B + Math.imul(_e, St) | 0, B = B + Math.imul(Ae, Tt) | 0, Q = Q + Math.imul(Ae, St) | 0, W = W + Math.imul(K, Kt) | 0, B = B + Math.imul(K, xt) | 0, B = B + Math.imul(ie, Kt) | 0, Q = Q + Math.imul(ie, xt) | 0, W = W + Math.imul(V, Mt) | 0, B = B + Math.imul(V, Bt) | 0, B = B + Math.imul(F, Mt) | 0, Q = Q + Math.imul(F, Bt) | 0;
      var Cr = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, W = Math.imul(Y, et), B = Math.imul(Y, De), B = B + Math.imul(le, et) | 0, Q = Math.imul(le, De), W = W + Math.imul(Fe, Qe) | 0, B = B + Math.imul(Fe, He) | 0, B = B + Math.imul(ue, Qe) | 0, Q = Q + Math.imul(ue, He) | 0, W = W + Math.imul(Ie, it) | 0, B = B + Math.imul(Ie, qe) | 0, B = B + Math.imul(Oe, it) | 0, Q = Q + Math.imul(Oe, qe) | 0, W = W + Math.imul(ge, bt) | 0, B = B + Math.imul(ge, dt) | 0, B = B + Math.imul(se, bt) | 0, Q = Q + Math.imul(se, dt) | 0, W = W + Math.imul(me, mt) | 0, B = B + Math.imul(me, ut) | 0, B = B + Math.imul(ye, mt) | 0, Q = Q + Math.imul(ye, ut) | 0, W = W + Math.imul(ee, Tt) | 0, B = B + Math.imul(ee, St) | 0, B = B + Math.imul(ae, Tt) | 0, Q = Q + Math.imul(ae, St) | 0, W = W + Math.imul(_e, Kt) | 0, B = B + Math.imul(_e, xt) | 0, B = B + Math.imul(Ae, Kt) | 0, Q = Q + Math.imul(Ae, xt) | 0, W = W + Math.imul(K, Mt) | 0, B = B + Math.imul(K, Bt) | 0, B = B + Math.imul(ie, Mt) | 0, Q = Q + Math.imul(ie, Bt) | 0;
      var br = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, W = Math.imul(Y, Qe), B = Math.imul(Y, He), B = B + Math.imul(le, Qe) | 0, Q = Math.imul(le, He), W = W + Math.imul(Fe, it) | 0, B = B + Math.imul(Fe, qe) | 0, B = B + Math.imul(ue, it) | 0, Q = Q + Math.imul(ue, qe) | 0, W = W + Math.imul(Ie, bt) | 0, B = B + Math.imul(Ie, dt) | 0, B = B + Math.imul(Oe, bt) | 0, Q = Q + Math.imul(Oe, dt) | 0, W = W + Math.imul(ge, mt) | 0, B = B + Math.imul(ge, ut) | 0, B = B + Math.imul(se, mt) | 0, Q = Q + Math.imul(se, ut) | 0, W = W + Math.imul(me, Tt) | 0, B = B + Math.imul(me, St) | 0, B = B + Math.imul(ye, Tt) | 0, Q = Q + Math.imul(ye, St) | 0, W = W + Math.imul(ee, Kt) | 0, B = B + Math.imul(ee, xt) | 0, B = B + Math.imul(ae, Kt) | 0, Q = Q + Math.imul(ae, xt) | 0, W = W + Math.imul(_e, Mt) | 0, B = B + Math.imul(_e, Bt) | 0, B = B + Math.imul(Ae, Mt) | 0, Q = Q + Math.imul(Ae, Bt) | 0;
      var _n = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, W = Math.imul(Y, it), B = Math.imul(Y, qe), B = B + Math.imul(le, it) | 0, Q = Math.imul(le, qe), W = W + Math.imul(Fe, bt) | 0, B = B + Math.imul(Fe, dt) | 0, B = B + Math.imul(ue, bt) | 0, Q = Q + Math.imul(ue, dt) | 0, W = W + Math.imul(Ie, mt) | 0, B = B + Math.imul(Ie, ut) | 0, B = B + Math.imul(Oe, mt) | 0, Q = Q + Math.imul(Oe, ut) | 0, W = W + Math.imul(ge, Tt) | 0, B = B + Math.imul(ge, St) | 0, B = B + Math.imul(se, Tt) | 0, Q = Q + Math.imul(se, St) | 0, W = W + Math.imul(me, Kt) | 0, B = B + Math.imul(me, xt) | 0, B = B + Math.imul(ye, Kt) | 0, Q = Q + Math.imul(ye, xt) | 0, W = W + Math.imul(ee, Mt) | 0, B = B + Math.imul(ee, Bt) | 0, B = B + Math.imul(ae, Mt) | 0, Q = Q + Math.imul(ae, Bt) | 0;
      var In = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, W = Math.imul(Y, bt), B = Math.imul(Y, dt), B = B + Math.imul(le, bt) | 0, Q = Math.imul(le, dt), W = W + Math.imul(Fe, mt) | 0, B = B + Math.imul(Fe, ut) | 0, B = B + Math.imul(ue, mt) | 0, Q = Q + Math.imul(ue, ut) | 0, W = W + Math.imul(Ie, Tt) | 0, B = B + Math.imul(Ie, St) | 0, B = B + Math.imul(Oe, Tt) | 0, Q = Q + Math.imul(Oe, St) | 0, W = W + Math.imul(ge, Kt) | 0, B = B + Math.imul(ge, xt) | 0, B = B + Math.imul(se, Kt) | 0, Q = Q + Math.imul(se, xt) | 0, W = W + Math.imul(me, Mt) | 0, B = B + Math.imul(me, Bt) | 0, B = B + Math.imul(ye, Mt) | 0, Q = Q + Math.imul(ye, Bt) | 0;
      var pn = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, W = Math.imul(Y, mt), B = Math.imul(Y, ut), B = B + Math.imul(le, mt) | 0, Q = Math.imul(le, ut), W = W + Math.imul(Fe, Tt) | 0, B = B + Math.imul(Fe, St) | 0, B = B + Math.imul(ue, Tt) | 0, Q = Q + Math.imul(ue, St) | 0, W = W + Math.imul(Ie, Kt) | 0, B = B + Math.imul(Ie, xt) | 0, B = B + Math.imul(Oe, Kt) | 0, Q = Q + Math.imul(Oe, xt) | 0, W = W + Math.imul(ge, Mt) | 0, B = B + Math.imul(ge, Bt) | 0, B = B + Math.imul(se, Mt) | 0, Q = Q + Math.imul(se, Bt) | 0;
      var Dr = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, W = Math.imul(Y, Tt), B = Math.imul(Y, St), B = B + Math.imul(le, Tt) | 0, Q = Math.imul(le, St), W = W + Math.imul(Fe, Kt) | 0, B = B + Math.imul(Fe, xt) | 0, B = B + Math.imul(ue, Kt) | 0, Q = Q + Math.imul(ue, xt) | 0, W = W + Math.imul(Ie, Mt) | 0, B = B + Math.imul(Ie, Bt) | 0, B = B + Math.imul(Oe, Mt) | 0, Q = Q + Math.imul(Oe, Bt) | 0;
      var Wn = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (Wn >>> 26) | 0, Wn &= 67108863, W = Math.imul(Y, Kt), B = Math.imul(Y, xt), B = B + Math.imul(le, Kt) | 0, Q = Math.imul(le, xt), W = W + Math.imul(Fe, Mt) | 0, B = B + Math.imul(Fe, Bt) | 0, B = B + Math.imul(ue, Mt) | 0, Q = Q + Math.imul(ue, Bt) | 0;
      var yi = (P + W | 0) + ((B & 8191) << 13) | 0;
      P = (Q + (B >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, W = Math.imul(Y, Mt), B = Math.imul(Y, Bt), B = B + Math.imul(le, Mt) | 0, Q = Math.imul(le, Bt);
      var ri = (P + W | 0) + ((B & 8191) << 13) | 0;
      return P = (Q + (B >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, U[0] = It, U[1] = jr, U[2] = Cn, U[3] = an, U[4] = Fr, U[5] = En, U[6] = dn, U[7] = on, U[8] = vr, U[9] = Vn, U[10] = Cr, U[11] = br, U[12] = _n, U[13] = In, U[14] = pn, U[15] = Dr, U[16] = Wn, U[17] = yi, U[18] = ri, P !== 0 && (U[19] = P, R.length++), R;
    };
    Math.imul || (v = b);
    function T(_, S, C) {
      C.negative = S.negative ^ _.negative, C.length = _.length + S.length;
      for (var R = 0, H = 0, z = 0; z < C.length - 1; z++) {
        var U = H;
        H = 0;
        for (var P = R & 67108863, W = Math.min(z, S.length - 1), B = Math.max(0, z - _.length + 1); B <= W; B++) {
          var Q = z - B, J = _.words[Q] | 0, re = S.words[B] | 0, G = J * re, N = G & 67108863;
          U = U + (G / 67108864 | 0) | 0, N = N + P | 0, P = N & 67108863, U = U + (N >>> 26) | 0, H += U >>> 26, U &= 67108863;
        }
        C.words[z] = P, R = U, U = H;
      }
      return R !== 0 ? C.words[z] = R : C.length--, C._strip();
    }
    function E(_, S, C) {
      return T(_, S, C);
    }
    d.prototype.mulTo = function(S, C) {
      var R, H = this.length + S.length;
      return this.length === 10 && S.length === 10 ? R = v(this, S, C) : H < 63 ? R = b(this, S, C) : H < 1024 ? R = T(this, S, C) : R = E(this, S, C), R;
    }, d.prototype.mul = function(S) {
      var C = new d(null);
      return C.words = new Array(this.length + S.length), this.mulTo(S, C);
    }, d.prototype.mulf = function(S) {
      var C = new d(null);
      return C.words = new Array(this.length + S.length), E(this, S, C);
    }, d.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, d.prototype.imuln = function(S) {
      var C = S < 0;
      C && (S = -S), a(typeof S == "number"), a(S < 67108864);
      for (var R = 0, H = 0; H < this.length; H++) {
        var z = (this.words[H] | 0) * S, U = (z & 67108863) + (R & 67108863);
        R >>= 26, R += z / 67108864 | 0, R += U >>> 26, this.words[H] = U & 67108863;
      }
      return R !== 0 && (this.words[H] = R, this.length++), C ? this.ineg() : this;
    }, d.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, d.prototype.sqr = function() {
      return this.mul(this);
    }, d.prototype.isqr = function() {
      return this.imul(this.clone());
    }, d.prototype.pow = function(S) {
      var C = g(S);
      if (C.length === 0) return new d(1);
      for (var R = this, H = 0; H < C.length && C[H] === 0; H++, R = R.sqr())
        ;
      if (++H < C.length)
        for (var z = R.sqr(); H < C.length; H++, z = z.sqr())
          C[H] !== 0 && (R = R.mul(z));
      return R;
    }, d.prototype.iushln = function(S) {
      a(typeof S == "number" && S >= 0);
      var C = S % 26, R = (S - C) / 26, H = 67108863 >>> 26 - C << 26 - C, z;
      if (C !== 0) {
        var U = 0;
        for (z = 0; z < this.length; z++) {
          var P = this.words[z] & H, W = (this.words[z] | 0) - P << C;
          this.words[z] = W | U, U = P >>> 26 - C;
        }
        U && (this.words[z] = U, this.length++);
      }
      if (R !== 0) {
        for (z = this.length - 1; z >= 0; z--)
          this.words[z + R] = this.words[z];
        for (z = 0; z < R; z++)
          this.words[z] = 0;
        this.length += R;
      }
      return this._strip();
    }, d.prototype.ishln = function(S) {
      return a(this.negative === 0), this.iushln(S);
    }, d.prototype.iushrn = function(S, C, R) {
      a(typeof S == "number" && S >= 0);
      var H;
      C ? H = (C - C % 26) / 26 : H = 0;
      var z = S % 26, U = Math.min((S - z) / 26, this.length), P = 67108863 ^ 67108863 >>> z << z, W = R;
      if (H -= U, H = Math.max(0, H), W) {
        for (var B = 0; B < U; B++)
          W.words[B] = this.words[B];
        W.length = U;
      }
      if (U !== 0) if (this.length > U)
        for (this.length -= U, B = 0; B < this.length; B++)
          this.words[B] = this.words[B + U];
      else
        this.words[0] = 0, this.length = 1;
      var Q = 0;
      for (B = this.length - 1; B >= 0 && (Q !== 0 || B >= H); B--) {
        var J = this.words[B] | 0;
        this.words[B] = Q << 26 - z | J >>> z, Q = J & P;
      }
      return W && Q !== 0 && (W.words[W.length++] = Q), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, d.prototype.ishrn = function(S, C, R) {
      return a(this.negative === 0), this.iushrn(S, C, R);
    }, d.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, d.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, d.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, d.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, d.prototype.testn = function(S) {
      a(typeof S == "number" && S >= 0);
      var C = S % 26, R = (S - C) / 26, H = 1 << C;
      if (this.length <= R) return !1;
      var z = this.words[R];
      return !!(z & H);
    }, d.prototype.imaskn = function(S) {
      a(typeof S == "number" && S >= 0);
      var C = S % 26, R = (S - C) / 26;
      if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= R)
        return this;
      if (C !== 0 && R++, this.length = Math.min(R, this.length), C !== 0) {
        var H = 67108863 ^ 67108863 >>> C << C;
        this.words[this.length - 1] &= H;
      }
      return this._strip();
    }, d.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, d.prototype.iaddn = function(S) {
      return a(typeof S == "number"), a(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, d.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var C = 0; C < this.length && this.words[C] >= 67108864; C++)
        this.words[C] -= 67108864, C === this.length - 1 ? this.words[C + 1] = 1 : this.words[C + 1]++;
      return this.length = Math.max(this.length, C + 1), this;
    }, d.prototype.isubn = function(S) {
      if (a(typeof S == "number"), a(S < 67108864), S < 0) return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var C = 0; C < this.length && this.words[C] < 0; C++)
          this.words[C] += 67108864, this.words[C + 1] -= 1;
      return this._strip();
    }, d.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, d.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, d.prototype.iabs = function() {
      return this.negative = 0, this;
    }, d.prototype.abs = function() {
      return this.clone().iabs();
    }, d.prototype._ishlnsubmul = function(S, C, R) {
      var H = S.length + R, z;
      this._expand(H);
      var U, P = 0;
      for (z = 0; z < S.length; z++) {
        U = (this.words[z + R] | 0) + P;
        var W = (S.words[z] | 0) * C;
        U -= W & 67108863, P = (U >> 26) - (W / 67108864 | 0), this.words[z + R] = U & 67108863;
      }
      for (; z < this.length - R; z++)
        U = (this.words[z + R] | 0) + P, P = U >> 26, this.words[z + R] = U & 67108863;
      if (P === 0) return this._strip();
      for (a(P === -1), P = 0, z = 0; z < this.length; z++)
        U = -(this.words[z] | 0) + P, P = U >> 26, this.words[z] = U & 67108863;
      return this.negative = 1, this._strip();
    }, d.prototype._wordDiv = function(S, C) {
      var R = this.length - S.length, H = this.clone(), z = S, U = z.words[z.length - 1] | 0, P = this._countBits(U);
      R = 26 - P, R !== 0 && (z = z.ushln(R), H.iushln(R), U = z.words[z.length - 1] | 0);
      var W = H.length - z.length, B;
      if (C !== "mod") {
        B = new d(null), B.length = W + 1, B.words = new Array(B.length);
        for (var Q = 0; Q < B.length; Q++)
          B.words[Q] = 0;
      }
      var J = H.clone()._ishlnsubmul(z, 1, W);
      J.negative === 0 && (H = J, B && (B.words[W] = 1));
      for (var re = W - 1; re >= 0; re--) {
        var G = (H.words[z.length + re] | 0) * 67108864 + (H.words[z.length + re - 1] | 0);
        for (G = Math.min(G / U | 0, 67108863), H._ishlnsubmul(z, G, re); H.negative !== 0; )
          G--, H.negative = 0, H._ishlnsubmul(z, 1, re), H.isZero() || (H.negative ^= 1);
        B && (B.words[re] = G);
      }
      return B && B._strip(), H._strip(), C !== "div" && R !== 0 && H.iushrn(R), {
        div: B || null,
        mod: H
      };
    }, d.prototype.divmod = function(S, C, R) {
      if (a(!S.isZero()), this.isZero())
        return {
          div: new d(0),
          mod: new d(0)
        };
      var H, z, U;
      return this.negative !== 0 && S.negative === 0 ? (U = this.neg().divmod(S, C), C !== "mod" && (H = U.div.neg()), C !== "div" && (z = U.mod.neg(), R && z.negative !== 0 && z.iadd(S)), {
        div: H,
        mod: z
      }) : this.negative === 0 && S.negative !== 0 ? (U = this.divmod(S.neg(), C), C !== "mod" && (H = U.div.neg()), {
        div: H,
        mod: U.mod
      }) : this.negative & S.negative ? (U = this.neg().divmod(S.neg(), C), C !== "div" && (z = U.mod.neg(), R && z.negative !== 0 && z.isub(S)), {
        div: U.div,
        mod: z
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new d(0),
        mod: this
      } : S.length === 1 ? C === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : C === "mod" ? {
        div: null,
        mod: new d(this.modrn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new d(this.modrn(S.words[0]))
      } : this._wordDiv(S, C);
    }, d.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, d.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, d.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, d.prototype.divRound = function(S) {
      var C = this.divmod(S);
      if (C.mod.isZero()) return C.div;
      var R = C.div.negative !== 0 ? C.mod.isub(S) : C.mod, H = S.ushrn(1), z = S.andln(1), U = R.cmp(H);
      return U < 0 || z === 1 && U === 0 ? C.div : C.div.negative !== 0 ? C.div.isubn(1) : C.div.iaddn(1);
    }, d.prototype.modrn = function(S) {
      var C = S < 0;
      C && (S = -S), a(S <= 67108863);
      for (var R = (1 << 26) % S, H = 0, z = this.length - 1; z >= 0; z--)
        H = (R * H + (this.words[z] | 0)) % S;
      return C ? -H : H;
    }, d.prototype.modn = function(S) {
      return this.modrn(S);
    }, d.prototype.idivn = function(S) {
      var C = S < 0;
      C && (S = -S), a(S <= 67108863);
      for (var R = 0, H = this.length - 1; H >= 0; H--) {
        var z = (this.words[H] | 0) + R * 67108864;
        this.words[H] = z / S | 0, R = z % S;
      }
      return this._strip(), C ? this.ineg() : this;
    }, d.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, d.prototype.egcd = function(S) {
      a(S.negative === 0), a(!S.isZero());
      var C = this, R = S.clone();
      C.negative !== 0 ? C = C.umod(S) : C = C.clone();
      for (var H = new d(1), z = new d(0), U = new d(0), P = new d(1), W = 0; C.isEven() && R.isEven(); )
        C.iushrn(1), R.iushrn(1), ++W;
      for (var B = R.clone(), Q = C.clone(); !C.isZero(); ) {
        for (var J = 0, re = 1; !(C.words[0] & re) && J < 26; ++J, re <<= 1) ;
        if (J > 0)
          for (C.iushrn(J); J-- > 0; )
            (H.isOdd() || z.isOdd()) && (H.iadd(B), z.isub(Q)), H.iushrn(1), z.iushrn(1);
        for (var G = 0, N = 1; !(R.words[0] & N) && G < 26; ++G, N <<= 1) ;
        if (G > 0)
          for (R.iushrn(G); G-- > 0; )
            (U.isOdd() || P.isOdd()) && (U.iadd(B), P.isub(Q)), U.iushrn(1), P.iushrn(1);
        C.cmp(R) >= 0 ? (C.isub(R), H.isub(U), z.isub(P)) : (R.isub(C), U.isub(H), P.isub(z));
      }
      return {
        a: U,
        b: P,
        gcd: R.iushln(W)
      };
    }, d.prototype._invmp = function(S) {
      a(S.negative === 0), a(!S.isZero());
      var C = this, R = S.clone();
      C.negative !== 0 ? C = C.umod(S) : C = C.clone();
      for (var H = new d(1), z = new d(0), U = R.clone(); C.cmpn(1) > 0 && R.cmpn(1) > 0; ) {
        for (var P = 0, W = 1; !(C.words[0] & W) && P < 26; ++P, W <<= 1) ;
        if (P > 0)
          for (C.iushrn(P); P-- > 0; )
            H.isOdd() && H.iadd(U), H.iushrn(1);
        for (var B = 0, Q = 1; !(R.words[0] & Q) && B < 26; ++B, Q <<= 1) ;
        if (B > 0)
          for (R.iushrn(B); B-- > 0; )
            z.isOdd() && z.iadd(U), z.iushrn(1);
        C.cmp(R) >= 0 ? (C.isub(R), H.isub(z)) : (R.isub(C), z.isub(H));
      }
      var J;
      return C.cmpn(1) === 0 ? J = H : J = z, J.cmpn(0) < 0 && J.iadd(S), J;
    }, d.prototype.gcd = function(S) {
      if (this.isZero()) return S.abs();
      if (S.isZero()) return this.abs();
      var C = this.clone(), R = S.clone();
      C.negative = 0, R.negative = 0;
      for (var H = 0; C.isEven() && R.isEven(); H++)
        C.iushrn(1), R.iushrn(1);
      do {
        for (; C.isEven(); )
          C.iushrn(1);
        for (; R.isEven(); )
          R.iushrn(1);
        var z = C.cmp(R);
        if (z < 0) {
          var U = C;
          C = R, R = U;
        } else if (z === 0 || R.cmpn(1) === 0)
          break;
        C.isub(R);
      } while (!0);
      return R.iushln(H);
    }, d.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, d.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, d.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, d.prototype.andln = function(S) {
      return this.words[0] & S;
    }, d.prototype.bincn = function(S) {
      a(typeof S == "number");
      var C = S % 26, R = (S - C) / 26, H = 1 << C;
      if (this.length <= R)
        return this._expand(R + 1), this.words[R] |= H, this;
      for (var z = H, U = R; z !== 0 && U < this.length; U++) {
        var P = this.words[U] | 0;
        P += z, z = P >>> 26, P &= 67108863, this.words[U] = P;
      }
      return z !== 0 && (this.words[U] = z, this.length++), this;
    }, d.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, d.prototype.cmpn = function(S) {
      var C = S < 0;
      if (this.negative !== 0 && !C) return -1;
      if (this.negative === 0 && C) return 1;
      this._strip();
      var R;
      if (this.length > 1)
        R = 1;
      else {
        C && (S = -S), a(S <= 67108863, "Number is too big");
        var H = this.words[0] | 0;
        R = H === S ? 0 : H < S ? -1 : 1;
      }
      return this.negative !== 0 ? -R | 0 : R;
    }, d.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0) return -1;
      if (this.negative === 0 && S.negative !== 0) return 1;
      var C = this.ucmp(S);
      return this.negative !== 0 ? -C | 0 : C;
    }, d.prototype.ucmp = function(S) {
      if (this.length > S.length) return 1;
      if (this.length < S.length) return -1;
      for (var C = 0, R = this.length - 1; R >= 0; R--) {
        var H = this.words[R] | 0, z = S.words[R] | 0;
        if (H !== z) {
          H < z ? C = -1 : H > z && (C = 1);
          break;
        }
      }
      return C;
    }, d.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, d.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, d.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, d.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, d.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, d.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, d.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, d.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, d.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, d.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, d.red = function(S) {
      return new M(S);
    }, d.prototype.toRed = function(S) {
      return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, d.prototype.fromRed = function() {
      return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, d.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, d.prototype.forceRed = function(S) {
      return a(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, d.prototype.redAdd = function(S) {
      return a(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, d.prototype.redIAdd = function(S) {
      return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, d.prototype.redSub = function(S) {
      return a(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, d.prototype.redISub = function(S) {
      return a(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, d.prototype.redShl = function(S) {
      return a(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, d.prototype.redMul = function(S) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, d.prototype.redIMul = function(S) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, d.prototype.redSqr = function() {
      return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, d.prototype.redISqr = function() {
      return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, d.prototype.redSqrt = function() {
      return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, d.prototype.redInvm = function() {
      return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, d.prototype.redNeg = function() {
      return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, d.prototype.redPow = function(S) {
      return a(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var O = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function D(_, S) {
      this.name = _, this.p = new d(S, 16), this.n = this.p.bitLength(), this.k = new d(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    D.prototype._tmp = function() {
      var S = new d(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, D.prototype.ireduce = function(S) {
      var C = S, R;
      do
        this.split(C, this.tmp), C = this.imulK(C), C = C.iadd(this.tmp), R = C.bitLength();
      while (R > this.n);
      var H = R < this.n ? -1 : C.ucmp(this.p);
      return H === 0 ? (C.words[0] = 0, C.length = 1) : H > 0 ? C.isub(this.p) : C.strip !== void 0 ? C.strip() : C._strip(), C;
    }, D.prototype.split = function(S, C) {
      S.iushrn(this.n, 0, C);
    }, D.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function $() {
      D.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    l($, D), $.prototype.split = function(S, C) {
      for (var R = 4194303, H = Math.min(S.length, 9), z = 0; z < H; z++)
        C.words[z] = S.words[z];
      if (C.length = H, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var U = S.words[9];
      for (C.words[C.length++] = U & R, z = 10; z < S.length; z++) {
        var P = S.words[z] | 0;
        S.words[z - 10] = (P & R) << 4 | U >>> 22, U = P;
      }
      U >>>= 22, S.words[z - 10] = U, U === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, $.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var C = 0, R = 0; R < S.length; R++) {
        var H = S.words[R] | 0;
        C += H * 977, S.words[R] = C & 67108863, C = H * 64 + (C / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function I() {
      D.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    l(I, D);
    function k() {
      D.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    l(k, D);
    function L() {
      D.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    l(L, D), L.prototype.imulK = function(S) {
      for (var C = 0, R = 0; R < S.length; R++) {
        var H = (S.words[R] | 0) * 19 + C, z = H & 67108863;
        H >>>= 26, S.words[R] = z, C = H;
      }
      return C !== 0 && (S.words[S.length++] = C), S;
    }, d._prime = function(S) {
      if (O[S]) return O[S];
      var C;
      if (S === "k256")
        C = new $();
      else if (S === "p224")
        C = new I();
      else if (S === "p192")
        C = new k();
      else if (S === "p25519")
        C = new L();
      else
        throw new Error("Unknown prime " + S);
      return O[S] = C, C;
    };
    function M(_) {
      if (typeof _ == "string") {
        var S = d._prime(_);
        this.m = S.p, this.prime = S;
      } else
        a(_.gtn(1), "modulus must be greater than 1"), this.m = _, this.prime = null;
    }
    M.prototype._verify1 = function(S) {
      a(S.negative === 0, "red works only with positives"), a(S.red, "red works only with red numbers");
    }, M.prototype._verify2 = function(S, C) {
      a((S.negative | C.negative) === 0, "red works only with positives"), a(
        S.red && S.red === C.red,
        "red works only with red numbers"
      );
    }, M.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : (c(S, S.umod(this.m)._forceRed(this)), S);
    }, M.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, M.prototype.add = function(S, C) {
      this._verify2(S, C);
      var R = S.add(C);
      return R.cmp(this.m) >= 0 && R.isub(this.m), R._forceRed(this);
    }, M.prototype.iadd = function(S, C) {
      this._verify2(S, C);
      var R = S.iadd(C);
      return R.cmp(this.m) >= 0 && R.isub(this.m), R;
    }, M.prototype.sub = function(S, C) {
      this._verify2(S, C);
      var R = S.sub(C);
      return R.cmpn(0) < 0 && R.iadd(this.m), R._forceRed(this);
    }, M.prototype.isub = function(S, C) {
      this._verify2(S, C);
      var R = S.isub(C);
      return R.cmpn(0) < 0 && R.iadd(this.m), R;
    }, M.prototype.shl = function(S, C) {
      return this._verify1(S), this.imod(S.ushln(C));
    }, M.prototype.imul = function(S, C) {
      return this._verify2(S, C), this.imod(S.imul(C));
    }, M.prototype.mul = function(S, C) {
      return this._verify2(S, C), this.imod(S.mul(C));
    }, M.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, M.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, M.prototype.sqrt = function(S) {
      if (S.isZero()) return S.clone();
      var C = this.m.andln(3);
      if (a(C % 2 === 1), C === 3) {
        var R = this.m.add(new d(1)).iushrn(2);
        return this.pow(S, R);
      }
      for (var H = this.m.subn(1), z = 0; !H.isZero() && H.andln(1) === 0; )
        z++, H.iushrn(1);
      a(!H.isZero());
      var U = new d(1).toRed(this), P = U.redNeg(), W = this.m.subn(1).iushrn(1), B = this.m.bitLength();
      for (B = new d(2 * B * B).toRed(this); this.pow(B, W).cmp(P) !== 0; )
        B.redIAdd(P);
      for (var Q = this.pow(B, H), J = this.pow(S, H.addn(1).iushrn(1)), re = this.pow(S, H), G = z; re.cmp(U) !== 0; ) {
        for (var N = re, V = 0; N.cmp(U) !== 0; V++)
          N = N.redSqr();
        a(V < G);
        var F = this.pow(Q, new d(1).iushln(G - V - 1));
        J = J.redMul(F), Q = F.redSqr(), re = re.redMul(Q), G = V;
      }
      return J;
    }, M.prototype.invm = function(S) {
      var C = S._invmp(this.m);
      return C.negative !== 0 ? (C.negative = 0, this.imod(C).redNeg()) : this.imod(C);
    }, M.prototype.pow = function(S, C) {
      if (C.isZero()) return new d(1).toRed(this);
      if (C.cmpn(1) === 0) return S.clone();
      var R = 4, H = new Array(1 << R);
      H[0] = new d(1).toRed(this), H[1] = S;
      for (var z = 2; z < H.length; z++)
        H[z] = this.mul(H[z - 1], S);
      var U = H[0], P = 0, W = 0, B = C.bitLength() % 26;
      for (B === 0 && (B = 26), z = C.length - 1; z >= 0; z--) {
        for (var Q = C.words[z], J = B - 1; J >= 0; J--) {
          var re = Q >> J & 1;
          if (U !== H[0] && (U = this.sqr(U)), re === 0 && P === 0) {
            W = 0;
            continue;
          }
          P <<= 1, P |= re, W++, !(W !== R && (z !== 0 || J !== 0)) && (U = this.mul(U, H[P]), W = 0, P = 0);
        }
        B = 26;
      }
      return U;
    }, M.prototype.convertTo = function(S) {
      var C = S.umod(this.m);
      return C === S ? C.clone() : C;
    }, M.prototype.convertFrom = function(S) {
      var C = S.clone();
      return C.red = null, C;
    }, d.mont = function(S) {
      return new x(S);
    };
    function x(_) {
      M.call(this, _), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new d(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    l(x, M), x.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, x.prototype.convertFrom = function(S) {
      var C = this.imod(S.mul(this.rinv));
      return C.red = null, C;
    }, x.prototype.imul = function(S, C) {
      if (S.isZero() || C.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var R = S.imul(C), H = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), z = R.isub(H).iushrn(this.shift), U = z;
      return z.cmp(this.m) >= 0 ? U = z.isub(this.m) : z.cmpn(0) < 0 && (U = z.iadd(this.m)), U._forceRed(this);
    }, x.prototype.mul = function(S, C) {
      if (S.isZero() || C.isZero()) return new d(0)._forceRed(this);
      var R = S.mul(C), H = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), z = R.isub(H).iushrn(this.shift), U = z;
      return z.cmp(this.m) >= 0 ? U = z.isub(this.m) : z.cmpn(0) < 0 && (U = z.iadd(this.m)), U._forceRed(this);
    }, x.prototype.invm = function(S) {
      var C = this.imod(S._invmp(this.m).mul(this.r2));
      return C._forceRed(this);
    };
  })(t, jt);
})(Lb);
var jb = Lb.exports, tl = jb, w$ = Cl;
function x$(t) {
  var e = e3(t), r = e.toRed(tl.mont(t.modulus)).redPow(new tl(t.publicExponent)).fromRed();
  return { blinder: r, unblinder: e.invm(t.modulus) };
}
function e3(t) {
  var e = t.modulus.byteLength(), r;
  do
    r = new tl(w$(e));
  while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
  return r;
}
function t3(t, e) {
  var r = x$(e), a = e.modulus.byteLength(), l = new tl(t).mul(r.blinder).umod(e.modulus), d = l.toRed(tl.mont(e.prime1)), h = l.toRed(tl.mont(e.prime2)), n = e.coefficient, u = e.prime1, i = e.prime2, c = d.redPow(e.exponent1).fromRed(), f = h.redPow(e.exponent2).fromRed(), s = c.isub(f).imul(n).umod(u).imul(i);
  return f.iadd(s).imul(r.unblinder).umod(e.modulus).toArrayLike(Gt, "be", a);
}
t3.getr = e3;
var Fb = t3, _m = {};
const T$ = "elliptic", A$ = "6.5.5", P$ = "EC cryptography", C$ = "lib/elliptic.js", I$ = [
  "lib"
], O$ = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, k$ = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, D$ = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], N$ = "Fedor Indutny <fedor@indutny.com>", R$ = "MIT", M$ = {
  url: "https://github.com/indutny/elliptic/issues"
}, L$ = "https://github.com/indutny/elliptic", j$ = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, F$ = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, B$ = {
  name: T$,
  version: A$,
  description: P$,
  main: C$,
  files: I$,
  scripts: O$,
  repository: k$,
  keywords: D$,
  author: N$,
  license: R$,
  bugs: M$,
  homepage: L$,
  devDependencies: j$,
  dependencies: F$
};
var Ai = {}, Bb = {};
(function(t) {
  var e = t;
  function r(d, h) {
    if (Array.isArray(d))
      return d.slice();
    if (!d)
      return [];
    var n = [];
    if (typeof d != "string") {
      for (var u = 0; u < d.length; u++)
        n[u] = d[u] | 0;
      return n;
    }
    if (h === "hex") {
      d = d.replace(/[^a-z0-9]+/ig, ""), d.length % 2 !== 0 && (d = "0" + d);
      for (var u = 0; u < d.length; u += 2)
        n.push(parseInt(d[u] + d[u + 1], 16));
    } else
      for (var u = 0; u < d.length; u++) {
        var i = d.charCodeAt(u), c = i >> 8, f = i & 255;
        c ? n.push(c, f) : n.push(f);
      }
    return n;
  }
  e.toArray = r;
  function a(d) {
    return d.length === 1 ? "0" + d : d;
  }
  e.zero2 = a;
  function l(d) {
    for (var h = "", n = 0; n < d.length; n++)
      h += a(d[n].toString(16));
    return h;
  }
  e.toHex = l, e.encode = function(h, n) {
    return n === "hex" ? l(h) : h;
  };
})(Bb);
(function(t) {
  var e = t, r = Gn, a = Gi, l = Bb;
  e.assert = a, e.toArray = l.toArray, e.zero2 = l.zero2, e.toHex = l.toHex, e.encode = l.encode;
  function d(c, f, s) {
    var o = new Array(Math.max(c.bitLength(), s) + 1), y;
    for (y = 0; y < o.length; y += 1)
      o[y] = 0;
    var m = 1 << f + 1, g = c.clone();
    for (y = 0; y < o.length; y++) {
      var b, v = g.andln(m - 1);
      g.isOdd() ? (v > (m >> 1) - 1 ? b = (m >> 1) - v : b = v, g.isubn(b)) : b = 0, o[y] = b, g.iushrn(1);
    }
    return o;
  }
  e.getNAF = d;
  function h(c, f) {
    var s = [
      [],
      []
    ];
    c = c.clone(), f = f.clone();
    for (var o = 0, y = 0, m; c.cmpn(-o) > 0 || f.cmpn(-y) > 0; ) {
      var g = c.andln(3) + o & 3, b = f.andln(3) + y & 3;
      g === 3 && (g = -1), b === 3 && (b = -1);
      var v;
      g & 1 ? (m = c.andln(7) + o & 7, (m === 3 || m === 5) && b === 2 ? v = -g : v = g) : v = 0, s[0].push(v);
      var T;
      b & 1 ? (m = f.andln(7) + y & 7, (m === 3 || m === 5) && g === 2 ? T = -b : T = b) : T = 0, s[1].push(T), 2 * o === v + 1 && (o = 1 - o), 2 * y === T + 1 && (y = 1 - y), c.iushrn(1), f.iushrn(1);
    }
    return s;
  }
  e.getJSF = h;
  function n(c, f, s) {
    var o = "_" + f;
    c.prototype[f] = function() {
      return this[o] !== void 0 ? this[o] : this[o] = s.call(this);
    };
  }
  e.cachedProperty = n;
  function u(c) {
    return typeof c == "string" ? e.toArray(c, "hex") : c;
  }
  e.parseBytes = u;
  function i(c) {
    return new r(c, "hex", "le");
  }
  e.intFromLE = i;
})(Ai);
var $b = {}, Wa = Gn, cc = Ai, Qf = cc.getNAF, $$ = cc.getJSF, Zf = cc.assert;
function Ra(t, e) {
  this.type = t, this.p = new Wa(e.p, 16), this.red = e.prime ? Wa.red(e.prime) : Wa.mont(this.p), this.zero = new Wa(0).toRed(this.red), this.one = new Wa(1).toRed(this.red), this.two = new Wa(2).toRed(this.red), this.n = e.n && new Wa(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var yp = Ra;
Ra.prototype.point = function() {
  throw new Error("Not implemented");
};
Ra.prototype.validate = function() {
  throw new Error("Not implemented");
};
Ra.prototype._fixedNafMul = function(e, r) {
  Zf(e.precomputed);
  var a = e._getDoubles(), l = Qf(r, 1, this._bitLength), d = (1 << a.step + 1) - (a.step % 2 === 0 ? 2 : 1);
  d /= 3;
  var h = [], n, u;
  for (n = 0; n < l.length; n += a.step) {
    u = 0;
    for (var i = n + a.step - 1; i >= n; i--)
      u = (u << 1) + l[i];
    h.push(u);
  }
  for (var c = this.jpoint(null, null, null), f = this.jpoint(null, null, null), s = d; s > 0; s--) {
    for (n = 0; n < h.length; n++)
      u = h[n], u === s ? f = f.mixedAdd(a.points[n]) : u === -s && (f = f.mixedAdd(a.points[n].neg()));
    c = c.add(f);
  }
  return c.toP();
};
Ra.prototype._wnafMul = function(e, r) {
  var a = 4, l = e._getNAFPoints(a);
  a = l.wnd;
  for (var d = l.points, h = Qf(r, a, this._bitLength), n = this.jpoint(null, null, null), u = h.length - 1; u >= 0; u--) {
    for (var i = 0; u >= 0 && h[u] === 0; u--)
      i++;
    if (u >= 0 && i++, n = n.dblp(i), u < 0)
      break;
    var c = h[u];
    Zf(c !== 0), e.type === "affine" ? c > 0 ? n = n.mixedAdd(d[c - 1 >> 1]) : n = n.mixedAdd(d[-c - 1 >> 1].neg()) : c > 0 ? n = n.add(d[c - 1 >> 1]) : n = n.add(d[-c - 1 >> 1].neg());
  }
  return e.type === "affine" ? n.toP() : n;
};
Ra.prototype._wnafMulAdd = function(e, r, a, l, d) {
  var h = this._wnafT1, n = this._wnafT2, u = this._wnafT3, i = 0, c, f, s;
  for (c = 0; c < l; c++) {
    s = r[c];
    var o = s._getNAFPoints(e);
    h[c] = o.wnd, n[c] = o.points;
  }
  for (c = l - 1; c >= 1; c -= 2) {
    var y = c - 1, m = c;
    if (h[y] !== 1 || h[m] !== 1) {
      u[y] = Qf(a[y], h[y], this._bitLength), u[m] = Qf(a[m], h[m], this._bitLength), i = Math.max(u[y].length, i), i = Math.max(u[m].length, i);
      continue;
    }
    var g = [
      r[y],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[m]
      /* 7 */
    ];
    r[y].y.cmp(r[m].y) === 0 ? (g[1] = r[y].add(r[m]), g[2] = r[y].toJ().mixedAdd(r[m].neg())) : r[y].y.cmp(r[m].y.redNeg()) === 0 ? (g[1] = r[y].toJ().mixedAdd(r[m]), g[2] = r[y].add(r[m].neg())) : (g[1] = r[y].toJ().mixedAdd(r[m]), g[2] = r[y].toJ().mixedAdd(r[m].neg()));
    var b = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], v = $$(a[y], a[m]);
    for (i = Math.max(v[0].length, i), u[y] = new Array(i), u[m] = new Array(i), f = 0; f < i; f++) {
      var T = v[0][f] | 0, E = v[1][f] | 0;
      u[y][f] = b[(T + 1) * 3 + (E + 1)], u[m][f] = 0, n[y] = g;
    }
  }
  var O = this.jpoint(null, null, null), D = this._wnafT4;
  for (c = i; c >= 0; c--) {
    for (var $ = 0; c >= 0; ) {
      var I = !0;
      for (f = 0; f < l; f++)
        D[f] = u[f][c] | 0, D[f] !== 0 && (I = !1);
      if (!I)
        break;
      $++, c--;
    }
    if (c >= 0 && $++, O = O.dblp($), c < 0)
      break;
    for (f = 0; f < l; f++) {
      var k = D[f];
      k !== 0 && (k > 0 ? s = n[f][k - 1 >> 1] : k < 0 && (s = n[f][-k - 1 >> 1].neg()), s.type === "affine" ? O = O.mixedAdd(s) : O = O.add(s));
    }
  }
  for (c = 0; c < l; c++)
    n[c] = null;
  return d ? O : O.toP();
};
function Ki(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Ra.BasePoint = Ki;
Ki.prototype.eq = function() {
  throw new Error("Not implemented");
};
Ki.prototype.validate = function() {
  return this.curve.validate(this);
};
Ra.prototype.decodePoint = function(e, r) {
  e = cc.toArray(e, r);
  var a = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * a) {
    e[0] === 6 ? Zf(e[e.length - 1] % 2 === 0) : e[0] === 7 && Zf(e[e.length - 1] % 2 === 1);
    var l = this.point(
      e.slice(1, 1 + a),
      e.slice(1 + a, 1 + 2 * a)
    );
    return l;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === a)
    return this.pointFromX(e.slice(1, 1 + a), e[0] === 3);
  throw new Error("Unknown point format");
};
Ki.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
Ki.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), a = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(a) : [4].concat(a, this.getY().toArray("be", r));
};
Ki.prototype.encode = function(e, r) {
  return cc.encode(this._encode(r), e);
};
Ki.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
Ki.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
Ki.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var a = [this], l = this, d = 0; d < r; d += e) {
    for (var h = 0; h < e; h++)
      l = l.dbl();
    a.push(l);
  }
  return {
    step: e,
    points: a
  };
};
Ki.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], a = (1 << e) - 1, l = a === 1 ? null : this.dbl(), d = 1; d < a; d++)
    r[d] = r[d - 1].add(l);
  return {
    wnd: e,
    points: r
  };
};
Ki.prototype._getBeta = function() {
  return null;
};
Ki.prototype.dblp = function(e) {
  for (var r = this, a = 0; a < e; a++)
    r = r.dbl();
  return r;
};
var U$ = Ai, nn = Gn, Ub = ir, kl = yp, V$ = U$.assert;
function Yi(t) {
  kl.call(this, "short", t), this.a = new nn(t.a, 16).toRed(this.red), this.b = new nn(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Ub(Yi, kl);
var W$ = Yi;
Yi.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, a;
    if (e.beta)
      r = new nn(e.beta, 16).toRed(this.red);
    else {
      var l = this._getEndoRoots(this.p);
      r = l[0].cmp(l[1]) < 0 ? l[0] : l[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      a = new nn(e.lambda, 16);
    else {
      var d = this._getEndoRoots(this.n);
      this.g.mul(d[0]).x.cmp(this.g.x.redMul(r)) === 0 ? a = d[0] : (a = d[1], V$(this.g.mul(a).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var h;
    return e.basis ? h = e.basis.map(function(n) {
      return {
        a: new nn(n.a, 16),
        b: new nn(n.b, 16)
      };
    }) : h = this._getEndoBasis(a), {
      beta: r,
      lambda: a,
      basis: h
    };
  }
};
Yi.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : nn.mont(e), a = new nn(2).toRed(r).redInvm(), l = a.redNeg(), d = new nn(3).toRed(r).redNeg().redSqrt().redMul(a), h = l.redAdd(d).fromRed(), n = l.redSub(d).fromRed();
  return [h, n];
};
Yi.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), a = e, l = this.n.clone(), d = new nn(1), h = new nn(0), n = new nn(0), u = new nn(1), i, c, f, s, o, y, m, g = 0, b, v; a.cmpn(0) !== 0; ) {
    var T = l.div(a);
    b = l.sub(T.mul(a)), v = n.sub(T.mul(d));
    var E = u.sub(T.mul(h));
    if (!f && b.cmp(r) < 0)
      i = m.neg(), c = d, f = b.neg(), s = v;
    else if (f && ++g === 2)
      break;
    m = b, l = a, a = b, n = d, d = v, u = h, h = E;
  }
  o = b.neg(), y = v;
  var O = f.sqr().add(s.sqr()), D = o.sqr().add(y.sqr());
  return D.cmp(O) >= 0 && (o = i, y = c), f.negative && (f = f.neg(), s = s.neg()), o.negative && (o = o.neg(), y = y.neg()), [
    { a: f, b: s },
    { a: o, b: y }
  ];
};
Yi.prototype._endoSplit = function(e) {
  var r = this.endo.basis, a = r[0], l = r[1], d = l.b.mul(e).divRound(this.n), h = a.b.neg().mul(e).divRound(this.n), n = d.mul(a.a), u = h.mul(l.a), i = d.mul(a.b), c = h.mul(l.b), f = e.sub(n).sub(u), s = i.add(c).neg();
  return { k1: f, k2: s };
};
Yi.prototype.pointFromX = function(e, r) {
  e = new nn(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), l = a.redSqrt();
  if (l.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var d = l.fromRed().isOdd();
  return (r && !d || !r && d) && (l = l.redNeg()), this.point(e, l);
};
Yi.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, a = e.y, l = this.a.redMul(r), d = r.redSqr().redMul(r).redIAdd(l).redIAdd(this.b);
  return a.redSqr().redISub(d).cmpn(0) === 0;
};
Yi.prototype._endoWnafMulAdd = function(e, r, a) {
  for (var l = this._endoWnafT1, d = this._endoWnafT2, h = 0; h < e.length; h++) {
    var n = this._endoSplit(r[h]), u = e[h], i = u._getBeta();
    n.k1.negative && (n.k1.ineg(), u = u.neg(!0)), n.k2.negative && (n.k2.ineg(), i = i.neg(!0)), l[h * 2] = u, l[h * 2 + 1] = i, d[h * 2] = n.k1, d[h * 2 + 1] = n.k2;
  }
  for (var c = this._wnafMulAdd(1, l, d, h * 2, a), f = 0; f < h * 2; f++)
    l[f] = null, d[f] = null;
  return c;
};
function Un(t, e, r, a) {
  kl.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new nn(e, 16), this.y = new nn(r, 16), a && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Ub(Un, kl.BasePoint);
Yi.prototype.point = function(e, r, a) {
  return new Un(this, e, r, a);
};
Yi.prototype.pointFromJSON = function(e, r) {
  return Un.fromJSON(this, e, r);
};
Un.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var a = this.curve, l = function(d) {
        return a.point(d.x.redMul(a.endo.beta), d.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(l)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(l)
        }
      };
    }
    return r;
  }
};
Un.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Un.fromJSON = function(e, r, a) {
  typeof r == "string" && (r = JSON.parse(r));
  var l = e.point(r[0], r[1], a);
  if (!r[2])
    return l;
  function d(n) {
    return e.point(n[0], n[1], a);
  }
  var h = r[2];
  return l.precomputed = {
    beta: null,
    doubles: h.doubles && {
      step: h.doubles.step,
      points: [l].concat(h.doubles.points.map(d))
    },
    naf: h.naf && {
      wnd: h.naf.wnd,
      points: [l].concat(h.naf.points.map(d))
    }
  }, l;
};
Un.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Un.prototype.isInfinity = function() {
  return this.inf;
};
Un.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var a = r.redSqr().redISub(this.x).redISub(e.x), l = r.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, l);
};
Un.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, a = this.x.redSqr(), l = e.redInvm(), d = a.redAdd(a).redIAdd(a).redIAdd(r).redMul(l), h = d.redSqr().redISub(this.x.redAdd(this.x)), n = d.redMul(this.x.redSub(h)).redISub(this.y);
  return this.curve.point(h, n);
};
Un.prototype.getX = function() {
  return this.x.fromRed();
};
Un.prototype.getY = function() {
  return this.y.fromRed();
};
Un.prototype.mul = function(e) {
  return e = new nn(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Un.prototype.mulAdd = function(e, r, a) {
  var l = [this, r], d = [e, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(l, d) : this.curve._wnafMulAdd(1, l, d, 2);
};
Un.prototype.jmulAdd = function(e, r, a) {
  var l = [this, r], d = [e, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(l, d, !0) : this.curve._wnafMulAdd(1, l, d, 2, !0);
};
Un.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Un.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var a = this.precomputed, l = function(d) {
      return d.neg();
    };
    r.precomputed = {
      naf: a.naf && {
        wnd: a.naf.wnd,
        points: a.naf.points.map(l)
      },
      doubles: a.doubles && {
        step: a.doubles.step,
        points: a.doubles.points.map(l)
      }
    };
  }
  return r;
};
Un.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function zn(t, e, r, a) {
  kl.BasePoint.call(this, t, "jacobian"), e === null && r === null && a === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new nn(0)) : (this.x = new nn(e, 16), this.y = new nn(r, 16), this.z = new nn(a, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Ub(zn, kl.BasePoint);
Yi.prototype.jpoint = function(e, r, a) {
  return new zn(this, e, r, a);
};
zn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), a = this.x.redMul(r), l = this.y.redMul(r).redMul(e);
  return this.curve.point(a, l);
};
zn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
zn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), a = this.z.redSqr(), l = this.x.redMul(r), d = e.x.redMul(a), h = this.y.redMul(r.redMul(e.z)), n = e.y.redMul(a.redMul(this.z)), u = l.redSub(d), i = h.redSub(n);
  if (u.cmpn(0) === 0)
    return i.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var c = u.redSqr(), f = c.redMul(u), s = l.redMul(c), o = i.redSqr().redIAdd(f).redISub(s).redISub(s), y = i.redMul(s.redISub(o)).redISub(h.redMul(f)), m = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(o, y, m);
};
zn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), a = this.x, l = e.x.redMul(r), d = this.y, h = e.y.redMul(r).redMul(this.z), n = a.redSub(l), u = d.redSub(h);
  if (n.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var i = n.redSqr(), c = i.redMul(n), f = a.redMul(i), s = u.redSqr().redIAdd(c).redISub(f).redISub(f), o = u.redMul(f.redISub(s)).redISub(d.redMul(c)), y = this.z.redMul(n);
  return this.curve.jpoint(s, o, y);
};
zn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var a = this;
    for (r = 0; r < e; r++)
      a = a.dbl();
    return a;
  }
  var l = this.curve.a, d = this.curve.tinv, h = this.x, n = this.y, u = this.z, i = u.redSqr().redSqr(), c = n.redAdd(n);
  for (r = 0; r < e; r++) {
    var f = h.redSqr(), s = c.redSqr(), o = s.redSqr(), y = f.redAdd(f).redIAdd(f).redIAdd(l.redMul(i)), m = h.redMul(s), g = y.redSqr().redISub(m.redAdd(m)), b = m.redISub(g), v = y.redMul(b);
    v = v.redIAdd(v).redISub(o);
    var T = c.redMul(u);
    r + 1 < e && (i = i.redMul(o)), h = g, u = T, c = v;
  }
  return this.curve.jpoint(h, c.redMul(d), u);
};
zn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
zn.prototype._zeroDbl = function() {
  var e, r, a;
  if (this.zOne) {
    var l = this.x.redSqr(), d = this.y.redSqr(), h = d.redSqr(), n = this.x.redAdd(d).redSqr().redISub(l).redISub(h);
    n = n.redIAdd(n);
    var u = l.redAdd(l).redIAdd(l), i = u.redSqr().redISub(n).redISub(n), c = h.redIAdd(h);
    c = c.redIAdd(c), c = c.redIAdd(c), e = i, r = u.redMul(n.redISub(i)).redISub(c), a = this.y.redAdd(this.y);
  } else {
    var f = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), y = this.x.redAdd(s).redSqr().redISub(f).redISub(o);
    y = y.redIAdd(y);
    var m = f.redAdd(f).redIAdd(f), g = m.redSqr(), b = o.redIAdd(o);
    b = b.redIAdd(b), b = b.redIAdd(b), e = g.redISub(y).redISub(y), r = m.redMul(y.redISub(e)).redISub(b), a = this.y.redMul(this.z), a = a.redIAdd(a);
  }
  return this.curve.jpoint(e, r, a);
};
zn.prototype._threeDbl = function() {
  var e, r, a;
  if (this.zOne) {
    var l = this.x.redSqr(), d = this.y.redSqr(), h = d.redSqr(), n = this.x.redAdd(d).redSqr().redISub(l).redISub(h);
    n = n.redIAdd(n);
    var u = l.redAdd(l).redIAdd(l).redIAdd(this.curve.a), i = u.redSqr().redISub(n).redISub(n);
    e = i;
    var c = h.redIAdd(h);
    c = c.redIAdd(c), c = c.redIAdd(c), r = u.redMul(n.redISub(i)).redISub(c), a = this.y.redAdd(this.y);
  } else {
    var f = this.z.redSqr(), s = this.y.redSqr(), o = this.x.redMul(s), y = this.x.redSub(f).redMul(this.x.redAdd(f));
    y = y.redAdd(y).redIAdd(y);
    var m = o.redIAdd(o);
    m = m.redIAdd(m);
    var g = m.redAdd(m);
    e = y.redSqr().redISub(g), a = this.y.redAdd(this.z).redSqr().redISub(s).redISub(f);
    var b = s.redSqr();
    b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b), r = y.redMul(m.redISub(e)).redISub(b);
  }
  return this.curve.jpoint(e, r, a);
};
zn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, a = this.y, l = this.z, d = l.redSqr().redSqr(), h = r.redSqr(), n = a.redSqr(), u = h.redAdd(h).redIAdd(h).redIAdd(e.redMul(d)), i = r.redAdd(r);
  i = i.redIAdd(i);
  var c = i.redMul(n), f = u.redSqr().redISub(c.redAdd(c)), s = c.redISub(f), o = n.redSqr();
  o = o.redIAdd(o), o = o.redIAdd(o), o = o.redIAdd(o);
  var y = u.redMul(s).redISub(o), m = a.redAdd(a).redMul(l);
  return this.curve.jpoint(f, y, m);
};
zn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), a = this.z.redSqr(), l = r.redSqr(), d = e.redAdd(e).redIAdd(e), h = d.redSqr(), n = this.x.redAdd(r).redSqr().redISub(e).redISub(l);
  n = n.redIAdd(n), n = n.redAdd(n).redIAdd(n), n = n.redISub(h);
  var u = n.redSqr(), i = l.redIAdd(l);
  i = i.redIAdd(i), i = i.redIAdd(i), i = i.redIAdd(i);
  var c = d.redIAdd(n).redSqr().redISub(h).redISub(u).redISub(i), f = r.redMul(c);
  f = f.redIAdd(f), f = f.redIAdd(f);
  var s = this.x.redMul(u).redISub(f);
  s = s.redIAdd(s), s = s.redIAdd(s);
  var o = this.y.redMul(c.redMul(i.redISub(c)).redISub(n.redMul(u)));
  o = o.redIAdd(o), o = o.redIAdd(o), o = o.redIAdd(o);
  var y = this.z.redAdd(n).redSqr().redISub(a).redISub(u);
  return this.curve.jpoint(s, o, y);
};
zn.prototype.mul = function(e, r) {
  return e = new nn(e, r), this.curve._wnafMul(this, e);
};
zn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), a = e.z.redSqr();
  if (this.x.redMul(a).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var l = r.redMul(this.z), d = a.redMul(e.z);
  return this.y.redMul(d).redISub(e.y.redMul(l)).cmpn(0) === 0;
};
zn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), a = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(a) === 0)
    return !0;
  for (var l = e.clone(), d = this.curve.redN.redMul(r); ; ) {
    if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0)
      return !1;
    if (a.redIAdd(d), this.x.cmp(a) === 0)
      return !0;
  }
};
zn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
zn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Go = Gn, r3 = ir, bp = yp, q$ = Ai;
function Dl(t) {
  bp.call(this, "mont", t), this.a = new Go(t.a, 16).toRed(this.red), this.b = new Go(t.b, 16).toRed(this.red), this.i4 = new Go(4).toRed(this.red).redInvm(), this.two = new Go(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
r3(Dl, bp);
var H$ = Dl;
Dl.prototype.validate = function(e) {
  var r = e.normalize().x, a = r.redSqr(), l = a.redMul(r).redAdd(a.redMul(this.a)).redAdd(r), d = l.redSqrt();
  return d.redSqr().cmp(l) === 0;
};
function Fn(t, e, r) {
  bp.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Go(e, 16), this.z = new Go(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
r3(Fn, bp.BasePoint);
Dl.prototype.decodePoint = function(e, r) {
  return this.point(q$.toArray(e, r), 1);
};
Dl.prototype.point = function(e, r) {
  return new Fn(this, e, r);
};
Dl.prototype.pointFromJSON = function(e) {
  return Fn.fromJSON(this, e);
};
Fn.prototype.precompute = function() {
};
Fn.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Fn.fromJSON = function(e, r) {
  return new Fn(e, r[0], r[1] || e.one);
};
Fn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Fn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Fn.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), r = e.redSqr(), a = this.x.redSub(this.z), l = a.redSqr(), d = r.redSub(l), h = r.redMul(l), n = d.redMul(l.redAdd(this.curve.a24.redMul(d)));
  return this.curve.point(h, n);
};
Fn.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Fn.prototype.diffAdd = function(e, r) {
  var a = this.x.redAdd(this.z), l = this.x.redSub(this.z), d = e.x.redAdd(e.z), h = e.x.redSub(e.z), n = h.redMul(a), u = d.redMul(l), i = r.z.redMul(n.redAdd(u).redSqr()), c = r.x.redMul(n.redISub(u).redSqr());
  return this.curve.point(i, c);
};
Fn.prototype.mul = function(e) {
  for (var r = e.clone(), a = this, l = this.curve.point(null, null), d = this, h = []; r.cmpn(0) !== 0; r.iushrn(1))
    h.push(r.andln(1));
  for (var n = h.length - 1; n >= 0; n--)
    h[n] === 0 ? (a = a.diffAdd(l, d), l = l.dbl()) : (l = a.diffAdd(l, d), a = a.dbl());
  return l;
};
Fn.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Fn.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Fn.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Fn.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Fn.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var G$ = Ai, Zs = Gn, n3 = ir, gp = yp, z$ = G$.assert;
function Ws(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, gp.call(this, "edwards", t), this.a = new Zs(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Zs(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Zs(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), z$(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
n3(Ws, gp);
var K$ = Ws;
Ws.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
Ws.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
Ws.prototype.jpoint = function(e, r, a, l) {
  return this.point(e, r, a, l);
};
Ws.prototype.pointFromX = function(e, r) {
  e = new Zs(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr(), l = this.c2.redSub(this.a.redMul(a)), d = this.one.redSub(this.c2.redMul(this.d).redMul(a)), h = l.redMul(d.redInvm()), n = h.redSqrt();
  if (n.redSqr().redSub(h).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var u = n.fromRed().isOdd();
  return (r && !u || !r && u) && (n = n.redNeg()), this.point(e, n);
};
Ws.prototype.pointFromY = function(e, r) {
  e = new Zs(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr(), l = a.redSub(this.c2), d = a.redMul(this.d).redMul(this.c2).redSub(this.a), h = l.redMul(d.redInvm());
  if (h.cmp(this.zero) === 0) {
    if (r)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var n = h.redSqrt();
  if (n.redSqr().redSub(h).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return n.fromRed().isOdd() !== r && (n = n.redNeg()), this.point(n, e);
};
Ws.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var r = e.x.redSqr(), a = e.y.redSqr(), l = r.redMul(this.a).redAdd(a), d = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(a)));
  return l.cmp(d) === 0;
};
function $r(t, e, r, a, l) {
  gp.BasePoint.call(this, t, "projective"), e === null && r === null && a === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Zs(e, 16), this.y = new Zs(r, 16), this.z = a ? new Zs(a, 16) : this.curve.one, this.t = l && new Zs(l, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
n3($r, gp.BasePoint);
Ws.prototype.pointFromJSON = function(e) {
  return $r.fromJSON(this, e);
};
Ws.prototype.point = function(e, r, a, l) {
  return new $r(this, e, r, a, l);
};
$r.fromJSON = function(e, r) {
  return new $r(e, r[0], r[1], r[2]);
};
$r.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
$r.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
$r.prototype._extDbl = function() {
  var e = this.x.redSqr(), r = this.y.redSqr(), a = this.z.redSqr();
  a = a.redIAdd(a);
  var l = this.curve._mulA(e), d = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), h = l.redAdd(r), n = h.redSub(a), u = l.redSub(r), i = d.redMul(n), c = h.redMul(u), f = d.redMul(u), s = n.redMul(h);
  return this.curve.point(i, c, s, f);
};
$r.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), a = this.y.redSqr(), l, d, h, n, u, i;
  if (this.curve.twisted) {
    n = this.curve._mulA(r);
    var c = n.redAdd(a);
    this.zOne ? (l = e.redSub(r).redSub(a).redMul(c.redSub(this.curve.two)), d = c.redMul(n.redSub(a)), h = c.redSqr().redSub(c).redSub(c)) : (u = this.z.redSqr(), i = c.redSub(u).redISub(u), l = e.redSub(r).redISub(a).redMul(i), d = c.redMul(n.redSub(a)), h = c.redMul(i));
  } else
    n = r.redAdd(a), u = this.curve._mulC(this.z).redSqr(), i = n.redSub(u).redSub(u), l = this.curve._mulC(e.redISub(n)).redMul(i), d = this.curve._mulC(n).redMul(r.redISub(a)), h = n.redMul(i);
  return this.curve.point(l, d, h);
};
$r.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
$r.prototype._extAdd = function(e) {
  var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), a = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), l = this.t.redMul(this.curve.dd).redMul(e.t), d = this.z.redMul(e.z.redAdd(e.z)), h = a.redSub(r), n = d.redSub(l), u = d.redAdd(l), i = a.redAdd(r), c = h.redMul(n), f = u.redMul(i), s = h.redMul(i), o = n.redMul(u);
  return this.curve.point(c, f, o, s);
};
$r.prototype._projAdd = function(e) {
  var r = this.z.redMul(e.z), a = r.redSqr(), l = this.x.redMul(e.x), d = this.y.redMul(e.y), h = this.curve.d.redMul(l).redMul(d), n = a.redSub(h), u = a.redAdd(h), i = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(l).redISub(d), c = r.redMul(n).redMul(i), f, s;
  return this.curve.twisted ? (f = r.redMul(u).redMul(d.redSub(this.curve._mulA(l))), s = n.redMul(u)) : (f = r.redMul(u).redMul(d.redSub(l)), s = this.curve._mulC(n).redMul(u)), this.curve.point(c, f, s);
};
$r.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
$r.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
$r.prototype.mulAdd = function(e, r, a) {
  return this.curve._wnafMulAdd(1, [this, r], [e, a], 2, !1);
};
$r.prototype.jmulAdd = function(e, r, a) {
  return this.curve._wnafMulAdd(1, [this, r], [e, a], 2, !0);
};
$r.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
$r.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
$r.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
$r.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
$r.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
$r.prototype.eqXToP = function(e) {
  var r = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var a = e.clone(), l = this.curve.redN.redMul(this.z); ; ) {
    if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(l), this.x.cmp(r) === 0)
      return !0;
  }
};
$r.prototype.toP = $r.prototype.normalize;
$r.prototype.mixedAdd = $r.prototype.add;
(function(t) {
  var e = t;
  e.base = yp, e.short = W$, e.mont = H$, e.edwards = K$;
})($b);
var vp = {}, Ep = {}, yr = {}, Y$ = Gi, X$ = ir;
yr.inherits = X$;
function J$(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function Q$(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var r = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), l = 0; l < t.length; l += 2)
          r.push(parseInt(t[l] + t[l + 1], 16));
    } else for (var a = 0, l = 0; l < t.length; l++) {
      var d = t.charCodeAt(l);
      d < 128 ? r[a++] = d : d < 2048 ? (r[a++] = d >> 6 | 192, r[a++] = d & 63 | 128) : J$(t, l) ? (d = 65536 + ((d & 1023) << 10) + (t.charCodeAt(++l) & 1023), r[a++] = d >> 18 | 240, r[a++] = d >> 12 & 63 | 128, r[a++] = d >> 6 & 63 | 128, r[a++] = d & 63 | 128) : (r[a++] = d >> 12 | 224, r[a++] = d >> 6 & 63 | 128, r[a++] = d & 63 | 128);
    }
  else
    for (l = 0; l < t.length; l++)
      r[l] = t[l] | 0;
  return r;
}
yr.toArray = Q$;
function Z$(t) {
  for (var e = "", r = 0; r < t.length; r++)
    e += s3(t[r].toString(16));
  return e;
}
yr.toHex = Z$;
function i3(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
yr.htonl = i3;
function eU(t, e) {
  for (var r = "", a = 0; a < t.length; a++) {
    var l = t[a];
    e === "little" && (l = i3(l)), r += a3(l.toString(16));
  }
  return r;
}
yr.toHex32 = eU;
function s3(t) {
  return t.length === 1 ? "0" + t : t;
}
yr.zero2 = s3;
function a3(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
yr.zero8 = a3;
function tU(t, e, r, a) {
  var l = r - e;
  Y$(l % 4 === 0);
  for (var d = new Array(l / 4), h = 0, n = e; h < d.length; h++, n += 4) {
    var u;
    a === "big" ? u = t[n] << 24 | t[n + 1] << 16 | t[n + 2] << 8 | t[n + 3] : u = t[n + 3] << 24 | t[n + 2] << 16 | t[n + 1] << 8 | t[n], d[h] = u >>> 0;
  }
  return d;
}
yr.join32 = tU;
function rU(t, e) {
  for (var r = new Array(t.length * 4), a = 0, l = 0; a < t.length; a++, l += 4) {
    var d = t[a];
    e === "big" ? (r[l] = d >>> 24, r[l + 1] = d >>> 16 & 255, r[l + 2] = d >>> 8 & 255, r[l + 3] = d & 255) : (r[l + 3] = d >>> 24, r[l + 2] = d >>> 16 & 255, r[l + 1] = d >>> 8 & 255, r[l] = d & 255);
  }
  return r;
}
yr.split32 = rU;
function nU(t, e) {
  return t >>> e | t << 32 - e;
}
yr.rotr32 = nU;
function iU(t, e) {
  return t << e | t >>> 32 - e;
}
yr.rotl32 = iU;
function sU(t, e) {
  return t + e >>> 0;
}
yr.sum32 = sU;
function aU(t, e, r) {
  return t + e + r >>> 0;
}
yr.sum32_3 = aU;
function oU(t, e, r, a) {
  return t + e + r + a >>> 0;
}
yr.sum32_4 = oU;
function lU(t, e, r, a, l) {
  return t + e + r + a + l >>> 0;
}
yr.sum32_5 = lU;
function uU(t, e, r, a) {
  var l = t[e], d = t[e + 1], h = a + d >>> 0, n = (h < a ? 1 : 0) + r + l;
  t[e] = n >>> 0, t[e + 1] = h;
}
yr.sum64 = uU;
function cU(t, e, r, a) {
  var l = e + a >>> 0, d = (l < e ? 1 : 0) + t + r;
  return d >>> 0;
}
yr.sum64_hi = cU;
function fU(t, e, r, a) {
  var l = e + a;
  return l >>> 0;
}
yr.sum64_lo = fU;
function dU(t, e, r, a, l, d, h, n) {
  var u = 0, i = e;
  i = i + a >>> 0, u += i < e ? 1 : 0, i = i + d >>> 0, u += i < d ? 1 : 0, i = i + n >>> 0, u += i < n ? 1 : 0;
  var c = t + r + l + h + u;
  return c >>> 0;
}
yr.sum64_4_hi = dU;
function pU(t, e, r, a, l, d, h, n) {
  var u = e + a + d + n;
  return u >>> 0;
}
yr.sum64_4_lo = pU;
function hU(t, e, r, a, l, d, h, n, u, i) {
  var c = 0, f = e;
  f = f + a >>> 0, c += f < e ? 1 : 0, f = f + d >>> 0, c += f < d ? 1 : 0, f = f + n >>> 0, c += f < n ? 1 : 0, f = f + i >>> 0, c += f < i ? 1 : 0;
  var s = t + r + l + h + u + c;
  return s >>> 0;
}
yr.sum64_5_hi = hU;
function mU(t, e, r, a, l, d, h, n, u, i) {
  var c = e + a + d + n + i;
  return c >>> 0;
}
yr.sum64_5_lo = mU;
function yU(t, e, r) {
  var a = e << 32 - r | t >>> r;
  return a >>> 0;
}
yr.rotr64_hi = yU;
function bU(t, e, r) {
  var a = t << 32 - r | e >>> r;
  return a >>> 0;
}
yr.rotr64_lo = bU;
function gU(t, e, r) {
  return t >>> r;
}
yr.shr64_hi = gU;
function vU(t, e, r) {
  var a = t << 32 - r | e >>> r;
  return a >>> 0;
}
yr.shr64_lo = vU;
var Nl = {}, Q_ = yr, EU = Gi;
function _p() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
Nl.BlockHash = _p;
_p.prototype.update = function(e, r) {
  if (e = Q_.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var a = e.length % this._delta8;
    this.pending = e.slice(e.length - a, e.length), this.pending.length === 0 && (this.pending = null), e = Q_.join32(e, 0, e.length - a, this.endian);
    for (var l = 0; l < e.length; l += this._delta32)
      this._update(e, l, l + this._delta32);
  }
  return this;
};
_p.prototype.digest = function(e) {
  return this.update(this._pad()), EU(this.pending === null), this._digest(e);
};
_p.prototype._pad = function() {
  var e = this.pendingTotal, r = this._delta8, a = r - (e + this.padLength) % r, l = new Array(a + this.padLength);
  l[0] = 128;
  for (var d = 1; d < a; d++)
    l[d] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var h = 8; h < this.padLength; h++)
      l[d++] = 0;
    l[d++] = 0, l[d++] = 0, l[d++] = 0, l[d++] = 0, l[d++] = e >>> 24 & 255, l[d++] = e >>> 16 & 255, l[d++] = e >>> 8 & 255, l[d++] = e & 255;
  } else
    for (l[d++] = e & 255, l[d++] = e >>> 8 & 255, l[d++] = e >>> 16 & 255, l[d++] = e >>> 24 & 255, l[d++] = 0, l[d++] = 0, l[d++] = 0, l[d++] = 0, h = 8; h < this.padLength; h++)
      l[d++] = 0;
  return l;
};
var Rl = {}, qs = {}, _U = yr, Ps = _U.rotr32;
function SU(t, e, r, a) {
  if (t === 0)
    return o3(e, r, a);
  if (t === 1 || t === 3)
    return u3(e, r, a);
  if (t === 2)
    return l3(e, r, a);
}
qs.ft_1 = SU;
function o3(t, e, r) {
  return t & e ^ ~t & r;
}
qs.ch32 = o3;
function l3(t, e, r) {
  return t & e ^ t & r ^ e & r;
}
qs.maj32 = l3;
function u3(t, e, r) {
  return t ^ e ^ r;
}
qs.p32 = u3;
function wU(t) {
  return Ps(t, 2) ^ Ps(t, 13) ^ Ps(t, 22);
}
qs.s0_256 = wU;
function xU(t) {
  return Ps(t, 6) ^ Ps(t, 11) ^ Ps(t, 25);
}
qs.s1_256 = xU;
function TU(t) {
  return Ps(t, 7) ^ Ps(t, 18) ^ t >>> 3;
}
qs.g0_256 = TU;
function AU(t) {
  return Ps(t, 17) ^ Ps(t, 19) ^ t >>> 10;
}
qs.g1_256 = AU;
var hl = yr, PU = Nl, CU = qs, Sm = hl.rotl32, eu = hl.sum32, IU = hl.sum32_5, OU = CU.ft_1, c3 = PU.BlockHash, kU = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Ls() {
  if (!(this instanceof Ls))
    return new Ls();
  c3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
hl.inherits(Ls, c3);
var DU = Ls;
Ls.blockSize = 512;
Ls.outSize = 160;
Ls.hmacStrength = 80;
Ls.padLength = 64;
Ls.prototype._update = function(e, r) {
  for (var a = this.W, l = 0; l < 16; l++)
    a[l] = e[r + l];
  for (; l < a.length; l++)
    a[l] = Sm(a[l - 3] ^ a[l - 8] ^ a[l - 14] ^ a[l - 16], 1);
  var d = this.h[0], h = this.h[1], n = this.h[2], u = this.h[3], i = this.h[4];
  for (l = 0; l < a.length; l++) {
    var c = ~~(l / 20), f = IU(Sm(d, 5), OU(c, h, n, u), i, a[l], kU[c]);
    i = u, u = n, n = Sm(h, 30), h = d, d = f;
  }
  this.h[0] = eu(this.h[0], d), this.h[1] = eu(this.h[1], h), this.h[2] = eu(this.h[2], n), this.h[3] = eu(this.h[3], u), this.h[4] = eu(this.h[4], i);
};
Ls.prototype._digest = function(e) {
  return e === "hex" ? hl.toHex32(this.h, "big") : hl.split32(this.h, "big");
};
var ml = yr, NU = Nl, Ml = qs, RU = Gi, Ji = ml.sum32, MU = ml.sum32_4, LU = ml.sum32_5, jU = Ml.ch32, FU = Ml.maj32, BU = Ml.s0_256, $U = Ml.s1_256, UU = Ml.g0_256, VU = Ml.g1_256, f3 = NU.BlockHash, WU = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function js() {
  if (!(this instanceof js))
    return new js();
  f3.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = WU, this.W = new Array(64);
}
ml.inherits(js, f3);
var d3 = js;
js.blockSize = 512;
js.outSize = 256;
js.hmacStrength = 192;
js.padLength = 64;
js.prototype._update = function(e, r) {
  for (var a = this.W, l = 0; l < 16; l++)
    a[l] = e[r + l];
  for (; l < a.length; l++)
    a[l] = MU(VU(a[l - 2]), a[l - 7], UU(a[l - 15]), a[l - 16]);
  var d = this.h[0], h = this.h[1], n = this.h[2], u = this.h[3], i = this.h[4], c = this.h[5], f = this.h[6], s = this.h[7];
  for (RU(this.k.length === a.length), l = 0; l < a.length; l++) {
    var o = LU(s, $U(i), jU(i, c, f), this.k[l], a[l]), y = Ji(BU(d), FU(d, h, n));
    s = f, f = c, c = i, i = Ji(u, o), u = n, n = h, h = d, d = Ji(o, y);
  }
  this.h[0] = Ji(this.h[0], d), this.h[1] = Ji(this.h[1], h), this.h[2] = Ji(this.h[2], n), this.h[3] = Ji(this.h[3], u), this.h[4] = Ji(this.h[4], i), this.h[5] = Ji(this.h[5], c), this.h[6] = Ji(this.h[6], f), this.h[7] = Ji(this.h[7], s);
};
js.prototype._digest = function(e) {
  return e === "hex" ? ml.toHex32(this.h, "big") : ml.split32(this.h, "big");
};
var L1 = yr, p3 = d3;
function sa() {
  if (!(this instanceof sa))
    return new sa();
  p3.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
L1.inherits(sa, p3);
var qU = sa;
sa.blockSize = 512;
sa.outSize = 224;
sa.hmacStrength = 192;
sa.padLength = 64;
sa.prototype._digest = function(e) {
  return e === "hex" ? L1.toHex32(this.h.slice(0, 7), "big") : L1.split32(this.h.slice(0, 7), "big");
};
var hi = yr, HU = Nl, GU = Gi, Cs = hi.rotr64_hi, Is = hi.rotr64_lo, h3 = hi.shr64_hi, m3 = hi.shr64_lo, ha = hi.sum64, wm = hi.sum64_hi, xm = hi.sum64_lo, zU = hi.sum64_4_hi, KU = hi.sum64_4_lo, YU = hi.sum64_5_hi, XU = hi.sum64_5_lo, y3 = HU.BlockHash, JU = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function ns() {
  if (!(this instanceof ns))
    return new ns();
  y3.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = JU, this.W = new Array(160);
}
hi.inherits(ns, y3);
var b3 = ns;
ns.blockSize = 1024;
ns.outSize = 512;
ns.hmacStrength = 192;
ns.padLength = 128;
ns.prototype._prepareBlock = function(e, r) {
  for (var a = this.W, l = 0; l < 32; l++)
    a[l] = e[r + l];
  for (; l < a.length; l += 2) {
    var d = lV(a[l - 4], a[l - 3]), h = uV(a[l - 4], a[l - 3]), n = a[l - 14], u = a[l - 13], i = aV(a[l - 30], a[l - 29]), c = oV(a[l - 30], a[l - 29]), f = a[l - 32], s = a[l - 31];
    a[l] = zU(
      d,
      h,
      n,
      u,
      i,
      c,
      f,
      s
    ), a[l + 1] = KU(
      d,
      h,
      n,
      u,
      i,
      c,
      f,
      s
    );
  }
};
ns.prototype._update = function(e, r) {
  this._prepareBlock(e, r);
  var a = this.W, l = this.h[0], d = this.h[1], h = this.h[2], n = this.h[3], u = this.h[4], i = this.h[5], c = this.h[6], f = this.h[7], s = this.h[8], o = this.h[9], y = this.h[10], m = this.h[11], g = this.h[12], b = this.h[13], v = this.h[14], T = this.h[15];
  GU(this.k.length === a.length);
  for (var E = 0; E < a.length; E += 2) {
    var O = v, D = T, $ = iV(s, o), I = sV(s, o), k = QU(s, o, y, m, g), L = ZU(s, o, y, m, g, b), M = this.k[E], x = this.k[E + 1], _ = a[E], S = a[E + 1], C = YU(
      O,
      D,
      $,
      I,
      k,
      L,
      M,
      x,
      _,
      S
    ), R = XU(
      O,
      D,
      $,
      I,
      k,
      L,
      M,
      x,
      _,
      S
    );
    O = rV(l, d), D = nV(l, d), $ = eV(l, d, h, n, u), I = tV(l, d, h, n, u, i);
    var H = wm(O, D, $, I), z = xm(O, D, $, I);
    v = g, T = b, g = y, b = m, y = s, m = o, s = wm(c, f, C, R), o = xm(f, f, C, R), c = u, f = i, u = h, i = n, h = l, n = d, l = wm(C, R, H, z), d = xm(C, R, H, z);
  }
  ha(this.h, 0, l, d), ha(this.h, 2, h, n), ha(this.h, 4, u, i), ha(this.h, 6, c, f), ha(this.h, 8, s, o), ha(this.h, 10, y, m), ha(this.h, 12, g, b), ha(this.h, 14, v, T);
};
ns.prototype._digest = function(e) {
  return e === "hex" ? hi.toHex32(this.h, "big") : hi.split32(this.h, "big");
};
function QU(t, e, r, a, l) {
  var d = t & r ^ ~t & l;
  return d < 0 && (d += 4294967296), d;
}
function ZU(t, e, r, a, l, d) {
  var h = e & a ^ ~e & d;
  return h < 0 && (h += 4294967296), h;
}
function eV(t, e, r, a, l) {
  var d = t & r ^ t & l ^ r & l;
  return d < 0 && (d += 4294967296), d;
}
function tV(t, e, r, a, l, d) {
  var h = e & a ^ e & d ^ a & d;
  return h < 0 && (h += 4294967296), h;
}
function rV(t, e) {
  var r = Cs(t, e, 28), a = Cs(e, t, 2), l = Cs(e, t, 7), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function nV(t, e) {
  var r = Is(t, e, 28), a = Is(e, t, 2), l = Is(e, t, 7), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function iV(t, e) {
  var r = Cs(t, e, 14), a = Cs(t, e, 18), l = Cs(e, t, 9), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function sV(t, e) {
  var r = Is(t, e, 14), a = Is(t, e, 18), l = Is(e, t, 9), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function aV(t, e) {
  var r = Cs(t, e, 1), a = Cs(t, e, 8), l = h3(t, e, 7), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function oV(t, e) {
  var r = Is(t, e, 1), a = Is(t, e, 8), l = m3(t, e, 7), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function lV(t, e) {
  var r = Cs(t, e, 19), a = Cs(e, t, 29), l = h3(t, e, 6), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
function uV(t, e) {
  var r = Is(t, e, 19), a = Is(e, t, 29), l = m3(t, e, 6), d = r ^ a ^ l;
  return d < 0 && (d += 4294967296), d;
}
var j1 = yr, g3 = b3;
function aa() {
  if (!(this instanceof aa))
    return new aa();
  g3.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
j1.inherits(aa, g3);
var cV = aa;
aa.blockSize = 1024;
aa.outSize = 384;
aa.hmacStrength = 192;
aa.padLength = 128;
aa.prototype._digest = function(e) {
  return e === "hex" ? j1.toHex32(this.h.slice(0, 12), "big") : j1.split32(this.h.slice(0, 12), "big");
};
Rl.sha1 = DU;
Rl.sha224 = qU;
Rl.sha256 = d3;
Rl.sha384 = cV;
Rl.sha512 = b3;
var v3 = {}, oo = yr, fV = Nl, Qc = oo.rotl32, Z_ = oo.sum32, tu = oo.sum32_3, eS = oo.sum32_4, E3 = fV.BlockHash;
function Fs() {
  if (!(this instanceof Fs))
    return new Fs();
  E3.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
oo.inherits(Fs, E3);
v3.ripemd160 = Fs;
Fs.blockSize = 512;
Fs.outSize = 160;
Fs.hmacStrength = 192;
Fs.padLength = 64;
Fs.prototype._update = function(e, r) {
  for (var a = this.h[0], l = this.h[1], d = this.h[2], h = this.h[3], n = this.h[4], u = a, i = l, c = d, f = h, s = n, o = 0; o < 80; o++) {
    var y = Z_(
      Qc(
        eS(a, tS(o, l, d, h), e[hV[o] + r], dV(o)),
        yV[o]
      ),
      n
    );
    a = n, n = h, h = Qc(d, 10), d = l, l = y, y = Z_(
      Qc(
        eS(u, tS(79 - o, i, c, f), e[mV[o] + r], pV(o)),
        bV[o]
      ),
      s
    ), u = s, s = f, f = Qc(c, 10), c = i, i = y;
  }
  y = tu(this.h[1], d, f), this.h[1] = tu(this.h[2], h, s), this.h[2] = tu(this.h[3], n, u), this.h[3] = tu(this.h[4], a, i), this.h[4] = tu(this.h[0], l, c), this.h[0] = y;
};
Fs.prototype._digest = function(e) {
  return e === "hex" ? oo.toHex32(this.h, "little") : oo.split32(this.h, "little");
};
function tS(t, e, r, a) {
  return t <= 15 ? e ^ r ^ a : t <= 31 ? e & r | ~e & a : t <= 47 ? (e | ~r) ^ a : t <= 63 ? e & a | r & ~a : e ^ (r | ~a);
}
function dV(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function pV(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var hV = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], mV = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], yV = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], bV = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], gV = yr, vV = Gi;
function yl(t, e, r) {
  if (!(this instanceof yl))
    return new yl(t, e, r);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(gV.toArray(e, r));
}
var EV = yl;
yl.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), vV(e.length <= this.blockSize);
  for (var r = e.length; r < this.blockSize; r++)
    e.push(0);
  for (r = 0; r < e.length; r++)
    e[r] ^= 54;
  for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
    e[r] ^= 106;
  this.outer = new this.Hash().update(e);
};
yl.prototype.update = function(e, r) {
  return this.inner.update(e, r), this;
};
yl.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = yr, e.common = Nl, e.sha = Rl, e.ripemd = v3, e.hmac = EV, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(Ep);
var Tm, rS;
function _V() {
  return rS || (rS = 1, Tm = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), Tm;
}
(function(t) {
  var e = t, r = Ep, a = $b, l = Ai, d = l.assert;
  function h(i) {
    i.type === "short" ? this.curve = new a.short(i) : i.type === "edwards" ? this.curve = new a.edwards(i) : this.curve = new a.mont(i), this.g = this.curve.g, this.n = this.curve.n, this.hash = i.hash, d(this.g.validate(), "Invalid curve"), d(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = h;
  function n(i, c) {
    Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var f = new h(c);
        return Object.defineProperty(e, i, {
          configurable: !0,
          enumerable: !0,
          value: f
        }), f;
      }
    });
  }
  n("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: r.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), n("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: r.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), n("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: r.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), n("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: r.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), n("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: r.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), n("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), n("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var u;
  try {
    u = _V();
  } catch {
    u = void 0;
  }
  n("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: r.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      u
    ]
  });
})(vp);
var SV = Ep, no = Bb, _3 = Gi;
function Ca(t) {
  if (!(this instanceof Ca))
    return new Ca(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = no.toArray(t.entropy, t.entropyEnc || "hex"), r = no.toArray(t.nonce, t.nonceEnc || "hex"), a = no.toArray(t.pers, t.persEnc || "hex");
  _3(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, a);
}
var wV = Ca;
Ca.prototype._init = function(e, r, a) {
  var l = e.concat(r).concat(a);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var d = 0; d < this.V.length; d++)
    this.K[d] = 0, this.V[d] = 1;
  this._update(l), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Ca.prototype._hmac = function() {
  return new SV.hmac(this.hash, this.K);
};
Ca.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Ca.prototype.reseed = function(e, r, a, l) {
  typeof r != "string" && (l = a, a = r, r = null), e = no.toArray(e, r), a = no.toArray(a, l), _3(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(a || [])), this._reseed = 1;
};
Ca.prototype.generate = function(e, r, a, l) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (l = a, a = r, r = null), a && (a = no.toArray(a, l || "hex"), this._update(a));
  for (var d = []; d.length < e; )
    this.V = this._hmac().update(this.V).digest(), d = d.concat(this.V);
  var h = d.slice(0, e);
  return this._update(a), this._reseed++, no.encode(h, r);
};
var xV = Gn, TV = Ai, F1 = TV.assert;
function ei(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var AV = ei;
ei.fromPublic = function(e, r, a) {
  return r instanceof ei ? r : new ei(e, {
    pub: r,
    pubEnc: a
  });
};
ei.fromPrivate = function(e, r, a) {
  return r instanceof ei ? r : new ei(e, {
    priv: r,
    privEnc: a
  });
};
ei.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
ei.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
ei.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
ei.prototype._importPrivate = function(e, r) {
  this.priv = new xV(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
ei.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? F1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && F1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
ei.prototype.derive = function(e) {
  return e.validate() || F1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
ei.prototype.sign = function(e, r, a) {
  return this.ec.sign(e, this, r, a);
};
ei.prototype.verify = function(e, r) {
  return this.ec.verify(e, r, this);
};
ei.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var ed = Gn, Vb = Ai, PV = Vb.assert;
function Sp(t, e) {
  if (t instanceof Sp)
    return t;
  this._importDER(t, e) || (PV(t.r && t.s, "Signature without r or s"), this.r = new ed(t.r, 16), this.s = new ed(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var CV = Sp;
function IV() {
  this.place = 0;
}
function Am(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var a = r & 15;
  if (a === 0 || a > 4)
    return !1;
  for (var l = 0, d = 0, h = e.place; d < a; d++, h++)
    l <<= 8, l |= t[h], l >>>= 0;
  return l <= 127 ? !1 : (e.place = h, l);
}
function nS(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
Sp.prototype._importDER = function(e, r) {
  e = Vb.toArray(e, r);
  var a = new IV();
  if (e[a.place++] !== 48)
    return !1;
  var l = Am(e, a);
  if (l === !1 || l + a.place !== e.length || e[a.place++] !== 2)
    return !1;
  var d = Am(e, a);
  if (d === !1)
    return !1;
  var h = e.slice(a.place, d + a.place);
  if (a.place += d, e[a.place++] !== 2)
    return !1;
  var n = Am(e, a);
  if (n === !1 || e.length !== n + a.place)
    return !1;
  var u = e.slice(a.place, n + a.place);
  if (h[0] === 0)
    if (h[1] & 128)
      h = h.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new ed(h), this.s = new ed(u), this.recoveryParam = null, !0;
};
function Pm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
Sp.prototype.toDER = function(e) {
  var r = this.r.toArray(), a = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), a[0] & 128 && (a = [0].concat(a)), r = nS(r), a = nS(a); !a[0] && !(a[1] & 128); )
    a = a.slice(1);
  var l = [2];
  Pm(l, r.length), l = l.concat(r), l.push(2), Pm(l, a.length);
  var d = l.concat(a), h = [48];
  return Pm(h, d.length), h = h.concat(d), Vb.encode(h, e);
};
var Cm, iS;
function OV() {
  if (iS) return Cm;
  iS = 1;
  var t = Gn, e = wV, r = Ai, a = vp, l = Mb(), d = r.assert, h = AV, n = CV;
  function u(i) {
    if (!(this instanceof u))
      return new u(i);
    typeof i == "string" && (d(
      Object.prototype.hasOwnProperty.call(a, i),
      "Unknown curve " + i
    ), i = a[i]), i instanceof a.PresetCurve && (i = { curve: i }), this.curve = i.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = i.curve.g, this.g.precompute(i.curve.n.bitLength() + 1), this.hash = i.hash || i.curve.hash;
  }
  return Cm = u, u.prototype.keyPair = function(c) {
    return new h(this, c);
  }, u.prototype.keyFromPrivate = function(c, f) {
    return h.fromPrivate(this, c, f);
  }, u.prototype.keyFromPublic = function(c, f) {
    return h.fromPublic(this, c, f);
  }, u.prototype.genKeyPair = function(c) {
    c || (c = {});
    for (var f = new e({
      hash: this.hash,
      pers: c.pers,
      persEnc: c.persEnc || "utf8",
      entropy: c.entropy || l(this.hash.hmacStrength),
      entropyEnc: c.entropy && c.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), s = this.n.byteLength(), o = this.n.sub(new t(2)); ; ) {
      var y = new t(f.generate(s));
      if (!(y.cmp(o) > 0))
        return y.iaddn(1), this.keyFromPrivate(y);
    }
  }, u.prototype._truncateToN = function(c, f) {
    var s = c.byteLength() * 8 - this.n.bitLength();
    return s > 0 && (c = c.ushrn(s)), !f && c.cmp(this.n) >= 0 ? c.sub(this.n) : c;
  }, u.prototype.sign = function(c, f, s, o) {
    typeof s == "object" && (o = s, s = null), o || (o = {}), f = this.keyFromPrivate(f, s), c = this._truncateToN(new t(c, 16));
    for (var y = this.n.byteLength(), m = f.getPrivate().toArray("be", y), g = c.toArray("be", y), b = new e({
      hash: this.hash,
      entropy: m,
      nonce: g,
      pers: o.pers,
      persEnc: o.persEnc || "utf8"
    }), v = this.n.sub(new t(1)), T = 0; ; T++) {
      var E = o.k ? o.k(T) : new t(b.generate(this.n.byteLength()));
      if (E = this._truncateToN(E, !0), !(E.cmpn(1) <= 0 || E.cmp(v) >= 0)) {
        var O = this.g.mul(E);
        if (!O.isInfinity()) {
          var D = O.getX(), $ = D.umod(this.n);
          if ($.cmpn(0) !== 0) {
            var I = E.invm(this.n).mul($.mul(f.getPrivate()).iadd(c));
            if (I = I.umod(this.n), I.cmpn(0) !== 0) {
              var k = (O.getY().isOdd() ? 1 : 0) | (D.cmp($) !== 0 ? 2 : 0);
              return o.canonical && I.cmp(this.nh) > 0 && (I = this.n.sub(I), k ^= 1), new n({ r: $, s: I, recoveryParam: k });
            }
          }
        }
      }
    }
  }, u.prototype.verify = function(c, f, s, o) {
    c = this._truncateToN(new t(c, 16)), s = this.keyFromPublic(s, o), f = new n(f, "hex");
    var y = f.r, m = f.s;
    if (y.cmpn(1) < 0 || y.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
      return !1;
    var g = m.invm(this.n), b = g.mul(c).umod(this.n), v = g.mul(y).umod(this.n), T;
    return this.curve._maxwellTrick ? (T = this.g.jmulAdd(b, s.getPublic(), v), T.isInfinity() ? !1 : T.eqXToP(y)) : (T = this.g.mulAdd(b, s.getPublic(), v), T.isInfinity() ? !1 : T.getX().umod(this.n).cmp(y) === 0);
  }, u.prototype.recoverPubKey = function(i, c, f, s) {
    d((3 & f) === f, "The recovery param is more than two bits"), c = new n(c, s);
    var o = this.n, y = new t(i), m = c.r, g = c.s, b = f & 1, v = f >> 1;
    if (m.cmp(this.curve.p.umod(this.curve.n)) >= 0 && v)
      throw new Error("Unable to find sencond key candinate");
    v ? m = this.curve.pointFromX(m.add(this.curve.n), b) : m = this.curve.pointFromX(m, b);
    var T = c.r.invm(o), E = o.sub(y).mul(T).umod(o), O = g.mul(T).umod(o);
    return this.g.mulAdd(E, m, O);
  }, u.prototype.getKeyRecoveryParam = function(i, c, f, s) {
    if (c = new n(c, s), c.recoveryParam !== null)
      return c.recoveryParam;
    for (var o = 0; o < 4; o++) {
      var y;
      try {
        y = this.recoverPubKey(i, c, o);
      } catch {
        continue;
      }
      if (y.eq(f))
        return o;
    }
    throw new Error("Unable to find valid recovery factor");
  }, Cm;
}
var fc = Ai, S3 = fc.assert, sS = fc.parseBytes, Ll = fc.cachedProperty;
function jn(t, e) {
  this.eddsa = t, this._secret = sS(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = sS(e.pub);
}
jn.fromPublic = function(e, r) {
  return r instanceof jn ? r : new jn(e, { pub: r });
};
jn.fromSecret = function(e, r) {
  return r instanceof jn ? r : new jn(e, { secret: r });
};
jn.prototype.secret = function() {
  return this._secret;
};
Ll(jn, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
Ll(jn, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
Ll(jn, "privBytes", function() {
  var e = this.eddsa, r = this.hash(), a = e.encodingLength - 1, l = r.slice(0, e.encodingLength);
  return l[0] &= 248, l[a] &= 127, l[a] |= 64, l;
});
Ll(jn, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
Ll(jn, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
Ll(jn, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
jn.prototype.sign = function(e) {
  return S3(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
jn.prototype.verify = function(e, r) {
  return this.eddsa.verify(e, r, this);
};
jn.prototype.getSecret = function(e) {
  return S3(this._secret, "KeyPair is public only"), fc.encode(this.secret(), e);
};
jn.prototype.getPublic = function(e) {
  return fc.encode(this.pubBytes(), e);
};
var kV = jn, DV = Gn, wp = Ai, NV = wp.assert, xp = wp.cachedProperty, RV = wp.parseBytes;
function vo(t, e) {
  this.eddsa = t, typeof e != "object" && (e = RV(e)), Array.isArray(e) && (e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), NV(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof DV && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
xp(vo, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
xp(vo, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
xp(vo, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
xp(vo, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
vo.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
vo.prototype.toHex = function() {
  return wp.encode(this.toBytes(), "hex").toUpperCase();
};
var MV = vo, LV = Ep, jV = vp, bl = Ai, FV = bl.assert, w3 = bl.parseBytes, x3 = kV, aS = MV;
function mi(t) {
  if (FV(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof mi))
    return new mi(t);
  t = jV[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = LV.sha512;
}
var BV = mi;
mi.prototype.sign = function(e, r) {
  e = w3(e);
  var a = this.keyFromSecret(r), l = this.hashInt(a.messagePrefix(), e), d = this.g.mul(l), h = this.encodePoint(d), n = this.hashInt(h, a.pubBytes(), e).mul(a.priv()), u = l.add(n).umod(this.curve.n);
  return this.makeSignature({ R: d, S: u, Rencoded: h });
};
mi.prototype.verify = function(e, r, a) {
  e = w3(e), r = this.makeSignature(r);
  var l = this.keyFromPublic(a), d = this.hashInt(r.Rencoded(), l.pubBytes(), e), h = this.g.mul(r.S()), n = r.R().add(l.pub().mul(d));
  return n.eq(h);
};
mi.prototype.hashInt = function() {
  for (var e = this.hash(), r = 0; r < arguments.length; r++)
    e.update(arguments[r]);
  return bl.intFromLE(e.digest()).umod(this.curve.n);
};
mi.prototype.keyFromPublic = function(e) {
  return x3.fromPublic(this, e);
};
mi.prototype.keyFromSecret = function(e) {
  return x3.fromSecret(this, e);
};
mi.prototype.makeSignature = function(e) {
  return e instanceof aS ? e : new aS(this, e);
};
mi.prototype.encodePoint = function(e) {
  var r = e.getY().toArray("le", this.encodingLength);
  return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
};
mi.prototype.decodePoint = function(e) {
  e = bl.parseBytes(e);
  var r = e.length - 1, a = e.slice(0, r).concat(e[r] & -129), l = (e[r] & 128) !== 0, d = bl.intFromLE(a);
  return this.curve.pointFromY(d, l);
};
mi.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
mi.prototype.decodeInt = function(e) {
  return bl.intFromLE(e);
};
mi.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var oS;
function Wb() {
  return oS || (oS = 1, function(t) {
    var e = t;
    e.version = B$.version, e.utils = Ai, e.rand = Mb(), e.curve = $b, e.curves = vp, e.ec = OV(), e.eddsa = BV;
  }(_m)), _m;
}
var ls = {}, Im = {}, Om = {}, lS;
function $V() {
  return lS || (lS = 1, function(t) {
    var e = dc(), r = ir, a = t;
    a.define = function(h, n) {
      return new l(h, n);
    };
    function l(d, h) {
      this.name = d, this.body = h, this.decoders = {}, this.encoders = {};
    }
    l.prototype._createNamed = function(h) {
      var n;
      try {
        n = Rr.runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        n = function(i) {
          this._initNamed(i);
        };
      }
      return r(n, h), n.prototype._initNamed = function(i) {
        h.call(this, i);
      }, new n(this);
    }, l.prototype._getDecoder = function(h) {
      return h = h || "der", this.decoders.hasOwnProperty(h) || (this.decoders[h] = this._createNamed(e.decoders[h])), this.decoders[h];
    }, l.prototype.decode = function(h, n, u) {
      return this._getDecoder(n).decode(h, u);
    }, l.prototype._getEncoder = function(h) {
      return h = h || "der", this.encoders.hasOwnProperty(h) || (this.encoders[h] = this._createNamed(e.encoders[h])), this.encoders[h];
    }, l.prototype.encode = function(h, n, u) {
      return this._getEncoder(n).encode(h, u);
    };
  }(Om)), Om;
}
var km = {}, T3 = {}, UV = ir;
function Xi(t) {
  this._reporterState = {
    obj: null,
    path: [],
    options: t || {},
    errors: []
  };
}
T3.Reporter = Xi;
Xi.prototype.isError = function(e) {
  return e instanceof gl;
};
Xi.prototype.save = function() {
  var e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
Xi.prototype.restore = function(e) {
  var r = this._reporterState;
  r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
};
Xi.prototype.enterKey = function(e) {
  return this._reporterState.path.push(e);
};
Xi.prototype.exitKey = function(e) {
  var r = this._reporterState;
  r.path = r.path.slice(0, e - 1);
};
Xi.prototype.leaveKey = function(e, r, a) {
  var l = this._reporterState;
  this.exitKey(e), l.obj !== null && (l.obj[r] = a);
};
Xi.prototype.path = function() {
  return this._reporterState.path.join("/");
};
Xi.prototype.enterObject = function() {
  var e = this._reporterState, r = e.obj;
  return e.obj = {}, r;
};
Xi.prototype.leaveObject = function(e) {
  var r = this._reporterState, a = r.obj;
  return r.obj = e, a;
};
Xi.prototype.error = function(e) {
  var r, a = this._reporterState, l = e instanceof gl;
  if (l ? r = e : r = new gl(a.path.map(function(d) {
    return "[" + JSON.stringify(d) + "]";
  }).join(""), e.message || e, e.stack), !a.options.partial)
    throw r;
  return l || a.errors.push(r), r;
};
Xi.prototype.wrapResult = function(e) {
  var r = this._reporterState;
  return r.options.partial ? {
    result: this.isError(e) ? null : e,
    errors: r.errors
  } : e;
};
function gl(t, e) {
  this.path = t, this.rethrow(e);
}
UV(gl, Error);
gl.prototype.rethrow = function(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, gl), !this.stack)
    try {
      throw new Error(this.message);
    } catch (r) {
      this.stack = r.stack;
    }
  return this;
};
var Zc = {}, uS;
function cS() {
  if (uS) return Zc;
  uS = 1;
  var t = ir, e = gu().Reporter, r = Ui.Buffer;
  function a(d, h) {
    if (e.call(this, h), !r.isBuffer(d)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = d, this.offset = 0, this.length = d.length;
  }
  t(a, e), Zc.DecoderBuffer = a, a.prototype.save = function() {
    return { offset: this.offset, reporter: e.prototype.save.call(this) };
  }, a.prototype.restore = function(h) {
    var n = new a(this.base);
    return n.offset = h.offset, n.length = this.offset, this.offset = h.offset, e.prototype.restore.call(this, h.reporter), n;
  }, a.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, a.prototype.readUInt8 = function(h) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(h || "DecoderBuffer overrun");
  }, a.prototype.skip = function(h, n) {
    if (!(this.offset + h <= this.length))
      return this.error(n || "DecoderBuffer overrun");
    var u = new a(this.base);
    return u._reporterState = this._reporterState, u.offset = this.offset, u.length = this.offset + h, this.offset += h, u;
  }, a.prototype.raw = function(h) {
    return this.base.slice(h ? h.offset : this.offset, this.length);
  };
  function l(d, h) {
    if (Array.isArray(d))
      this.length = 0, this.value = d.map(function(n) {
        return n instanceof l || (n = new l(n, h)), this.length += n.length, n;
      }, this);
    else if (typeof d == "number") {
      if (!(0 <= d && d <= 255))
        return h.error("non-byte EncoderBuffer value");
      this.value = d, this.length = 1;
    } else if (typeof d == "string")
      this.value = d, this.length = r.byteLength(d);
    else if (r.isBuffer(d))
      this.value = d, this.length = d.length;
    else
      return h.error("Unsupported type: " + typeof d);
  }
  return Zc.EncoderBuffer = l, l.prototype.join = function(h, n) {
    return h || (h = new r(this.length)), n || (n = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(u) {
      u.join(h, n), n += u.length;
    }) : (typeof this.value == "number" ? h[n] = this.value : typeof this.value == "string" ? h.write(this.value, n) : r.isBuffer(this.value) && this.value.copy(h, n), n += this.length)), h;
  }, Zc;
}
var Dm, fS;
function VV() {
  if (fS) return Dm;
  fS = 1;
  var t = gu().Reporter, e = gu().EncoderBuffer, r = gu().DecoderBuffer, a = Gi, l = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], d = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(l), h = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function n(i, c) {
    var f = {};
    this._baseState = f, f.enc = i, f.parent = c || null, f.children = null, f.tag = null, f.args = null, f.reverseArgs = null, f.choice = null, f.optional = !1, f.any = !1, f.obj = !1, f.use = null, f.useDecoder = null, f.key = null, f.default = null, f.explicit = null, f.implicit = null, f.contains = null, f.parent || (f.children = [], this._wrap());
  }
  Dm = n;
  var u = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return n.prototype.clone = function() {
    var c = this._baseState, f = {};
    u.forEach(function(o) {
      f[o] = c[o];
    });
    var s = new this.constructor(f.parent);
    return s._baseState = f, s;
  }, n.prototype._wrap = function() {
    var c = this._baseState;
    d.forEach(function(f) {
      this[f] = function() {
        var o = new this.constructor(this);
        return c.children.push(o), o[f].apply(o, arguments);
      };
    }, this);
  }, n.prototype._init = function(c) {
    var f = this._baseState;
    a(f.parent === null), c.call(this), f.children = f.children.filter(function(s) {
      return s._baseState.parent === this;
    }, this), a.equal(f.children.length, 1, "Root node can have only one child");
  }, n.prototype._useArgs = function(c) {
    var f = this._baseState, s = c.filter(function(o) {
      return o instanceof this.constructor;
    }, this);
    c = c.filter(function(o) {
      return !(o instanceof this.constructor);
    }, this), s.length !== 0 && (a(f.children === null), f.children = s, s.forEach(function(o) {
      o._baseState.parent = this;
    }, this)), c.length !== 0 && (a(f.args === null), f.args = c, f.reverseArgs = c.map(function(o) {
      if (typeof o != "object" || o.constructor !== Object)
        return o;
      var y = {};
      return Object.keys(o).forEach(function(m) {
        m == (m | 0) && (m |= 0);
        var g = o[m];
        y[g] = m;
      }), y;
    }));
  }, h.forEach(function(i) {
    n.prototype[i] = function() {
      var f = this._baseState;
      throw new Error(i + " not implemented for encoding: " + f.enc);
    };
  }), l.forEach(function(i) {
    n.prototype[i] = function() {
      var f = this._baseState, s = Array.prototype.slice.call(arguments);
      return a(f.tag === null), f.tag = i, this._useArgs(s), this;
    };
  }), n.prototype.use = function(c) {
    a(c);
    var f = this._baseState;
    return a(f.use === null), f.use = c, this;
  }, n.prototype.optional = function() {
    var c = this._baseState;
    return c.optional = !0, this;
  }, n.prototype.def = function(c) {
    var f = this._baseState;
    return a(f.default === null), f.default = c, f.optional = !0, this;
  }, n.prototype.explicit = function(c) {
    var f = this._baseState;
    return a(f.explicit === null && f.implicit === null), f.explicit = c, this;
  }, n.prototype.implicit = function(c) {
    var f = this._baseState;
    return a(f.explicit === null && f.implicit === null), f.implicit = c, this;
  }, n.prototype.obj = function() {
    var c = this._baseState, f = Array.prototype.slice.call(arguments);
    return c.obj = !0, f.length !== 0 && this._useArgs(f), this;
  }, n.prototype.key = function(c) {
    var f = this._baseState;
    return a(f.key === null), f.key = c, this;
  }, n.prototype.any = function() {
    var c = this._baseState;
    return c.any = !0, this;
  }, n.prototype.choice = function(c) {
    var f = this._baseState;
    return a(f.choice === null), f.choice = c, this._useArgs(Object.keys(c).map(function(s) {
      return c[s];
    })), this;
  }, n.prototype.contains = function(c) {
    var f = this._baseState;
    return a(f.use === null), f.contains = c, this;
  }, n.prototype._decode = function(c, f) {
    var s = this._baseState;
    if (s.parent === null)
      return c.wrapResult(s.children[0]._decode(c, f));
    var o = s.default, y = !0, m = null;
    if (s.key !== null && (m = c.enterKey(s.key)), s.optional) {
      var g = null;
      if (s.explicit !== null ? g = s.explicit : s.implicit !== null ? g = s.implicit : s.tag !== null && (g = s.tag), g === null && !s.any) {
        var b = c.save();
        try {
          s.choice === null ? this._decodeGeneric(s.tag, c, f) : this._decodeChoice(c, f), y = !0;
        } catch {
          y = !1;
        }
        c.restore(b);
      } else if (y = this._peekTag(c, g, s.any), c.isError(y))
        return y;
    }
    var v;
    if (s.obj && y && (v = c.enterObject()), y) {
      if (s.explicit !== null) {
        var T = this._decodeTag(c, s.explicit);
        if (c.isError(T))
          return T;
        c = T;
      }
      var E = c.offset;
      if (s.use === null && s.choice === null) {
        if (s.any)
          var b = c.save();
        var O = this._decodeTag(
          c,
          s.implicit !== null ? s.implicit : s.tag,
          s.any
        );
        if (c.isError(O))
          return O;
        s.any ? o = c.raw(b) : c = O;
      }
      if (f && f.track && s.tag !== null && f.track(c.path(), E, c.length, "tagged"), f && f.track && s.tag !== null && f.track(c.path(), c.offset, c.length, "content"), s.any ? o = o : s.choice === null ? o = this._decodeGeneric(s.tag, c, f) : o = this._decodeChoice(c, f), c.isError(o))
        return o;
      if (!s.any && s.choice === null && s.children !== null && s.children.forEach(function(I) {
        I._decode(c, f);
      }), s.contains && (s.tag === "octstr" || s.tag === "bitstr")) {
        var D = new r(o);
        o = this._getUse(s.contains, c._reporterState.obj)._decode(D, f);
      }
    }
    return s.obj && y && (o = c.leaveObject(v)), s.key !== null && (o !== null || y === !0) ? c.leaveKey(m, s.key, o) : m !== null && c.exitKey(m), o;
  }, n.prototype._decodeGeneric = function(c, f, s) {
    var o = this._baseState;
    return c === "seq" || c === "set" ? null : c === "seqof" || c === "setof" ? this._decodeList(f, c, o.args[0], s) : /str$/.test(c) ? this._decodeStr(f, c, s) : c === "objid" && o.args ? this._decodeObjid(f, o.args[0], o.args[1], s) : c === "objid" ? this._decodeObjid(f, null, null, s) : c === "gentime" || c === "utctime" ? this._decodeTime(f, c, s) : c === "null_" ? this._decodeNull(f, s) : c === "bool" ? this._decodeBool(f, s) : c === "objDesc" ? this._decodeStr(f, c, s) : c === "int" || c === "enum" ? this._decodeInt(f, o.args && o.args[0], s) : o.use !== null ? this._getUse(o.use, f._reporterState.obj)._decode(f, s) : f.error("unknown tag: " + c);
  }, n.prototype._getUse = function(c, f) {
    var s = this._baseState;
    return s.useDecoder = this._use(c, f), a(s.useDecoder._baseState.parent === null), s.useDecoder = s.useDecoder._baseState.children[0], s.implicit !== s.useDecoder._baseState.implicit && (s.useDecoder = s.useDecoder.clone(), s.useDecoder._baseState.implicit = s.implicit), s.useDecoder;
  }, n.prototype._decodeChoice = function(c, f) {
    var s = this._baseState, o = null, y = !1;
    return Object.keys(s.choice).some(function(m) {
      var g = c.save(), b = s.choice[m];
      try {
        var v = b._decode(c, f);
        if (c.isError(v))
          return !1;
        o = { type: m, value: v }, y = !0;
      } catch {
        return c.restore(g), !1;
      }
      return !0;
    }, this), y ? o : c.error("Choice not matched");
  }, n.prototype._createEncoderBuffer = function(c) {
    return new e(c, this.reporter);
  }, n.prototype._encode = function(c, f, s) {
    var o = this._baseState;
    if (!(o.default !== null && o.default === c)) {
      var y = this._encodeValue(c, f, s);
      if (y !== void 0 && !this._skipDefault(y, f, s))
        return y;
    }
  }, n.prototype._encodeValue = function(c, f, s) {
    var o = this._baseState;
    if (o.parent === null)
      return o.children[0]._encode(c, f || new t());
    var b = null;
    if (this.reporter = f, o.optional && c === void 0)
      if (o.default !== null)
        c = o.default;
      else
        return;
    var y = null, m = !1;
    if (o.any)
      b = this._createEncoderBuffer(c);
    else if (o.choice)
      b = this._encodeChoice(c, f);
    else if (o.contains)
      y = this._getUse(o.contains, s)._encode(c, f), m = !0;
    else if (o.children)
      y = o.children.map(function(E) {
        if (E._baseState.tag === "null_")
          return E._encode(null, f, c);
        if (E._baseState.key === null)
          return f.error("Child should have a key");
        var O = f.enterKey(E._baseState.key);
        if (typeof c != "object")
          return f.error("Child expected, but input is not object");
        var D = E._encode(c[E._baseState.key], f, c);
        return f.leaveKey(O), D;
      }, this).filter(function(E) {
        return E;
      }), y = this._createEncoderBuffer(y);
    else if (o.tag === "seqof" || o.tag === "setof") {
      if (!(o.args && o.args.length === 1))
        return f.error("Too many args for : " + o.tag);
      if (!Array.isArray(c))
        return f.error("seqof/setof, but data is not Array");
      var g = this.clone();
      g._baseState.implicit = null, y = this._createEncoderBuffer(c.map(function(E) {
        var O = this._baseState;
        return this._getUse(O.args[0], c)._encode(E, f);
      }, g));
    } else o.use !== null ? b = this._getUse(o.use, s)._encode(c, f) : (y = this._encodePrimitive(o.tag, c), m = !0);
    var b;
    if (!o.any && o.choice === null) {
      var v = o.implicit !== null ? o.implicit : o.tag, T = o.implicit === null ? "universal" : "context";
      v === null ? o.use === null && f.error("Tag could be omitted only for .use()") : o.use === null && (b = this._encodeComposite(v, m, T, y));
    }
    return o.explicit !== null && (b = this._encodeComposite(o.explicit, !1, "context", b)), b;
  }, n.prototype._encodeChoice = function(c, f) {
    var s = this._baseState, o = s.choice[c.type];
    return o || a(
      !1,
      c.type + " not found in " + JSON.stringify(Object.keys(s.choice))
    ), o._encode(c.value, f);
  }, n.prototype._encodePrimitive = function(c, f) {
    var s = this._baseState;
    if (/str$/.test(c))
      return this._encodeStr(f, c);
    if (c === "objid" && s.args)
      return this._encodeObjid(f, s.reverseArgs[0], s.args[1]);
    if (c === "objid")
      return this._encodeObjid(f, null, null);
    if (c === "gentime" || c === "utctime")
      return this._encodeTime(f, c);
    if (c === "null_")
      return this._encodeNull();
    if (c === "int" || c === "enum")
      return this._encodeInt(f, s.args && s.reverseArgs[0]);
    if (c === "bool")
      return this._encodeBool(f);
    if (c === "objDesc")
      return this._encodeStr(f, c);
    throw new Error("Unsupported tag: " + c);
  }, n.prototype._isNumstr = function(c) {
    return /^[0-9 ]*$/.test(c);
  }, n.prototype._isPrintstr = function(c) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(c);
  }, Dm;
}
var dS;
function gu() {
  return dS || (dS = 1, function(t) {
    var e = t;
    e.Reporter = T3.Reporter, e.DecoderBuffer = cS().DecoderBuffer, e.EncoderBuffer = cS().EncoderBuffer, e.Node = VV();
  }(km)), km;
}
var Nm = {}, Rm = {}, pS;
function WV() {
  return pS || (pS = 1, function(t) {
    var e = A3();
    t.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, t.tagClassByName = e._reverse(t.tagClass), t.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, t.tagByName = e._reverse(t.tag);
  }(Rm)), Rm;
}
var hS;
function A3() {
  return hS || (hS = 1, function(t) {
    var e = t;
    e._reverse = function(a) {
      var l = {};
      return Object.keys(a).forEach(function(d) {
        (d | 0) == d && (d = d | 0);
        var h = a[d];
        l[h] = d;
      }), l;
    }, e.der = WV();
  }(Nm)), Nm;
}
var Mm = {}, Lm, mS;
function P3() {
  if (mS) return Lm;
  mS = 1;
  var t = ir, e = dc(), r = e.base, a = e.bignum, l = e.constants.der;
  function d(i) {
    this.enc = "der", this.name = i.name, this.entity = i, this.tree = new h(), this.tree._init(i.body);
  }
  Lm = d, d.prototype.decode = function(c, f) {
    return c instanceof r.DecoderBuffer || (c = new r.DecoderBuffer(c, f)), this.tree._decode(c, f);
  };
  function h(i) {
    r.Node.call(this, "der", i);
  }
  t(h, r.Node), h.prototype._peekTag = function(c, f, s) {
    if (c.isEmpty())
      return !1;
    var o = c.save(), y = n(c, 'Failed to peek tag: "' + f + '"');
    return c.isError(y) ? y : (c.restore(o), y.tag === f || y.tagStr === f || y.tagStr + "of" === f || s);
  }, h.prototype._decodeTag = function(c, f, s) {
    var o = n(
      c,
      'Failed to decode tag of "' + f + '"'
    );
    if (c.isError(o))
      return o;
    var y = u(
      c,
      o.primitive,
      'Failed to get length of "' + f + '"'
    );
    if (c.isError(y))
      return y;
    if (!s && o.tag !== f && o.tagStr !== f && o.tagStr + "of" !== f)
      return c.error('Failed to match tag: "' + f + '"');
    if (o.primitive || y !== null)
      return c.skip(y, 'Failed to match body of: "' + f + '"');
    var m = c.save(), g = this._skipUntilEnd(
      c,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return c.isError(g) ? g : (y = c.offset - m.offset, c.restore(m), c.skip(y, 'Failed to match body of: "' + f + '"'));
  }, h.prototype._skipUntilEnd = function(c, f) {
    for (; ; ) {
      var s = n(c, f);
      if (c.isError(s))
        return s;
      var o = u(c, s.primitive, f);
      if (c.isError(o))
        return o;
      var y;
      if (s.primitive || o !== null ? y = c.skip(o) : y = this._skipUntilEnd(c, f), c.isError(y))
        return y;
      if (s.tagStr === "end")
        break;
    }
  }, h.prototype._decodeList = function(c, f, s, o) {
    for (var y = []; !c.isEmpty(); ) {
      var m = this._peekTag(c, "end");
      if (c.isError(m))
        return m;
      var g = s.decode(c, "der", o);
      if (c.isError(g) && m)
        break;
      y.push(g);
    }
    return y;
  }, h.prototype._decodeStr = function(c, f) {
    if (f === "bitstr") {
      var s = c.readUInt8();
      return c.isError(s) ? s : { unused: s, data: c.raw() };
    } else if (f === "bmpstr") {
      var o = c.raw();
      if (o.length % 2 === 1)
        return c.error("Decoding of string type: bmpstr length mismatch");
      for (var y = "", m = 0; m < o.length / 2; m++)
        y += String.fromCharCode(o.readUInt16BE(m * 2));
      return y;
    } else if (f === "numstr") {
      var g = c.raw().toString("ascii");
      return this._isNumstr(g) ? g : c.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (f === "octstr")
        return c.raw();
      if (f === "objDesc")
        return c.raw();
      if (f === "printstr") {
        var b = c.raw().toString("ascii");
        return this._isPrintstr(b) ? b : c.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(f) ? c.raw().toString() : c.error("Decoding of string type: " + f + " unsupported");
    }
  }, h.prototype._decodeObjid = function(c, f, s) {
    for (var o, y = [], m = 0; !c.isEmpty(); ) {
      var g = c.readUInt8();
      m <<= 7, m |= g & 127, g & 128 || (y.push(m), m = 0);
    }
    g & 128 && y.push(m);
    var b = y[0] / 40 | 0, v = y[0] % 40;
    if (s ? o = y : o = [b, v].concat(y.slice(1)), f) {
      var T = f[o.join(" ")];
      T === void 0 && (T = f[o.join(".")]), T !== void 0 && (o = T);
    }
    return o;
  }, h.prototype._decodeTime = function(c, f) {
    var s = c.raw().toString();
    if (f === "gentime")
      var o = s.slice(0, 4) | 0, y = s.slice(4, 6) | 0, m = s.slice(6, 8) | 0, g = s.slice(8, 10) | 0, b = s.slice(10, 12) | 0, v = s.slice(12, 14) | 0;
    else if (f === "utctime") {
      var o = s.slice(0, 2) | 0, y = s.slice(2, 4) | 0, m = s.slice(4, 6) | 0, g = s.slice(6, 8) | 0, b = s.slice(8, 10) | 0, v = s.slice(10, 12) | 0;
      o < 70 ? o = 2e3 + o : o = 1900 + o;
    } else
      return c.error("Decoding " + f + " time is not supported yet");
    return Date.UTC(o, y - 1, m, g, b, v, 0);
  }, h.prototype._decodeNull = function(c) {
    return null;
  }, h.prototype._decodeBool = function(c) {
    var f = c.readUInt8();
    return c.isError(f) ? f : f !== 0;
  }, h.prototype._decodeInt = function(c, f) {
    var s = c.raw(), o = new a(s);
    return f && (o = f[o.toString(10)] || o), o;
  }, h.prototype._use = function(c, f) {
    return typeof c == "function" && (c = c(f)), c._getDecoder("der").tree;
  };
  function n(i, c) {
    var f = i.readUInt8(c);
    if (i.isError(f))
      return f;
    var s = l.tagClass[f >> 6], o = (f & 32) === 0;
    if ((f & 31) === 31) {
      var y = f;
      for (f = 0; (y & 128) === 128; ) {
        if (y = i.readUInt8(c), i.isError(y))
          return y;
        f <<= 7, f |= y & 127;
      }
    } else
      f &= 31;
    var m = l.tag[f];
    return {
      cls: s,
      primitive: o,
      tag: f,
      tagStr: m
    };
  }
  function u(i, c, f) {
    var s = i.readUInt8(f);
    if (i.isError(s))
      return s;
    if (!c && s === 128)
      return null;
    if (!(s & 128))
      return s;
    var o = s & 127;
    if (o > 4)
      return i.error("length octect is too long");
    s = 0;
    for (var y = 0; y < o; y++) {
      s <<= 8;
      var m = i.readUInt8(f);
      if (i.isError(m))
        return m;
      s |= m;
    }
    return s;
  }
  return Lm;
}
var jm, yS;
function qV() {
  if (yS) return jm;
  yS = 1;
  var t = ir, e = Ui.Buffer, r = P3();
  function a(l) {
    r.call(this, l), this.enc = "pem";
  }
  return t(a, r), jm = a, a.prototype.decode = function(d, h) {
    for (var n = d.toString().split(/[\r\n]+/g), u = h.label.toUpperCase(), i = /^-----(BEGIN|END) ([^-]+)-----$/, c = -1, f = -1, s = 0; s < n.length; s++) {
      var o = n[s].match(i);
      if (o !== null && o[2] === u)
        if (c === -1) {
          if (o[1] !== "BEGIN")
            break;
          c = s;
        } else {
          if (o[1] !== "END")
            break;
          f = s;
          break;
        }
    }
    if (c === -1 || f === -1)
      throw new Error("PEM section not found for: " + u);
    var y = n.slice(c + 1, f).join("");
    y.replace(/[^a-z0-9\+\/=]+/gi, "");
    var m = new e(y, "base64");
    return r.prototype.decode.call(this, m, h);
  }, jm;
}
var bS;
function HV() {
  return bS || (bS = 1, function(t) {
    var e = t;
    e.der = P3(), e.pem = qV();
  }(Mm)), Mm;
}
var Fm = {}, Bm, gS;
function C3() {
  if (gS) return Bm;
  gS = 1;
  var t = ir, e = Ui.Buffer, r = dc(), a = r.base, l = r.constants.der;
  function d(i) {
    this.enc = "der", this.name = i.name, this.entity = i, this.tree = new h(), this.tree._init(i.body);
  }
  Bm = d, d.prototype.encode = function(c, f) {
    return this.tree._encode(c, f).join();
  };
  function h(i) {
    a.Node.call(this, "der", i);
  }
  t(h, a.Node), h.prototype._encodeComposite = function(c, f, s, o) {
    var y = u(c, f, s, this.reporter);
    if (o.length < 128) {
      var b = new e(2);
      return b[0] = y, b[1] = o.length, this._createEncoderBuffer([b, o]);
    }
    for (var m = 1, g = o.length; g >= 256; g >>= 8)
      m++;
    var b = new e(2 + m);
    b[0] = y, b[1] = 128 | m;
    for (var g = 1 + m, v = o.length; v > 0; g--, v >>= 8)
      b[g] = v & 255;
    return this._createEncoderBuffer([b, o]);
  }, h.prototype._encodeStr = function(c, f) {
    if (f === "bitstr")
      return this._createEncoderBuffer([c.unused | 0, c.data]);
    if (f === "bmpstr") {
      for (var s = new e(c.length * 2), o = 0; o < c.length; o++)
        s.writeUInt16BE(c.charCodeAt(o), o * 2);
      return this._createEncoderBuffer(s);
    } else return f === "numstr" ? this._isNumstr(c) ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : f === "printstr" ? this._isPrintstr(c) ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(f) ? this._createEncoderBuffer(c) : f === "objDesc" ? this._createEncoderBuffer(c) : this.reporter.error("Encoding of string type: " + f + " unsupported");
  }, h.prototype._encodeObjid = function(c, f, s) {
    if (typeof c == "string") {
      if (!f)
        return this.reporter.error("string objid given, but no values map found");
      if (!f.hasOwnProperty(c))
        return this.reporter.error("objid not found in values map");
      c = f[c].split(/[\s\.]+/g);
      for (var o = 0; o < c.length; o++)
        c[o] |= 0;
    } else if (Array.isArray(c)) {
      c = c.slice();
      for (var o = 0; o < c.length; o++)
        c[o] |= 0;
    }
    if (!Array.isArray(c))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(c));
    if (!s) {
      if (c[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      c.splice(0, 2, c[0] * 40 + c[1]);
    }
    for (var y = 0, o = 0; o < c.length; o++) {
      var m = c[o];
      for (y++; m >= 128; m >>= 7)
        y++;
    }
    for (var g = new e(y), b = g.length - 1, o = c.length - 1; o >= 0; o--) {
      var m = c[o];
      for (g[b--] = m & 127; (m >>= 7) > 0; )
        g[b--] = 128 | m & 127;
    }
    return this._createEncoderBuffer(g);
  };
  function n(i) {
    return i < 10 ? "0" + i : i;
  }
  h.prototype._encodeTime = function(c, f) {
    var s, o = new Date(c);
    return f === "gentime" ? s = [
      n(o.getFullYear()),
      n(o.getUTCMonth() + 1),
      n(o.getUTCDate()),
      n(o.getUTCHours()),
      n(o.getUTCMinutes()),
      n(o.getUTCSeconds()),
      "Z"
    ].join("") : f === "utctime" ? s = [
      n(o.getFullYear() % 100),
      n(o.getUTCMonth() + 1),
      n(o.getUTCDate()),
      n(o.getUTCHours()),
      n(o.getUTCMinutes()),
      n(o.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + f + " time is not supported yet"), this._encodeStr(s, "octstr");
  }, h.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, h.prototype._encodeInt = function(c, f) {
    if (typeof c == "string") {
      if (!f)
        return this.reporter.error("String int or enum given, but no values map");
      if (!f.hasOwnProperty(c))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(c));
      c = f[c];
    }
    if (typeof c != "number" && !e.isBuffer(c)) {
      var s = c.toArray();
      !c.sign && s[0] & 128 && s.unshift(0), c = new e(s);
    }
    if (e.isBuffer(c)) {
      var o = c.length;
      c.length === 0 && o++;
      var m = new e(o);
      return c.copy(m), c.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
    }
    if (c < 128)
      return this._createEncoderBuffer(c);
    if (c < 256)
      return this._createEncoderBuffer([0, c]);
    for (var o = 1, y = c; y >= 256; y >>= 8)
      o++;
    for (var m = new Array(o), y = m.length - 1; y >= 0; y--)
      m[y] = c & 255, c >>= 8;
    return m[0] & 128 && m.unshift(0), this._createEncoderBuffer(new e(m));
  }, h.prototype._encodeBool = function(c) {
    return this._createEncoderBuffer(c ? 255 : 0);
  }, h.prototype._use = function(c, f) {
    return typeof c == "function" && (c = c(f)), c._getEncoder("der").tree;
  }, h.prototype._skipDefault = function(c, f, s) {
    var o = this._baseState, y;
    if (o.default === null)
      return !1;
    var m = c.join();
    if (o.defaultBuffer === void 0 && (o.defaultBuffer = this._encodeValue(o.default, f, s).join()), m.length !== o.defaultBuffer.length)
      return !1;
    for (y = 0; y < m.length; y++)
      if (m[y] !== o.defaultBuffer[y])
        return !1;
    return !0;
  };
  function u(i, c, f, s) {
    var o;
    if (i === "seqof" ? i = "seq" : i === "setof" && (i = "set"), l.tagByName.hasOwnProperty(i))
      o = l.tagByName[i];
    else if (typeof i == "number" && (i | 0) === i)
      o = i;
    else
      return s.error("Unknown tag: " + i);
    return o >= 31 ? s.error("Multi-octet tag encoding unsupported") : (c || (o |= 32), o |= l.tagClassByName[f || "universal"] << 6, o);
  }
  return Bm;
}
var $m, vS;
function GV() {
  if (vS) return $m;
  vS = 1;
  var t = ir, e = C3();
  function r(a) {
    e.call(this, a), this.enc = "pem";
  }
  return t(r, e), $m = r, r.prototype.encode = function(l, d) {
    for (var h = e.prototype.encode.call(this, l), n = h.toString("base64"), u = ["-----BEGIN " + d.label + "-----"], i = 0; i < n.length; i += 64)
      u.push(n.slice(i, i + 64));
    return u.push("-----END " + d.label + "-----"), u.join(`
`);
  }, $m;
}
var ES;
function zV() {
  return ES || (ES = 1, function(t) {
    var e = t;
    e.der = C3(), e.pem = GV();
  }(Fm)), Fm;
}
var _S;
function dc() {
  return _S || (_S = 1, function(t) {
    var e = t;
    e.bignum = Gn, e.define = $V().define, e.base = gu(), e.constants = A3(), e.decoders = HV(), e.encoders = zV();
  }(Im)), Im;
}
var us = dc(), SS = us.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), KV = us.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), qb = us.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), YV = us.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(qb),
    this.key("subjectPublicKey").bitstr()
  );
}), XV = us.define("RelativeDistinguishedName", function() {
  this.setof(KV);
}), JV = us.define("RDNSequence", function() {
  this.seqof(XV);
}), wS = us.define("Name", function() {
  this.choice({
    rdnSequence: this.use(JV)
  });
}), QV = us.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(SS),
    this.key("notAfter").use(SS)
  );
}), ZV = us.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), eW = us.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(qb),
    this.key("issuer").use(wS),
    this.key("validity").use(QV),
    this.key("subject").use(wS),
    this.key("subjectPublicKeyInfo").use(YV),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(ZV).optional()
  );
}), tW = us.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(eW),
    this.key("signatureAlgorithm").use(qb),
    this.key("signatureValue").bitstr()
  );
}), rW = tW, cs = dc();
ls.certificate = rW;
var nW = cs.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
ls.RSAPrivateKey = nW;
var iW = cs.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
ls.RSAPublicKey = iW;
var I3 = cs.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), sW = cs.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(I3),
    this.key("subjectPublicKey").bitstr()
  );
});
ls.PublicKey = sW;
var aW = cs.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(I3),
    this.key("subjectPrivateKey").octstr()
  );
});
ls.PrivateKey = aW;
var oW = cs.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
ls.EncryptedPrivateKey = oW;
var lW = cs.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
ls.DSAPrivateKey = lW;
ls.DSAparam = cs.define("DSAparam", function() {
  this.int();
});
var uW = cs.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), cW = cs.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(uW),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
ls.ECPrivateKey = cW;
ls.signature = cs.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const fW = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var dW = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, pW = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, hW = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, mW = up, yW = wi, ef = cr.Buffer, bW = function(t, e) {
  var r = t.toString(), a = r.match(dW), l;
  if (a) {
    var h = "aes" + a[1], n = ef.from(a[2], "hex"), u = ef.from(a[3].replace(/[\r\n]/g, ""), "base64"), i = mW(e, n.slice(0, 8), parseInt(a[1], 10)).key, c = [], f = yW.createDecipheriv(h, i, n);
    c.push(f.update(u)), c.push(f.final()), l = ef.concat(c);
  } else {
    var d = r.match(hW);
    l = ef.from(d[2].replace(/[\r\n]/g, ""), "base64");
  }
  var s = r.match(pW)[1];
  return {
    tag: s,
    data: l
  };
}, fi = ls, gW = fW, vW = bW, EW = wi, _W = ap, B1 = cr.Buffer;
function SW(t, e) {
  var r = t.algorithm.decrypt.kde.kdeparams.salt, a = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), l = gW[t.algorithm.decrypt.cipher.algo.join(".")], d = t.algorithm.decrypt.cipher.iv, h = t.subjectPrivateKey, n = parseInt(l.split("-")[1], 10) / 8, u = _W.pbkdf2Sync(e, r, a, n, "sha1"), i = EW.createDecipheriv(l, u, d), c = [];
  return c.push(i.update(h)), c.push(i.final()), B1.concat(c);
}
function O3(t) {
  var e;
  typeof t == "object" && !B1.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = B1.from(t));
  var r = vW(t, e), a = r.tag, l = r.data, d, h;
  switch (a) {
    case "CERTIFICATE":
      h = fi.certificate.decode(l, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (h || (h = fi.PublicKey.decode(l, "der")), d = h.algorithm.algorithm.join("."), d) {
        case "1.2.840.113549.1.1.1":
          return fi.RSAPublicKey.decode(h.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return h.subjectPrivateKey = h.subjectPublicKey, {
            type: "ec",
            data: h
          };
        case "1.2.840.10040.4.1":
          return h.algorithm.params.pub_key = fi.DSAparam.decode(h.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: h.algorithm.params
          };
        default:
          throw new Error("unknown key id " + d);
      }
    case "ENCRYPTED PRIVATE KEY":
      l = fi.EncryptedPrivateKey.decode(l, "der"), l = SW(l, e);
    case "PRIVATE KEY":
      switch (h = fi.PrivateKey.decode(l, "der"), d = h.algorithm.algorithm.join("."), d) {
        case "1.2.840.113549.1.1.1":
          return fi.RSAPrivateKey.decode(h.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: h.algorithm.curve,
            privateKey: fi.ECPrivateKey.decode(h.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return h.algorithm.params.priv_key = fi.DSAparam.decode(h.subjectPrivateKey, "der"), {
            type: "dsa",
            params: h.algorithm.params
          };
        default:
          throw new Error("unknown key id " + d);
      }
    case "RSA PUBLIC KEY":
      return fi.RSAPublicKey.decode(l, "der");
    case "RSA PRIVATE KEY":
      return fi.RSAPrivateKey.decode(l, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: fi.DSAPrivateKey.decode(l, "der")
      };
    case "EC PRIVATE KEY":
      return l = fi.ECPrivateKey.decode(l, "der"), {
        curve: l.parameters.value,
        privateKey: l.privateKey
      };
    default:
      throw new Error("unknown key type " + a);
  }
}
O3.signature = fi.signature;
var Tp = O3;
const k3 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var xS;
function wW() {
  if (xS) return Zl.exports;
  xS = 1;
  var t = cr.Buffer, e = tP, r = Fb, a = Wb().ec, l = jb, d = Tp, h = k3, n = 1;
  function u(b, v, T, E, O) {
    var D = d(v);
    if (D.curve) {
      if (E !== "ecdsa" && E !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return i(b, D);
    } else if (D.type === "dsa") {
      if (E !== "dsa")
        throw new Error("wrong private key type");
      return c(b, D, T);
    }
    if (E !== "rsa" && E !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (v.padding !== void 0 && v.padding !== n)
      throw new Error("illegal or unsupported padding mode");
    b = t.concat([O, b]);
    for (var $ = D.modulus.byteLength(), I = [0, 1]; b.length + I.length + 1 < $; )
      I.push(255);
    I.push(0);
    for (var k = -1; ++k < b.length; )
      I.push(b[k]);
    var L = r(I, D);
    return L;
  }
  function i(b, v) {
    var T = h[v.curve.join(".")];
    if (!T)
      throw new Error("unknown curve " + v.curve.join("."));
    var E = new a(T), O = E.keyFromPrivate(v.privateKey), D = O.sign(b);
    return t.from(D.toDER());
  }
  function c(b, v, T) {
    for (var E = v.params.priv_key, O = v.params.p, D = v.params.q, $ = v.params.g, I = new l(0), k, L = o(b, D).mod(D), M = !1, x = s(E, D, b, T); M === !1; )
      k = m(D, x, T), I = g($, k, O, D), M = k.invm(D).imul(L.add(E.mul(I))).mod(D), M.cmpn(0) === 0 && (M = !1, I = new l(0));
    return f(I, M);
  }
  function f(b, v) {
    b = b.toArray(), v = v.toArray(), b[0] & 128 && (b = [0].concat(b)), v[0] & 128 && (v = [0].concat(v));
    var T = b.length + v.length + 4, E = [
      48,
      T,
      2,
      b.length
    ];
    return E = E.concat(b, [2, v.length], v), t.from(E);
  }
  function s(b, v, T, E) {
    if (b = t.from(b.toArray()), b.length < v.byteLength()) {
      var O = t.alloc(v.byteLength() - b.length);
      b = t.concat([O, b]);
    }
    var D = T.length, $ = y(T, v), I = t.alloc(D);
    I.fill(1);
    var k = t.alloc(D);
    return k = e(E, k).update(I).update(t.from([0])).update(b).update($).digest(), I = e(E, k).update(I).digest(), k = e(E, k).update(I).update(t.from([1])).update(b).update($).digest(), I = e(E, k).update(I).digest(), { k, v: I };
  }
  function o(b, v) {
    var T = new l(b), E = (b.length << 3) - v.bitLength();
    return E > 0 && T.ishrn(E), T;
  }
  function y(b, v) {
    b = o(b, v), b = b.mod(v);
    var T = t.from(b.toArray());
    if (T.length < v.byteLength()) {
      var E = t.alloc(v.byteLength() - T.length);
      T = t.concat([E, T]);
    }
    return T;
  }
  function m(b, v, T) {
    var E, O;
    do {
      for (E = t.alloc(0); E.length * 8 < b.bitLength(); )
        v.v = e(T, v.k).update(v.v).digest(), E = t.concat([E, v.v]);
      O = o(E, b), v.k = e(T, v.k).update(v.v).update(t.from([0])).digest(), v.v = e(T, v.k).update(v.v).digest();
    } while (O.cmp(b) !== -1);
    return O;
  }
  function g(b, v, T, E) {
    return b.toRed(l.mont(T)).redPow(v).fromRed().mod(E);
  }
  return Zl.exports = u, Zl.exports.getKey = s, Zl.exports.makeKey = m, Zl.exports;
}
var Um, TS;
function xW() {
  if (TS) return Um;
  TS = 1;
  var t = cr.Buffer, e = jb, r = Wb().ec, a = Tp, l = k3;
  function d(i, c, f, s, o) {
    var y = a(f);
    if (y.type === "ec") {
      if (s !== "ecdsa" && s !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return h(i, c, y);
    } else if (y.type === "dsa") {
      if (s !== "dsa")
        throw new Error("wrong public key type");
      return n(i, c, y);
    }
    if (s !== "rsa" && s !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    c = t.concat([o, c]);
    for (var m = y.modulus.byteLength(), g = [1], b = 0; c.length + g.length + 2 < m; )
      g.push(255), b += 1;
    g.push(0);
    for (var v = -1; ++v < c.length; )
      g.push(c[v]);
    g = t.from(g);
    var T = e.mont(y.modulus);
    i = new e(i).toRed(T), i = i.redPow(new e(y.publicExponent)), i = t.from(i.fromRed().toArray());
    var E = b < 8 ? 1 : 0;
    for (m = Math.min(i.length, g.length), i.length !== g.length && (E = 1), v = -1; ++v < m; )
      E |= i[v] ^ g[v];
    return E === 0;
  }
  function h(i, c, f) {
    var s = l[f.data.algorithm.curve.join(".")];
    if (!s)
      throw new Error("unknown curve " + f.data.algorithm.curve.join("."));
    var o = new r(s), y = f.data.subjectPrivateKey.data;
    return o.verify(c, i, y);
  }
  function n(i, c, f) {
    var s = f.data.p, o = f.data.q, y = f.data.g, m = f.data.pub_key, g = a.signature.decode(i, "der"), b = g.s, v = g.r;
    u(b, o), u(v, o);
    var T = e.mont(s), E = b.invm(o), O = y.toRed(T).redPow(new e(c).mul(E).mod(o)).fromRed().mul(m.toRed(T).redPow(v.mul(E).mod(o)).fromRed()).mod(s).mod(o);
    return O.cmp(v) === 0;
  }
  function u(i, c) {
    if (i.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (i.cmp(c) >= 0)
      throw new Error("invalid sig");
  }
  return Um = d, Um;
}
var Vm, AS;
function TW() {
  if (AS) return Vm;
  AS = 1;
  var t = cr.Buffer, e = ic, r = S$, a = ir, l = wW(), d = xW(), h = rP;
  Object.keys(h).forEach(function(f) {
    h[f].id = t.from(h[f].id, "hex"), h[f.toLowerCase()] = h[f];
  });
  function n(f) {
    r.Writable.call(this);
    var s = h[f];
    if (!s)
      throw new Error("Unknown message digest");
    this._hashType = s.hash, this._hash = e(s.hash), this._tag = s.id, this._signType = s.sign;
  }
  a(n, r.Writable), n.prototype._write = function(s, o, y) {
    this._hash.update(s), y();
  }, n.prototype.update = function(s, o) {
    return this._hash.update(typeof s == "string" ? t.from(s, o) : s), this;
  }, n.prototype.sign = function(s, o) {
    this.end();
    var y = this._hash.digest(), m = l(y, s, this._hashType, this._signType, this._tag);
    return o ? m.toString(o) : m;
  };
  function u(f) {
    r.Writable.call(this);
    var s = h[f];
    if (!s)
      throw new Error("Unknown message digest");
    this._hash = e(s.hash), this._tag = s.id, this._signType = s.sign;
  }
  a(u, r.Writable), u.prototype._write = function(s, o, y) {
    this._hash.update(s), y();
  }, u.prototype.update = function(s, o) {
    return this._hash.update(typeof s == "string" ? t.from(s, o) : s), this;
  }, u.prototype.verify = function(s, o, y) {
    var m = typeof o == "string" ? t.from(o, y) : o;
    this.end();
    var g = this._hash.digest();
    return d(m, g, s, this._signType, this._tag);
  };
  function i(f) {
    return new n(f);
  }
  function c(f) {
    return new u(f);
  }
  return Vm = {
    Sign: i,
    Verify: c,
    createSign: i,
    createVerify: c
  }, Vm;
}
var Wm, PS;
function AW() {
  if (PS) return Wm;
  PS = 1;
  var t = Wb(), e = Gn;
  Wm = function(h) {
    return new a(h);
  };
  var r = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  r.p224 = r.secp224r1, r.p256 = r.secp256r1 = r.prime256v1, r.p192 = r.secp192r1 = r.prime192v1, r.p384 = r.secp384r1, r.p521 = r.secp521r1;
  function a(d) {
    this.curveType = r[d], this.curveType || (this.curveType = {
      name: d
    }), this.curve = new t.ec(this.curveType.name), this.keys = void 0;
  }
  a.prototype.generateKeys = function(d, h) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(d, h);
  }, a.prototype.computeSecret = function(d, h, n) {
    h = h || "utf8", Gt.isBuffer(d) || (d = new Gt(d, h));
    var u = this.curve.keyFromPublic(d).getPublic(), i = u.mul(this.keys.getPrivate()).getX();
    return l(i, n, this.curveType.byteLength);
  }, a.prototype.getPublicKey = function(d, h) {
    var n = this.keys.getPublic(h === "compressed", !0);
    return h === "hybrid" && (n[n.length - 1] % 2 ? n[0] = 7 : n[0] = 6), l(n, d);
  }, a.prototype.getPrivateKey = function(d) {
    return l(this.keys.getPrivate(), d);
  }, a.prototype.setPublicKey = function(d, h) {
    return h = h || "utf8", Gt.isBuffer(d) || (d = new Gt(d, h)), this.keys._importPublic(d), this;
  }, a.prototype.setPrivateKey = function(d, h) {
    h = h || "utf8", Gt.isBuffer(d) || (d = new Gt(d, h));
    var n = new e(d);
    return n = n.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(n), this;
  };
  function l(d, h, n) {
    Array.isArray(d) || (d = d.toArray());
    var u = new Gt(d);
    if (n && u.length < n) {
      var i = new Gt(n - u.length);
      i.fill(0), u = Gt.concat([i, u]);
    }
    return h ? u.toString(h) : u;
  }
  return Wm;
}
var D3 = {}, PW = ic, $1 = cr.Buffer, N3 = function(t, e) {
  for (var r = $1.alloc(0), a = 0, l; r.length < e; )
    l = CW(a++), r = $1.concat([r, PW("sha1").update(t).update(l).digest()]);
  return r.slice(0, e);
};
function CW(t) {
  var e = $1.allocUnsafe(4);
  return e.writeUInt32BE(t, 0), e;
}
var R3 = function(e, r) {
  for (var a = e.length, l = -1; ++l < a; )
    e[l] ^= r[l];
  return e;
}, CS = Gn, IW = cr.Buffer;
function OW(t, e) {
  return IW.from(t.toRed(CS.mont(e.modulus)).redPow(new CS(e.publicExponent)).fromRed().toArray());
}
var M3 = OW, kW = Tp, U1 = Cl, DW = ic, IS = N3, OS = R3, Hb = Gn, NW = M3, RW = Fb, es = cr.Buffer, MW = function(e, r, a) {
  var l;
  e.padding ? l = e.padding : a ? l = 1 : l = 4;
  var d = kW(e), h;
  if (l === 4)
    h = LW(d, r);
  else if (l === 1)
    h = jW(d, r, a);
  else if (l === 3) {
    if (h = new Hb(r), h.cmp(d.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return a ? RW(h, d) : NW(h, d);
};
function LW(t, e) {
  var r = t.modulus.byteLength(), a = e.length, l = DW("sha1").update(es.alloc(0)).digest(), d = l.length, h = 2 * d;
  if (a > r - h - 2)
    throw new Error("message too long");
  var n = es.alloc(r - a - h - 2), u = r - d - 1, i = U1(d), c = OS(es.concat([l, n, es.alloc(1, 1), e], u), IS(i, u)), f = OS(i, IS(c, d));
  return new Hb(es.concat([es.alloc(1), f, c], r));
}
function jW(t, e, r) {
  var a = e.length, l = t.modulus.byteLength();
  if (a > l - 11)
    throw new Error("message too long");
  var d;
  return r ? d = es.alloc(l - a - 3, 255) : d = FW(l - a - 3), new Hb(es.concat([es.from([0, r ? 1 : 2]), d, es.alloc(1), e], l));
}
function FW(t) {
  for (var e = es.allocUnsafe(t), r = 0, a = U1(t * 2), l = 0, d; r < t; )
    l === a.length && (a = U1(t * 2), l = 0), d = a[l++], d && (e[r++] = d);
  return e;
}
var BW = Tp, kS = N3, DS = R3, NS = Gn, $W = Fb, UW = ic, VW = M3, Nu = cr.Buffer, WW = function(e, r, a) {
  var l;
  e.padding ? l = e.padding : a ? l = 1 : l = 4;
  var d = BW(e), h = d.modulus.byteLength();
  if (r.length > h || new NS(r).cmp(d.modulus) >= 0)
    throw new Error("decryption error");
  var n;
  a ? n = VW(new NS(r), d) : n = $W(r, d);
  var u = Nu.alloc(h - n.length);
  if (n = Nu.concat([u, n], h), l === 4)
    return qW(d, n);
  if (l === 1)
    return HW(d, n, a);
  if (l === 3)
    return n;
  throw new Error("unknown padding");
};
function qW(t, e) {
  var r = t.modulus.byteLength(), a = UW("sha1").update(Nu.alloc(0)).digest(), l = a.length;
  if (e[0] !== 0)
    throw new Error("decryption error");
  var d = e.slice(1, l + 1), h = e.slice(l + 1), n = DS(d, kS(h, l)), u = DS(h, kS(n, r - l - 1));
  if (GW(a, u.slice(0, l)))
    throw new Error("decryption error");
  for (var i = l; u[i] === 0; )
    i++;
  if (u[i++] !== 1)
    throw new Error("decryption error");
  return u.slice(i);
}
function HW(t, e, r) {
  for (var a = e.slice(0, 2), l = 2, d = 0; e[l++] !== 0; )
    if (l >= e.length) {
      d++;
      break;
    }
  var h = e.slice(2, l - 1);
  if ((a.toString("hex") !== "0002" && !r || a.toString("hex") !== "0001" && r) && d++, h.length < 8 && d++, d)
    throw new Error("decryption error");
  return e.slice(l);
}
function GW(t, e) {
  t = Nu.from(t), e = Nu.from(e);
  var r = 0, a = t.length;
  t.length !== e.length && (r++, a = Math.min(t.length, e.length));
  for (var l = -1; ++l < a; )
    r += t[l] ^ e[l];
  return r;
}
(function(t) {
  t.publicEncrypt = MW, t.privateDecrypt = WW, t.privateEncrypt = function(r, a) {
    return t.publicEncrypt(r, a, !0);
  }, t.publicDecrypt = function(r, a) {
    return t.privateDecrypt(r, a, !0);
  };
})(D3);
var uu = {};
function RS() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var L3 = cr, MS = Cl, j3 = L3.Buffer, F3 = L3.kMaxLength, V1 = jt.crypto || jt.msCrypto, B3 = Math.pow(2, 32) - 1;
function $3(t, e) {
  if (typeof t != "number" || t !== t)
    throw new TypeError("offset must be a number");
  if (t > B3 || t < 0)
    throw new TypeError("offset must be a uint32");
  if (t > F3 || t > e)
    throw new RangeError("offset out of range");
}
function U3(t, e, r) {
  if (typeof t != "number" || t !== t)
    throw new TypeError("size must be a number");
  if (t > B3 || t < 0)
    throw new TypeError("size must be a uint32");
  if (t + e > r || t > F3)
    throw new RangeError("buffer too small");
}
V1 && V1.getRandomValues || !Ze.browser ? (uu.randomFill = zW, uu.randomFillSync = KW) : (uu.randomFill = RS, uu.randomFillSync = RS);
function zW(t, e, r, a) {
  if (!j3.isBuffer(t) && !(t instanceof jt.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof e == "function")
    a = e, e = 0, r = t.length;
  else if (typeof r == "function")
    a = r, r = t.length - e;
  else if (typeof a != "function")
    throw new TypeError('"cb" argument must be a function');
  return $3(e, t.length), U3(r, e, t.length), V3(t, e, r, a);
}
function V3(t, e, r, a) {
  if (Ze.browser) {
    var l = t.buffer, d = new Uint8Array(l, e, r);
    if (V1.getRandomValues(d), a) {
      Ze.nextTick(function() {
        a(null, t);
      });
      return;
    }
    return t;
  }
  if (a) {
    MS(r, function(n, u) {
      if (n)
        return a(n);
      u.copy(t, e), a(null, t);
    });
    return;
  }
  var h = MS(r);
  return h.copy(t, e), t;
}
function KW(t, e, r) {
  if (typeof e > "u" && (e = 0), !j3.isBuffer(t) && !(t instanceof jt.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return $3(e, t.length), r === void 0 && (r = t.length - e), U3(r, e, t.length), V3(t, e, r);
}
var LS;
function Gb() {
  if (LS) return or;
  LS = 1, or.randomBytes = or.rng = or.pseudoRandomBytes = or.prng = Cl, or.createHash = or.Hash = ic, or.createHmac = or.Hmac = tP;
  var t = EF, e = Object.keys(t), r = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(e);
  or.getHashes = function() {
    return r;
  };
  var a = ap;
  or.pbkdf2 = a.pbkdf2, or.pbkdf2Sync = a.pbkdf2Sync;
  var l = rs;
  or.Cipher = l.Cipher, or.createCipher = l.createCipher, or.Cipheriv = l.Cipheriv, or.createCipheriv = l.createCipheriv, or.Decipher = l.Decipher, or.createDecipher = l.createDecipher, or.Decipheriv = l.Decipheriv, or.createDecipheriv = l.createDecipheriv, or.getCiphers = l.getCiphers, or.listCiphers = l.listCiphers;
  var d = QB();
  or.DiffieHellmanGroup = d.DiffieHellmanGroup, or.createDiffieHellmanGroup = d.createDiffieHellmanGroup, or.getDiffieHellman = d.getDiffieHellman, or.createDiffieHellman = d.createDiffieHellman, or.DiffieHellman = d.DiffieHellman;
  var h = TW();
  or.createSign = h.createSign, or.Sign = h.Sign, or.createVerify = h.createVerify, or.Verify = h.Verify, or.createECDH = AW();
  var n = D3;
  or.publicEncrypt = n.publicEncrypt, or.privateEncrypt = n.privateEncrypt, or.publicDecrypt = n.publicDecrypt, or.privateDecrypt = n.privateDecrypt;
  var u = uu;
  return or.randomFill = u.randomFill, or.randomFillSync = u.randomFillSync, or.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, or.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, or;
}
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "hasContentChanged", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ a(Gb()), r = /* @__PURE__ */ d(mo);
  function a(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  function l(u) {
    if (typeof WeakMap != "function") return null;
    var i = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
    return (l = function(f) {
      return f ? c : i;
    })(u);
  }
  function d(u, i) {
    if (u && u.__esModule)
      return u;
    if (u === null || typeof u != "object" && typeof u != "function")
      return {
        default: u
      };
    var c = l(i);
    if (c && c.has(u))
      return c.get(u);
    var f = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var o in u)
      if (o !== "default" && Object.prototype.hasOwnProperty.call(u, o)) {
        var y = s ? Object.getOwnPropertyDescriptor(u, o) : null;
        y && (y.get || y.set) ? Object.defineProperty(f, o, y) : f[o] = u[o];
      }
    return f.default = u, c && c.set(u, f), f;
  }
  function h(u) {
    try {
      return e.default.createHash("md5").update(u, "utf-8").digest("binary");
    } catch {
      return "";
    }
  }
  function n(u, i) {
    let c = i.toString();
    if (!c.includes("@tailwind"))
      return !1;
    let f = r.sourceHashMap.get(u), s = h(c), o = f !== s;
    return r.sourceHashMap.set(u, s), o;
  }
})(AA);
var W3 = {}, q3 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    return (r > 0n) - (r < 0n);
  }
})(q3);
var H3 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "remapBitfield", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, a) {
    let l = 0n, d = 0n;
    for (let [h, n] of a)
      r & h && (l = l | h, d = d | n);
    return r & ~l | d;
  }
})(H3);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "Offsets", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(q3), r = H3;
  function a(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  class l {
    constructor() {
      this.offsets = {
        defaults: 0n,
        base: 0n,
        components: 0n,
        utilities: 0n,
        variants: 0n,
        user: 0n
      }, this.layerPositions = {
        defaults: 0n,
        base: 1n,
        components: 2n,
        utilities: 3n,
        // There isn't technically a "user" layer, but we need to give it a position
        // Because it's used for ordering user-css from @apply
        user: 4n,
        variants: 5n
      }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
    }
    /**
    * @param {Layer} layer
    * @returns {RuleOffset}
    */
    create(u) {
      return {
        layer: u,
        parentLayer: u,
        arbitrary: 0n,
        variants: 0n,
        parallelIndex: 0n,
        index: this.offsets[u]++,
        options: []
      };
    }
    /**
    * @returns {RuleOffset}
    */
    arbitraryProperty() {
      return {
        ...this.create("utilities"),
        arbitrary: 1n
      };
    }
    /**
    * Get the offset for a variant
    *
    * @param {string} variant
    * @param {number} index
    * @returns {RuleOffset}
    */
    forVariant(u, i = 0) {
      let c = this.variantOffsets.get(u);
      if (c === void 0)
        throw new Error(`Cannot find offset for unknown variant ${u}`);
      return {
        ...this.create("variants"),
        variants: c << BigInt(i)
      };
    }
    /**
    * @param {RuleOffset} rule
    * @param {RuleOffset} variant
    * @param {VariantOption} options
    * @returns {RuleOffset}
    */
    applyVariantOffset(u, i, c) {
      return c.variant = i.variants, {
        ...u,
        layer: "variants",
        parentLayer: u.layer === "variants" ? u.parentLayer : u.layer,
        variants: u.variants | i.variants,
        options: c.sort ? [].concat(c, u.options) : u.options,
        // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
        // We'll take the max of all the parallel indexes for now.
        // @ts-ignore
        parallelIndex: d([
          u.parallelIndex,
          i.parallelIndex
        ])
      };
    }
    /**
    * @param {RuleOffset} offset
    * @param {number} parallelIndex
    * @returns {RuleOffset}
    */
    applyParallelOffset(u, i) {
      return {
        ...u,
        parallelIndex: BigInt(i)
      };
    }
    /**
    * Each variant gets 1 bit per function / rule registered.
    * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
    * Additionally, every unique group of variants is grouped together in the stylesheet.
    *
    * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
    *
    * @param {string[]} variants
    * @param {(name: string) => number} getLength
    */
    recordVariants(u, i) {
      for (let c of u)
        this.recordVariant(c, i(c));
    }
    /**
    * The same as `recordVariants` but for a single arbitrary variant at runtime.
    * @param {string} variant
    * @param {number} fnCount
    *
    * @returns {RuleOffset} The highest offset for this variant
    */
    recordVariant(u, i = 1) {
      return this.variantOffsets.set(u, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(i), {
        ...this.create("variants"),
        variants: this.variantOffsets.get(u)
      };
    }
    /**
    * @param {RuleOffset} a
    * @param {RuleOffset} b
    * @returns {bigint}
    */
    compare(u, i) {
      if (u.layer !== i.layer)
        return this.layerPositions[u.layer] - this.layerPositions[i.layer];
      if (u.parentLayer !== i.parentLayer)
        return this.layerPositions[u.parentLayer] - this.layerPositions[i.parentLayer];
      for (let f of u.options)
        for (let s of i.options) {
          if (f.id !== s.id || !f.sort || !s.sort) continue;
          var c;
          let o = (c = d([
            f.variant,
            s.variant
          ])) !== null && c !== void 0 ? c : 0n, y = ~(o | o - 1n), m = u.variants & y, g = i.variants & y;
          if (m !== g)
            continue;
          let b = f.sort({
            value: f.value,
            modifier: f.modifier
          }, {
            value: s.value,
            modifier: s.modifier
          });
          if (b !== 0) return b;
        }
      return u.variants !== i.variants ? u.variants - i.variants : u.parallelIndex !== i.parallelIndex ? u.parallelIndex - i.parallelIndex : u.arbitrary !== i.arbitrary ? u.arbitrary - i.arbitrary : u.index - i.index;
    }
    /**
    * Arbitrary variants are recorded in the order they're encountered.
    * This means that the order is not stable between environments and sets of content files.
    *
    * In order to make the order stable, we need to remap the arbitrary variant offsets to
    * be in alphabetical order starting from the offset of the first arbitrary variant.
    */
    recalculateVariantOffsets() {
      let u = Array.from(this.variantOffsets.entries()).filter(([f]) => f.startsWith("[")).sort(([f], [s]) => h(f, s)), i = u.map(([, f]) => f).sort((f, s) => (0, e.default)(f - s));
      return u.map(([, f], s) => [
        f,
        i[s]
      ]).filter(([f, s]) => f !== s);
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    remapArbitraryVariantOffsets(u) {
      let i = this.recalculateVariantOffsets();
      return i.length === 0 ? u : u.map((c) => {
        let [f, s] = c;
        return f = {
          ...f,
          variants: (0, r.remapBitfield)(f.variants, i)
        }, [
          f,
          s
        ];
      });
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    sort(u) {
      return u = this.remapArbitraryVariantOffsets(u), u.sort(([i], [c]) => (0, e.default)(this.compare(i, c)));
    }
  }
  function d(n) {
    let u = null;
    for (const i of n)
      u = u ?? i, u = u > i ? u : i;
    return u;
  }
  function h(n, u) {
    let i = n.length, c = u.length, f = i < c ? i : c;
    for (let s = 0; s < f; s++) {
      let o = n.charCodeAt(s) - u.charCodeAt(s);
      if (o !== 0) return o;
    }
    return i - c;
  }
})(W3);
var jS;
function zb() {
  return jS || (jS = 1, function(t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    function e(oe, me) {
      for (var ye in me) Object.defineProperty(oe, ye, {
        enumerable: !0,
        get: me[ye]
      });
    }
    e(t, {
      isValidVariantFormatString: function() {
        return B;
      },
      parseVariant: function() {
        return Q;
      },
      getFileModifiedMap: function() {
        return G;
      },
      createContext: function() {
        return _e;
      },
      getContext: function() {
        return ae;
      }
    });
    const r = /* @__PURE__ */ k(oi), a = /* @__PURE__ */ k(Ns), l = /* @__PURE__ */ k(Vi), d = /* @__PURE__ */ k(YT), h = /* @__PURE__ */ k(ua), n = /* @__PURE__ */ k(Qu), u = /* @__PURE__ */ k(cb), i = /* @__PURE__ */ k(Gd), c = /* @__PURE__ */ k(Al), f = /* @__PURE__ */ k(Pl), s = /* @__PURE__ */ M(yb), o = Gu, y = EA, m = /* @__PURE__ */ M(mo), g = Fd, b = /* @__PURE__ */ k(as), v = /* @__PURE__ */ k(jd), T = /* @__PURE__ */ k(bb), E = Eb(), O = AA, D = W3, $ = Vs, I = gb;
    function k(oe) {
      return oe && oe.__esModule ? oe : {
        default: oe
      };
    }
    function L(oe) {
      if (typeof WeakMap != "function") return null;
      var me = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakMap();
      return (L = function(we) {
        return we ? ye : me;
      })(oe);
    }
    function M(oe, me) {
      if (oe && oe.__esModule)
        return oe;
      if (oe === null || typeof oe != "object" && typeof oe != "function")
        return {
          default: oe
        };
      var ye = L(me);
      if (ye && ye.has(oe))
        return ye.get(oe);
      var we = {}, ge = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var se in oe)
        if (se !== "default" && Object.prototype.hasOwnProperty.call(oe, se)) {
          var be = ge ? Object.getOwnPropertyDescriptor(oe, se) : null;
          be && (be.get || be.set) ? Object.defineProperty(we, se, be) : we[se] = oe[se];
        }
      return we.default = oe, ye && ye.set(oe, we), we;
    }
    const x = {
      AddVariant: Symbol.for("ADD_VARIANT"),
      MatchVariant: Symbol.for("MATCH_VARIANT")
    }, _ = {
      Base: 1,
      Dynamic: 2
    };
    function S(oe, me) {
      let ye = oe.tailwindConfig.prefix;
      return typeof ye == "function" ? ye(me) : ye + me;
    }
    function C({ type: oe = "any", ...me }) {
      let ye = [].concat(oe);
      return {
        ...me,
        types: ye.map((we) => Array.isArray(we) ? {
          type: we[0],
          ...we[1]
        } : {
          type: we,
          preferOnConflict: !1
        })
      };
    }
    function R(oe) {
      let me = [], ye = "", we = 0;
      for (let ge = 0; ge < oe.length; ge++) {
        let se = oe[ge];
        if (se === "\\")
          ye += "\\" + oe[++ge];
        else if (se === "{")
          ++we, me.push(ye.trim()), ye = "";
        else if (se === "}") {
          if (--we < 0)
            throw new Error("Your { and } are unbalanced.");
          me.push(ye.trim()), ye = "";
        } else
          ye += se;
      }
      return ye.length > 0 && me.push(ye.trim()), me = me.filter((ge) => ge !== ""), me;
    }
    function H(oe, me, { before: ye = [] } = {}) {
      if (ye = [].concat(ye), ye.length <= 0) {
        oe.push(me);
        return;
      }
      let we = oe.length - 1;
      for (let ge of ye) {
        let se = oe.indexOf(ge);
        se !== -1 && (we = Math.min(we, se));
      }
      oe.splice(we, 0, me);
    }
    function z(oe) {
      return Array.isArray(oe) ? oe.flatMap((me) => !Array.isArray(me) && !(0, c.default)(me) ? me : (0, u.default)(me)) : z([
        oe
      ]);
    }
    function U(oe, me) {
      return (0, h.default)((we) => {
        let ge = [];
        return me && me(we), we.walkClasses((se) => {
          ge.push(se.value);
        }), ge;
      }).transformSync(oe);
    }
    function P(oe, me = {
      containsNonOnDemandable: !1
    }, ye = 0) {
      let we = [];
      if (oe.type === "rule") {
        let ge = function(se) {
          se.walkPseudos((be) => {
            be.value === ":not" && be.remove();
          });
        };
        for (let se of oe.selectors) {
          let be = U(se, ge);
          be.length === 0 && (me.containsNonOnDemandable = !0);
          for (let Ie of be)
            we.push(Ie);
        }
      } else oe.type === "atrule" && oe.walkRules((ge) => {
        for (let se of ge.selectors.flatMap((be) => U(be)))
          we.push(se);
      });
      return ye === 0 ? [
        me.containsNonOnDemandable || we.length === 0,
        we
      ] : we;
    }
    function W(oe) {
      return z(oe).flatMap((me) => {
        let ye = /* @__PURE__ */ new Map(), [we, ge] = P(me);
        return we && ge.unshift(m.NOT_ON_DEMAND), ge.map((se) => (ye.has(me) || ye.set(me, me), [
          se,
          ye.get(me)
        ]));
      });
    }
    function B(oe) {
      return oe.startsWith("@") || oe.includes("&");
    }
    function Q(oe) {
      oe = oe.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let me = R(oe).map((ye) => {
        if (!ye.startsWith("@"))
          return ({ format: se }) => se(ye);
        let [, we, ge] = /@(.*?)( .+|[({].*)/g.exec(ye);
        return ({ wrap: se }) => se(l.default.atRule({
          name: we,
          params: ge.trim()
        }));
      }).reverse();
      return (ye) => {
        for (let we of me)
          we(ye);
      };
    }
    function J(oe, me, { variantList: ye, variantMap: we, offsets: ge, classList: se }) {
      function be(te, Y) {
        return te ? (0, d.default)(oe, te, Y) : oe;
      }
      function Ie(te) {
        return (0, i.default)(oe.prefix, te);
      }
      function Oe(te, Y) {
        return te === m.NOT_ON_DEMAND ? m.NOT_ON_DEMAND : Y.respectPrefix ? me.tailwindConfig.prefix + te : te;
      }
      function Be(te, Y, le = {}) {
        let Ee = (0, g.toPath)(te), Se = be([
          "theme",
          ...Ee
        ], Y);
        return (0, n.default)(Ee[0])(Se, le);
      }
      let Fe = 0, ue = {
        postcss: l.default,
        prefix: Ie,
        e: f.default,
        config: be,
        theme: Be,
        corePlugins: (te) => Array.isArray(oe.corePlugins) ? oe.corePlugins.includes(te) : be([
          "corePlugins",
          te
        ], !0),
        variants: () => [],
        addBase(te) {
          for (let [Y, le] of W(te)) {
            let Ee = Oe(Y, {}), Se = ge.create("base");
            me.candidateRuleMap.has(Ee) || me.candidateRuleMap.set(Ee, []), me.candidateRuleMap.get(Ee).push([
              {
                sort: Se,
                layer: "base"
              },
              le
            ]);
          }
        },
        /**
        * @param {string} group
        * @param {Record<string, string | string[]>} declarations
        */
        addDefaults(te, Y) {
          const le = {
            [`@defaults ${te}`]: Y
          };
          for (let [Ee, Se] of W(le)) {
            let Pe = Oe(Ee, {});
            me.candidateRuleMap.has(Pe) || me.candidateRuleMap.set(Pe, []), me.candidateRuleMap.get(Pe).push([
              {
                sort: ge.create("defaults"),
                layer: "defaults"
              },
              Se
            ]);
          }
        },
        addComponents(te, Y) {
          Y = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !1
          }, Array.isArray(Y) ? {} : Y);
          for (let [Ee, Se] of W(te)) {
            let Pe = Oe(Ee, Y);
            se.add(Pe), me.candidateRuleMap.has(Pe) || me.candidateRuleMap.set(Pe, []), me.candidateRuleMap.get(Pe).push([
              {
                sort: ge.create("components"),
                layer: "components",
                options: Y
              },
              Se
            ]);
          }
        },
        addUtilities(te, Y) {
          Y = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !0
          }, Array.isArray(Y) ? {} : Y);
          for (let [Ee, Se] of W(te)) {
            let Pe = Oe(Ee, Y);
            se.add(Pe), me.candidateRuleMap.has(Pe) || me.candidateRuleMap.set(Pe, []), me.candidateRuleMap.get(Pe).push([
              {
                sort: ge.create("utilities"),
                layer: "utilities",
                options: Y
              },
              Se
            ]);
          }
        },
        matchUtilities: function(te, Y) {
          Y = C({
            ...{
              respectPrefix: !0,
              respectImportant: !0,
              modifiers: !1
            },
            ...Y
          });
          let Ee = ge.create("utilities");
          for (let Se in te) {
            let Xe = function(We, { isOnlyPlugin: et }) {
              let [De, Me, Qe] = (0, o.coerceValue)(Y.types, We, Y, oe);
              if (De === void 0)
                return [];
              if (!Y.types.some(({ type: qe }) => qe === Me))
                if (et)
                  b.default.warn([
                    `Unnecessary typehint \`${Me}\` in \`${Se}-${We}\`.`,
                    `You can safely update it to \`${Se}-${We.replace(Me + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, T.default)(De))
                return [];
              let He = {
                get modifier() {
                  return Y.modifiers || b.default.warn(`modifier-used-without-options-for-${Se}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Qe;
                }
              }, st = (0, $.flagEnabled)(oe, "generalizedModifiers");
              return [].concat(st ? Ve(De, He) : Ve(De)).filter(Boolean).map((qe) => ({
                [(0, s.default)(Se, We)]: qe
              }));
            }, Pe = Oe(Se, Y), Ve = te[Se];
            se.add([
              Pe,
              Y
            ]);
            let Ye = [
              {
                sort: Ee,
                layer: "utilities",
                options: Y
              },
              Xe
            ];
            me.candidateRuleMap.has(Pe) || me.candidateRuleMap.set(Pe, []), me.candidateRuleMap.get(Pe).push(Ye);
          }
        },
        matchComponents: function(te, Y) {
          Y = C({
            ...{
              respectPrefix: !0,
              respectImportant: !1,
              modifiers: !1
            },
            ...Y
          });
          let Ee = ge.create("components");
          for (let Se in te) {
            let Xe = function(We, { isOnlyPlugin: et }) {
              let [De, Me, Qe] = (0, o.coerceValue)(Y.types, We, Y, oe);
              if (De === void 0)
                return [];
              if (!Y.types.some(({ type: qe }) => qe === Me))
                if (et)
                  b.default.warn([
                    `Unnecessary typehint \`${Me}\` in \`${Se}-${We}\`.`,
                    `You can safely update it to \`${Se}-${We.replace(Me + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, T.default)(De))
                return [];
              let He = {
                get modifier() {
                  return Y.modifiers || b.default.warn(`modifier-used-without-options-for-${Se}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Qe;
                }
              }, st = (0, $.flagEnabled)(oe, "generalizedModifiers");
              return [].concat(st ? Ve(De, He) : Ve(De)).filter(Boolean).map((qe) => ({
                [(0, s.default)(Se, We)]: qe
              }));
            }, Pe = Oe(Se, Y), Ve = te[Se];
            se.add([
              Pe,
              Y
            ]);
            let Ye = [
              {
                sort: Ee,
                layer: "components",
                options: Y
              },
              Xe
            ];
            me.candidateRuleMap.has(Pe) || me.candidateRuleMap.set(Pe, []), me.candidateRuleMap.get(Pe).push(Ye);
          }
        },
        addVariant(te, Y, le = {}) {
          Y = [].concat(Y).map((Ee) => {
            if (typeof Ee != "string")
              return (Se = {}) => {
                let { args: Pe, modifySelectors: Ve, container: Xe, separator: Ye, wrap: We, format: et } = Se, De = Ee(Object.assign({
                  modifySelectors: Ve,
                  container: Xe,
                  separator: Ye
                }, le.type === x.MatchVariant && {
                  args: Pe,
                  wrap: We,
                  format: et
                }));
                if (typeof De == "string" && !B(De))
                  throw new Error(`Your custom variant \`${te}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return Array.isArray(De) ? De.filter((Me) => typeof Me == "string").map((Me) => Q(Me)) : De && typeof De == "string" && Q(De)(Se);
              };
            if (!B(Ee))
              throw new Error(`Your custom variant \`${te}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return Q(Ee);
          }), H(ye, te, le), we.set(te, Y), me.variantOptions.set(te, le);
        },
        matchVariant(te, Y, le) {
          var Ee;
          let Se = (Ee = le == null ? void 0 : le.id) !== null && Ee !== void 0 ? Ee : ++Fe, Pe = te === "@", Ve = (0, $.flagEnabled)(oe, "generalizedModifiers");
          var Xe;
          for (let [et, De] of Object.entries((Xe = le == null ? void 0 : le.values) !== null && Xe !== void 0 ? Xe : {}))
            et !== "DEFAULT" && ue.addVariant(Pe ? `${te}${et}` : `${te}-${et}`, ({ args: Me, container: Qe }) => Y(De, Ve ? {
              modifier: Me == null ? void 0 : Me.modifier,
              container: Qe
            } : {
              container: Qe
            }), {
              ...le,
              value: De,
              id: Se,
              type: x.MatchVariant,
              variantInfo: _.Base
            });
          var Ye;
          let We = "DEFAULT" in ((Ye = le == null ? void 0 : le.values) !== null && Ye !== void 0 ? Ye : {});
          ue.addVariant(te, ({ args: et, container: De }) => {
            if ((et == null ? void 0 : et.value) === m.NONE && !We)
              return null;
            var Me;
            return Y((et == null ? void 0 : et.value) === m.NONE ? le.values.DEFAULT : (Me = et == null ? void 0 : et.value) !== null && Me !== void 0 ? Me : typeof et == "string" ? et : "", Ve ? {
              modifier: et == null ? void 0 : et.modifier,
              container: De
            } : {
              container: De
            });
          }, {
            ...le,
            id: Se,
            type: x.MatchVariant,
            variantInfo: _.Dynamic
          });
        }
      };
      return ue;
    }
    let re = /* @__PURE__ */ new WeakMap();
    function G(oe) {
      return re.has(oe) || re.set(oe, /* @__PURE__ */ new Map()), re.get(oe);
    }
    function N(oe, me) {
      let ye = !1, we = /* @__PURE__ */ new Map();
      for (let se of oe) {
        var ge;
        if (!se) continue;
        let be = a.default.parse(se), Ie = be.hash ? be.href.replace(be.hash, "") : be.href;
        Ie = be.search ? Ie.replace(be.search, "") : Ie;
        let Oe = (ge = r.default.statSync(decodeURIComponent(Ie), {
          throwIfNoEntry: !1
        })) === null || ge === void 0 ? void 0 : ge.mtimeMs;
        Oe && ((!me.has(se) || Oe > me.get(se)) && (ye = !0), we.set(se, Oe));
      }
      return [
        ye,
        we
      ];
    }
    function V(oe) {
      oe.walkAtRules((me) => {
        [
          "responsive",
          "variants"
        ].includes(me.name) && (V(me), me.before(me.nodes), me.remove());
      });
    }
    function F(oe) {
      let me = [];
      return oe.each((ye) => {
        ye.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(ye.name) && (ye.name = "layer", ye.params = "utilities");
      }), oe.walkAtRules("layer", (ye) => {
        if (V(ye), ye.params === "base") {
          for (let we of ye.nodes)
            me.push(function({ addBase: ge }) {
              ge(we, {
                respectPrefix: !1
              });
            });
          ye.remove();
        } else if (ye.params === "components") {
          for (let we of ye.nodes)
            me.push(function({ addComponents: ge }) {
              ge(we, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          ye.remove();
        } else if (ye.params === "utilities") {
          for (let we of ye.nodes)
            me.push(function({ addUtilities: ge }) {
              ge(we, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          ye.remove();
        }
      }), me;
    }
    function X(oe, me) {
      let ye = Object.entries({
        ...y.variantPlugins,
        ...y.corePlugins
      }).map(([Ie, Oe]) => oe.tailwindConfig.corePlugins.includes(Ie) ? Oe : null).filter(Boolean), we = oe.tailwindConfig.plugins.map((Ie) => (Ie.__isOptionsFunction && (Ie = Ie()), typeof Ie == "function" ? Ie : Ie.handler)), ge = F(me), se = [
        y.variantPlugins.pseudoElementVariants,
        y.variantPlugins.pseudoClassVariants,
        y.variantPlugins.ariaVariants,
        y.variantPlugins.dataVariants
      ], be = [
        y.variantPlugins.supportsVariants,
        y.variantPlugins.directionVariants,
        y.variantPlugins.reducedMotionVariants,
        y.variantPlugins.prefersContrastVariants,
        y.variantPlugins.darkVariants,
        y.variantPlugins.printVariant,
        y.variantPlugins.screenVariants,
        y.variantPlugins.orientationVariants
      ];
      return [
        ...ye,
        ...se,
        ...we,
        ...be,
        ...ge
      ];
    }
    function K(oe, me) {
      let ye = [], we = /* @__PURE__ */ new Map();
      me.variantMap = we;
      let ge = new D.Offsets();
      me.offsets = ge;
      let se = /* @__PURE__ */ new Set(), be = J(me.tailwindConfig, me, {
        variantList: ye,
        variantMap: we,
        offsets: ge,
        classList: se
      });
      for (let Y of oe)
        if (Array.isArray(Y))
          for (let le of Y)
            le(be);
        else
          Y == null || Y(be);
      ge.recordVariants(ye, (Y) => we.get(Y).length);
      for (let [Y, le] of we.entries())
        me.variantMap.set(Y, le.map((Ee, Se) => [
          ge.forVariant(Y, Se),
          Ee
        ]));
      var Ie;
      let Oe = ((Ie = me.tailwindConfig.safelist) !== null && Ie !== void 0 ? Ie : []).filter(Boolean);
      if (Oe.length > 0) {
        let Y = [];
        for (let le of Oe) {
          if (typeof le == "string") {
            me.changedContent.push({
              content: le,
              extension: "html"
            });
            continue;
          }
          if (le instanceof RegExp) {
            b.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          Y.push(le);
        }
        if (Y.length > 0) {
          let le = /* @__PURE__ */ new Map(), Ee = me.tailwindConfig.prefix.length, Se = Y.some((Pe) => Pe.pattern.source.includes("!"));
          for (let Pe of se) {
            let Ve = Array.isArray(Pe) ? (() => {
              let [Xe, Ye] = Pe;
              var We;
              let De = Object.keys((We = Ye == null ? void 0 : Ye.values) !== null && We !== void 0 ? We : {}).map((Me) => (0, s.formatClass)(Xe, Me));
              return Ye != null && Ye.supportsNegativeValues && (De = [
                ...De,
                ...De.map((Me) => "-" + Me)
              ], De = [
                ...De,
                ...De.map((Me) => Me.slice(0, Ee) + "-" + Me.slice(Ee))
              ]), Ye.types.some(({ type: Me }) => Me === "color") && (De = [
                ...De,
                ...De.flatMap((Me) => Object.keys(me.tailwindConfig.theme.opacity).map((Qe) => `${Me}/${Qe}`))
              ]), Se && (Ye != null && Ye.respectImportant) && (De = [
                ...De,
                ...De.map((Me) => "!" + Me)
              ]), De;
            })() : [
              Pe
            ];
            for (let Xe of Ve)
              for (let { pattern: Ye, variants: We = [] } of Y)
                if (Ye.lastIndex = 0, le.has(Ye) || le.set(Ye, 0), !!Ye.test(Xe)) {
                  le.set(Ye, le.get(Ye) + 1), me.changedContent.push({
                    content: Xe,
                    extension: "html"
                  });
                  for (let et of We)
                    me.changedContent.push({
                      content: et + me.tailwindConfig.separator + Xe,
                      extension: "html"
                    });
                }
          }
          for (let [Pe, Ve] of le.entries())
            Ve === 0 && b.default.warn([
              `The safelist pattern \`${Pe}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
      }
      var Be, Fe;
      let ue = (Fe = [].concat((Be = me.tailwindConfig.darkMode) !== null && Be !== void 0 ? Be : "media")[1]) !== null && Fe !== void 0 ? Fe : "dark", te = [
        S(me, ue),
        S(me, "group"),
        S(me, "peer")
      ];
      me.getClassOrder = function(le) {
        let Ee = [
          ...le
        ].sort((Xe, Ye) => Xe === Ye ? 0 : Xe < Ye ? -1 : 1), Se = new Map(Ee.map((Xe) => [
          Xe,
          null
        ])), Pe = (0, E.generateRules)(new Set(Ee), me);
        Pe = me.offsets.sort(Pe);
        let Ve = BigInt(te.length);
        for (const [, Xe] of Pe)
          Se.set(Xe.raws.tailwind.candidate, Ve++);
        return le.map((Xe) => {
          var Ye;
          let We = (Ye = Se.get(Xe)) !== null && Ye !== void 0 ? Ye : null, et = te.indexOf(Xe);
          return We === null && et !== -1 && (We = BigInt(et)), [
            Xe,
            We
          ];
        });
      }, me.getClassList = function(le = {}) {
        let Ee = [];
        for (let Ye of se)
          if (Array.isArray(Ye)) {
            var Se;
            let [We, et] = Ye, De = [];
            var Pe;
            let Me = Object.keys((Pe = et == null ? void 0 : et.modifiers) !== null && Pe !== void 0 ? Pe : {});
            if (!(et == null || (Se = et.types) === null || Se === void 0) && Se.some(({ type: st }) => st === "color")) {
              var Ve;
              Me.push(...Object.keys((Ve = me.tailwindConfig.theme.opacity) !== null && Ve !== void 0 ? Ve : {}));
            }
            let Qe = {
              modifiers: Me
            }, He = le.includeMetadata && Me.length > 0;
            var Xe;
            for (let [st, it] of Object.entries((Xe = et == null ? void 0 : et.values) !== null && Xe !== void 0 ? Xe : {})) {
              if (it == null)
                continue;
              let qe = (0, s.formatClass)(We, st);
              if (Ee.push(He ? [
                qe,
                Qe
              ] : qe), et != null && et.supportsNegativeValues && (0, v.default)(it)) {
                let rt = (0, s.formatClass)(We, `-${st}`);
                De.push(He ? [
                  rt,
                  Qe
                ] : rt);
              }
            }
            Ee.push(...De);
          } else
            Ee.push(Ye);
        return Ee;
      }, me.getVariants = function() {
        let le = [];
        for (let [Se, Pe] of me.variantOptions.entries())
          if (Pe.variantInfo !== _.Base) {
            var Ee;
            le.push({
              name: Se,
              isArbitrary: Pe.type === Symbol.for("MATCH_VARIANT"),
              values: Object.keys((Ee = Pe.values) !== null && Ee !== void 0 ? Ee : {}),
              hasDash: Se !== "@",
              selectors({ modifier: Ve, value: Xe } = {}) {
                let Ye = "__TAILWIND_PLACEHOLDER__", We = l.default.rule({
                  selector: `.${Ye}`
                }), et = l.default.root({
                  nodes: [
                    We.clone()
                  ]
                }), De = et.toString();
                var Me;
                let Qe = ((Me = me.variantMap.get(Se)) !== null && Me !== void 0 ? Me : []).flatMap(([ut, Et]) => Et), He = [];
                for (let ut of Qe) {
                  var st;
                  let Et = [];
                  var it;
                  let Tt = {
                    args: {
                      modifier: Ve,
                      value: (it = (st = Pe.values) === null || st === void 0 ? void 0 : st[Xe]) !== null && it !== void 0 ? it : Xe
                    },
                    separator: me.tailwindConfig.separator,
                    modifySelectors(Vt) {
                      return et.each((Kt) => {
                        Kt.type === "rule" && (Kt.selectors = Kt.selectors.map((xt) => Vt({
                          get className() {
                            return (0, E.getClassNameFromSelector)(xt);
                          },
                          selector: xt
                        })));
                      }), et;
                    },
                    format(Vt) {
                      Et.push(Vt);
                    },
                    wrap(Vt) {
                      Et.push(`@${Vt.name} ${Vt.params} { & }`);
                    },
                    container: et
                  }, St = ut(Tt);
                  if (Et.length > 0 && He.push(Et), Array.isArray(St))
                    for (let Vt of St)
                      Et = [], Vt(Tt), He.push(Et);
                }
                let qe = [], rt = et.toString();
                De !== rt && (et.walkRules((ut) => {
                  let Et = ut.selector, Tt = (0, h.default)((St) => {
                    St.walkClasses((Vt) => {
                      Vt.value = `${Se}${me.tailwindConfig.separator}${Vt.value}`;
                    });
                  }).processSync(Et);
                  qe.push(Et.replace(Tt, "&").replace(Ye, "&"));
                }), et.walkAtRules((ut) => {
                  qe.push(`@${ut.name} (${ut.params}) { & }`);
                }));
                var bt;
                let dt = !(Xe in ((bt = Pe.values) !== null && bt !== void 0 ? bt : {}));
                He = He.map((ut) => ut.map((Et) => ({
                  format: Et,
                  isArbitraryVariant: dt
                }))), qe = qe.map((ut) => ({
                  format: ut,
                  isArbitraryVariant: dt
                }));
                let Je = {
                  candidate: Ye,
                  context: me
                }, mt = He.map((ut) => (0, I.finalizeSelector)(`.${Ye}`, (0, I.formatVariantSelector)(ut, Je), Je).replace(`.${Ye}`, "&").replace("{ & }", "").trim());
                return qe.length > 0 && mt.push((0, I.formatVariantSelector)(qe, Je).toString().replace(`.${Ye}`, "&")), mt;
              }
            });
          }
        return le;
      };
    }
    function ie(oe, me) {
      oe.classCache.has(me) && (oe.notClassCache.add(me), oe.classCache.delete(me), oe.applyClassCache.delete(me), oe.candidateRuleMap.delete(me), oe.candidateRuleCache.delete(me), oe.stylesheetCache = null);
    }
    function fe(oe, me) {
      let ye = me.raws.tailwind.candidate;
      if (ye) {
        for (const we of oe.ruleCache)
          we[1].raws.tailwind.candidate === ye && oe.ruleCache.delete(we);
        ie(oe, ye);
      }
    }
    function _e(oe, me = [], ye = l.default.root()) {
      var we;
      let ge = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set(),
        candidateRuleCache: /* @__PURE__ */ new Map(),
        classCache: /* @__PURE__ */ new Map(),
        applyClassCache: /* @__PURE__ */ new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((we = oe.blocklist) !== null && we !== void 0 ? we : []),
        postCssNodeCache: /* @__PURE__ */ new Map(),
        candidateRuleMap: /* @__PURE__ */ new Map(),
        tailwindConfig: oe,
        changedContent: me,
        variantMap: /* @__PURE__ */ new Map(),
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map(),
        markInvalidUtilityCandidate: (be) => ie(ge, be),
        markInvalidUtilityNode: (be) => fe(ge, be)
      }, se = X(ge, ye);
      return K(se, ge), ge;
    }
    let Ae = m.contextMap, ce = m.configContextMap, ee = m.contextSourcesMap;
    function ae(oe, me, ye, we, ge, se) {
      let be = me.opts.from, Ie = we !== null;
      m.env.DEBUG && console.log("Source path:", be);
      let Oe;
      if (Ie && Ae.has(be))
        Oe = Ae.get(be);
      else if (ce.has(ge)) {
        let te = ce.get(ge);
        ee.get(te).add(be), Ae.set(be, te), Oe = te;
      }
      let Be = (0, O.hasContentChanged)(be, oe);
      if (Oe) {
        let [te, Y] = N([
          ...se
        ], G(Oe));
        if (!te && !Be)
          return [
            Oe,
            !1,
            Y
          ];
      }
      if (Ae.has(be)) {
        let te = Ae.get(be);
        if (ee.has(te) && (ee.get(te).delete(be), ee.get(te).size === 0)) {
          ee.delete(te);
          for (let [Y, le] of ce)
            le === te && ce.delete(Y);
          for (let Y of te.disposables.splice(0))
            Y(te);
        }
      }
      m.env.DEBUG && console.log("Setting up new context...");
      let Fe = _e(ye, [], oe);
      Object.assign(Fe, {
        userConfigPath: we
      });
      let [, ue] = N([
        ...se
      ], G(Fe));
      return ce.set(ge, Fe), Ae.set(be, Fe), ee.has(Fe) || ee.set(Fe, /* @__PURE__ */ new Set()), ee.get(Fe).add(be), [
        Fe,
        !0,
        ue
      ];
    }
  }(Vh)), Vh;
}
var G3 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r) {
    return r.ignore ? [] : r.glob ? Ze.env.ROLLUP_WATCH === "true" ? [
      {
        type: "dependency",
        file: r.base
      }
    ] : [
      {
        type: "dir-dependency",
        dir: r.base,
        glob: r.glob
      }
    ] : [
      {
        type: "dependency",
        file: r.base
      }
    ];
  }
})(G3);
var z3 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "validateConfig", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ r(as);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function a(l) {
    return l.content.files.length === 0 && e.default.warn("content-problems", [
      "The `content` option in your Tailwind CSS configuration is missing or empty.",
      "Configure your content sources or your generated CSS will be missing styles.",
      "https://tailwindcss.com/docs/content-configuration"
    ]), l;
  }
})(z3);
var K3 = {};
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var YW = function(e) {
  if (typeof e != "string" || e === "")
    return !1;
  for (var r; r = /(\\).|([@?!+*]\(.*\))/g.exec(e); ) {
    if (r[2]) return !0;
    e = e.slice(r.index + r[0].length);
  }
  return !1;
};
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var XW = YW, Y3 = { "{": "}", "(": ")", "[": "]" }, JW = function(t) {
  if (t[0] === "!")
    return !0;
  for (var e = 0, r = -2, a = -2, l = -2, d = -2, h = -2; e < t.length; ) {
    if (t[e] === "*" || t[e + 1] === "?" && /[\].+)]/.test(t[e]) || a !== -1 && t[e] === "[" && t[e + 1] !== "]" && (a < e && (a = t.indexOf("]", e)), a > e && (h === -1 || h > a || (h = t.indexOf("\\", e), h === -1 || h > a))) || l !== -1 && t[e] === "{" && t[e + 1] !== "}" && (l = t.indexOf("}", e), l > e && (h = t.indexOf("\\", e), h === -1 || h > l)) || d !== -1 && t[e] === "(" && t[e + 1] === "?" && /[:!=]/.test(t[e + 2]) && t[e + 3] !== ")" && (d = t.indexOf(")", e), d > e && (h = t.indexOf("\\", e), h === -1 || h > d)) || r !== -1 && t[e] === "(" && t[e + 1] !== "|" && (r < e && (r = t.indexOf("|", e)), r !== -1 && t[r + 1] !== ")" && (d = t.indexOf(")", r), d > r && (h = t.indexOf("\\", r), h === -1 || h > d))))
      return !0;
    if (t[e] === "\\") {
      var n = t[e + 1];
      e += 2;
      var u = Y3[n];
      if (u) {
        var i = t.indexOf(u, e);
        i !== -1 && (e = i + 1);
      }
      if (t[e] === "!")
        return !0;
    } else
      e++;
  }
  return !1;
}, QW = function(t) {
  if (t[0] === "!")
    return !0;
  for (var e = 0; e < t.length; ) {
    if (/[*?{}()[\]]/.test(t[e]))
      return !0;
    if (t[e] === "\\") {
      var r = t[e + 1];
      e += 2;
      var a = Y3[r];
      if (a) {
        var l = t.indexOf(a, e);
        l !== -1 && (e = l + 1);
      }
      if (t[e] === "!")
        return !0;
    } else
      e++;
  }
  return !1;
}, Kb = function(e, r) {
  if (typeof e != "string" || e === "")
    return !1;
  if (XW(e))
    return !0;
  var a = JW;
  return r && r.strict === !1 && (a = QW), a(e);
}, Zn = {}, Jr = {}, vl = {};
Object.defineProperty(vl, "__esModule", { value: !0 });
vl.splitWhen = vl.flatten = void 0;
function ZW(t) {
  return t.reduce((e, r) => [].concat(e, r), []);
}
vl.flatten = ZW;
function eq(t, e) {
  const r = [[]];
  let a = 0;
  for (const l of t)
    e(l) ? (a++, r[a] = []) : r[a].push(l);
  return r;
}
vl.splitWhen = eq;
var Ap = {};
Object.defineProperty(Ap, "__esModule", { value: !0 });
Ap.isEnoentCodeError = void 0;
function tq(t) {
  return t.code === "ENOENT";
}
Ap.isEnoentCodeError = tq;
var Pp = {};
Object.defineProperty(Pp, "__esModule", { value: !0 });
Pp.createDirentFromStats = void 0;
let rq = class {
  constructor(e, r) {
    this.name = e, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink = r.isSymbolicLink.bind(r);
  }
};
function nq(t, e) {
  return new rq(t, e);
}
Pp.createDirentFromStats = nq;
var bn = {}, Zr = {};
Zr.endianness = function() {
  return "LE";
};
Zr.hostname = function() {
  return typeof location < "u" ? location.hostname : "";
};
Zr.loadavg = function() {
  return [];
};
Zr.uptime = function() {
  return 0;
};
Zr.freemem = function() {
  return Number.MAX_VALUE;
};
Zr.totalmem = function() {
  return Number.MAX_VALUE;
};
Zr.cpus = function() {
  return [];
};
Zr.type = function() {
  return "Browser";
};
Zr.release = function() {
  return typeof navigator < "u" ? navigator.appVersion : "";
};
Zr.networkInterfaces = Zr.getNetworkInterfaces = function() {
  return {};
};
Zr.arch = function() {
  return "javascript";
};
Zr.platform = function() {
  return "browser";
};
Zr.tmpdir = Zr.tmpDir = function() {
  return "/tmp";
};
Zr.EOL = `
`;
Zr.homedir = function() {
  return "/";
};
Object.defineProperty(bn, "__esModule", { value: !0 });
bn.convertPosixPathToPattern = bn.convertWindowsPathToPattern = bn.convertPathToPattern = bn.escapePosixPath = bn.escapeWindowsPath = bn.escape = bn.removeLeadingDotSegment = bn.makeAbsolute = bn.unixify = void 0;
const iq = Zr, sq = Qr, X3 = iq.platform() === "win32", aq = 2, oq = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, lq = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, uq = /^\\\\([.?])/, cq = /\\(?![!()+@[\]{}])/g;
function fq(t) {
  return t.replace(/\\/g, "/");
}
bn.unixify = fq;
function dq(t, e) {
  return sq.resolve(t, e);
}
bn.makeAbsolute = dq;
function pq(t) {
  if (t.charAt(0) === ".") {
    const e = t.charAt(1);
    if (e === "/" || e === "\\")
      return t.slice(aq);
  }
  return t;
}
bn.removeLeadingDotSegment = pq;
bn.escape = X3 ? Yb : Xb;
function Yb(t) {
  return t.replace(lq, "\\$2");
}
bn.escapeWindowsPath = Yb;
function Xb(t) {
  return t.replace(oq, "\\$2");
}
bn.escapePosixPath = Xb;
bn.convertPathToPattern = X3 ? J3 : Q3;
function J3(t) {
  return Yb(t).replace(uq, "//$1").replace(cq, "/");
}
bn.convertWindowsPathToPattern = J3;
function Q3(t) {
  return Xb(t);
}
bn.convertPosixPathToPattern = Q3;
var Qt = {}, hq = Kb, mq = Qr.posix.dirname, yq = Zr.platform() === "win32", qm = "/", bq = /\\/g, gq = /[\{\[].*[\}\]]$/, vq = /(^|[^\\])([\{\[]|\([^\)]+$)/, Eq = /\\([\!\*\?\|\[\]\(\)\{\}])/g, _q = function(e, r) {
  var a = Object.assign({ flipBackslashes: !0 }, r);
  a.flipBackslashes && yq && e.indexOf(qm) < 0 && (e = e.replace(bq, qm)), gq.test(e) && (e += qm), e += "a";
  do
    e = mq(e);
  while (hq(e) || vq.test(e));
  return e.replace(Eq, "$1");
}, Cp = {};
(function(t) {
  t.isInteger = (e) => typeof e == "number" ? Number.isInteger(e) : typeof e == "string" && e.trim() !== "" ? Number.isInteger(Number(e)) : !1, t.find = (e, r) => e.nodes.find((a) => a.type === r), t.exceedsLimit = (e, r, a = 1, l) => l === !1 || !t.isInteger(e) || !t.isInteger(r) ? !1 : (Number(r) - Number(e)) / Number(a) >= l, t.escapeNode = (e, r = 0, a) => {
    const l = e.nodes[r];
    l && (a && l.type === a || l.type === "open" || l.type === "close") && l.escaped !== !0 && (l.value = "\\" + l.value, l.escaped = !0);
  }, t.encloseBrace = (e) => e.type !== "brace" || e.commas >> 0 + e.ranges >> 0 ? !1 : (e.invalid = !0, !0), t.isInvalidBrace = (e) => e.type !== "brace" ? !1 : e.invalid === !0 || e.dollar ? !0 : !(e.commas >> 0 + e.ranges >> 0) || e.open !== !0 || e.close !== !0 ? (e.invalid = !0, !0) : !1, t.isOpenOrClose = (e) => e.type === "open" || e.type === "close" ? !0 : e.open === !0 || e.close === !0, t.reduce = (e) => e.reduce((r, a) => (a.type === "text" && r.push(a.value), a.type === "range" && (a.type = "text"), r), []), t.flatten = (...e) => {
    const r = [], a = (l) => {
      for (let d = 0; d < l.length; d++) {
        const h = l[d];
        if (Array.isArray(h)) {
          a(h);
          continue;
        }
        h !== void 0 && r.push(h);
      }
      return r;
    };
    return a(e), r;
  };
})(Cp);
const FS = Cp;
var Jb = (t, e = {}) => {
  const r = (a, l = {}) => {
    const d = e.escapeInvalid && FS.isInvalidBrace(l), h = a.invalid === !0 && e.escapeInvalid === !0;
    let n = "";
    if (a.value)
      return (d || h) && FS.isOpenOrClose(a) ? "\\" + a.value : a.value;
    if (a.value)
      return a.value;
    if (a.nodes)
      for (const u of a.nodes)
        n += r(u);
    return n;
  };
  return r(t);
};
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var Sq = function(t) {
  return typeof t == "number" ? t - t === 0 : typeof t == "string" && t.trim() !== "" ? Number.isFinite ? Number.isFinite(+t) : isFinite(+t) : !1;
};
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const BS = Sq, io = (t, e, r) => {
  if (BS(t) === !1)
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  if (e === void 0 || t === e)
    return String(t);
  if (BS(e) === !1)
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  let a = { relaxZeros: !0, ...r };
  typeof a.strictZeros == "boolean" && (a.relaxZeros = a.strictZeros === !1);
  let l = String(a.relaxZeros), d = String(a.shorthand), h = String(a.capture), n = String(a.wrap), u = t + ":" + e + "=" + l + d + h + n;
  if (io.cache.hasOwnProperty(u))
    return io.cache[u].result;
  let i = Math.min(t, e), c = Math.max(t, e);
  if (Math.abs(i - c) === 1) {
    let m = t + "|" + e;
    return a.capture ? `(${m})` : a.wrap === !1 ? m : `(?:${m})`;
  }
  let f = HS(t) || HS(e), s = { min: t, max: e, a: i, b: c }, o = [], y = [];
  if (f && (s.isPadded = f, s.maxLen = String(s.max).length), i < 0) {
    let m = c < 0 ? Math.abs(c) : 1;
    y = $S(m, Math.abs(i), s, a), i = s.a = 0;
  }
  return c >= 0 && (o = $S(i, c, s, a)), s.negatives = y, s.positives = o, s.result = wq(y, o), a.capture === !0 ? s.result = `(${s.result})` : a.wrap !== !1 && o.length + y.length > 1 && (s.result = `(?:${s.result})`), io.cache[u] = s, s.result;
};
function wq(t, e, r) {
  let a = Hm(t, e, "-", !1) || [], l = Hm(e, t, "", !1) || [], d = Hm(t, e, "-?", !0) || [];
  return a.concat(d).concat(l).join("|");
}
function xq(t, e) {
  let r = 1, a = 1, l = VS(t, r), d = /* @__PURE__ */ new Set([e]);
  for (; t <= l && l <= e; )
    d.add(l), r += 1, l = VS(t, r);
  for (l = WS(e + 1, a) - 1; t < l && l <= e; )
    d.add(l), a += 1, l = WS(e + 1, a) - 1;
  return d = [...d], d.sort(Pq), d;
}
function Tq(t, e, r) {
  if (t === e)
    return { pattern: t, count: [], digits: 0 };
  let a = Aq(t, e), l = a.length, d = "", h = 0;
  for (let n = 0; n < l; n++) {
    let [u, i] = a[n];
    u === i ? d += u : u !== "0" || i !== "9" ? d += Cq(u, i) : h++;
  }
  return h && (d += r.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: d, count: [h], digits: l };
}
function $S(t, e, r, a) {
  let l = xq(t, e), d = [], h = t, n;
  for (let u = 0; u < l.length; u++) {
    let i = l[u], c = Tq(String(h), String(i), a), f = "";
    if (!r.isPadded && n && n.pattern === c.pattern) {
      n.count.length > 1 && n.count.pop(), n.count.push(c.count[0]), n.string = n.pattern + qS(n.count), h = i + 1;
      continue;
    }
    r.isPadded && (f = Iq(i, r, a)), c.string = f + c.pattern + qS(c.count), d.push(c), h = i + 1, n = c;
  }
  return d;
}
function Hm(t, e, r, a, l) {
  let d = [];
  for (let h of t) {
    let { string: n } = h;
    !a && !US(e, "string", n) && d.push(r + n), a && US(e, "string", n) && d.push(r + n);
  }
  return d;
}
function Aq(t, e) {
  let r = [];
  for (let a = 0; a < t.length; a++) r.push([t[a], e[a]]);
  return r;
}
function Pq(t, e) {
  return t > e ? 1 : e > t ? -1 : 0;
}
function US(t, e, r) {
  return t.some((a) => a[e] === r);
}
function VS(t, e) {
  return Number(String(t).slice(0, -e) + "9".repeat(e));
}
function WS(t, e) {
  return t - t % Math.pow(10, e);
}
function qS(t) {
  let [e = 0, r = ""] = t;
  return r || e > 1 ? `{${e + (r ? "," + r : "")}}` : "";
}
function Cq(t, e, r) {
  return `[${t}${e - t === 1 ? "" : "-"}${e}]`;
}
function HS(t) {
  return /^-?(0+)\d/.test(t);
}
function Iq(t, e, r) {
  if (!e.isPadded)
    return t;
  let a = Math.abs(e.maxLen - String(t).length), l = r.relaxZeros !== !1;
  switch (a) {
    case 0:
      return "";
    case 1:
      return l ? "0?" : "0";
    case 2:
      return l ? "0{0,2}" : "00";
    default:
      return l ? `0{0,${a}}` : `0{${a}}`;
  }
}
io.cache = {};
io.clearCache = () => io.cache = {};
var Oq = io;
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
const kq = Fi, Z3 = Oq, GS = (t) => t !== null && typeof t == "object" && !Array.isArray(t), Dq = (t) => (e) => t === !0 ? Number(e) : String(e), Gm = (t) => typeof t == "number" || typeof t == "string" && t !== "", vu = (t) => Number.isInteger(+t), zm = (t) => {
  let e = `${t}`, r = -1;
  if (e[0] === "-" && (e = e.slice(1)), e === "0") return !1;
  for (; e[++r] === "0"; ) ;
  return r > 0;
}, Nq = (t, e, r) => typeof t == "string" || typeof e == "string" ? !0 : r.stringify === !0, Rq = (t, e, r) => {
  if (e > 0) {
    let a = t[0] === "-" ? "-" : "";
    a && (t = t.slice(1)), t = a + t.padStart(a ? e - 1 : e, "0");
  }
  return r === !1 ? String(t) : t;
}, td = (t, e) => {
  let r = t[0] === "-" ? "-" : "";
  for (r && (t = t.slice(1), e--); t.length < e; ) t = "0" + t;
  return r ? "-" + t : t;
}, Mq = (t, e, r) => {
  t.negatives.sort((n, u) => n < u ? -1 : n > u ? 1 : 0), t.positives.sort((n, u) => n < u ? -1 : n > u ? 1 : 0);
  let a = e.capture ? "" : "?:", l = "", d = "", h;
  return t.positives.length && (l = t.positives.map((n) => td(String(n), r)).join("|")), t.negatives.length && (d = `-(${a}${t.negatives.map((n) => td(String(n), r)).join("|")})`), l && d ? h = `${l}|${d}` : h = l || d, e.wrap ? `(${a}${h})` : h;
}, e4 = (t, e, r, a) => {
  if (r)
    return Z3(t, e, { wrap: !1, ...a });
  let l = String.fromCharCode(t);
  if (t === e) return l;
  let d = String.fromCharCode(e);
  return `[${l}-${d}]`;
}, t4 = (t, e, r) => {
  if (Array.isArray(t)) {
    let a = r.wrap === !0, l = r.capture ? "" : "?:";
    return a ? `(${l}${t.join("|")})` : t.join("|");
  }
  return Z3(t, e, r);
}, r4 = (...t) => new RangeError("Invalid range arguments: " + kq.inspect(...t)), n4 = (t, e, r) => {
  if (r.strictRanges === !0) throw r4([t, e]);
  return [];
}, Lq = (t, e) => {
  if (e.strictRanges === !0)
    throw new TypeError(`Expected step "${t}" to be a number`);
  return [];
}, jq = (t, e, r = 1, a = {}) => {
  let l = Number(t), d = Number(e);
  if (!Number.isInteger(l) || !Number.isInteger(d)) {
    if (a.strictRanges === !0) throw r4([t, e]);
    return [];
  }
  l === 0 && (l = 0), d === 0 && (d = 0);
  let h = l > d, n = String(t), u = String(e), i = String(r);
  r = Math.max(Math.abs(r), 1);
  let c = zm(n) || zm(u) || zm(i), f = c ? Math.max(n.length, u.length, i.length) : 0, s = c === !1 && Nq(t, e, a) === !1, o = a.transform || Dq(s);
  if (a.toRegex && r === 1)
    return e4(td(t, f), td(e, f), !0, a);
  let y = { negatives: [], positives: [] }, m = (v) => y[v < 0 ? "negatives" : "positives"].push(Math.abs(v)), g = [], b = 0;
  for (; h ? l >= d : l <= d; )
    a.toRegex === !0 && r > 1 ? m(l) : g.push(Rq(o(l, b), f, s)), l = h ? l - r : l + r, b++;
  return a.toRegex === !0 ? r > 1 ? Mq(y, a, f) : t4(g, null, { wrap: !1, ...a }) : g;
}, Fq = (t, e, r = 1, a = {}) => {
  if (!vu(t) && t.length > 1 || !vu(e) && e.length > 1)
    return n4(t, e, a);
  let l = a.transform || ((s) => String.fromCharCode(s)), d = `${t}`.charCodeAt(0), h = `${e}`.charCodeAt(0), n = d > h, u = Math.min(d, h), i = Math.max(d, h);
  if (a.toRegex && r === 1)
    return e4(u, i, !1, a);
  let c = [], f = 0;
  for (; n ? d >= h : d <= h; )
    c.push(l(d, f)), d = n ? d - r : d + r, f++;
  return a.toRegex === !0 ? t4(c, null, { wrap: !1, options: a }) : c;
}, Af = (t, e, r, a = {}) => {
  if (e == null && Gm(t))
    return [t];
  if (!Gm(t) || !Gm(e))
    return n4(t, e, a);
  if (typeof r == "function")
    return Af(t, e, 1, { transform: r });
  if (GS(r))
    return Af(t, e, 0, r);
  let l = { ...a };
  return l.capture === !0 && (l.wrap = !0), r = r || l.step || 1, vu(r) ? vu(t) && vu(e) ? jq(t, e, r, l) : Fq(t, e, Math.max(Math.abs(r), 1), l) : r != null && !GS(r) ? Lq(r, l) : Af(t, e, 1, r);
};
var i4 = Af;
const Bq = i4, zS = Cp, $q = (t, e = {}) => {
  const r = (a, l = {}) => {
    const d = zS.isInvalidBrace(l), h = a.invalid === !0 && e.escapeInvalid === !0, n = d === !0 || h === !0, u = e.escapeInvalid === !0 ? "\\" : "";
    let i = "";
    if (a.isOpen === !0)
      return u + a.value;
    if (a.isClose === !0)
      return console.log("node.isClose", u, a.value), u + a.value;
    if (a.type === "open")
      return n ? u + a.value : "(";
    if (a.type === "close")
      return n ? u + a.value : ")";
    if (a.type === "comma")
      return a.prev.type === "comma" ? "" : n ? a.value : "|";
    if (a.value)
      return a.value;
    if (a.nodes && a.ranges > 0) {
      const c = zS.reduce(a.nodes), f = Bq(...c, { ...e, wrap: !1, toRegex: !0, strictZeros: !0 });
      if (f.length !== 0)
        return c.length > 1 && f.length > 1 ? `(${f})` : f;
    }
    if (a.nodes)
      for (const c of a.nodes)
        i += r(c, a);
    return i;
  };
  return r(t);
};
var Uq = $q;
const Vq = i4, KS = Jb, zo = Cp, za = (t = "", e = "", r = !1) => {
  const a = [];
  if (t = [].concat(t), e = [].concat(e), !e.length) return t;
  if (!t.length)
    return r ? zo.flatten(e).map((l) => `{${l}}`) : e;
  for (const l of t)
    if (Array.isArray(l))
      for (const d of l)
        a.push(za(d, e, r));
    else
      for (let d of e)
        r === !0 && typeof d == "string" && (d = `{${d}}`), a.push(Array.isArray(d) ? za(l, d, r) : l + d);
  return zo.flatten(a);
}, Wq = (t, e = {}) => {
  const r = e.rangeLimit === void 0 ? 1e3 : e.rangeLimit, a = (l, d = {}) => {
    l.queue = [];
    let h = d, n = d.queue;
    for (; h.type !== "brace" && h.type !== "root" && h.parent; )
      h = h.parent, n = h.queue;
    if (l.invalid || l.dollar) {
      n.push(za(n.pop(), KS(l, e)));
      return;
    }
    if (l.type === "brace" && l.invalid !== !0 && l.nodes.length === 2) {
      n.push(za(n.pop(), ["{}"]));
      return;
    }
    if (l.nodes && l.ranges > 0) {
      const f = zo.reduce(l.nodes);
      if (zo.exceedsLimit(...f, e.step, r))
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      let s = Vq(...f, e);
      s.length === 0 && (s = KS(l, e)), n.push(za(n.pop(), s)), l.nodes = [];
      return;
    }
    const u = zo.encloseBrace(l);
    let i = l.queue, c = l;
    for (; c.type !== "brace" && c.type !== "root" && c.parent; )
      c = c.parent, i = c.queue;
    for (let f = 0; f < l.nodes.length; f++) {
      const s = l.nodes[f];
      if (s.type === "comma" && l.type === "brace") {
        f === 1 && i.push(""), i.push("");
        continue;
      }
      if (s.type === "close") {
        n.push(za(n.pop(), i, u));
        continue;
      }
      if (s.value && s.type !== "open") {
        i.push(za(i.pop(), s.value));
        continue;
      }
      s.nodes && a(s, l);
    }
    return i;
  };
  return zo.flatten(a(t));
};
var qq = Wq, Hq = {
  MAX_LENGTH: 1e4,
  // Digits
  CHAR_0: "0",
  /* 0 */
  CHAR_9: "9",
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: "A",
  /* A */
  CHAR_LOWERCASE_A: "a",
  /* a */
  CHAR_UPPERCASE_Z: "Z",
  /* Z */
  CHAR_LOWERCASE_Z: "z",
  /* z */
  CHAR_LEFT_PARENTHESES: "(",
  /* ( */
  CHAR_RIGHT_PARENTHESES: ")",
  /* ) */
  CHAR_ASTERISK: "*",
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: "&",
  /* & */
  CHAR_AT: "@",
  /* @ */
  CHAR_BACKSLASH: "\\",
  /* \ */
  CHAR_BACKTICK: "`",
  /* ` */
  CHAR_CARRIAGE_RETURN: "\r",
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: "^",
  /* ^ */
  CHAR_COLON: ":",
  /* : */
  CHAR_COMMA: ",",
  /* , */
  CHAR_DOLLAR: "$",
  /* . */
  CHAR_DOT: ".",
  /* . */
  CHAR_DOUBLE_QUOTE: '"',
  /* " */
  CHAR_EQUAL: "=",
  /* = */
  CHAR_EXCLAMATION_MARK: "!",
  /* ! */
  CHAR_FORM_FEED: "\f",
  /* \f */
  CHAR_FORWARD_SLASH: "/",
  /* / */
  CHAR_HASH: "#",
  /* # */
  CHAR_HYPHEN_MINUS: "-",
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: "<",
  /* < */
  CHAR_LEFT_CURLY_BRACE: "{",
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: "[",
  /* [ */
  CHAR_LINE_FEED: `
`,
  /* \n */
  CHAR_NO_BREAK_SPACE: " ",
  /* \u00A0 */
  CHAR_PERCENT: "%",
  /* % */
  CHAR_PLUS: "+",
  /* + */
  CHAR_QUESTION_MARK: "?",
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: ">",
  /* > */
  CHAR_RIGHT_CURLY_BRACE: "}",
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: "]",
  /* ] */
  CHAR_SEMICOLON: ";",
  /* ; */
  CHAR_SINGLE_QUOTE: "'",
  /* ' */
  CHAR_SPACE: " ",
  /*   */
  CHAR_TAB: "	",
  /* \t */
  CHAR_UNDERSCORE: "_",
  /* _ */
  CHAR_VERTICAL_LINE: "|",
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  /* \uFEFF */
};
const Gq = Jb, {
  MAX_LENGTH: YS,
  CHAR_BACKSLASH: Km,
  /* \ */
  CHAR_BACKTICK: zq,
  /* ` */
  CHAR_COMMA: Kq,
  /* , */
  CHAR_DOT: Yq,
  /* . */
  CHAR_LEFT_PARENTHESES: Xq,
  /* ( */
  CHAR_RIGHT_PARENTHESES: Jq,
  /* ) */
  CHAR_LEFT_CURLY_BRACE: Qq,
  /* { */
  CHAR_RIGHT_CURLY_BRACE: Zq,
  /* } */
  CHAR_LEFT_SQUARE_BRACKET: XS,
  /* [ */
  CHAR_RIGHT_SQUARE_BRACKET: JS,
  /* ] */
  CHAR_DOUBLE_QUOTE: eH,
  /* " */
  CHAR_SINGLE_QUOTE: tH,
  /* ' */
  CHAR_NO_BREAK_SPACE: rH,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: nH
} = Hq, iH = (t, e = {}) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  const r = e || {}, a = typeof r.maxLength == "number" ? Math.min(YS, r.maxLength) : YS;
  if (t.length > a)
    throw new SyntaxError(`Input length (${t.length}), exceeds max characters (${a})`);
  const l = { type: "root", input: t, nodes: [] }, d = [l];
  let h = l, n = l, u = 0;
  const i = t.length;
  let c = 0, f = 0, s;
  const o = () => t[c++], y = (m) => {
    if (m.type === "text" && n.type === "dot" && (n.type = "text"), n && n.type === "text" && m.type === "text") {
      n.value += m.value;
      return;
    }
    return h.nodes.push(m), m.parent = h, m.prev = n, n = m, m;
  };
  for (y({ type: "bos" }); c < i; )
    if (h = d[d.length - 1], s = o(), !(s === nH || s === rH)) {
      if (s === Km) {
        y({ type: "text", value: (e.keepEscaping ? s : "") + o() });
        continue;
      }
      if (s === JS) {
        y({ type: "text", value: "\\" + s });
        continue;
      }
      if (s === XS) {
        u++;
        let m;
        for (; c < i && (m = o()); ) {
          if (s += m, m === XS) {
            u++;
            continue;
          }
          if (m === Km) {
            s += o();
            continue;
          }
          if (m === JS && (u--, u === 0))
            break;
        }
        y({ type: "text", value: s });
        continue;
      }
      if (s === Xq) {
        h = y({ type: "paren", nodes: [] }), d.push(h), y({ type: "text", value: s });
        continue;
      }
      if (s === Jq) {
        if (h.type !== "paren") {
          y({ type: "text", value: s });
          continue;
        }
        h = d.pop(), y({ type: "text", value: s }), h = d[d.length - 1];
        continue;
      }
      if (s === eH || s === tH || s === zq) {
        const m = s;
        let g;
        for (e.keepQuotes !== !0 && (s = ""); c < i && (g = o()); ) {
          if (g === Km) {
            s += g + o();
            continue;
          }
          if (g === m) {
            e.keepQuotes === !0 && (s += g);
            break;
          }
          s += g;
        }
        y({ type: "text", value: s });
        continue;
      }
      if (s === Qq) {
        f++;
        const g = {
          type: "brace",
          open: !0,
          close: !1,
          dollar: n.value && n.value.slice(-1) === "$" || h.dollar === !0,
          depth: f,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        h = y(g), d.push(h), y({ type: "open", value: s });
        continue;
      }
      if (s === Zq) {
        if (h.type !== "brace") {
          y({ type: "text", value: s });
          continue;
        }
        const m = "close";
        h = d.pop(), h.close = !0, y({ type: m, value: s }), f--, h = d[d.length - 1];
        continue;
      }
      if (s === Kq && f > 0) {
        if (h.ranges > 0) {
          h.ranges = 0;
          const m = h.nodes.shift();
          h.nodes = [m, { type: "text", value: Gq(h) }];
        }
        y({ type: "comma", value: s }), h.commas++;
        continue;
      }
      if (s === Yq && f > 0 && h.commas === 0) {
        const m = h.nodes;
        if (f === 0 || m.length === 0) {
          y({ type: "text", value: s });
          continue;
        }
        if (n.type === "dot") {
          if (h.range = [], n.value += s, n.type = "range", h.nodes.length !== 3 && h.nodes.length !== 5) {
            h.invalid = !0, h.ranges = 0, n.type = "text";
            continue;
          }
          h.ranges++, h.args = [];
          continue;
        }
        if (n.type === "range") {
          m.pop();
          const g = m[m.length - 1];
          g.value += n.value + s, n = g, h.ranges--;
          continue;
        }
        y({ type: "dot", value: s });
        continue;
      }
      y({ type: "text", value: s });
    }
  do
    if (h = d.pop(), h.type !== "root") {
      h.nodes.forEach((b) => {
        b.nodes || (b.type === "open" && (b.isOpen = !0), b.type === "close" && (b.isClose = !0), b.nodes || (b.type = "text"), b.invalid = !0);
      });
      const m = d[d.length - 1], g = m.nodes.indexOf(h);
      m.nodes.splice(g, 1, ...h.nodes);
    }
  while (d.length > 0);
  return y({ type: "eos" }), l;
};
var sH = iH;
const QS = Jb, aH = Uq, oH = qq, lH = sH, _i = (t, e = {}) => {
  let r = [];
  if (Array.isArray(t))
    for (const a of t) {
      const l = _i.create(a, e);
      Array.isArray(l) ? r.push(...l) : r.push(l);
    }
  else
    r = [].concat(_i.create(t, e));
  return e && e.expand === !0 && e.nodupes === !0 && (r = [...new Set(r)]), r;
};
_i.parse = (t, e = {}) => lH(t, e);
_i.stringify = (t, e = {}) => QS(typeof t == "string" ? _i.parse(t, e) : t, e);
_i.compile = (t, e = {}) => (typeof t == "string" && (t = _i.parse(t, e)), aH(t, e));
_i.expand = (t, e = {}) => {
  typeof t == "string" && (t = _i.parse(t, e));
  let r = oH(t, e);
  return e.noempty === !0 && (r = r.filter(Boolean)), e.nodupes === !0 && (r = [...new Set(r)]), r;
};
_i.create = (t, e = {}) => t === "" || t.length < 3 ? [t] : e.expand !== !0 ? _i.compile(t, e) : _i.expand(t, e);
var uH = _i, pc = {};
const cH = Qr, bs = "\\\\/", ZS = `[^${bs}]`, Js = "\\.", fH = "\\+", dH = "\\?", Ip = "\\/", pH = "(?=.)", s4 = "[^/]", Qb = `(?:${Ip}|$)`, a4 = `(?:^|${Ip})`, Zb = `${Js}{1,2}${Qb}`, hH = `(?!${Js})`, mH = `(?!${a4}${Zb})`, yH = `(?!${Js}{0,1}${Qb})`, bH = `(?!${Zb})`, gH = `[^.${Ip}]`, vH = `${s4}*?`, o4 = {
  DOT_LITERAL: Js,
  PLUS_LITERAL: fH,
  QMARK_LITERAL: dH,
  SLASH_LITERAL: Ip,
  ONE_CHAR: pH,
  QMARK: s4,
  END_ANCHOR: Qb,
  DOTS_SLASH: Zb,
  NO_DOT: hH,
  NO_DOTS: mH,
  NO_DOT_SLASH: yH,
  NO_DOTS_SLASH: bH,
  QMARK_NO_DOT: gH,
  STAR: vH,
  START_ANCHOR: a4
}, EH = {
  ...o4,
  SLASH_LITERAL: `[${bs}]`,
  QMARK: ZS,
  STAR: `${ZS}*?`,
  DOTS_SLASH: `${Js}{1,2}(?:[${bs}]|$)`,
  NO_DOT: `(?!${Js})`,
  NO_DOTS: `(?!(?:^|[${bs}])${Js}{1,2}(?:[${bs}]|$))`,
  NO_DOT_SLASH: `(?!${Js}{0,1}(?:[${bs}]|$))`,
  NO_DOTS_SLASH: `(?!${Js}{1,2}(?:[${bs}]|$))`,
  QMARK_NO_DOT: `[^.${bs}]`,
  START_ANCHOR: `(?:^|[${bs}])`,
  END_ANCHOR: `(?:[${bs}]|$)`
}, _H = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var Op = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: _H,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  SEP: cH.sep,
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(t) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${t.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(t) {
    return t === !0 ? EH : o4;
  }
};
(function(t) {
  const e = Qr, r = Ze.platform === "win32", {
    REGEX_BACKSLASH: a,
    REGEX_REMOVE_BACKSLASH: l,
    REGEX_SPECIAL_CHARS: d,
    REGEX_SPECIAL_CHARS_GLOBAL: h
  } = Op;
  t.isObject = (n) => n !== null && typeof n == "object" && !Array.isArray(n), t.hasRegexChars = (n) => d.test(n), t.isRegexChar = (n) => n.length === 1 && t.hasRegexChars(n), t.escapeRegex = (n) => n.replace(h, "\\$1"), t.toPosixSlashes = (n) => n.replace(a, "/"), t.removeBackslashes = (n) => n.replace(l, (u) => u === "\\" ? "" : u), t.supportsLookbehinds = () => {
    const n = Ze.version.slice(1).split(".").map(Number);
    return n.length === 3 && n[0] >= 9 || n[0] === 8 && n[1] >= 10;
  }, t.isWindows = (n) => n && typeof n.windows == "boolean" ? n.windows : r === !0 || e.sep === "\\", t.escapeLast = (n, u, i) => {
    const c = n.lastIndexOf(u, i);
    return c === -1 ? n : n[c - 1] === "\\" ? t.escapeLast(n, u, c - 1) : `${n.slice(0, c)}\\${n.slice(c)}`;
  }, t.removePrefix = (n, u = {}) => {
    let i = n;
    return i.startsWith("./") && (i = i.slice(2), u.prefix = "./"), i;
  }, t.wrapOutput = (n, u = {}, i = {}) => {
    const c = i.contains ? "" : "^", f = i.contains ? "" : "$";
    let s = `${c}(?:${n})${f}`;
    return u.negated === !0 && (s = `(?:^(?!${s}).*$)`), s;
  };
})(pc);
const ew = pc, {
  CHAR_ASTERISK: Ym,
  /* * */
  CHAR_AT: SH,
  /* @ */
  CHAR_BACKWARD_SLASH: cu,
  /* \ */
  CHAR_COMMA: wH,
  /* , */
  CHAR_DOT: Xm,
  /* . */
  CHAR_EXCLAMATION_MARK: Jm,
  /* ! */
  CHAR_FORWARD_SLASH: l4,
  /* / */
  CHAR_LEFT_CURLY_BRACE: Qm,
  /* { */
  CHAR_LEFT_PARENTHESES: Zm,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: xH,
  /* [ */
  CHAR_PLUS: TH,
  /* + */
  CHAR_QUESTION_MARK: tw,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE: AH,
  /* } */
  CHAR_RIGHT_PARENTHESES: rw,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: PH
  /* ] */
} = Op, nw = (t) => t === l4 || t === cu, iw = (t) => {
  t.isPrefix !== !0 && (t.depth = t.isGlobstar ? 1 / 0 : 1);
}, CH = (t, e) => {
  const r = e || {}, a = t.length - 1, l = r.parts === !0 || r.scanToEnd === !0, d = [], h = [], n = [];
  let u = t, i = -1, c = 0, f = 0, s = !1, o = !1, y = !1, m = !1, g = !1, b = !1, v = !1, T = !1, E = !1, O = !1, D = 0, $, I, k = { value: "", depth: 0, isGlob: !1 };
  const L = () => i >= a, M = () => u.charCodeAt(i + 1), x = () => ($ = I, u.charCodeAt(++i));
  for (; i < a; ) {
    I = x();
    let H;
    if (I === cu) {
      v = k.backslashes = !0, I = x(), I === Qm && (b = !0);
      continue;
    }
    if (b === !0 || I === Qm) {
      for (D++; L() !== !0 && (I = x()); ) {
        if (I === cu) {
          v = k.backslashes = !0, x();
          continue;
        }
        if (I === Qm) {
          D++;
          continue;
        }
        if (b !== !0 && I === Xm && (I = x()) === Xm) {
          if (s = k.isBrace = !0, y = k.isGlob = !0, O = !0, l === !0)
            continue;
          break;
        }
        if (b !== !0 && I === wH) {
          if (s = k.isBrace = !0, y = k.isGlob = !0, O = !0, l === !0)
            continue;
          break;
        }
        if (I === AH && (D--, D === 0)) {
          b = !1, s = k.isBrace = !0, O = !0;
          break;
        }
      }
      if (l === !0)
        continue;
      break;
    }
    if (I === l4) {
      if (d.push(i), h.push(k), k = { value: "", depth: 0, isGlob: !1 }, O === !0) continue;
      if ($ === Xm && i === c + 1) {
        c += 2;
        continue;
      }
      f = i + 1;
      continue;
    }
    if (r.noext !== !0 && (I === TH || I === SH || I === Ym || I === tw || I === Jm) === !0 && M() === Zm) {
      if (y = k.isGlob = !0, m = k.isExtglob = !0, O = !0, I === Jm && i === c && (E = !0), l === !0) {
        for (; L() !== !0 && (I = x()); ) {
          if (I === cu) {
            v = k.backslashes = !0, I = x();
            continue;
          }
          if (I === rw) {
            y = k.isGlob = !0, O = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (I === Ym) {
      if ($ === Ym && (g = k.isGlobstar = !0), y = k.isGlob = !0, O = !0, l === !0)
        continue;
      break;
    }
    if (I === tw) {
      if (y = k.isGlob = !0, O = !0, l === !0)
        continue;
      break;
    }
    if (I === xH) {
      for (; L() !== !0 && (H = x()); ) {
        if (H === cu) {
          v = k.backslashes = !0, x();
          continue;
        }
        if (H === PH) {
          o = k.isBracket = !0, y = k.isGlob = !0, O = !0;
          break;
        }
      }
      if (l === !0)
        continue;
      break;
    }
    if (r.nonegate !== !0 && I === Jm && i === c) {
      T = k.negated = !0, c++;
      continue;
    }
    if (r.noparen !== !0 && I === Zm) {
      if (y = k.isGlob = !0, l === !0) {
        for (; L() !== !0 && (I = x()); ) {
          if (I === Zm) {
            v = k.backslashes = !0, I = x();
            continue;
          }
          if (I === rw) {
            O = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (y === !0) {
      if (O = !0, l === !0)
        continue;
      break;
    }
  }
  r.noext === !0 && (m = !1, y = !1);
  let _ = u, S = "", C = "";
  c > 0 && (S = u.slice(0, c), u = u.slice(c), f -= c), _ && y === !0 && f > 0 ? (_ = u.slice(0, f), C = u.slice(f)) : y === !0 ? (_ = "", C = u) : _ = u, _ && _ !== "" && _ !== "/" && _ !== u && nw(_.charCodeAt(_.length - 1)) && (_ = _.slice(0, -1)), r.unescape === !0 && (C && (C = ew.removeBackslashes(C)), _ && v === !0 && (_ = ew.removeBackslashes(_)));
  const R = {
    prefix: S,
    input: t,
    start: c,
    base: _,
    glob: C,
    isBrace: s,
    isBracket: o,
    isGlob: y,
    isExtglob: m,
    isGlobstar: g,
    negated: T,
    negatedExtglob: E
  };
  if (r.tokens === !0 && (R.maxDepth = 0, nw(I) || h.push(k), R.tokens = h), r.parts === !0 || r.tokens === !0) {
    let H;
    for (let z = 0; z < d.length; z++) {
      const U = H ? H + 1 : c, P = d[z], W = t.slice(U, P);
      r.tokens && (z === 0 && c !== 0 ? (h[z].isPrefix = !0, h[z].value = S) : h[z].value = W, iw(h[z]), R.maxDepth += h[z].depth), (z !== 0 || W !== "") && n.push(W), H = P;
    }
    if (H && H + 1 < t.length) {
      const z = t.slice(H + 1);
      n.push(z), r.tokens && (h[h.length - 1].value = z, iw(h[h.length - 1]), R.maxDepth += h[h.length - 1].depth);
    }
    R.slashes = d, R.parts = n;
  }
  return R;
};
var IH = CH;
const rd = Op, gi = pc, {
  MAX_LENGTH: nd,
  POSIX_REGEX_SOURCE: OH,
  REGEX_NON_SPECIAL_CHARS: kH,
  REGEX_SPECIAL_CHARS_BACKREF: DH,
  REPLACEMENTS: u4
} = rd, NH = (t, e) => {
  if (typeof e.expandRange == "function")
    return e.expandRange(...t, e);
  t.sort();
  const r = `[${t.join("-")}]`;
  try {
    new RegExp(r);
  } catch {
    return t.map((l) => gi.escapeRegex(l)).join("..");
  }
  return r;
}, $o = (t, e) => `Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`, eg = (t, e) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  t = u4[t] || t;
  const r = { ...e }, a = typeof r.maxLength == "number" ? Math.min(nd, r.maxLength) : nd;
  let l = t.length;
  if (l > a)
    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${a}`);
  const d = { type: "bos", value: "", output: r.prepend || "" }, h = [d], n = r.capture ? "" : "?:", u = gi.isWindows(e), i = rd.globChars(u), c = rd.extglobChars(i), {
    DOT_LITERAL: f,
    PLUS_LITERAL: s,
    SLASH_LITERAL: o,
    ONE_CHAR: y,
    DOTS_SLASH: m,
    NO_DOT: g,
    NO_DOT_SLASH: b,
    NO_DOTS_SLASH: v,
    QMARK: T,
    QMARK_NO_DOT: E,
    STAR: O,
    START_ANCHOR: D
  } = i, $ = (F) => `(${n}(?:(?!${D}${F.dot ? m : f}).)*?)`, I = r.dot ? "" : g, k = r.dot ? T : E;
  let L = r.bash === !0 ? $(r) : O;
  r.capture && (L = `(${L})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
  const M = {
    input: t,
    index: -1,
    start: 0,
    dot: r.dot === !0,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: !1,
    negated: !1,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: !1,
    tokens: h
  };
  t = gi.removePrefix(t, M), l = t.length;
  const x = [], _ = [], S = [];
  let C = d, R;
  const H = () => M.index === l - 1, z = M.peek = (F = 1) => t[M.index + F], U = M.advance = () => t[++M.index] || "", P = () => t.slice(M.index + 1), W = (F = "", X = 0) => {
    M.consumed += F, M.index += X;
  }, B = (F) => {
    M.output += F.output != null ? F.output : F.value, W(F.value);
  }, Q = () => {
    let F = 1;
    for (; z() === "!" && (z(2) !== "(" || z(3) === "?"); )
      U(), M.start++, F++;
    return F % 2 === 0 ? !1 : (M.negated = !0, M.start++, !0);
  }, J = (F) => {
    M[F]++, S.push(F);
  }, re = (F) => {
    M[F]--, S.pop();
  }, G = (F) => {
    if (C.type === "globstar") {
      const X = M.braces > 0 && (F.type === "comma" || F.type === "brace"), K = F.extglob === !0 || x.length && (F.type === "pipe" || F.type === "paren");
      F.type !== "slash" && F.type !== "paren" && !X && !K && (M.output = M.output.slice(0, -C.output.length), C.type = "star", C.value = "*", C.output = L, M.output += C.output);
    }
    if (x.length && F.type !== "paren" && (x[x.length - 1].inner += F.value), (F.value || F.output) && B(F), C && C.type === "text" && F.type === "text") {
      C.value += F.value, C.output = (C.output || "") + F.value;
      return;
    }
    F.prev = C, h.push(F), C = F;
  }, N = (F, X) => {
    const K = { ...c[X], conditions: 1, inner: "" };
    K.prev = C, K.parens = M.parens, K.output = M.output;
    const ie = (r.capture ? "(" : "") + K.open;
    J("parens"), G({ type: F, value: X, output: M.output ? "" : y }), G({ type: "paren", extglob: !0, value: U(), output: ie }), x.push(K);
  }, V = (F) => {
    let X = F.close + (r.capture ? ")" : ""), K;
    if (F.type === "negate") {
      let ie = L;
      if (F.inner && F.inner.length > 1 && F.inner.includes("/") && (ie = $(r)), (ie !== L || H() || /^\)+$/.test(P())) && (X = F.close = `)$))${ie}`), F.inner.includes("*") && (K = P()) && /^\.[^\\/.]+$/.test(K)) {
        const fe = eg(K, { ...e, fastpaths: !1 }).output;
        X = F.close = `)${fe})${ie})`;
      }
      F.prev.type === "bos" && (M.negatedExtglob = !0);
    }
    G({ type: "paren", extglob: !0, value: R, output: X }), re("parens");
  };
  if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(t)) {
    let F = !1, X = t.replace(DH, (K, ie, fe, _e, Ae, ce) => _e === "\\" ? (F = !0, K) : _e === "?" ? ie ? ie + _e + (Ae ? T.repeat(Ae.length) : "") : ce === 0 ? k + (Ae ? T.repeat(Ae.length) : "") : T.repeat(fe.length) : _e === "." ? f.repeat(fe.length) : _e === "*" ? ie ? ie + _e + (Ae ? L : "") : L : ie ? K : `\\${K}`);
    return F === !0 && (r.unescape === !0 ? X = X.replace(/\\/g, "") : X = X.replace(/\\+/g, (K) => K.length % 2 === 0 ? "\\\\" : K ? "\\" : "")), X === t && r.contains === !0 ? (M.output = t, M) : (M.output = gi.wrapOutput(X, M, e), M);
  }
  for (; !H(); ) {
    if (R = U(), R === "\0")
      continue;
    if (R === "\\") {
      const K = z();
      if (K === "/" && r.bash !== !0 || K === "." || K === ";")
        continue;
      if (!K) {
        R += "\\", G({ type: "text", value: R });
        continue;
      }
      const ie = /^\\+/.exec(P());
      let fe = 0;
      if (ie && ie[0].length > 2 && (fe = ie[0].length, M.index += fe, fe % 2 !== 0 && (R += "\\")), r.unescape === !0 ? R = U() : R += U(), M.brackets === 0) {
        G({ type: "text", value: R });
        continue;
      }
    }
    if (M.brackets > 0 && (R !== "]" || C.value === "[" || C.value === "[^")) {
      if (r.posix !== !1 && R === ":") {
        const K = C.value.slice(1);
        if (K.includes("[") && (C.posix = !0, K.includes(":"))) {
          const ie = C.value.lastIndexOf("["), fe = C.value.slice(0, ie), _e = C.value.slice(ie + 2), Ae = OH[_e];
          if (Ae) {
            C.value = fe + Ae, M.backtrack = !0, U(), !d.output && h.indexOf(C) === 1 && (d.output = y);
            continue;
          }
        }
      }
      (R === "[" && z() !== ":" || R === "-" && z() === "]") && (R = `\\${R}`), R === "]" && (C.value === "[" || C.value === "[^") && (R = `\\${R}`), r.posix === !0 && R === "!" && C.value === "[" && (R = "^"), C.value += R, B({ value: R });
      continue;
    }
    if (M.quotes === 1 && R !== '"') {
      R = gi.escapeRegex(R), C.value += R, B({ value: R });
      continue;
    }
    if (R === '"') {
      M.quotes = M.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && G({ type: "text", value: R });
      continue;
    }
    if (R === "(") {
      J("parens"), G({ type: "paren", value: R });
      continue;
    }
    if (R === ")") {
      if (M.parens === 0 && r.strictBrackets === !0)
        throw new SyntaxError($o("opening", "("));
      const K = x[x.length - 1];
      if (K && M.parens === K.parens + 1) {
        V(x.pop());
        continue;
      }
      G({ type: "paren", value: R, output: M.parens ? ")" : "\\)" }), re("parens");
      continue;
    }
    if (R === "[") {
      if (r.nobracket === !0 || !P().includes("]")) {
        if (r.nobracket !== !0 && r.strictBrackets === !0)
          throw new SyntaxError($o("closing", "]"));
        R = `\\${R}`;
      } else
        J("brackets");
      G({ type: "bracket", value: R });
      continue;
    }
    if (R === "]") {
      if (r.nobracket === !0 || C && C.type === "bracket" && C.value.length === 1) {
        G({ type: "text", value: R, output: `\\${R}` });
        continue;
      }
      if (M.brackets === 0) {
        if (r.strictBrackets === !0)
          throw new SyntaxError($o("opening", "["));
        G({ type: "text", value: R, output: `\\${R}` });
        continue;
      }
      re("brackets");
      const K = C.value.slice(1);
      if (C.posix !== !0 && K[0] === "^" && !K.includes("/") && (R = `/${R}`), C.value += R, B({ value: R }), r.literalBrackets === !1 || gi.hasRegexChars(K))
        continue;
      const ie = gi.escapeRegex(C.value);
      if (M.output = M.output.slice(0, -C.value.length), r.literalBrackets === !0) {
        M.output += ie, C.value = ie;
        continue;
      }
      C.value = `(${n}${ie}|${C.value})`, M.output += C.value;
      continue;
    }
    if (R === "{" && r.nobrace !== !0) {
      J("braces");
      const K = {
        type: "brace",
        value: R,
        output: "(",
        outputIndex: M.output.length,
        tokensIndex: M.tokens.length
      };
      _.push(K), G(K);
      continue;
    }
    if (R === "}") {
      const K = _[_.length - 1];
      if (r.nobrace === !0 || !K) {
        G({ type: "text", value: R, output: R });
        continue;
      }
      let ie = ")";
      if (K.dots === !0) {
        const fe = h.slice(), _e = [];
        for (let Ae = fe.length - 1; Ae >= 0 && (h.pop(), fe[Ae].type !== "brace"); Ae--)
          fe[Ae].type !== "dots" && _e.unshift(fe[Ae].value);
        ie = NH(_e, r), M.backtrack = !0;
      }
      if (K.comma !== !0 && K.dots !== !0) {
        const fe = M.output.slice(0, K.outputIndex), _e = M.tokens.slice(K.tokensIndex);
        K.value = K.output = "\\{", R = ie = "\\}", M.output = fe;
        for (const Ae of _e)
          M.output += Ae.output || Ae.value;
      }
      G({ type: "brace", value: R, output: ie }), re("braces"), _.pop();
      continue;
    }
    if (R === "|") {
      x.length > 0 && x[x.length - 1].conditions++, G({ type: "text", value: R });
      continue;
    }
    if (R === ",") {
      let K = R;
      const ie = _[_.length - 1];
      ie && S[S.length - 1] === "braces" && (ie.comma = !0, K = "|"), G({ type: "comma", value: R, output: K });
      continue;
    }
    if (R === "/") {
      if (C.type === "dot" && M.index === M.start + 1) {
        M.start = M.index + 1, M.consumed = "", M.output = "", h.pop(), C = d;
        continue;
      }
      G({ type: "slash", value: R, output: o });
      continue;
    }
    if (R === ".") {
      if (M.braces > 0 && C.type === "dot") {
        C.value === "." && (C.output = f);
        const K = _[_.length - 1];
        C.type = "dots", C.output += R, C.value += R, K.dots = !0;
        continue;
      }
      if (M.braces + M.parens === 0 && C.type !== "bos" && C.type !== "slash") {
        G({ type: "text", value: R, output: f });
        continue;
      }
      G({ type: "dot", value: R, output: f });
      continue;
    }
    if (R === "?") {
      if (!(C && C.value === "(") && r.noextglob !== !0 && z() === "(" && z(2) !== "?") {
        N("qmark", R);
        continue;
      }
      if (C && C.type === "paren") {
        const ie = z();
        let fe = R;
        if (ie === "<" && !gi.supportsLookbehinds())
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        (C.value === "(" && !/[!=<:]/.test(ie) || ie === "<" && !/<([!=]|\w+>)/.test(P())) && (fe = `\\${R}`), G({ type: "text", value: R, output: fe });
        continue;
      }
      if (r.dot !== !0 && (C.type === "slash" || C.type === "bos")) {
        G({ type: "qmark", value: R, output: E });
        continue;
      }
      G({ type: "qmark", value: R, output: T });
      continue;
    }
    if (R === "!") {
      if (r.noextglob !== !0 && z() === "(" && (z(2) !== "?" || !/[!=<:]/.test(z(3)))) {
        N("negate", R);
        continue;
      }
      if (r.nonegate !== !0 && M.index === 0) {
        Q();
        continue;
      }
    }
    if (R === "+") {
      if (r.noextglob !== !0 && z() === "(" && z(2) !== "?") {
        N("plus", R);
        continue;
      }
      if (C && C.value === "(" || r.regex === !1) {
        G({ type: "plus", value: R, output: s });
        continue;
      }
      if (C && (C.type === "bracket" || C.type === "paren" || C.type === "brace") || M.parens > 0) {
        G({ type: "plus", value: R });
        continue;
      }
      G({ type: "plus", value: s });
      continue;
    }
    if (R === "@") {
      if (r.noextglob !== !0 && z() === "(" && z(2) !== "?") {
        G({ type: "at", extglob: !0, value: R, output: "" });
        continue;
      }
      G({ type: "text", value: R });
      continue;
    }
    if (R !== "*") {
      (R === "$" || R === "^") && (R = `\\${R}`);
      const K = kH.exec(P());
      K && (R += K[0], M.index += K[0].length), G({ type: "text", value: R });
      continue;
    }
    if (C && (C.type === "globstar" || C.star === !0)) {
      C.type = "star", C.star = !0, C.value += R, C.output = L, M.backtrack = !0, M.globstar = !0, W(R);
      continue;
    }
    let F = P();
    if (r.noextglob !== !0 && /^\([^?]/.test(F)) {
      N("star", R);
      continue;
    }
    if (C.type === "star") {
      if (r.noglobstar === !0) {
        W(R);
        continue;
      }
      const K = C.prev, ie = K.prev, fe = K.type === "slash" || K.type === "bos", _e = ie && (ie.type === "star" || ie.type === "globstar");
      if (r.bash === !0 && (!fe || F[0] && F[0] !== "/")) {
        G({ type: "star", value: R, output: "" });
        continue;
      }
      const Ae = M.braces > 0 && (K.type === "comma" || K.type === "brace"), ce = x.length && (K.type === "pipe" || K.type === "paren");
      if (!fe && K.type !== "paren" && !Ae && !ce) {
        G({ type: "star", value: R, output: "" });
        continue;
      }
      for (; F.slice(0, 3) === "/**"; ) {
        const ee = t[M.index + 4];
        if (ee && ee !== "/")
          break;
        F = F.slice(3), W("/**", 3);
      }
      if (K.type === "bos" && H()) {
        C.type = "globstar", C.value += R, C.output = $(r), M.output = C.output, M.globstar = !0, W(R);
        continue;
      }
      if (K.type === "slash" && K.prev.type !== "bos" && !_e && H()) {
        M.output = M.output.slice(0, -(K.output + C.output).length), K.output = `(?:${K.output}`, C.type = "globstar", C.output = $(r) + (r.strictSlashes ? ")" : "|$)"), C.value += R, M.globstar = !0, M.output += K.output + C.output, W(R);
        continue;
      }
      if (K.type === "slash" && K.prev.type !== "bos" && F[0] === "/") {
        const ee = F[1] !== void 0 ? "|$" : "";
        M.output = M.output.slice(0, -(K.output + C.output).length), K.output = `(?:${K.output}`, C.type = "globstar", C.output = `${$(r)}${o}|${o}${ee})`, C.value += R, M.output += K.output + C.output, M.globstar = !0, W(R + U()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (K.type === "bos" && F[0] === "/") {
        C.type = "globstar", C.value += R, C.output = `(?:^|${o}|${$(r)}${o})`, M.output = C.output, M.globstar = !0, W(R + U()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      M.output = M.output.slice(0, -C.output.length), C.type = "globstar", C.output = $(r), C.value += R, M.output += C.output, M.globstar = !0, W(R);
      continue;
    }
    const X = { type: "star", value: R, output: L };
    if (r.bash === !0) {
      X.output = ".*?", (C.type === "bos" || C.type === "slash") && (X.output = I + X.output), G(X);
      continue;
    }
    if (C && (C.type === "bracket" || C.type === "paren") && r.regex === !0) {
      X.output = R, G(X);
      continue;
    }
    (M.index === M.start || C.type === "slash" || C.type === "dot") && (C.type === "dot" ? (M.output += b, C.output += b) : r.dot === !0 ? (M.output += v, C.output += v) : (M.output += I, C.output += I), z() !== "*" && (M.output += y, C.output += y)), G(X);
  }
  for (; M.brackets > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError($o("closing", "]"));
    M.output = gi.escapeLast(M.output, "["), re("brackets");
  }
  for (; M.parens > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError($o("closing", ")"));
    M.output = gi.escapeLast(M.output, "("), re("parens");
  }
  for (; M.braces > 0; ) {
    if (r.strictBrackets === !0) throw new SyntaxError($o("closing", "}"));
    M.output = gi.escapeLast(M.output, "{"), re("braces");
  }
  if (r.strictSlashes !== !0 && (C.type === "star" || C.type === "bracket") && G({ type: "maybe_slash", value: "", output: `${o}?` }), M.backtrack === !0) {
    M.output = "";
    for (const F of M.tokens)
      M.output += F.output != null ? F.output : F.value, F.suffix && (M.output += F.suffix);
  }
  return M;
};
eg.fastpaths = (t, e) => {
  const r = { ...e }, a = typeof r.maxLength == "number" ? Math.min(nd, r.maxLength) : nd, l = t.length;
  if (l > a)
    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${a}`);
  t = u4[t] || t;
  const d = gi.isWindows(e), {
    DOT_LITERAL: h,
    SLASH_LITERAL: n,
    ONE_CHAR: u,
    DOTS_SLASH: i,
    NO_DOT: c,
    NO_DOTS: f,
    NO_DOTS_SLASH: s,
    STAR: o,
    START_ANCHOR: y
  } = rd.globChars(d), m = r.dot ? f : c, g = r.dot ? s : c, b = r.capture ? "" : "?:", v = { negated: !1, prefix: "" };
  let T = r.bash === !0 ? ".*?" : o;
  r.capture && (T = `(${T})`);
  const E = (I) => I.noglobstar === !0 ? T : `(${b}(?:(?!${y}${I.dot ? i : h}).)*?)`, O = (I) => {
    switch (I) {
      case "*":
        return `${m}${u}${T}`;
      case ".*":
        return `${h}${u}${T}`;
      case "*.*":
        return `${m}${T}${h}${u}${T}`;
      case "*/*":
        return `${m}${T}${n}${u}${g}${T}`;
      case "**":
        return m + E(r);
      case "**/*":
        return `(?:${m}${E(r)}${n})?${g}${u}${T}`;
      case "**/*.*":
        return `(?:${m}${E(r)}${n})?${g}${T}${h}${u}${T}`;
      case "**/.*":
        return `(?:${m}${E(r)}${n})?${h}${u}${T}`;
      default: {
        const k = /^(.*?)\.(\w+)$/.exec(I);
        if (!k) return;
        const L = O(k[1]);
        return L ? L + h + k[2] : void 0;
      }
    }
  }, D = gi.removePrefix(t, v);
  let $ = O(D);
  return $ && r.strictSlashes !== !0 && ($ += `${n}?`), $;
};
var RH = eg;
const MH = Qr, LH = IH, W1 = RH, tg = pc, jH = Op, FH = (t) => t && typeof t == "object" && !Array.isArray(t), cn = (t, e, r = !1) => {
  if (Array.isArray(t)) {
    const c = t.map((s) => cn(s, e, r));
    return (s) => {
      for (const o of c) {
        const y = o(s);
        if (y) return y;
      }
      return !1;
    };
  }
  const a = FH(t) && t.tokens && t.input;
  if (t === "" || typeof t != "string" && !a)
    throw new TypeError("Expected pattern to be a non-empty string");
  const l = e || {}, d = tg.isWindows(e), h = a ? cn.compileRe(t, e) : cn.makeRe(t, e, !1, !0), n = h.state;
  delete h.state;
  let u = () => !1;
  if (l.ignore) {
    const c = { ...e, ignore: null, onMatch: null, onResult: null };
    u = cn(l.ignore, c, r);
  }
  const i = (c, f = !1) => {
    const { isMatch: s, match: o, output: y } = cn.test(c, h, e, { glob: t, posix: d }), m = { glob: t, state: n, regex: h, posix: d, input: c, output: y, match: o, isMatch: s };
    return typeof l.onResult == "function" && l.onResult(m), s === !1 ? (m.isMatch = !1, f ? m : !1) : u(c) ? (typeof l.onIgnore == "function" && l.onIgnore(m), m.isMatch = !1, f ? m : !1) : (typeof l.onMatch == "function" && l.onMatch(m), f ? m : !0);
  };
  return r && (i.state = n), i;
};
cn.test = (t, e, r, { glob: a, posix: l } = {}) => {
  if (typeof t != "string")
    throw new TypeError("Expected input to be a string");
  if (t === "")
    return { isMatch: !1, output: "" };
  const d = r || {}, h = d.format || (l ? tg.toPosixSlashes : null);
  let n = t === a, u = n && h ? h(t) : t;
  return n === !1 && (u = h ? h(t) : t, n = u === a), (n === !1 || d.capture === !0) && (d.matchBase === !0 || d.basename === !0 ? n = cn.matchBase(t, e, r, l) : n = e.exec(u)), { isMatch: !!n, match: n, output: u };
};
cn.matchBase = (t, e, r, a = tg.isWindows(r)) => (e instanceof RegExp ? e : cn.makeRe(e, r)).test(MH.basename(t));
cn.isMatch = (t, e, r) => cn(e, r)(t);
cn.parse = (t, e) => Array.isArray(t) ? t.map((r) => cn.parse(r, e)) : W1(t, { ...e, fastpaths: !1 });
cn.scan = (t, e) => LH(t, e);
cn.compileRe = (t, e, r = !1, a = !1) => {
  if (r === !0)
    return t.output;
  const l = e || {}, d = l.contains ? "" : "^", h = l.contains ? "" : "$";
  let n = `${d}(?:${t.output})${h}`;
  t && t.negated === !0 && (n = `^(?!${n}).*$`);
  const u = cn.toRegex(n, e);
  return a === !0 && (u.state = t), u;
};
cn.makeRe = (t, e = {}, r = !1, a = !1) => {
  if (!t || typeof t != "string")
    throw new TypeError("Expected a non-empty string");
  let l = { negated: !1, fastpaths: !0 };
  return e.fastpaths !== !1 && (t[0] === "." || t[0] === "*") && (l.output = W1.fastpaths(t, e)), l.output || (l = W1(t, e)), cn.compileRe(l, e, r, a);
};
cn.toRegex = (t, e) => {
  try {
    const r = e || {};
    return new RegExp(t, r.flags || (r.nocase ? "i" : ""));
  } catch (r) {
    if (e && e.debug === !0) throw r;
    return /$^/;
  }
};
cn.constants = jH;
var BH = cn, $H = BH;
const c4 = Fi, f4 = uH, Hs = $H, q1 = pc, sw = (t) => t === "" || t === "./", Kr = (t, e, r) => {
  e = [].concat(e), t = [].concat(t);
  let a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set(), h = 0, n = (c) => {
    d.add(c.output), r && r.onResult && r.onResult(c);
  };
  for (let c = 0; c < e.length; c++) {
    let f = Hs(String(e[c]), { ...r, onResult: n }, !0), s = f.state.negated || f.state.negatedExtglob;
    s && h++;
    for (let o of t) {
      let y = f(o, !0);
      (s ? !y.isMatch : y.isMatch) && (s ? a.add(y.output) : (a.delete(y.output), l.add(y.output)));
    }
  }
  let i = (h === e.length ? [...d] : [...l]).filter((c) => !a.has(c));
  if (r && i.length === 0) {
    if (r.failglob === !0)
      throw new Error(`No matches found for "${e.join(", ")}"`);
    if (r.nonull === !0 || r.nullglob === !0)
      return r.unescape ? e.map((c) => c.replace(/\\/g, "")) : e;
  }
  return i;
};
Kr.match = Kr;
Kr.matcher = (t, e) => Hs(t, e);
Kr.isMatch = (t, e, r) => Hs(e, r)(t);
Kr.any = Kr.isMatch;
Kr.not = (t, e, r = {}) => {
  e = [].concat(e).map(String);
  let a = /* @__PURE__ */ new Set(), l = [], d = (n) => {
    r.onResult && r.onResult(n), l.push(n.output);
  }, h = new Set(Kr(t, e, { ...r, onResult: d }));
  for (let n of l)
    h.has(n) || a.add(n);
  return [...a];
};
Kr.contains = (t, e, r) => {
  if (typeof t != "string")
    throw new TypeError(`Expected a string: "${c4.inspect(t)}"`);
  if (Array.isArray(e))
    return e.some((a) => Kr.contains(t, a, r));
  if (typeof e == "string") {
    if (sw(t) || sw(e))
      return !1;
    if (t.includes(e) || t.startsWith("./") && t.slice(2).includes(e))
      return !0;
  }
  return Kr.isMatch(t, e, { ...r, contains: !0 });
};
Kr.matchKeys = (t, e, r) => {
  if (!q1.isObject(t))
    throw new TypeError("Expected the first argument to be an object");
  let a = Kr(Object.keys(t), e, r), l = {};
  for (let d of a) l[d] = t[d];
  return l;
};
Kr.some = (t, e, r) => {
  let a = [].concat(t);
  for (let l of [].concat(e)) {
    let d = Hs(String(l), r);
    if (a.some((h) => d(h)))
      return !0;
  }
  return !1;
};
Kr.every = (t, e, r) => {
  let a = [].concat(t);
  for (let l of [].concat(e)) {
    let d = Hs(String(l), r);
    if (!a.every((h) => d(h)))
      return !1;
  }
  return !0;
};
Kr.all = (t, e, r) => {
  if (typeof t != "string")
    throw new TypeError(`Expected a string: "${c4.inspect(t)}"`);
  return [].concat(e).every((a) => Hs(a, r)(t));
};
Kr.capture = (t, e, r) => {
  let a = q1.isWindows(r), d = Hs.makeRe(String(t), { ...r, capture: !0 }).exec(a ? q1.toPosixSlashes(e) : e);
  if (d)
    return d.slice(1).map((h) => h === void 0 ? "" : h);
};
Kr.makeRe = (...t) => Hs.makeRe(...t);
Kr.scan = (...t) => Hs.scan(...t);
Kr.parse = (t, e) => {
  let r = [];
  for (let a of [].concat(t || []))
    for (let l of f4(String(a), e))
      r.push(Hs.parse(l, e));
  return r;
};
Kr.braces = (t, e) => {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return e && e.nobrace === !0 || !/\{.*\}/.test(t) ? [t] : f4(t, e);
};
Kr.braceExpand = (t, e) => {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return Kr.braces(t, { ...e, expand: !0 });
};
var UH = Kr;
Object.defineProperty(Qt, "__esModule", { value: !0 });
Qt.removeDuplicateSlashes = Qt.matchAny = Qt.convertPatternsToRe = Qt.makeRe = Qt.getPatternParts = Qt.expandBraceExpansion = Qt.expandPatternsWithBraceExpansion = Qt.isAffectDepthOfReadingPattern = Qt.endsWithSlashGlobStar = Qt.hasGlobStar = Qt.getBaseDirectory = Qt.isPatternRelatedToParentDirectory = Qt.getPatternsOutsideCurrentDirectory = Qt.getPatternsInsideCurrentDirectory = Qt.getPositivePatterns = Qt.getNegativePatterns = Qt.isPositivePattern = Qt.isNegativePattern = Qt.convertToNegativePattern = Qt.convertToPositivePattern = Qt.isDynamicPattern = Qt.isStaticPattern = void 0;
const VH = Qr, WH = _q, rg = UH, d4 = "**", qH = "\\", HH = /[*?]|^!/, GH = /\[[^[]*]/, zH = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, KH = /[!*+?@]\([^(]*\)/, YH = /,|\.\./, XH = /(?!^)\/{2,}/g;
function p4(t, e = {}) {
  return !h4(t, e);
}
Qt.isStaticPattern = p4;
function h4(t, e = {}) {
  return t === "" ? !1 : !!(e.caseSensitiveMatch === !1 || t.includes(qH) || HH.test(t) || GH.test(t) || zH.test(t) || e.extglob !== !1 && KH.test(t) || e.braceExpansion !== !1 && JH(t));
}
Qt.isDynamicPattern = h4;
function JH(t) {
  const e = t.indexOf("{");
  if (e === -1)
    return !1;
  const r = t.indexOf("}", e + 1);
  if (r === -1)
    return !1;
  const a = t.slice(e, r);
  return YH.test(a);
}
function QH(t) {
  return kp(t) ? t.slice(1) : t;
}
Qt.convertToPositivePattern = QH;
function ZH(t) {
  return "!" + t;
}
Qt.convertToNegativePattern = ZH;
function kp(t) {
  return t.startsWith("!") && t[1] !== "(";
}
Qt.isNegativePattern = kp;
function m4(t) {
  return !kp(t);
}
Qt.isPositivePattern = m4;
function eG(t) {
  return t.filter(kp);
}
Qt.getNegativePatterns = eG;
function tG(t) {
  return t.filter(m4);
}
Qt.getPositivePatterns = tG;
function rG(t) {
  return t.filter((e) => !ng(e));
}
Qt.getPatternsInsideCurrentDirectory = rG;
function nG(t) {
  return t.filter(ng);
}
Qt.getPatternsOutsideCurrentDirectory = nG;
function ng(t) {
  return t.startsWith("..") || t.startsWith("./..");
}
Qt.isPatternRelatedToParentDirectory = ng;
function iG(t) {
  return WH(t, { flipBackslashes: !1 });
}
Qt.getBaseDirectory = iG;
function sG(t) {
  return t.includes(d4);
}
Qt.hasGlobStar = sG;
function y4(t) {
  return t.endsWith("/" + d4);
}
Qt.endsWithSlashGlobStar = y4;
function aG(t) {
  const e = VH.basename(t);
  return y4(t) || p4(e);
}
Qt.isAffectDepthOfReadingPattern = aG;
function oG(t) {
  return t.reduce((e, r) => e.concat(b4(r)), []);
}
Qt.expandPatternsWithBraceExpansion = oG;
function b4(t) {
  const e = rg.braces(t, { expand: !0, nodupes: !0, keepEscaping: !0 });
  return e.sort((r, a) => r.length - a.length), e.filter((r) => r !== "");
}
Qt.expandBraceExpansion = b4;
function lG(t, e) {
  let { parts: r } = rg.scan(t, Object.assign(Object.assign({}, e), { parts: !0 }));
  return r.length === 0 && (r = [t]), r[0].startsWith("/") && (r[0] = r[0].slice(1), r.unshift("")), r;
}
Qt.getPatternParts = lG;
function g4(t, e) {
  return rg.makeRe(t, e);
}
Qt.makeRe = g4;
function uG(t, e) {
  return t.map((r) => g4(r, e));
}
Qt.convertPatternsToRe = uG;
function cG(t, e) {
  return e.some((r) => r.test(t));
}
Qt.matchAny = cG;
function fG(t) {
  return t.replace(XH, "/");
}
Qt.removeDuplicateSlashes = fG;
var Dp = {};
const dG = Rr, v4 = dG.PassThrough, pG = Array.prototype.slice;
var hG = mG;
function mG() {
  const t = [], e = pG.call(arguments);
  let r = !1, a = e[e.length - 1];
  a && !Array.isArray(a) && a.pipe == null ? e.pop() : a = {};
  const l = a.end !== !1, d = a.pipeError === !0;
  a.objectMode == null && (a.objectMode = !0), a.highWaterMark == null && (a.highWaterMark = 64 * 1024);
  const h = v4(a);
  function n() {
    for (let c = 0, f = arguments.length; c < f; c++)
      t.push(E4(arguments[c], a));
    return u(), this;
  }
  function u() {
    if (r)
      return;
    r = !0;
    let c = t.shift();
    if (!c) {
      Ze.nextTick(i);
      return;
    }
    Array.isArray(c) || (c = [c]);
    let f = c.length + 1;
    function s() {
      --f > 0 || (r = !1, u());
    }
    function o(y) {
      function m() {
        y.removeListener("merge2UnpipeEnd", m), y.removeListener("end", m), d && y.removeListener("error", g), s();
      }
      function g(b) {
        h.emit("error", b);
      }
      if (y._readableState.endEmitted)
        return s();
      y.on("merge2UnpipeEnd", m), y.on("end", m), d && y.on("error", g), y.pipe(h, { end: !1 }), y.resume();
    }
    for (let y = 0; y < c.length; y++)
      o(c[y]);
    s();
  }
  function i() {
    r = !1, h.emit("queueDrain"), l && h.end();
  }
  return h.setMaxListeners(0), h.add = n, h.on("unpipe", function(c) {
    c.emit("merge2UnpipeEnd");
  }), e.length && n.apply(null, e), h;
}
function E4(t, e) {
  if (Array.isArray(t))
    for (let r = 0, a = t.length; r < a; r++)
      t[r] = E4(t[r], e);
  else {
    if (!t._readableState && t.pipe && (t = t.pipe(v4(e))), !t._readableState || !t.pause || !t.pipe)
      throw new Error("Only readable stream can be merged.");
    t.pause();
  }
  return t;
}
Object.defineProperty(Dp, "__esModule", { value: !0 });
Dp.merge = void 0;
const yG = hG;
function bG(t) {
  const e = yG(t);
  return t.forEach((r) => {
    r.once("error", (a) => e.emit("error", a));
  }), e.once("close", () => aw(t)), e.once("end", () => aw(t)), e;
}
Dp.merge = bG;
function aw(t) {
  t.forEach((e) => e.emit("close"));
}
var El = {};
Object.defineProperty(El, "__esModule", { value: !0 });
El.isEmpty = El.isString = void 0;
function gG(t) {
  return typeof t == "string";
}
El.isString = gG;
function vG(t) {
  return t === "";
}
El.isEmpty = vG;
Object.defineProperty(Jr, "__esModule", { value: !0 });
Jr.string = Jr.stream = Jr.pattern = Jr.path = Jr.fs = Jr.errno = Jr.array = void 0;
const EG = vl;
Jr.array = EG;
const _G = Ap;
Jr.errno = _G;
const SG = Pp;
Jr.fs = SG;
const wG = bn;
Jr.path = wG;
const xG = Qt;
Jr.pattern = xG;
const TG = Dp;
Jr.stream = TG;
const AG = El;
Jr.string = AG;
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.convertPatternGroupToTask = Zn.convertPatternGroupsToTasks = Zn.groupPatternsByBaseDirectory = Zn.getNegativePatternsAsPositive = Zn.getPositivePatterns = Zn.convertPatternsToTasks = Zn.generate = void 0;
const is = Jr;
function PG(t, e) {
  const r = ow(t, e), a = ow(e.ignore, e), l = _4(r), d = S4(r, a), h = l.filter((c) => is.pattern.isStaticPattern(c, e)), n = l.filter((c) => is.pattern.isDynamicPattern(c, e)), u = H1(
    h,
    d,
    /* dynamic */
    !1
  ), i = H1(
    n,
    d,
    /* dynamic */
    !0
  );
  return u.concat(i);
}
Zn.generate = PG;
function ow(t, e) {
  let r = t;
  return e.braceExpansion && (r = is.pattern.expandPatternsWithBraceExpansion(r)), e.baseNameMatch && (r = r.map((a) => a.includes("/") ? a : `**/${a}`)), r.map((a) => is.pattern.removeDuplicateSlashes(a));
}
function H1(t, e, r) {
  const a = [], l = is.pattern.getPatternsOutsideCurrentDirectory(t), d = is.pattern.getPatternsInsideCurrentDirectory(t), h = G1(l), n = G1(d);
  return a.push(...z1(h, e, r)), "." in n ? a.push(ig(".", d, e, r)) : a.push(...z1(n, e, r)), a;
}
Zn.convertPatternsToTasks = H1;
function _4(t) {
  return is.pattern.getPositivePatterns(t);
}
Zn.getPositivePatterns = _4;
function S4(t, e) {
  return is.pattern.getNegativePatterns(t).concat(e).map(is.pattern.convertToPositivePattern);
}
Zn.getNegativePatternsAsPositive = S4;
function G1(t) {
  const e = {};
  return t.reduce((r, a) => {
    const l = is.pattern.getBaseDirectory(a);
    return l in r ? r[l].push(a) : r[l] = [a], r;
  }, e);
}
Zn.groupPatternsByBaseDirectory = G1;
function z1(t, e, r) {
  return Object.keys(t).map((a) => ig(a, t[a], e, r));
}
Zn.convertPatternGroupsToTasks = z1;
function ig(t, e, r, a) {
  return {
    dynamic: a,
    positive: e,
    negative: r,
    base: t,
    patterns: [].concat(e, r.map(is.pattern.convertToNegativePattern))
  };
}
Zn.convertPatternGroupToTask = ig;
var sg = {}, ag = {}, Ri = {}, og = {}, Np = {}, Os = {}, _a = {}, Si = {}, Rp = {};
Object.defineProperty(Rp, "__esModule", { value: !0 });
Rp.read = void 0;
function CG(t, e, r) {
  e.fs.lstat(t, (a, l) => {
    if (a !== null) {
      lw(r, a);
      return;
    }
    if (!l.isSymbolicLink() || !e.followSymbolicLink) {
      e0(r, l);
      return;
    }
    e.fs.stat(t, (d, h) => {
      if (d !== null) {
        if (e.throwErrorOnBrokenSymbolicLink) {
          lw(r, d);
          return;
        }
        e0(r, l);
        return;
      }
      e.markSymbolicLink && (h.isSymbolicLink = () => !0), e0(r, h);
    });
  });
}
Rp.read = CG;
function lw(t, e) {
  t(e);
}
function e0(t, e) {
  t(null, e);
}
var Mp = {};
Object.defineProperty(Mp, "__esModule", { value: !0 });
Mp.read = void 0;
function IG(t, e) {
  const r = e.fs.lstatSync(t);
  if (!r.isSymbolicLink() || !e.followSymbolicLink)
    return r;
  try {
    const a = e.fs.statSync(t);
    return e.markSymbolicLink && (a.isSymbolicLink = () => !0), a;
  } catch (a) {
    if (!e.throwErrorOnBrokenSymbolicLink)
      return r;
    throw a;
  }
}
Mp.read = IG;
var lg = {}, w4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0;
  const e = oi;
  t.FILE_SYSTEM_ADAPTER = {
    lstat: e.lstat,
    stat: e.stat,
    lstatSync: e.lstatSync,
    statSync: e.statSync
  };
  function r(a) {
    return a === void 0 ? t.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), a);
  }
  t.createFileSystemAdapter = r;
})(w4);
Object.defineProperty(lg, "__esModule", { value: !0 });
const OG = w4;
let kG = class {
  constructor(e = {}) {
    this._options = e, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = OG.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
  }
  _getValue(e, r) {
    return e ?? r;
  }
};
lg.default = kG;
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.statSync = Si.stat = Si.Settings = void 0;
const uw = Rp, DG = Mp, K1 = lg;
Si.Settings = K1.default;
function NG(t, e, r) {
  if (typeof e == "function") {
    uw.read(t, Y1(), e);
    return;
  }
  uw.read(t, Y1(e), r);
}
Si.stat = NG;
function RG(t, e) {
  const r = Y1(e);
  return DG.read(t, r);
}
Si.statSync = RG;
function Y1(t = {}) {
  return t instanceof K1.default ? t : new K1.default(t);
}
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let cw;
var MG = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : jt) : (t) => (cw || (cw = Promise.resolve())).then(t).catch((e) => setTimeout(() => {
  throw e;
}, 0));
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var LG = FG;
const jG = MG;
function FG(t, e) {
  let r, a, l, d = !0;
  Array.isArray(t) ? (r = [], a = t.length) : (l = Object.keys(t), r = {}, a = l.length);
  function h(u) {
    function i() {
      e && e(u, r), e = null;
    }
    d ? jG(i) : i();
  }
  function n(u, i, c) {
    r[u] = c, (--a === 0 || i) && h(i);
  }
  a ? l ? l.forEach(function(u) {
    t[u](function(i, c) {
      n(u, i, c);
    });
  }) : t.forEach(function(u, i) {
    u(function(c, f) {
      n(i, c, f);
    });
  }) : h(null), d = !1;
}
var hc = {}, x4 = { node: "18.18.2" };
Object.defineProperty(hc, "__esModule", { value: !0 });
hc.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const id = x4.node.split(".");
if (id[0] === void 0 || id[1] === void 0)
  throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${x4.node}`);
const T4 = Number.parseInt(id[0], 10), BG = Number.parseInt(id[1], 10), A4 = 10, $G = 10, UG = T4 > A4, VG = T4 === A4 && BG >= $G;
hc.IS_SUPPORT_READDIR_WITH_FILE_TYPES = UG || VG;
var mc = {}, Lp = {};
Object.defineProperty(Lp, "__esModule", { value: !0 });
Lp.createDirentFromStats = void 0;
class WG {
  constructor(e, r) {
    this.name = e, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink = r.isSymbolicLink.bind(r);
  }
}
function qG(t, e) {
  return new WG(t, e);
}
Lp.createDirentFromStats = qG;
Object.defineProperty(mc, "__esModule", { value: !0 });
mc.fs = void 0;
const HG = Lp;
mc.fs = HG;
var yc = {};
Object.defineProperty(yc, "__esModule", { value: !0 });
yc.joinPathSegments = void 0;
function GG(t, e, r) {
  return t.endsWith(r) ? t + e : t + r + e;
}
yc.joinPathSegments = GG;
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.readdir = _a.readdirWithFileTypes = _a.read = void 0;
const zG = Si, P4 = LG, KG = hc, C4 = mc, I4 = yc;
function YG(t, e, r) {
  if (!e.stats && KG.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    O4(t, e, r);
    return;
  }
  k4(t, e, r);
}
_a.read = YG;
function O4(t, e, r) {
  e.fs.readdir(t, { withFileTypes: !0 }, (a, l) => {
    if (a !== null) {
      sd(r, a);
      return;
    }
    const d = l.map((n) => ({
      dirent: n,
      name: n.name,
      path: I4.joinPathSegments(t, n.name, e.pathSegmentSeparator)
    }));
    if (!e.followSymbolicLinks) {
      X1(r, d);
      return;
    }
    const h = d.map((n) => XG(n, e));
    P4(h, (n, u) => {
      if (n !== null) {
        sd(r, n);
        return;
      }
      X1(r, u);
    });
  });
}
_a.readdirWithFileTypes = O4;
function XG(t, e) {
  return (r) => {
    if (!t.dirent.isSymbolicLink()) {
      r(null, t);
      return;
    }
    e.fs.stat(t.path, (a, l) => {
      if (a !== null) {
        if (e.throwErrorOnBrokenSymbolicLink) {
          r(a);
          return;
        }
        r(null, t);
        return;
      }
      t.dirent = C4.fs.createDirentFromStats(t.name, l), r(null, t);
    });
  };
}
function k4(t, e, r) {
  e.fs.readdir(t, (a, l) => {
    if (a !== null) {
      sd(r, a);
      return;
    }
    const d = l.map((h) => {
      const n = I4.joinPathSegments(t, h, e.pathSegmentSeparator);
      return (u) => {
        zG.stat(n, e.fsStatSettings, (i, c) => {
          if (i !== null) {
            u(i);
            return;
          }
          const f = {
            name: h,
            path: n,
            dirent: C4.fs.createDirentFromStats(h, c)
          };
          e.stats && (f.stats = c), u(null, f);
        });
      };
    });
    P4(d, (h, n) => {
      if (h !== null) {
        sd(r, h);
        return;
      }
      X1(r, n);
    });
  });
}
_a.readdir = k4;
function sd(t, e) {
  t(e);
}
function X1(t, e) {
  t(null, e);
}
var Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.readdir = Sa.readdirWithFileTypes = Sa.read = void 0;
const JG = Si, QG = hc, D4 = mc, N4 = yc;
function ZG(t, e) {
  return !e.stats && QG.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? R4(t, e) : M4(t, e);
}
Sa.read = ZG;
function R4(t, e) {
  return e.fs.readdirSync(t, { withFileTypes: !0 }).map((a) => {
    const l = {
      dirent: a,
      name: a.name,
      path: N4.joinPathSegments(t, a.name, e.pathSegmentSeparator)
    };
    if (l.dirent.isSymbolicLink() && e.followSymbolicLinks)
      try {
        const d = e.fs.statSync(l.path);
        l.dirent = D4.fs.createDirentFromStats(l.name, d);
      } catch (d) {
        if (e.throwErrorOnBrokenSymbolicLink)
          throw d;
      }
    return l;
  });
}
Sa.readdirWithFileTypes = R4;
function M4(t, e) {
  return e.fs.readdirSync(t).map((a) => {
    const l = N4.joinPathSegments(t, a, e.pathSegmentSeparator), d = JG.statSync(l, e.fsStatSettings), h = {
      name: a,
      path: l,
      dirent: D4.fs.createDirentFromStats(a, d)
    };
    return e.stats && (h.stats = d), h;
  });
}
Sa.readdir = M4;
var ug = {}, L4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0;
  const e = oi;
  t.FILE_SYSTEM_ADAPTER = {
    lstat: e.lstat,
    stat: e.stat,
    lstatSync: e.lstatSync,
    statSync: e.statSync,
    readdir: e.readdir,
    readdirSync: e.readdirSync
  };
  function r(a) {
    return a === void 0 ? t.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), a);
  }
  t.createFileSystemAdapter = r;
})(L4);
Object.defineProperty(ug, "__esModule", { value: !0 });
const ez = Qr, tz = Si, rz = L4;
let nz = class {
  constructor(e = {}) {
    this._options = e, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = rz.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, ez.sep), this.stats = this._getValue(this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.fsStatSettings = new tz.Settings({
      followSymbolicLink: this.followSymbolicLinks,
      fs: this.fs,
      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(e, r) {
    return e ?? r;
  }
};
ug.default = nz;
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.Settings = Os.scandirSync = Os.scandir = void 0;
const fw = _a, iz = Sa, J1 = ug;
Os.Settings = J1.default;
function sz(t, e, r) {
  if (typeof e == "function") {
    fw.read(t, Q1(), e);
    return;
  }
  fw.read(t, Q1(e), r);
}
Os.scandir = sz;
function az(t, e) {
  const r = Q1(e);
  return iz.read(t, r);
}
Os.scandirSync = az;
function Q1(t = {}) {
  return t instanceof J1.default ? t : new J1.default(t);
}
var cg = { exports: {} };
function oz(t) {
  var e = new t(), r = e;
  function a() {
    var d = e;
    return d.next ? e = d.next : (e = new t(), r = e), d.next = null, d;
  }
  function l(d) {
    r.next = d, r = d;
  }
  return {
    get: a,
    release: l
  };
}
var lz = oz, uz = lz;
function j4(t, e, r) {
  if (typeof t == "function" && (r = e, e = t, t = null), !(r >= 1))
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var a = uz(cz), l = null, d = null, h = 0, n = null, u = {
    push: m,
    drain: Ni,
    saturated: Ni,
    pause: c,
    paused: !1,
    get concurrency() {
      return r;
    },
    set concurrency(O) {
      if (!(O >= 1))
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      if (r = O, !u.paused)
        for (; l && h < r; )
          h++, b();
    },
    running: i,
    resume: o,
    idle: y,
    length: f,
    getQueue: s,
    unshift: g,
    empty: Ni,
    kill: v,
    killAndDrain: T,
    error: E
  };
  return u;
  function i() {
    return h;
  }
  function c() {
    u.paused = !0;
  }
  function f() {
    for (var O = l, D = 0; O; )
      O = O.next, D++;
    return D;
  }
  function s() {
    for (var O = l, D = []; O; )
      D.push(O.value), O = O.next;
    return D;
  }
  function o() {
    if (u.paused) {
      if (u.paused = !1, l === null) {
        h++, b();
        return;
      }
      for (; l && h < r; )
        h++, b();
    }
  }
  function y() {
    return h === 0 && u.length() === 0;
  }
  function m(O, D) {
    var $ = a.get();
    $.context = t, $.release = b, $.value = O, $.callback = D || Ni, $.errorHandler = n, h >= r || u.paused ? d ? (d.next = $, d = $) : (l = $, d = $, u.saturated()) : (h++, e.call(t, $.value, $.worked));
  }
  function g(O, D) {
    var $ = a.get();
    $.context = t, $.release = b, $.value = O, $.callback = D || Ni, $.errorHandler = n, h >= r || u.paused ? l ? ($.next = l, l = $) : (l = $, d = $, u.saturated()) : (h++, e.call(t, $.value, $.worked));
  }
  function b(O) {
    O && a.release(O);
    var D = l;
    D && h <= r ? u.paused ? h-- : (d === l && (d = null), l = D.next, D.next = null, e.call(t, D.value, D.worked), d === null && u.empty()) : --h === 0 && u.drain();
  }
  function v() {
    l = null, d = null, u.drain = Ni;
  }
  function T() {
    l = null, d = null, u.drain(), u.drain = Ni;
  }
  function E(O) {
    n = O;
  }
}
function Ni() {
}
function cz() {
  this.value = null, this.callback = Ni, this.next = null, this.release = Ni, this.context = null, this.errorHandler = null;
  var t = this;
  this.worked = function(r, a) {
    var l = t.callback, d = t.errorHandler, h = t.value;
    t.value = null, t.callback = Ni, t.errorHandler && d(r, h), l.call(t.context, r, a), t.release(t);
  };
}
function fz(t, e, r) {
  typeof t == "function" && (r = e, e = t, t = null);
  function a(c, f) {
    e.call(this, c).then(function(s) {
      f(null, s);
    }, f);
  }
  var l = j4(t, a, r), d = l.push, h = l.unshift;
  return l.push = n, l.unshift = u, l.drained = i, l;
  function n(c) {
    var f = new Promise(function(s, o) {
      d(c, function(y, m) {
        if (y) {
          o(y);
          return;
        }
        s(m);
      });
    });
    return f.catch(Ni), f;
  }
  function u(c) {
    var f = new Promise(function(s, o) {
      h(c, function(y, m) {
        if (y) {
          o(y);
          return;
        }
        s(m);
      });
    });
    return f.catch(Ni), f;
  }
  function i() {
    if (l.idle())
      return new Promise(function(s) {
        s();
      });
    var c = l.drain, f = new Promise(function(s) {
      l.drain = function() {
        c(), s();
      };
    });
    return f;
  }
}
cg.exports = j4;
cg.exports.promise = fz;
var dz = cg.exports, Mi = {};
Object.defineProperty(Mi, "__esModule", { value: !0 });
Mi.joinPathSegments = Mi.replacePathSegmentSeparator = Mi.isAppliedFilter = Mi.isFatalError = void 0;
function pz(t, e) {
  return t.errorFilter === null ? !0 : !t.errorFilter(e);
}
Mi.isFatalError = pz;
function hz(t, e) {
  return t === null || t(e);
}
Mi.isAppliedFilter = hz;
function mz(t, e) {
  return t.split(/[/\\]/).join(e);
}
Mi.replacePathSegmentSeparator = mz;
function yz(t, e, r) {
  return t === "" ? e : t.endsWith(r) ? t + e : t + r + e;
}
Mi.joinPathSegments = yz;
var jp = {};
Object.defineProperty(jp, "__esModule", { value: !0 });
const bz = Mi;
let gz = class {
  constructor(e, r) {
    this._root = e, this._settings = r, this._root = bz.replacePathSegmentSeparator(e, r.pathSegmentSeparator);
  }
};
jp.default = gz;
Object.defineProperty(Np, "__esModule", { value: !0 });
const vz = po, Ez = Os, _z = dz, tf = Mi, Sz = jp;
class wz extends Sz.default {
  constructor(e, r) {
    super(e, r), this._settings = r, this._scandir = Ez.scandir, this._emitter = new vz.EventEmitter(), this._queue = _z(this._worker.bind(this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
      this._isFatalError || this._emitter.emit("end");
    };
  }
  read() {
    return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
      this._pushToQueue(this._root, this._settings.basePath);
    }), this._emitter;
  }
  get isDestroyed() {
    return this._isDestroyed;
  }
  destroy() {
    if (this._isDestroyed)
      throw new Error("The reader is already destroyed");
    this._isDestroyed = !0, this._queue.killAndDrain();
  }
  onEntry(e) {
    this._emitter.on("entry", e);
  }
  onError(e) {
    this._emitter.once("error", e);
  }
  onEnd(e) {
    this._emitter.once("end", e);
  }
  _pushToQueue(e, r) {
    const a = { directory: e, base: r };
    this._queue.push(a, (l) => {
      l !== null && this._handleError(l);
    });
  }
  _worker(e, r) {
    this._scandir(e.directory, this._settings.fsScandirSettings, (a, l) => {
      if (a !== null) {
        r(a, void 0);
        return;
      }
      for (const d of l)
        this._handleEntry(d, e.base);
      r(null, void 0);
    });
  }
  _handleError(e) {
    this._isDestroyed || !tf.isFatalError(this._settings, e) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("error", e));
  }
  _handleEntry(e, r) {
    if (this._isDestroyed || this._isFatalError)
      return;
    const a = e.path;
    r !== void 0 && (e.path = tf.joinPathSegments(r, e.name, this._settings.pathSegmentSeparator)), tf.isAppliedFilter(this._settings.entryFilter, e) && this._emitEntry(e), e.dirent.isDirectory() && tf.isAppliedFilter(this._settings.deepFilter, e) && this._pushToQueue(a, r === void 0 ? void 0 : e.path);
  }
  _emitEntry(e) {
    this._emitter.emit("entry", e);
  }
}
Np.default = wz;
Object.defineProperty(og, "__esModule", { value: !0 });
const xz = Np;
class Tz {
  constructor(e, r) {
    this._root = e, this._settings = r, this._reader = new xz.default(this._root, this._settings), this._storage = [];
  }
  read(e) {
    this._reader.onError((r) => {
      Az(e, r);
    }), this._reader.onEntry((r) => {
      this._storage.push(r);
    }), this._reader.onEnd(() => {
      Pz(e, this._storage);
    }), this._reader.read();
  }
}
og.default = Tz;
function Az(t, e) {
  t(e);
}
function Pz(t, e) {
  t(null, e);
}
var fg = {};
Object.defineProperty(fg, "__esModule", { value: !0 });
const Cz = Rr, Iz = Np;
class Oz {
  constructor(e, r) {
    this._root = e, this._settings = r, this._reader = new Iz.default(this._root, this._settings), this._stream = new Cz.Readable({
      objectMode: !0,
      read: () => {
      },
      destroy: () => {
        this._reader.isDestroyed || this._reader.destroy();
      }
    });
  }
  read() {
    return this._reader.onError((e) => {
      this._stream.emit("error", e);
    }), this._reader.onEntry((e) => {
      this._stream.push(e);
    }), this._reader.onEnd(() => {
      this._stream.push(null);
    }), this._reader.read(), this._stream;
  }
}
fg.default = Oz;
var dg = {}, pg = {};
Object.defineProperty(pg, "__esModule", { value: !0 });
const kz = Os, rf = Mi, Dz = jp;
class Nz extends Dz.default {
  constructor() {
    super(...arguments), this._scandir = kz.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
  }
  read() {
    return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
  }
  _pushToQueue(e, r) {
    this._queue.add({ directory: e, base: r });
  }
  _handleQueue() {
    for (const e of this._queue.values())
      this._handleDirectory(e.directory, e.base);
  }
  _handleDirectory(e, r) {
    try {
      const a = this._scandir(e, this._settings.fsScandirSettings);
      for (const l of a)
        this._handleEntry(l, r);
    } catch (a) {
      this._handleError(a);
    }
  }
  _handleError(e) {
    if (rf.isFatalError(this._settings, e))
      throw e;
  }
  _handleEntry(e, r) {
    const a = e.path;
    r !== void 0 && (e.path = rf.joinPathSegments(r, e.name, this._settings.pathSegmentSeparator)), rf.isAppliedFilter(this._settings.entryFilter, e) && this._pushToStorage(e), e.dirent.isDirectory() && rf.isAppliedFilter(this._settings.deepFilter, e) && this._pushToQueue(a, r === void 0 ? void 0 : e.path);
  }
  _pushToStorage(e) {
    this._storage.push(e);
  }
}
pg.default = Nz;
Object.defineProperty(dg, "__esModule", { value: !0 });
const Rz = pg;
class Mz {
  constructor(e, r) {
    this._root = e, this._settings = r, this._reader = new Rz.default(this._root, this._settings);
  }
  read() {
    return this._reader.read();
  }
}
dg.default = Mz;
var hg = {};
Object.defineProperty(hg, "__esModule", { value: !0 });
const Lz = Qr, jz = Os;
class Fz {
  constructor(e = {}) {
    this._options = e, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, Lz.sep), this.fsScandirSettings = new jz.Settings({
      followSymbolicLinks: this._options.followSymbolicLinks,
      fs: this._options.fs,
      pathSegmentSeparator: this._options.pathSegmentSeparator,
      stats: this._options.stats,
      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(e, r) {
    return e ?? r;
  }
}
hg.default = Fz;
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.Settings = Ri.walkStream = Ri.walkSync = Ri.walk = void 0;
const dw = og, Bz = fg, $z = dg, Z1 = hg;
Ri.Settings = Z1.default;
function Uz(t, e, r) {
  if (typeof e == "function") {
    new dw.default(t, ad()).read(e);
    return;
  }
  new dw.default(t, ad(e)).read(r);
}
Ri.walk = Uz;
function Vz(t, e) {
  const r = ad(e);
  return new $z.default(t, r).read();
}
Ri.walkSync = Vz;
function Wz(t, e) {
  const r = ad(e);
  return new Bz.default(t, r).read();
}
Ri.walkStream = Wz;
function ad(t = {}) {
  return t instanceof Z1.default ? t : new Z1.default(t);
}
var bc = {};
Object.defineProperty(bc, "__esModule", { value: !0 });
const qz = Qr, Hz = Si, pw = Jr;
class Gz {
  constructor(e) {
    this._settings = e, this._fsStatSettings = new Hz.Settings({
      followSymbolicLink: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
    });
  }
  _getFullEntryPath(e) {
    return qz.resolve(this._settings.cwd, e);
  }
  _makeEntry(e, r) {
    const a = {
      name: r,
      path: r,
      dirent: pw.fs.createDirentFromStats(r, e)
    };
    return this._settings.stats && (a.stats = e), a;
  }
  _isFatalError(e) {
    return !pw.errno.isEnoentCodeError(e) && !this._settings.suppressErrors;
  }
}
bc.default = Gz;
var Fp = {};
Object.defineProperty(Fp, "__esModule", { value: !0 });
const zz = Rr, Kz = Si, Yz = Ri, Xz = bc;
class Jz extends Xz.default {
  constructor() {
    super(...arguments), this._walkStream = Yz.walkStream, this._stat = Kz.stat;
  }
  dynamic(e, r) {
    return this._walkStream(e, r);
  }
  static(e, r) {
    const a = e.map(this._getFullEntryPath, this), l = new zz.PassThrough({ objectMode: !0 });
    l._write = (d, h, n) => this._getEntry(a[d], e[d], r).then((u) => {
      u !== null && r.entryFilter(u) && l.push(u), d === a.length - 1 && l.end(), n();
    }).catch(n);
    for (let d = 0; d < a.length; d++)
      l.write(d);
    return l;
  }
  _getEntry(e, r, a) {
    return this._getStat(e).then((l) => this._makeEntry(l, r)).catch((l) => {
      if (a.errorFilter(l))
        return null;
      throw l;
    });
  }
  _getStat(e) {
    return new Promise((r, a) => {
      this._stat(e, this._fsStatSettings, (l, d) => l === null ? r(d) : a(l));
    });
  }
}
Fp.default = Jz;
Object.defineProperty(ag, "__esModule", { value: !0 });
const Qz = Ri, Zz = bc, eK = Fp;
class tK extends Zz.default {
  constructor() {
    super(...arguments), this._walkAsync = Qz.walk, this._readerStream = new eK.default(this._settings);
  }
  dynamic(e, r) {
    return new Promise((a, l) => {
      this._walkAsync(e, r, (d, h) => {
        d === null ? a(h) : l(d);
      });
    });
  }
  async static(e, r) {
    const a = [], l = this._readerStream.static(e, r);
    return new Promise((d, h) => {
      l.once("error", h), l.on("data", (n) => a.push(n)), l.once("end", () => d(a));
    });
  }
}
ag.default = tK;
var gc = {}, mg = {}, yg = {}, bg = {};
Object.defineProperty(bg, "__esModule", { value: !0 });
const ru = Jr;
class rK {
  constructor(e, r, a) {
    this._patterns = e, this._settings = r, this._micromatchOptions = a, this._storage = [], this._fillStorage();
  }
  _fillStorage() {
    for (const e of this._patterns) {
      const r = this._getPatternSegments(e), a = this._splitSegmentsIntoSections(r);
      this._storage.push({
        complete: a.length <= 1,
        pattern: e,
        segments: r,
        sections: a
      });
    }
  }
  _getPatternSegments(e) {
    return ru.pattern.getPatternParts(e, this._micromatchOptions).map((a) => ru.pattern.isDynamicPattern(a, this._settings) ? {
      dynamic: !0,
      pattern: a,
      patternRe: ru.pattern.makeRe(a, this._micromatchOptions)
    } : {
      dynamic: !1,
      pattern: a
    });
  }
  _splitSegmentsIntoSections(e) {
    return ru.array.splitWhen(e, (r) => r.dynamic && ru.pattern.hasGlobStar(r.pattern));
  }
}
bg.default = rK;
Object.defineProperty(yg, "__esModule", { value: !0 });
const nK = bg;
class iK extends nK.default {
  match(e) {
    const r = e.split("/"), a = r.length, l = this._storage.filter((d) => !d.complete || d.segments.length > a);
    for (const d of l) {
      const h = d.sections[0];
      if (!d.complete && a > h.length || r.every((u, i) => {
        const c = d.segments[i];
        return !!(c.dynamic && c.patternRe.test(u) || !c.dynamic && c.pattern === u);
      }))
        return !0;
    }
    return !1;
  }
}
yg.default = iK;
Object.defineProperty(mg, "__esModule", { value: !0 });
const nf = Jr, sK = yg;
class aK {
  constructor(e, r) {
    this._settings = e, this._micromatchOptions = r;
  }
  getFilter(e, r, a) {
    const l = this._getMatcher(r), d = this._getNegativePatternsRe(a);
    return (h) => this._filter(e, h, l, d);
  }
  _getMatcher(e) {
    return new sK.default(e, this._settings, this._micromatchOptions);
  }
  _getNegativePatternsRe(e) {
    const r = e.filter(nf.pattern.isAffectDepthOfReadingPattern);
    return nf.pattern.convertPatternsToRe(r, this._micromatchOptions);
  }
  _filter(e, r, a, l) {
    if (this._isSkippedByDeep(e, r.path) || this._isSkippedSymbolicLink(r))
      return !1;
    const d = nf.path.removeLeadingDotSegment(r.path);
    return this._isSkippedByPositivePatterns(d, a) ? !1 : this._isSkippedByNegativePatterns(d, l);
  }
  _isSkippedByDeep(e, r) {
    return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(e, r) >= this._settings.deep;
  }
  _getEntryLevel(e, r) {
    const a = r.split("/").length;
    if (e === "")
      return a;
    const l = e.split("/").length;
    return a - l;
  }
  _isSkippedSymbolicLink(e) {
    return !this._settings.followSymbolicLinks && e.dirent.isSymbolicLink();
  }
  _isSkippedByPositivePatterns(e, r) {
    return !this._settings.baseNameMatch && !r.match(e);
  }
  _isSkippedByNegativePatterns(e, r) {
    return !nf.pattern.matchAny(e, r);
  }
}
mg.default = aK;
var gg = {};
Object.defineProperty(gg, "__esModule", { value: !0 });
const qa = Jr;
class oK {
  constructor(e, r) {
    this._settings = e, this._micromatchOptions = r, this.index = /* @__PURE__ */ new Map();
  }
  getFilter(e, r) {
    const a = qa.pattern.convertPatternsToRe(e, this._micromatchOptions), l = qa.pattern.convertPatternsToRe(r, Object.assign(Object.assign({}, this._micromatchOptions), { dot: !0 }));
    return (d) => this._filter(d, a, l);
  }
  _filter(e, r, a) {
    const l = qa.path.removeLeadingDotSegment(e.path);
    if (this._settings.unique && this._isDuplicateEntry(l) || this._onlyFileFilter(e) || this._onlyDirectoryFilter(e) || this._isSkippedByAbsoluteNegativePatterns(l, a))
      return !1;
    const d = e.dirent.isDirectory(), h = this._isMatchToPatterns(l, r, d) && !this._isMatchToPatterns(l, a, d);
    return this._settings.unique && h && this._createIndexRecord(l), h;
  }
  _isDuplicateEntry(e) {
    return this.index.has(e);
  }
  _createIndexRecord(e) {
    this.index.set(e, void 0);
  }
  _onlyFileFilter(e) {
    return this._settings.onlyFiles && !e.dirent.isFile();
  }
  _onlyDirectoryFilter(e) {
    return this._settings.onlyDirectories && !e.dirent.isDirectory();
  }
  _isSkippedByAbsoluteNegativePatterns(e, r) {
    if (!this._settings.absolute)
      return !1;
    const a = qa.path.makeAbsolute(this._settings.cwd, e);
    return qa.pattern.matchAny(a, r);
  }
  _isMatchToPatterns(e, r, a) {
    const l = qa.pattern.matchAny(e, r);
    return !l && a ? qa.pattern.matchAny(e + "/", r) : l;
  }
}
gg.default = oK;
var vg = {};
Object.defineProperty(vg, "__esModule", { value: !0 });
const lK = Jr;
class uK {
  constructor(e) {
    this._settings = e;
  }
  getFilter() {
    return (e) => this._isNonFatalError(e);
  }
  _isNonFatalError(e) {
    return lK.errno.isEnoentCodeError(e) || this._settings.suppressErrors;
  }
}
vg.default = uK;
var Eg = {};
Object.defineProperty(Eg, "__esModule", { value: !0 });
const hw = Jr;
class cK {
  constructor(e) {
    this._settings = e;
  }
  getTransformer() {
    return (e) => this._transform(e);
  }
  _transform(e) {
    let r = e.path;
    return this._settings.absolute && (r = hw.path.makeAbsolute(this._settings.cwd, r), r = hw.path.unixify(r)), this._settings.markDirectories && e.dirent.isDirectory() && (r += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, e), { path: r }) : r;
  }
}
Eg.default = cK;
Object.defineProperty(gc, "__esModule", { value: !0 });
const fK = Qr, dK = mg, pK = gg, hK = vg, mK = Eg;
class yK {
  constructor(e) {
    this._settings = e, this.errorFilter = new hK.default(this._settings), this.entryFilter = new pK.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new dK.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new mK.default(this._settings);
  }
  _getRootDirectory(e) {
    return fK.resolve(this._settings.cwd, e.base);
  }
  _getReaderOptions(e) {
    const r = e.base === "." ? "" : e.base;
    return {
      basePath: r,
      pathSegmentSeparator: "/",
      concurrency: this._settings.concurrency,
      deepFilter: this.deepFilter.getFilter(r, e.positive, e.negative),
      entryFilter: this.entryFilter.getFilter(e.positive, e.negative),
      errorFilter: this.errorFilter.getFilter(),
      followSymbolicLinks: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      stats: this._settings.stats,
      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
      transform: this.entryTransformer.getTransformer()
    };
  }
  _getMicromatchOptions() {
    return {
      dot: this._settings.dot,
      matchBase: this._settings.baseNameMatch,
      nobrace: !this._settings.braceExpansion,
      nocase: !this._settings.caseSensitiveMatch,
      noext: !this._settings.extglob,
      noglobstar: !this._settings.globstar,
      posix: !0,
      strictSlashes: !1
    };
  }
}
gc.default = yK;
Object.defineProperty(sg, "__esModule", { value: !0 });
const bK = ag, gK = gc;
class vK extends gK.default {
  constructor() {
    super(...arguments), this._reader = new bK.default(this._settings);
  }
  async read(e) {
    const r = this._getRootDirectory(e), a = this._getReaderOptions(e);
    return (await this.api(r, e, a)).map((d) => a.transform(d));
  }
  api(e, r, a) {
    return r.dynamic ? this._reader.dynamic(e, a) : this._reader.static(r.patterns, a);
  }
}
sg.default = vK;
var _g = {};
Object.defineProperty(_g, "__esModule", { value: !0 });
const EK = Rr, _K = Fp, SK = gc;
class wK extends SK.default {
  constructor() {
    super(...arguments), this._reader = new _K.default(this._settings);
  }
  read(e) {
    const r = this._getRootDirectory(e), a = this._getReaderOptions(e), l = this.api(r, e, a), d = new EK.Readable({ objectMode: !0, read: () => {
    } });
    return l.once("error", (h) => d.emit("error", h)).on("data", (h) => d.emit("data", a.transform(h))).once("end", () => d.emit("end")), d.once("close", () => l.destroy()), d;
  }
  api(e, r, a) {
    return r.dynamic ? this._reader.dynamic(e, a) : this._reader.static(r.patterns, a);
  }
}
_g.default = wK;
var Sg = {}, wg = {};
Object.defineProperty(wg, "__esModule", { value: !0 });
const xK = Si, TK = Ri, AK = bc;
class PK extends AK.default {
  constructor() {
    super(...arguments), this._walkSync = TK.walkSync, this._statSync = xK.statSync;
  }
  dynamic(e, r) {
    return this._walkSync(e, r);
  }
  static(e, r) {
    const a = [];
    for (const l of e) {
      const d = this._getFullEntryPath(l), h = this._getEntry(d, l, r);
      h === null || !r.entryFilter(h) || a.push(h);
    }
    return a;
  }
  _getEntry(e, r, a) {
    try {
      const l = this._getStat(e);
      return this._makeEntry(l, r);
    } catch (l) {
      if (a.errorFilter(l))
        return null;
      throw l;
    }
  }
  _getStat(e) {
    return this._statSync(e, this._fsStatSettings);
  }
}
wg.default = PK;
Object.defineProperty(Sg, "__esModule", { value: !0 });
const CK = wg, IK = gc;
class OK extends IK.default {
  constructor() {
    super(...arguments), this._reader = new CK.default(this._settings);
  }
  read(e) {
    const r = this._getRootDirectory(e), a = this._getReaderOptions(e);
    return this.api(r, e, a).map(a.transform);
  }
  api(e, r, a) {
    return r.dynamic ? this._reader.dynamic(e, a) : this._reader.static(r.patterns, a);
  }
}
Sg.default = OK;
var F4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  const e = oi, a = Math.max(Zr.cpus().length, 1);
  t.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: e.lstat,
    lstatSync: e.lstatSync,
    stat: e.stat,
    statSync: e.statSync,
    readdir: e.readdir,
    readdirSync: e.readdirSync
  };
  class l {
    constructor(h = {}) {
      this._options = h, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch, !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, !0), this.concurrency = this._getValue(this._options.concurrency, a), this.cwd = this._getValue(this._options.cwd, Ze.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this._options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1), this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0), this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories && (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
    }
    _getValue(h, n) {
      return h === void 0 ? n : h;
    }
    _getFileSystemMethods(h = {}) {
      return Object.assign(Object.assign({}, t.DEFAULT_FILE_SYSTEM_ADAPTER), h);
    }
  }
  t.default = l;
})(F4);
const B4 = Zn, kK = sg, DK = _g, NK = Sg, ey = F4, Di = Jr;
async function ty(t, e) {
  Zi(t);
  const r = ry(t, kK.default, e), a = await Promise.all(r);
  return Di.array.flatten(a);
}
(function(t) {
  t.glob = t, t.globSync = e, t.globStream = r, t.async = t;
  function e(n, u) {
    Zi(n);
    const i = ry(n, NK.default, u);
    return Di.array.flatten(i);
  }
  t.sync = e;
  function r(n, u) {
    Zi(n);
    const i = ry(n, DK.default, u);
    return Di.stream.merge(i);
  }
  t.stream = r;
  function a(n, u) {
    Zi(n);
    const i = [].concat(n), c = new ey.default(u);
    return B4.generate(i, c);
  }
  t.generateTasks = a;
  function l(n, u) {
    Zi(n);
    const i = new ey.default(u);
    return Di.pattern.isDynamicPattern(n, i);
  }
  t.isDynamicPattern = l;
  function d(n) {
    return Zi(n), Di.path.escape(n);
  }
  t.escapePath = d;
  function h(n) {
    return Zi(n), Di.path.convertPathToPattern(n);
  }
  t.convertPathToPattern = h, function(n) {
    function u(c) {
      return Zi(c), Di.path.escapePosixPath(c);
    }
    n.escapePath = u;
    function i(c) {
      return Zi(c), Di.path.convertPosixPathToPattern(c);
    }
    n.convertPathToPattern = i;
  }(t.posix || (t.posix = {})), function(n) {
    function u(c) {
      return Zi(c), Di.path.escapeWindowsPath(c);
    }
    n.escapePath = u;
    function i(c) {
      return Zi(c), Di.path.convertWindowsPathToPattern(c);
    }
    n.convertPathToPattern = i;
  }(t.win32 || (t.win32 = {}));
})(ty || (ty = {}));
function ry(t, e, r) {
  const a = [].concat(t), l = new ey.default(r), d = B4.generate(a, l), h = new e(l);
  return d.map(h.read, h);
}
function Zi(t) {
  if (![].concat(t).every((a) => Di.string.isString(a) && !Di.string.isEmpty(a)))
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
}
var RK = ty;
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var MK = function(t, e) {
  if (typeof t != "string")
    throw new TypeError("expected path to be a string");
  if (t === "\\" || t === "/") return "/";
  var r = t.length;
  if (r <= 1) return t;
  var a = "";
  if (r > 4 && t[3] === "\\") {
    var l = t[2];
    (l === "?" || l === ".") && t.slice(0, 2) === "\\\\" && (t = t.slice(2), a = "//");
  }
  var d = t.split(/[/\\]+/);
  return e !== !1 && d[d.length - 1] === "" && d.pop(), a + d.join("/");
}, $4 = {}, LK = Kb, jK = Qr.posix.dirname, FK = Zr.platform() === "win32", Pf = "/", BK = /\\/g, $K = /\\([!*?|[\](){}])/g, UK = function(e, r) {
  var a = Object.assign({ flipBackslashes: !0 }, r);
  a.flipBackslashes && FK && e.indexOf(Pf) < 0 && (e = e.replace(BK, Pf)), VK(e) && (e += Pf), e += "a";
  do
    e = jK(e);
  while (WK(e));
  return e.replace($K, "$1");
};
function VK(t) {
  var e = t.slice(-1), r;
  switch (e) {
    case "}":
      r = "{";
      break;
    case "]":
      r = "[";
      break;
    default:
      return !1;
  }
  var a = t.indexOf(r);
  return a < 0 ? !1 : t.slice(a + 1, -1).includes(Pf);
}
function WK(t) {
  return /\([^()]+$/.test(t) || t[0] === "{" || t[0] === "[" || /[^\\][{[]/.test(t) ? !0 : LK(t);
}
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "parseGlob", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ r(UK);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function a(l) {
    let d = l, h = (0, e.default)(l);
    return h !== "." && (d = l.substr(h.length), d.charAt(0) === "/" && (d = d.substr(1))), d.substr(0, 2) === "./" && (d = d.substr(2)), d.charAt(0) === "/" && (d = d.substr(1)), {
      base: h,
      glob: d
    };
  }
})($4);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(b, v) {
    for (var T in v) Object.defineProperty(b, T, {
      enumerable: !0,
      get: v[T]
    });
  }
  e(t, {
    parseCandidateFiles: function() {
      return c;
    },
    resolvedChangedContent: function() {
      return m;
    }
  });
  const r = /* @__PURE__ */ i(oi), a = /* @__PURE__ */ i(Qr), l = /* @__PURE__ */ i(Kb), d = /* @__PURE__ */ i(RK), h = /* @__PURE__ */ i(MK), n = $4, u = mo;
  function i(b) {
    return b && b.__esModule ? b : {
      default: b
    };
  }
  function c(b, v) {
    let T = v.content.files;
    T = T.filter((I) => typeof I == "string"), T = T.map(h.default);
    let E = d.default.generateTasks(T), O = [], D = [];
    for (const I of E)
      O.push(...I.positive.map((k) => f(k, !1))), D.push(...I.negative.map((k) => f(k, !0)));
    let $ = [
      ...O,
      ...D
    ];
    return $ = o(b, $), $ = $.flatMap(y), $ = $.map(s), $;
  }
  function f(b, v) {
    let T = {
      original: b,
      base: b,
      ignore: v,
      pattern: b,
      glob: null
    };
    return (0, l.default)(b) && Object.assign(T, (0, n.parseGlob)(b)), T;
  }
  function s(b) {
    let v = (0, h.default)(b.base);
    return v = d.default.escapePath(v), b.pattern = b.glob ? `${v}/${b.glob}` : v, b.pattern = b.ignore ? `!${b.pattern}` : b.pattern, b;
  }
  function o(b, v) {
    let T = [];
    return b.userConfigPath && b.tailwindConfig.content.relative && (T = [
      a.default.dirname(b.userConfigPath)
    ]), v.map((E) => (E.base = a.default.resolve(...T, E.base), E));
  }
  function y(b) {
    let v = [
      b
    ];
    try {
      let T = r.default.realpathSync(b.base);
      T !== b.base && v.push({
        ...b,
        base: T
      });
    } catch {
    }
    return v;
  }
  function m(b, v, T) {
    let E = b.tailwindConfig.content.files.filter(($) => typeof $.raw == "string").map(({ raw: $, extension: I = "html" }) => ({
      content: $,
      extension: I
    })), [O, D] = g(v, T);
    for (let $ of O) {
      let I = a.default.extname($).slice(1);
      E.push({
        file: $,
        extension: I
      });
    }
    return [
      E,
      D
    ];
  }
  function g(b, v) {
    let T = b.map(($) => $.pattern), E = /* @__PURE__ */ new Map(), O = /* @__PURE__ */ new Set();
    u.env.DEBUG && console.time("Finding changed files");
    let D = d.default.sync(T, {
      absolute: !0
    });
    for (let $ of D) {
      let I = v.get($) || -1 / 0, k = r.default.statSync($).mtimeMs;
      k > I && (O.add($), E.set($, k));
    }
    return u.env.DEBUG && console.timeEnd("Finding changed files"), [
      O,
      E
    ];
  }
})(K3);
var U4 = {}, t0 = { exports: {} }, mw;
function qK() {
  return mw || (mw = 1, function(t) {
    var e = { node: "18.18.2" };
    (() => {
      var r = { "./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js": (h, n, u) => {
        const i = u("module"), c = u("path"), f = u("fs");
        h.exports = function(s) {
          return s || (s = Ze.cwd()), function(o) {
            try {
              return f.lstatSync(o).isDirectory();
            } catch {
              return !1;
            }
          }(s) && (s = c.join(s, "index.js")), i.createRequire ? i.createRequire(s) : i.createRequireFromPath ? i.createRequireFromPath(s) : function(o) {
            const y = new i.Module(o, null);
            return y.filename = o, y.paths = i.Module._nodeModulePaths(c.dirname(o)), y._compile("module.exports = require;", o), y.exports;
          }(s);
        };
      }, "./node_modules/.pnpm/mlly@1.7.1/node_modules/mlly/dist lazy recursive": (h) => {
        function n(u) {
          return Promise.resolve().then(() => {
            var i = new Error("Cannot find module '" + u + "'");
            throw i.code = "MODULE_NOT_FOUND", i;
          });
        }
        n.keys = () => [], n.resolve = n, n.id = "./node_modules/.pnpm/mlly@1.7.1/node_modules/mlly/dist lazy recursive", h.exports = n;
      }, "./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js": (h, n, u) => {
        var i = u("crypto");
        function c(b, v) {
          return function(T, E) {
            var O;
            O = E.algorithm !== "passthrough" ? i.createHash(E.algorithm) : new g(), O.write === void 0 && (O.write = O.update, O.end = O.update);
            var D = m(E, O);
            if (D.dispatch(T), O.update || O.end(""), O.digest) return O.digest(E.encoding === "buffer" ? void 0 : E.encoding);
            var $ = O.read();
            return E.encoding === "buffer" ? $ : $.toString(E.encoding);
          }(b, v = o(b, v));
        }
        (n = h.exports = c).sha1 = function(b) {
          return c(b);
        }, n.keys = function(b) {
          return c(b, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, n.MD5 = function(b) {
          return c(b, { algorithm: "md5", encoding: "hex" });
        }, n.keysMD5 = function(b) {
          return c(b, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var f = i.getHashes ? i.getHashes().slice() : ["sha1", "md5"];
        f.push("passthrough");
        var s = ["buffer", "hex", "binary", "base64"];
        function o(b, v) {
          v = v || {};
          var T = {};
          if (T.algorithm = v.algorithm || "sha1", T.encoding = v.encoding || "hex", T.excludeValues = !!v.excludeValues, T.algorithm = T.algorithm.toLowerCase(), T.encoding = T.encoding.toLowerCase(), T.ignoreUnknown = v.ignoreUnknown === !0, T.respectType = v.respectType !== !1, T.respectFunctionNames = v.respectFunctionNames !== !1, T.respectFunctionProperties = v.respectFunctionProperties !== !1, T.unorderedArrays = v.unorderedArrays === !0, T.unorderedSets = v.unorderedSets !== !1, T.unorderedObjects = v.unorderedObjects !== !1, T.replacer = v.replacer || void 0, T.excludeKeys = v.excludeKeys || void 0, b === void 0) throw new Error("Object argument required.");
          for (var E = 0; E < f.length; ++E) f[E].toLowerCase() === T.algorithm.toLowerCase() && (T.algorithm = f[E]);
          if (f.indexOf(T.algorithm) === -1) throw new Error('Algorithm "' + T.algorithm + '"  not supported. supported values: ' + f.join(", "));
          if (s.indexOf(T.encoding) === -1 && T.algorithm !== "passthrough") throw new Error('Encoding "' + T.encoding + '"  not supported. supported values: ' + s.join(", "));
          return T;
        }
        function y(b) {
          return typeof b != "function" ? !1 : /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(b)) != null;
        }
        function m(b, v, T) {
          T = T || [];
          var E = function(O) {
            return v.update ? v.update(O, "utf8") : v.write(O, "utf8");
          };
          return { dispatch: function(O) {
            b.replacer && (O = b.replacer(O));
            var D = typeof O;
            return O === null && (D = "null"), this["_" + D](O);
          }, _object: function(O) {
            var D = Object.prototype.toString.call(O), $ = /\[object (.*)\]/i.exec(D);
            $ = ($ = $ ? $[1] : "unknown:[" + D + "]").toLowerCase();
            var I;
            if ((I = T.indexOf(O)) >= 0) return this.dispatch("[CIRCULAR:" + I + "]");
            if (T.push(O), typeof Gt < "u" && Gt.isBuffer && Gt.isBuffer(O)) return E("buffer:"), E(O);
            if ($ === "object" || $ === "function" || $ === "asyncfunction") {
              var k = Object.keys(O);
              b.unorderedObjects && (k = k.sort()), b.respectType === !1 || y(O) || k.splice(0, 0, "prototype", "__proto__", "constructor"), b.excludeKeys && (k = k.filter(function(M) {
                return !b.excludeKeys(M);
              })), E("object:" + k.length + ":");
              var L = this;
              return k.forEach(function(M) {
                L.dispatch(M), E(":"), b.excludeValues || L.dispatch(O[M]), E(",");
              });
            }
            if (!this["_" + $]) {
              if (b.ignoreUnknown) return E("[" + $ + "]");
              throw new Error('Unknown object type "' + $ + '"');
            }
            this["_" + $](O);
          }, _array: function(O, D) {
            D = D !== void 0 ? D : b.unorderedArrays !== !1;
            var $ = this;
            if (E("array:" + O.length + ":"), !D || O.length <= 1) return O.forEach(function(L) {
              return $.dispatch(L);
            });
            var I = [], k = O.map(function(L) {
              var M = new g(), x = T.slice();
              return m(b, M, x).dispatch(L), I = I.concat(x.slice(T.length)), M.read().toString();
            });
            return T = T.concat(I), k.sort(), this._array(k, !1);
          }, _date: function(O) {
            return E("date:" + O.toJSON());
          }, _symbol: function(O) {
            return E("symbol:" + O.toString());
          }, _error: function(O) {
            return E("error:" + O.toString());
          }, _boolean: function(O) {
            return E("bool:" + O.toString());
          }, _string: function(O) {
            E("string:" + O.length + ":"), E(O.toString());
          }, _function: function(O) {
            E("fn:"), y(O) ? this.dispatch("[native]") : this.dispatch(O.toString()), b.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(O.name)), b.respectFunctionProperties && this._object(O);
          }, _number: function(O) {
            return E("number:" + O.toString());
          }, _xml: function(O) {
            return E("xml:" + O.toString());
          }, _null: function() {
            return E("Null");
          }, _undefined: function() {
            return E("Undefined");
          }, _regexp: function(O) {
            return E("regex:" + O.toString());
          }, _uint8array: function(O) {
            return E("uint8array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _uint8clampedarray: function(O) {
            return E("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(O));
          }, _int8array: function(O) {
            return E("int8array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _uint16array: function(O) {
            return E("uint16array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _int16array: function(O) {
            return E("int16array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _uint32array: function(O) {
            return E("uint32array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _int32array: function(O) {
            return E("int32array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _float32array: function(O) {
            return E("float32array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _float64array: function(O) {
            return E("float64array:"), this.dispatch(Array.prototype.slice.call(O));
          }, _arraybuffer: function(O) {
            return E("arraybuffer:"), this.dispatch(new Uint8Array(O));
          }, _url: function(O) {
            return E("url:" + O.toString());
          }, _map: function(O) {
            E("map:");
            var D = Array.from(O);
            return this._array(D, b.unorderedSets !== !1);
          }, _set: function(O) {
            E("set:");
            var D = Array.from(O);
            return this._array(D, b.unorderedSets !== !1);
          }, _file: function(O) {
            return E("file:"), this.dispatch([O.name, O.size, O.type, O.lastModfied]);
          }, _blob: function() {
            if (b.ignoreUnknown) return E("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return E("domwindow");
          }, _bigint: function(O) {
            return E("bigint:" + O.toString());
          }, _process: function() {
            return E("process");
          }, _timer: function() {
            return E("timer");
          }, _pipe: function() {
            return E("pipe");
          }, _tcp: function() {
            return E("tcp");
          }, _udp: function() {
            return E("udp");
          }, _tty: function() {
            return E("tty");
          }, _statwatcher: function() {
            return E("statwatcher");
          }, _securecontext: function() {
            return E("securecontext");
          }, _connection: function() {
            return E("connection");
          }, _zlib: function() {
            return E("zlib");
          }, _context: function() {
            return E("context");
          }, _nodescript: function() {
            return E("nodescript");
          }, _httpparser: function() {
            return E("httpparser");
          }, _dataview: function() {
            return E("dataview");
          }, _signal: function() {
            return E("signal");
          }, _fsevent: function() {
            return E("fsevent");
          }, _tlswrap: function() {
            return E("tlswrap");
          } };
        }
        function g() {
          return { buf: "", write: function(b) {
            this.buf += b;
          }, end: function(b) {
            this.buf += b;
          }, read: function() {
            return this.buf;
          } };
        }
        n.writeToStream = function(b, v, T) {
          return T === void 0 && (T = v, v = {}), m(v = o(b, v), T).dispatch(b);
        };
      }, "./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js": (h, n, u) => {
        h = u.nmd(h), Object.defineProperty(n, "__esModule", { value: !0 }), n.addHook = function(m, g = {}) {
          let b = !1;
          const v = [], T = [];
          let E;
          const O = o._extensions[".js"], D = g.matcher || null, $ = g.ignoreNodeModules !== !1;
          return E = g.extensions || g.exts || g.extension || g.ext || [".js"], Array.isArray(E) || (E = [E]), E.forEach((I) => {
            if (typeof I != "string") throw new TypeError(`Invalid Extension: ${I}`);
            const k = o._extensions[I] || O;
            T[I] = o._extensions[I], v[I] = o._extensions[I] = function(L, M) {
              let x;
              b || function(_, S, C, R) {
                if (typeof _ != "string" || S.indexOf(c.default.extname(_)) === -1) return !1;
                const H = c.default.resolve(_);
                return R && s.test(H) ? !1 : C && typeof C == "function" ? !!C(H) : !0;
              }(M, E, D, $) && (x = L._compile, L._compile = function(_) {
                L._compile = x;
                const S = m(_, M);
                if (typeof S != "string") throw new Error(y);
                return L._compile(S, M);
              }), k(L, M);
            };
          }), function() {
            b || (b = !0, E.forEach((I) => {
              o._extensions[I] === v[I] && (T[I] ? o._extensions[I] = T[I] : delete o._extensions[I]);
            }));
          };
        };
        var i = f(u("module")), c = f(u("path"));
        function f(m) {
          return m && m.__esModule ? m : { default: m };
        }
        const s = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/, o = h.constructor.length > 1 ? h.constructor : i.default, y = `[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!
--------------------
If you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.`;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/comparator.js": (h, n, u) => {
        const i = Symbol("SemVer ANY");
        class c {
          static get ANY() {
            return i;
          }
          constructor(T, E) {
            if (E = f(E), T instanceof c) {
              if (T.loose === !!E.loose) return T;
              T = T.value;
            }
            T = T.trim().split(/\s+/).join(" "), m("comparator", T, E), this.options = E, this.loose = !!E.loose, this.parse(T), this.semver === i ? this.value = "" : this.value = this.operator + this.semver.version, m("comp", this);
          }
          parse(T) {
            const E = this.options.loose ? s[o.COMPARATORLOOSE] : s[o.COMPARATOR], O = T.match(E);
            if (!O) throw new TypeError(`Invalid comparator: ${T}`);
            this.operator = O[1] !== void 0 ? O[1] : "", this.operator === "=" && (this.operator = ""), O[2] ? this.semver = new g(O[2], this.options.loose) : this.semver = i;
          }
          toString() {
            return this.value;
          }
          test(T) {
            if (m("Comparator.test", T, this.options.loose), this.semver === i || T === i) return !0;
            if (typeof T == "string") try {
              T = new g(T, this.options);
            } catch {
              return !1;
            }
            return y(T, this.operator, this.semver, this.options);
          }
          intersects(T, E) {
            if (!(T instanceof c)) throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" || new b(T.value, E).test(this.value) : T.operator === "" ? T.value === "" || new b(this.value, E).test(T.semver) : (!(E = f(E)).includePrerelease || this.value !== "<0.0.0-0" && T.value !== "<0.0.0-0") && !(!E.includePrerelease && (this.value.startsWith("<0.0.0") || T.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !T.operator.startsWith(">")) || !(!this.operator.startsWith("<") || !T.operator.startsWith("<")) || !(this.semver.version !== T.semver.version || !this.operator.includes("=") || !T.operator.includes("=")) || !!(y(this.semver, "<", T.semver, E) && this.operator.startsWith(">") && T.operator.startsWith("<")) || !!(y(this.semver, ">", T.semver, E) && this.operator.startsWith("<") && T.operator.startsWith(">")));
          }
        }
        h.exports = c;
        const f = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js"), { safeRe: s, t: o } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js"), y = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/cmp.js"), m = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js"), g = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), b = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js": (h, n, u) => {
        class i {
          constructor(B, Q) {
            if (Q = f(Q), B instanceof i) return B.loose === !!Q.loose && B.includePrerelease === !!Q.includePrerelease ? B : new i(B.raw, Q);
            if (B instanceof s) return this.raw = B.value, this.set = [[B]], this.format(), this;
            if (this.options = Q, this.loose = !!Q.loose, this.includePrerelease = !!Q.includePrerelease, this.raw = B.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((J) => this.parseRange(J.trim())).filter((J) => J.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
              const J = this.set[0];
              if (this.set = this.set.filter((re) => !D(re[0])), this.set.length === 0) this.set = [J];
              else if (this.set.length > 1) {
                for (const re of this.set) if (re.length === 1 && $(re[0])) {
                  this.set = [re];
                  break;
                }
              }
            }
            this.format();
          }
          format() {
            return this.range = this.set.map((B) => B.join(" ").trim()).join("||").trim(), this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(B) {
            const Q = ((this.options.includePrerelease && E) | (this.options.loose && O)) + ":" + B, J = c.get(Q);
            if (J) return J;
            const re = this.options.loose, G = re ? m[g.HYPHENRANGELOOSE] : m[g.HYPHENRANGE];
            B = B.replace(G, U(this.options.includePrerelease)), o("hyphen replace", B), B = B.replace(m[g.COMPARATORTRIM], b), o("comparator trim", B), B = B.replace(m[g.TILDETRIM], v), o("tilde trim", B), B = B.replace(m[g.CARETTRIM], T), o("caret trim", B);
            let N = B.split(" ").map((K) => k(K, this.options)).join(" ").split(/\s+/).map((K) => z(K, this.options));
            re && (N = N.filter((K) => (o("loose invalid filter", K, this.options), !!K.match(m[g.COMPARATORLOOSE])))), o("range list", N);
            const V = /* @__PURE__ */ new Map(), F = N.map((K) => new s(K, this.options));
            for (const K of F) {
              if (D(K)) return [K];
              V.set(K.value, K);
            }
            V.size > 1 && V.has("") && V.delete("");
            const X = [...V.values()];
            return c.set(Q, X), X;
          }
          intersects(B, Q) {
            if (!(B instanceof i)) throw new TypeError("a Range is required");
            return this.set.some((J) => I(J, Q) && B.set.some((re) => I(re, Q) && J.every((G) => re.every((N) => G.intersects(N, Q)))));
          }
          test(B) {
            if (!B) return !1;
            if (typeof B == "string") try {
              B = new y(B, this.options);
            } catch {
              return !1;
            }
            for (let Q = 0; Q < this.set.length; Q++) if (P(this.set[Q], B, this.options)) return !0;
            return !1;
          }
        }
        h.exports = i;
        const c = new (u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/lrucache.js"))(), f = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js"), s = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/comparator.js"), o = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js"), y = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), { safeRe: m, t: g, comparatorTrimReplace: b, tildeTrimReplace: v, caretTrimReplace: T } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js"), { FLAG_INCLUDE_PRERELEASE: E, FLAG_LOOSE: O } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js"), D = (W) => W.value === "<0.0.0-0", $ = (W) => W.value === "", I = (W, B) => {
          let Q = !0;
          const J = W.slice();
          let re = J.pop();
          for (; Q && J.length; ) Q = J.every((G) => re.intersects(G, B)), re = J.pop();
          return Q;
        }, k = (W, B) => (o("comp", W, B), W = _(W, B), o("caret", W), W = M(W, B), o("tildes", W), W = C(W, B), o("xrange", W), W = H(W, B), o("stars", W), W), L = (W) => !W || W.toLowerCase() === "x" || W === "*", M = (W, B) => W.trim().split(/\s+/).map((Q) => x(Q, B)).join(" "), x = (W, B) => {
          const Q = B.loose ? m[g.TILDELOOSE] : m[g.TILDE];
          return W.replace(Q, (J, re, G, N, V) => {
            let F;
            return o("tilde", W, J, re, G, N, V), L(re) ? F = "" : L(G) ? F = `>=${re}.0.0 <${+re + 1}.0.0-0` : L(N) ? F = `>=${re}.${G}.0 <${re}.${+G + 1}.0-0` : V ? (o("replaceTilde pr", V), F = `>=${re}.${G}.${N}-${V} <${re}.${+G + 1}.0-0`) : F = `>=${re}.${G}.${N} <${re}.${+G + 1}.0-0`, o("tilde return", F), F;
          });
        }, _ = (W, B) => W.trim().split(/\s+/).map((Q) => S(Q, B)).join(" "), S = (W, B) => {
          o("caret", W, B);
          const Q = B.loose ? m[g.CARETLOOSE] : m[g.CARET], J = B.includePrerelease ? "-0" : "";
          return W.replace(Q, (re, G, N, V, F) => {
            let X;
            return o("caret", W, re, G, N, V, F), L(G) ? X = "" : L(N) ? X = `>=${G}.0.0${J} <${+G + 1}.0.0-0` : L(V) ? X = G === "0" ? `>=${G}.${N}.0${J} <${G}.${+N + 1}.0-0` : `>=${G}.${N}.0${J} <${+G + 1}.0.0-0` : F ? (o("replaceCaret pr", F), X = G === "0" ? N === "0" ? `>=${G}.${N}.${V}-${F} <${G}.${N}.${+V + 1}-0` : `>=${G}.${N}.${V}-${F} <${G}.${+N + 1}.0-0` : `>=${G}.${N}.${V}-${F} <${+G + 1}.0.0-0`) : (o("no pr"), X = G === "0" ? N === "0" ? `>=${G}.${N}.${V}${J} <${G}.${N}.${+V + 1}-0` : `>=${G}.${N}.${V}${J} <${G}.${+N + 1}.0-0` : `>=${G}.${N}.${V} <${+G + 1}.0.0-0`), o("caret return", X), X;
          });
        }, C = (W, B) => (o("replaceXRanges", W, B), W.split(/\s+/).map((Q) => R(Q, B)).join(" ")), R = (W, B) => {
          W = W.trim();
          const Q = B.loose ? m[g.XRANGELOOSE] : m[g.XRANGE];
          return W.replace(Q, (J, re, G, N, V, F) => {
            o("xRange", W, J, re, G, N, V, F);
            const X = L(G), K = X || L(N), ie = K || L(V), fe = ie;
            return re === "=" && fe && (re = ""), F = B.includePrerelease ? "-0" : "", X ? J = re === ">" || re === "<" ? "<0.0.0-0" : "*" : re && fe ? (K && (N = 0), V = 0, re === ">" ? (re = ">=", K ? (G = +G + 1, N = 0, V = 0) : (N = +N + 1, V = 0)) : re === "<=" && (re = "<", K ? G = +G + 1 : N = +N + 1), re === "<" && (F = "-0"), J = `${re + G}.${N}.${V}${F}`) : K ? J = `>=${G}.0.0${F} <${+G + 1}.0.0-0` : ie && (J = `>=${G}.${N}.0${F} <${G}.${+N + 1}.0-0`), o("xRange return", J), J;
          });
        }, H = (W, B) => (o("replaceStars", W, B), W.trim().replace(m[g.STAR], "")), z = (W, B) => (o("replaceGTE0", W, B), W.trim().replace(m[B.includePrerelease ? g.GTE0PRE : g.GTE0], "")), U = (W) => (B, Q, J, re, G, N, V, F, X, K, ie, fe) => `${Q = L(J) ? "" : L(re) ? `>=${J}.0.0${W ? "-0" : ""}` : L(G) ? `>=${J}.${re}.0${W ? "-0" : ""}` : N ? `>=${Q}` : `>=${Q}${W ? "-0" : ""}`} ${F = L(X) ? "" : L(K) ? `<${+X + 1}.0.0-0` : L(ie) ? `<${X}.${+K + 1}.0-0` : fe ? `<=${X}.${K}.${ie}-${fe}` : W ? `<${X}.${K}.${+ie + 1}-0` : `<=${F}`}`.trim(), P = (W, B, Q) => {
          for (let J = 0; J < W.length; J++) if (!W[J].test(B)) return !1;
          if (B.prerelease.length && !Q.includePrerelease) {
            for (let J = 0; J < W.length; J++) if (o(W[J].semver), W[J].semver !== s.ANY && W[J].semver.prerelease.length > 0) {
              const re = W[J].semver;
              if (re.major === B.major && re.minor === B.minor && re.patch === B.patch) return !0;
            }
            return !1;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js"), { MAX_LENGTH: c, MAX_SAFE_INTEGER: f } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js"), { safeRe: s, t: o } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js"), y = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js"), { compareIdentifiers: m } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/identifiers.js");
        class g {
          constructor(v, T) {
            if (T = y(T), v instanceof g) {
              if (v.loose === !!T.loose && v.includePrerelease === !!T.includePrerelease) return v;
              v = v.version;
            } else if (typeof v != "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof v}".`);
            if (v.length > c) throw new TypeError(`version is longer than ${c} characters`);
            i("SemVer", v, T), this.options = T, this.loose = !!T.loose, this.includePrerelease = !!T.includePrerelease;
            const E = v.trim().match(T.loose ? s[o.LOOSE] : s[o.FULL]);
            if (!E) throw new TypeError(`Invalid Version: ${v}`);
            if (this.raw = v, this.major = +E[1], this.minor = +E[2], this.patch = +E[3], this.major > f || this.major < 0) throw new TypeError("Invalid major version");
            if (this.minor > f || this.minor < 0) throw new TypeError("Invalid minor version");
            if (this.patch > f || this.patch < 0) throw new TypeError("Invalid patch version");
            E[4] ? this.prerelease = E[4].split(".").map((O) => {
              if (/^[0-9]+$/.test(O)) {
                const D = +O;
                if (D >= 0 && D < f) return D;
              }
              return O;
            }) : this.prerelease = [], this.build = E[5] ? E[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(v) {
            if (i("SemVer.compare", this.version, this.options, v), !(v instanceof g)) {
              if (typeof v == "string" && v === this.version) return 0;
              v = new g(v, this.options);
            }
            return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);
          }
          compareMain(v) {
            return v instanceof g || (v = new g(v, this.options)), m(this.major, v.major) || m(this.minor, v.minor) || m(this.patch, v.patch);
          }
          comparePre(v) {
            if (v instanceof g || (v = new g(v, this.options)), this.prerelease.length && !v.prerelease.length) return -1;
            if (!this.prerelease.length && v.prerelease.length) return 1;
            if (!this.prerelease.length && !v.prerelease.length) return 0;
            let T = 0;
            do {
              const E = this.prerelease[T], O = v.prerelease[T];
              if (i("prerelease compare", T, E, O), E === void 0 && O === void 0) return 0;
              if (O === void 0) return 1;
              if (E === void 0) return -1;
              if (E !== O) return m(E, O);
            } while (++T);
          }
          compareBuild(v) {
            v instanceof g || (v = new g(v, this.options));
            let T = 0;
            do {
              const E = this.build[T], O = v.build[T];
              if (i("build compare", T, E, O), E === void 0 && O === void 0) return 0;
              if (O === void 0) return 1;
              if (E === void 0) return -1;
              if (E !== O) return m(E, O);
            } while (++T);
          }
          inc(v, T, E) {
            switch (v) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", T, E);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", T, E);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", T, E), this.inc("pre", T, E);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", T, E), this.inc("pre", T, E);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre": {
                const O = Number(E) ? 1 : 0;
                if (!T && E === !1) throw new Error("invalid increment argument: identifier is empty");
                if (this.prerelease.length === 0) this.prerelease = [O];
                else {
                  let D = this.prerelease.length;
                  for (; --D >= 0; ) typeof this.prerelease[D] == "number" && (this.prerelease[D]++, D = -2);
                  if (D === -1) {
                    if (T === this.prerelease.join(".") && E === !1) throw new Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(O);
                  }
                }
                if (T) {
                  let D = [T, O];
                  E === !1 && (D = [T]), m(this.prerelease[0], T) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = D) : this.prerelease = D;
                }
                break;
              }
              default:
                throw new Error(`invalid increment argument: ${v}`);
            }
            return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
          }
        }
        h.exports = g;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/clean.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js");
        h.exports = (c, f) => {
          const s = i(c.trim().replace(/^[=v]+/, ""), f);
          return s ? s.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/cmp.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/eq.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/neq.js"), f = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gt.js"), s = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js"), o = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lt.js"), y = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js");
        h.exports = (m, g, b, v) => {
          switch (g) {
            case "===":
              return typeof m == "object" && (m = m.version), typeof b == "object" && (b = b.version), m === b;
            case "!==":
              return typeof m == "object" && (m = m.version), typeof b == "object" && (b = b.version), m !== b;
            case "":
            case "=":
            case "==":
              return i(m, b, v);
            case "!=":
              return c(m, b, v);
            case ">":
              return f(m, b, v);
            case ">=":
              return s(m, b, v);
            case "<":
              return o(m, b, v);
            case "<=":
              return y(m, b, v);
            default:
              throw new TypeError(`Invalid operator: ${g}`);
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/coerce.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js"), { safeRe: f, t: s } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js");
        h.exports = (o, y) => {
          if (o instanceof i) return o;
          if (typeof o == "number" && (o = String(o)), typeof o != "string") return null;
          let m = null;
          if ((y = y || {}).rtl) {
            const O = y.includePrerelease ? f[s.COERCERTLFULL] : f[s.COERCERTL];
            let D;
            for (; (D = O.exec(o)) && (!m || m.index + m[0].length !== o.length); ) m && D.index + D[0].length === m.index + m[0].length || (m = D), O.lastIndex = D.index + D[1].length + D[2].length;
            O.lastIndex = -1;
          } else m = o.match(y.includePrerelease ? f[s.COERCEFULL] : f[s.COERCE]);
          if (m === null) return null;
          const g = m[2], b = m[3] || "0", v = m[4] || "0", T = y.includePrerelease && m[5] ? `-${m[5]}` : "", E = y.includePrerelease && m[6] ? `+${m[6]}` : "";
          return c(`${g}.${b}.${v}${T}${E}`, y);
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-build.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f, s) => {
          const o = new i(c, s), y = new i(f, s);
          return o.compare(y) || o.compareBuild(y);
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-loose.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f) => i(c, f, !0);
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f, s) => new i(c, s).compare(new i(f, s));
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/diff.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js");
        h.exports = (c, f) => {
          const s = i(c, null, !0), o = i(f, null, !0), y = s.compare(o);
          if (y === 0) return null;
          const m = y > 0, g = m ? s : o, b = m ? o : s, v = !!g.prerelease.length;
          if (b.prerelease.length && !v) return b.patch || b.minor ? g.patch ? "patch" : g.minor ? "minor" : "major" : "major";
          const T = v ? "pre" : "";
          return s.major !== o.major ? T + "major" : s.minor !== o.minor ? T + "minor" : s.patch !== o.patch ? T + "patch" : "prerelease";
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/eq.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(c, f, s) === 0;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gt.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(c, f, s) > 0;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(c, f, s) >= 0;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/inc.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f, s, o, y) => {
          typeof s == "string" && (y = o, o = s, s = void 0);
          try {
            return new i(c instanceof i ? c.version : c, s).inc(f, o, y).version;
          } catch {
            return null;
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lt.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(c, f, s) < 0;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(c, f, s) <= 0;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/major.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f) => new i(c, f).major;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/minor.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f) => new i(c, f).minor;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/neq.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(c, f, s) !== 0;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f, s = !1) => {
          if (c instanceof i) return c;
          try {
            return new i(c, f);
          } catch (o) {
            if (!s) return null;
            throw o;
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/patch.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js");
        h.exports = (c, f) => new i(c, f).patch;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/prerelease.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js");
        h.exports = (c, f) => {
          const s = i(c, f);
          return s && s.prerelease.length ? s.prerelease : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/rcompare.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (c, f, s) => i(f, c, s);
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/rsort.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-build.js");
        h.exports = (c, f) => c.sort((s, o) => i(o, s, f));
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/satisfies.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
        h.exports = (c, f, s) => {
          try {
            f = new i(f, s);
          } catch {
            return !1;
          }
          return f.test(c);
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/sort.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-build.js");
        h.exports = (c, f) => c.sort((s, o) => i(s, o, f));
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/valid.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js");
        h.exports = (c, f) => {
          const s = i(c, f);
          return s ? s.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/index.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js"), f = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), s = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/identifiers.js"), o = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/parse.js"), y = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/valid.js"), m = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/clean.js"), g = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/inc.js"), b = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/diff.js"), v = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/major.js"), T = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/minor.js"), E = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/patch.js"), O = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/prerelease.js"), D = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js"), $ = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/rcompare.js"), I = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-loose.js"), k = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare-build.js"), L = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/sort.js"), M = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/rsort.js"), x = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gt.js"), _ = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lt.js"), S = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/eq.js"), C = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/neq.js"), R = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js"), H = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js"), z = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/cmp.js"), U = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/coerce.js"), P = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/comparator.js"), W = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js"), B = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/satisfies.js"), Q = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/to-comparators.js"), J = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/max-satisfying.js"), re = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/min-satisfying.js"), G = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/min-version.js"), N = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/valid.js"), V = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/outside.js"), F = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/gtr.js"), X = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/ltr.js"), K = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/intersects.js"), ie = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/simplify.js"), fe = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/subset.js");
        h.exports = { parse: o, valid: y, clean: m, inc: g, diff: b, major: v, minor: T, patch: E, prerelease: O, compare: D, rcompare: $, compareLoose: I, compareBuild: k, sort: L, rsort: M, gt: x, lt: _, eq: S, neq: C, gte: R, lte: H, cmp: z, coerce: U, Comparator: P, Range: W, satisfies: B, toComparators: Q, maxSatisfying: J, minSatisfying: re, minVersion: G, validRange: N, outside: V, gtr: F, ltr: X, intersects: K, simplifyRange: ie, subset: fe, SemVer: f, re: i.re, src: i.src, tokens: i.t, SEMVER_SPEC_VERSION: c.SEMVER_SPEC_VERSION, RELEASE_TYPES: c.RELEASE_TYPES, compareIdentifiers: s.compareIdentifiers, rcompareIdentifiers: s.rcompareIdentifiers };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js": (h) => {
        const n = Number.MAX_SAFE_INTEGER || 9007199254740991;
        h.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: n, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js": (h) => {
        const n = typeof Ze == "object" && Ze.env && Ze.env.NODE_DEBUG && /\bsemver\b/i.test(Ze.env.NODE_DEBUG) ? (...u) => console.error("SEMVER", ...u) : () => {
        };
        h.exports = n;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/identifiers.js": (h) => {
        const n = /^[0-9]+$/, u = (i, c) => {
          const f = n.test(i), s = n.test(c);
          return f && s && (i = +i, c = +c), i === c ? 0 : f && !s ? -1 : s && !f ? 1 : i < c ? -1 : 1;
        };
        h.exports = { compareIdentifiers: u, rcompareIdentifiers: (i, c) => u(c, i) };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/lrucache.js": (h) => {
        h.exports = class {
          constructor() {
            this.max = 1e3, this.map = /* @__PURE__ */ new Map();
          }
          get(n) {
            const u = this.map.get(n);
            return u === void 0 ? void 0 : (this.map.delete(n), this.map.set(n, u), u);
          }
          delete(n) {
            return this.map.delete(n);
          }
          set(n, u) {
            if (!this.delete(n) && u !== void 0) {
              if (this.map.size >= this.max) {
                const i = this.map.keys().next().value;
                this.delete(i);
              }
              this.map.set(n, u);
            }
            return this;
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/parse-options.js": (h) => {
        const n = Object.freeze({ loose: !0 }), u = Object.freeze({});
        h.exports = (i) => i ? typeof i != "object" ? n : i : u;
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/re.js": (h, n, u) => {
        const { MAX_SAFE_COMPONENT_LENGTH: i, MAX_SAFE_BUILD_LENGTH: c, MAX_LENGTH: f } = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/constants.js"), s = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/internal/debug.js"), o = (n = h.exports = {}).re = [], y = n.safeRe = [], m = n.src = [], g = n.t = {};
        let b = 0;
        const v = [["\\s", 1], ["\\d", f], ["[a-zA-Z0-9-]", c]], T = (E, O, D) => {
          const $ = ((k) => {
            for (const [L, M] of v) k = k.split(`${L}*`).join(`${L}{0,${M}}`).split(`${L}+`).join(`${L}{1,${M}}`);
            return k;
          })(O), I = b++;
          s(E, I, O), g[E] = I, m[I] = O, o[I] = new RegExp(O, D ? "g" : void 0), y[I] = new RegExp($, D ? "g" : void 0);
        };
        T("NUMERICIDENTIFIER", "0|[1-9]\\d*"), T("NUMERICIDENTIFIERLOOSE", "\\d+"), T("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), T("MAINVERSION", `(${m[g.NUMERICIDENTIFIER]})\\.(${m[g.NUMERICIDENTIFIER]})\\.(${m[g.NUMERICIDENTIFIER]})`), T("MAINVERSIONLOOSE", `(${m[g.NUMERICIDENTIFIERLOOSE]})\\.(${m[g.NUMERICIDENTIFIERLOOSE]})\\.(${m[g.NUMERICIDENTIFIERLOOSE]})`), T("PRERELEASEIDENTIFIER", `(?:${m[g.NUMERICIDENTIFIER]}|${m[g.NONNUMERICIDENTIFIER]})`), T("PRERELEASEIDENTIFIERLOOSE", `(?:${m[g.NUMERICIDENTIFIERLOOSE]}|${m[g.NONNUMERICIDENTIFIER]})`), T("PRERELEASE", `(?:-(${m[g.PRERELEASEIDENTIFIER]}(?:\\.${m[g.PRERELEASEIDENTIFIER]})*))`), T("PRERELEASELOOSE", `(?:-?(${m[g.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${m[g.PRERELEASEIDENTIFIERLOOSE]})*))`), T("BUILDIDENTIFIER", "[a-zA-Z0-9-]+"), T("BUILD", `(?:\\+(${m[g.BUILDIDENTIFIER]}(?:\\.${m[g.BUILDIDENTIFIER]})*))`), T("FULLPLAIN", `v?${m[g.MAINVERSION]}${m[g.PRERELEASE]}?${m[g.BUILD]}?`), T("FULL", `^${m[g.FULLPLAIN]}$`), T("LOOSEPLAIN", `[v=\\s]*${m[g.MAINVERSIONLOOSE]}${m[g.PRERELEASELOOSE]}?${m[g.BUILD]}?`), T("LOOSE", `^${m[g.LOOSEPLAIN]}$`), T("GTLT", "((?:<|>)?=?)"), T("XRANGEIDENTIFIERLOOSE", `${m[g.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), T("XRANGEIDENTIFIER", `${m[g.NUMERICIDENTIFIER]}|x|X|\\*`), T("XRANGEPLAIN", `[v=\\s]*(${m[g.XRANGEIDENTIFIER]})(?:\\.(${m[g.XRANGEIDENTIFIER]})(?:\\.(${m[g.XRANGEIDENTIFIER]})(?:${m[g.PRERELEASE]})?${m[g.BUILD]}?)?)?`), T("XRANGEPLAINLOOSE", `[v=\\s]*(${m[g.XRANGEIDENTIFIERLOOSE]})(?:\\.(${m[g.XRANGEIDENTIFIERLOOSE]})(?:\\.(${m[g.XRANGEIDENTIFIERLOOSE]})(?:${m[g.PRERELEASELOOSE]})?${m[g.BUILD]}?)?)?`), T("XRANGE", `^${m[g.GTLT]}\\s*${m[g.XRANGEPLAIN]}$`), T("XRANGELOOSE", `^${m[g.GTLT]}\\s*${m[g.XRANGEPLAINLOOSE]}$`), T("COERCEPLAIN", `(^|[^\\d])(\\d{1,${i}})(?:\\.(\\d{1,${i}}))?(?:\\.(\\d{1,${i}}))?`), T("COERCE", `${m[g.COERCEPLAIN]}(?:$|[^\\d])`), T("COERCEFULL", m[g.COERCEPLAIN] + `(?:${m[g.PRERELEASE]})?(?:${m[g.BUILD]})?(?:$|[^\\d])`), T("COERCERTL", m[g.COERCE], !0), T("COERCERTLFULL", m[g.COERCEFULL], !0), T("LONETILDE", "(?:~>?)"), T("TILDETRIM", `(\\s*)${m[g.LONETILDE]}\\s+`, !0), n.tildeTrimReplace = "$1~", T("TILDE", `^${m[g.LONETILDE]}${m[g.XRANGEPLAIN]}$`), T("TILDELOOSE", `^${m[g.LONETILDE]}${m[g.XRANGEPLAINLOOSE]}$`), T("LONECARET", "(?:\\^)"), T("CARETTRIM", `(\\s*)${m[g.LONECARET]}\\s+`, !0), n.caretTrimReplace = "$1^", T("CARET", `^${m[g.LONECARET]}${m[g.XRANGEPLAIN]}$`), T("CARETLOOSE", `^${m[g.LONECARET]}${m[g.XRANGEPLAINLOOSE]}$`), T("COMPARATORLOOSE", `^${m[g.GTLT]}\\s*(${m[g.LOOSEPLAIN]})$|^$`), T("COMPARATOR", `^${m[g.GTLT]}\\s*(${m[g.FULLPLAIN]})$|^$`), T("COMPARATORTRIM", `(\\s*)${m[g.GTLT]}\\s*(${m[g.LOOSEPLAIN]}|${m[g.XRANGEPLAIN]})`, !0), n.comparatorTrimReplace = "$1$2$3", T("HYPHENRANGE", `^\\s*(${m[g.XRANGEPLAIN]})\\s+-\\s+(${m[g.XRANGEPLAIN]})\\s*$`), T("HYPHENRANGELOOSE", `^\\s*(${m[g.XRANGEPLAINLOOSE]})\\s+-\\s+(${m[g.XRANGEPLAINLOOSE]})\\s*$`), T("STAR", "(<|>)?=?\\s*\\*"), T("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), T("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/gtr.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/outside.js");
        h.exports = (c, f, s) => i(c, f, ">", s);
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/intersects.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
        h.exports = (c, f, s) => (c = new i(c, s), f = new i(f, s), c.intersects(f, s));
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/ltr.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/outside.js");
        h.exports = (c, f, s) => i(c, f, "<", s);
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/max-satisfying.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
        h.exports = (f, s, o) => {
          let y = null, m = null, g = null;
          try {
            g = new c(s, o);
          } catch {
            return null;
          }
          return f.forEach((b) => {
            g.test(b) && (y && m.compare(b) !== -1 || (y = b, m = new i(y, o)));
          }), y;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/min-satisfying.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
        h.exports = (f, s, o) => {
          let y = null, m = null, g = null;
          try {
            g = new c(s, o);
          } catch {
            return null;
          }
          return f.forEach((b) => {
            g.test(b) && (y && m.compare(b) !== 1 || (y = b, m = new i(y, o)));
          }), y;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/min-version.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js"), f = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gt.js");
        h.exports = (s, o) => {
          s = new c(s, o);
          let y = new i("0.0.0");
          if (s.test(y) || (y = new i("0.0.0-0"), s.test(y))) return y;
          y = null;
          for (let m = 0; m < s.set.length; ++m) {
            const g = s.set[m];
            let b = null;
            g.forEach((v) => {
              const T = new i(v.semver.version);
              switch (v.operator) {
                case ">":
                  T.prerelease.length === 0 ? T.patch++ : T.prerelease.push(0), T.raw = T.format();
                case "":
                case ">=":
                  b && !f(T, b) || (b = T);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${v.operator}`);
              }
            }), !b || y && !f(y, b) || (y = b);
          }
          return y && s.test(y) ? y : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/outside.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/semver.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/comparator.js"), { ANY: f } = c, s = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js"), o = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/satisfies.js"), y = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gt.js"), m = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lt.js"), g = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/lte.js"), b = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/gte.js");
        h.exports = (v, T, E, O) => {
          let D, $, I, k, L;
          switch (v = new i(v, O), T = new s(T, O), E) {
            case ">":
              D = y, $ = g, I = m, k = ">", L = ">=";
              break;
            case "<":
              D = m, $ = b, I = y, k = "<", L = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (o(v, T, O)) return !1;
          for (let M = 0; M < T.set.length; ++M) {
            const x = T.set[M];
            let _ = null, S = null;
            if (x.forEach((C) => {
              C.semver === f && (C = new c(">=0.0.0")), _ = _ || C, S = S || C, D(C.semver, _.semver, O) ? _ = C : I(C.semver, S.semver, O) && (S = C);
            }), _.operator === k || _.operator === L || (!S.operator || S.operator === k) && $(v, S.semver) || S.operator === L && I(v, S.semver)) return !1;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/simplify.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/satisfies.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js");
        h.exports = (f, s, o) => {
          const y = [];
          let m = null, g = null;
          const b = f.sort((O, D) => c(O, D, o));
          for (const O of b)
            i(O, s, o) ? (g = O, m || (m = O)) : (g && y.push([m, g]), g = null, m = null);
          m && y.push([m, null]);
          const v = [];
          for (const [O, D] of y) O === D ? v.push(O) : D || O !== b[0] ? D ? O === b[0] ? v.push(`<=${D}`) : v.push(`${O} - ${D}`) : v.push(`>=${O}`) : v.push("*");
          const T = v.join(" || "), E = typeof s.raw == "string" ? s.raw : String(s);
          return T.length < E.length ? T : s;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/subset.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js"), c = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/comparator.js"), { ANY: f } = c, s = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/satisfies.js"), o = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/functions/compare.js"), y = [new c(">=0.0.0-0")], m = [new c(">=0.0.0")], g = (T, E, O) => {
          if (T === E) return !0;
          if (T.length === 1 && T[0].semver === f) {
            if (E.length === 1 && E[0].semver === f) return !0;
            T = O.includePrerelease ? y : m;
          }
          if (E.length === 1 && E[0].semver === f) {
            if (O.includePrerelease) return !0;
            E = m;
          }
          const D = /* @__PURE__ */ new Set();
          let $, I, k, L, M, x, _;
          for (const R of T) R.operator === ">" || R.operator === ">=" ? $ = b($, R, O) : R.operator === "<" || R.operator === "<=" ? I = v(I, R, O) : D.add(R.semver);
          if (D.size > 1 || $ && I && (k = o($.semver, I.semver, O), k > 0 || k === 0 && ($.operator !== ">=" || I.operator !== "<=")))
            return null;
          for (const R of D) {
            if ($ && !s(R, String($), O) || I && !s(R, String(I), O)) return null;
            for (const H of E) if (!s(R, String(H), O)) return !1;
            return !0;
          }
          let S = !(!I || O.includePrerelease || !I.semver.prerelease.length) && I.semver, C = !(!$ || O.includePrerelease || !$.semver.prerelease.length) && $.semver;
          S && S.prerelease.length === 1 && I.operator === "<" && S.prerelease[0] === 0 && (S = !1);
          for (const R of E) {
            if (_ = _ || R.operator === ">" || R.operator === ">=", x = x || R.operator === "<" || R.operator === "<=", $) {
              if (C && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === C.major && R.semver.minor === C.minor && R.semver.patch === C.patch && (C = !1), R.operator === ">" || R.operator === ">=") {
                if (L = b($, R, O), L === R && L !== $) return !1;
              } else if ($.operator === ">=" && !s($.semver, String(R), O)) return !1;
            }
            if (I) {
              if (S && R.semver.prerelease && R.semver.prerelease.length && R.semver.major === S.major && R.semver.minor === S.minor && R.semver.patch === S.patch && (S = !1), R.operator === "<" || R.operator === "<=") {
                if (M = v(I, R, O), M === R && M !== I) return !1;
              } else if (I.operator === "<=" && !s(I.semver, String(R), O)) return !1;
            }
            if (!R.operator && (I || $) && k !== 0) return !1;
          }
          return !($ && x && !I && k !== 0) && !(I && _ && !$ && k !== 0) && !C && !S;
        }, b = (T, E, O) => {
          if (!T) return E;
          const D = o(T.semver, E.semver, O);
          return D > 0 ? T : D < 0 || E.operator === ">" && T.operator === ">=" ? E : T;
        }, v = (T, E, O) => {
          if (!T) return E;
          const D = o(T.semver, E.semver, O);
          return D < 0 ? T : D > 0 || E.operator === "<" && T.operator === "<=" ? E : T;
        };
        h.exports = (T, E, O = {}) => {
          if (T === E) return !0;
          T = new i(T, O), E = new i(E, O);
          let D = !1;
          e: for (const $ of T.set) {
            for (const I of E.set) {
              const k = g($, I, O);
              if (D = D || k !== null, k) continue e;
            }
            if (D) return !1;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/to-comparators.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
        h.exports = (c, f) => new i(c, f).set.map((s) => s.map((o) => o.value).join(" ").trim().split(" "));
      }, "./node_modules/.pnpm/semver@7.6.2/node_modules/semver/ranges/valid.js": (h, n, u) => {
        const i = u("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/classes/range.js");
        h.exports = (c, f) => {
          try {
            return new i(c, f).range || "*";
          } catch {
            return null;
          }
        };
      }, crypto: (h) => {
        h.exports = Gb();
      }, fs: (h) => {
        h.exports = oi;
      }, module: (h) => {
        h.exports = Rr;
      }, path: (h) => {
        h.exports = Qr;
      } }, a = {};
      function l(h) {
        var n = a[h];
        if (n !== void 0) return n.exports;
        var u = a[h] = { id: h, loaded: !1, exports: {} };
        return r[h](u, u.exports, l), u.loaded = !0, u.exports;
      }
      l.n = (h) => {
        var n = h && h.__esModule ? () => h.default : () => h;
        return l.d(n, { a: n }), n;
      }, l.d = (h, n) => {
        for (var u in n) l.o(n, u) && !l.o(h, u) && Object.defineProperty(h, u, { enumerable: !0, get: n[u] });
      }, l.o = (h, n) => Object.prototype.hasOwnProperty.call(h, n), l.nmd = (h) => (h.paths = [], h.children || (h.children = []), h);
      var d = {};
      (() => {
        l.d(d, { default: () => bv });
        var h = l("fs"), n = l("module");
        const u = Rr, i = Zr, c = Rr;
        var f = l.n(c);
        const s = Ns, o = /^[A-Za-z]:\//;
        function y(A = "") {
          return A && A.replace(/\\/g, "/").replace(o, (Z) => Z.toUpperCase());
        }
        const m = /^[/\\]{2}/, g = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, b = /^[A-Za-z]:$/, v = function(A) {
          if (A.length === 0) return ".";
          const Z = (A = y(A)).match(m), he = O(A), ve = A[A.length - 1] === "/";
          return (A = E(A, !he)).length === 0 ? he ? "/" : ve ? "./" : "." : (ve && (A += "/"), b.test(A) && (A += "/"), Z ? he ? `//${A}` : `//./${A}` : he && !O(A) ? `/${A}` : A);
        }, T = function(...A) {
          if (A.length === 0) return ".";
          let Z;
          for (const he of A) he && he.length > 0 && (Z === void 0 ? Z = he : Z += `/${he}`);
          return Z === void 0 ? "." : v(Z.replace(/\/\/+/g, "/"));
        };
        function E(A, Z) {
          let he = "", ve = 0, ke = -1, Le = 0, je = null;
          for (let Ge = 0; Ge <= A.length; ++Ge) {
            if (Ge < A.length) je = A[Ge];
            else {
              if (je === "/") break;
              je = "/";
            }
            if (je === "/") {
              if (!(ke === Ge - 1 || Le === 1)) if (Le === 2) {
                if (he.length < 2 || ve !== 2 || he[he.length - 1] !== "." || he[he.length - 2] !== ".") {
                  if (he.length > 2) {
                    const lt = he.lastIndexOf("/");
                    lt === -1 ? (he = "", ve = 0) : (he = he.slice(0, lt), ve = he.length - 1 - he.lastIndexOf("/")), ke = Ge, Le = 0;
                    continue;
                  }
                  if (he.length > 0) {
                    he = "", ve = 0, ke = Ge, Le = 0;
                    continue;
                  }
                }
                Z && (he += he.length > 0 ? "/.." : "..", ve = 2);
              } else he.length > 0 ? he += `/${A.slice(ke + 1, Ge)}` : he = A.slice(ke + 1, Ge), ve = Ge - ke - 1;
              ke = Ge, Le = 0;
            } else je === "." && Le !== -1 ? ++Le : Le = -1;
          }
          return he;
        }
        const O = function(A) {
          return g.test(A);
        }, D = /.(\.[^./]+)$/, $ = function(A) {
          const Z = D.exec(y(A));
          return Z && Z[1] || "";
        }, I = function(A) {
          const Z = y(A).replace(/\/$/, "").split("/").slice(0, -1);
          return Z.length === 1 && b.test(Z[0]) && (Z[0] += "/"), Z.join("/") || (O(A) ? "/" : ".");
        }, k = function(A, Z) {
          return y(A).split("/").pop();
        }, L = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, M = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, x = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
        function _(A, Z) {
          if (!(A === "__proto__" || A === "constructor" && Z && typeof Z == "object" && "prototype" in Z)) return Z;
          (function(he) {
            console.warn(`[destr] Dropping "${he}" key to prevent prototype pollution.`);
          })(A);
        }
        function S(A, Z = {}) {
          if (typeof A != "string") return A;
          const he = A.trim();
          if (A[0] === '"' && A.endsWith('"') && !A.includes("\\")) return he.slice(1, -1);
          if (he.length <= 9) {
            const ve = he.toLowerCase();
            if (ve === "true") return !0;
            if (ve === "false") return !1;
            if (ve === "undefined") return;
            if (ve === "null") return null;
            if (ve === "nan") return Number.NaN;
            if (ve === "infinity") return Number.POSITIVE_INFINITY;
            if (ve === "-infinity") return Number.NEGATIVE_INFINITY;
          }
          if (!x.test(A)) {
            if (Z.strict) throw new SyntaxError("[destr] Invalid JSON");
            return A;
          }
          try {
            if (L.test(A) || M.test(A)) {
              if (Z.strict) throw new Error("[destr] Possible prototype pollution");
              return JSON.parse(A, _);
            }
            return JSON.parse(A);
          } catch (ve) {
            if (Z.strict) throw ve;
            return A;
          }
        }
        function C(A) {
          if (typeof A != "string") throw new TypeError("Expected a string");
          return A.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var R = l("./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js"), H = l.n(R), z = l("./node_modules/.pnpm/semver@7.6.2/node_modules/semver/index.js");
        const U = /* @__PURE__ */ new Set(["/", "\\", void 0]), P = Symbol.for("pathe:normalizedAlias");
        function W(A) {
          if (A[P]) return A;
          const Z = Object.fromEntries(Object.entries(A).sort(([he], [ve]) => function(ke, Le) {
            return Le.split("/").length - ke.split("/").length;
          }(he, ve)));
          for (const he in Z) for (const ve in Z) ve === he || he.startsWith(ve) || Z[he].startsWith(ve) && U.has(Z[he][ve.length]) && (Z[he] = Z[ve] + Z[he].slice(ve.length));
          return Object.defineProperty(Z, P, { value: !0, enumerable: !1 }), Z;
        }
        function B(A = "/") {
          const Z = A[A.length - 1];
          return Z === "/" || Z === "\\";
        }
        var Q = l("./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js"), J = l("./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js"), re = l.n(J), G = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], N = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], V = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", F = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, X = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", K = { 5: X, "5module": X + " export import", 6: X + " const class extends export import super" }, ie = /^in(stanceof)?$/, fe = new RegExp("[" + V + "]"), _e = new RegExp("[" + V + "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･]");
        function Ae(A, Z) {
          for (var he = 65536, ve = 0; ve < Z.length; ve += 2) {
            if ((he += Z[ve]) > A) return !1;
            if ((he += Z[ve + 1]) >= A) return !0;
          }
          return !1;
        }
        function ce(A, Z) {
          return A < 65 ? A === 36 : A < 91 || (A < 97 ? A === 95 : A < 123 || (A <= 65535 ? A >= 170 && fe.test(String.fromCharCode(A)) : Z !== !1 && Ae(A, N)));
        }
        function ee(A, Z) {
          return A < 48 ? A === 36 : A < 58 || !(A < 65) && (A < 91 || (A < 97 ? A === 95 : A < 123 || (A <= 65535 ? A >= 170 && _e.test(String.fromCharCode(A)) : Z !== !1 && (Ae(A, N) || Ae(A, G)))));
        }
        var ae = function(A, Z) {
          Z === void 0 && (Z = {}), this.label = A, this.keyword = Z.keyword, this.beforeExpr = !!Z.beforeExpr, this.startsExpr = !!Z.startsExpr, this.isLoop = !!Z.isLoop, this.isAssign = !!Z.isAssign, this.prefix = !!Z.prefix, this.postfix = !!Z.postfix, this.binop = Z.binop || null, this.updateContext = null;
        };
        function oe(A, Z) {
          return new ae(A, { beforeExpr: !0, binop: Z });
        }
        var me = { beforeExpr: !0 }, ye = { startsExpr: !0 }, we = {};
        function ge(A, Z) {
          return Z === void 0 && (Z = {}), Z.keyword = A, we[A] = new ae(A, Z);
        }
        var se = { num: new ae("num", ye), regexp: new ae("regexp", ye), string: new ae("string", ye), name: new ae("name", ye), privateId: new ae("privateId", ye), eof: new ae("eof"), bracketL: new ae("[", { beforeExpr: !0, startsExpr: !0 }), bracketR: new ae("]"), braceL: new ae("{", { beforeExpr: !0, startsExpr: !0 }), braceR: new ae("}"), parenL: new ae("(", { beforeExpr: !0, startsExpr: !0 }), parenR: new ae(")"), comma: new ae(",", me), semi: new ae(";", me), colon: new ae(":", me), dot: new ae("."), question: new ae("?", me), questionDot: new ae("?."), arrow: new ae("=>", me), template: new ae("template"), invalidTemplate: new ae("invalidTemplate"), ellipsis: new ae("...", me), backQuote: new ae("`", ye), dollarBraceL: new ae("${", { beforeExpr: !0, startsExpr: !0 }), eq: new ae("=", { beforeExpr: !0, isAssign: !0 }), assign: new ae("_=", { beforeExpr: !0, isAssign: !0 }), incDec: new ae("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), prefix: new ae("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), logicalOR: oe("||", 1), logicalAND: oe("&&", 2), bitwiseOR: oe("|", 3), bitwiseXOR: oe("^", 4), bitwiseAND: oe("&", 5), equality: oe("==/!=/===/!==", 6), relational: oe("</>/<=/>=", 7), bitShift: oe("<</>>/>>>", 8), plusMin: new ae("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: oe("%", 10), star: oe("*", 10), slash: oe("/", 10), starstar: new ae("**", { beforeExpr: !0 }), coalesce: oe("??", 1), _break: ge("break"), _case: ge("case", me), _catch: ge("catch"), _continue: ge("continue"), _debugger: ge("debugger"), _default: ge("default", me), _do: ge("do", { isLoop: !0, beforeExpr: !0 }), _else: ge("else", me), _finally: ge("finally"), _for: ge("for", { isLoop: !0 }), _function: ge("function", ye), _if: ge("if"), _return: ge("return", me), _switch: ge("switch"), _throw: ge("throw", me), _try: ge("try"), _var: ge("var"), _const: ge("const"), _while: ge("while", { isLoop: !0 }), _with: ge("with"), _new: ge("new", { beforeExpr: !0, startsExpr: !0 }), _this: ge("this", ye), _super: ge("super", ye), _class: ge("class", ye), _extends: ge("extends", me), _export: ge("export"), _import: ge("import", ye), _null: ge("null", ye), _true: ge("true", ye), _false: ge("false", ye), _in: ge("in", { beforeExpr: !0, binop: 7 }), _instanceof: ge("instanceof", { beforeExpr: !0, binop: 7 }), _typeof: ge("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: ge("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: ge("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }) }, be = /\r\n?|\n|\u2028|\u2029/, Ie = new RegExp(be.source, "g");
        function Oe(A) {
          return A === 10 || A === 13 || A === 8232 || A === 8233;
        }
        function Be(A, Z, he) {
          he === void 0 && (he = A.length);
          for (var ve = Z; ve < he; ve++) {
            var ke = A.charCodeAt(ve);
            if (Oe(ke)) return ve < he - 1 && ke === 13 && A.charCodeAt(ve + 1) === 10 ? ve + 2 : ve + 1;
          }
          return -1;
        }
        var Fe = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, ue = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, te = Object.prototype, Y = te.hasOwnProperty, le = te.toString, Ee = Object.hasOwn || function(A, Z) {
          return Y.call(A, Z);
        }, Se = Array.isArray || function(A) {
          return le.call(A) === "[object Array]";
        }, Pe = /* @__PURE__ */ Object.create(null);
        function Ve(A) {
          return Pe[A] || (Pe[A] = new RegExp("^(?:" + A.replace(/ /g, "|") + ")$"));
        }
        function Xe(A) {
          return A <= 65535 ? String.fromCharCode(A) : (A -= 65536, String.fromCharCode(55296 + (A >> 10), 56320 + (1023 & A)));
        }
        var Ye = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, We = function(A, Z) {
          this.line = A, this.column = Z;
        };
        We.prototype.offset = function(A) {
          return new We(this.line, this.column + A);
        };
        var et = function(A, Z, he) {
          this.start = Z, this.end = he, A.sourceFile !== null && (this.source = A.sourceFile);
        };
        function De(A, Z) {
          for (var he = 1, ve = 0; ; ) {
            var ke = Be(A, ve, Z);
            if (ke < 0) return new We(he, Z - ve);
            ++he, ve = ke;
          }
        }
        var Me = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: !1, checkPrivateFields: !0, locations: !1, onToken: null, onComment: null, ranges: !1, program: null, sourceFile: null, directSourceFile: null, preserveParens: !1 }, Qe = !1;
        function He(A) {
          var Z = {};
          for (var he in Me) Z[he] = A && Ee(A, he) ? A[he] : Me[he];
          if (Z.ecmaVersion === "latest" ? Z.ecmaVersion = 1e8 : Z.ecmaVersion == null ? (!Qe && typeof console == "object" && console.warn && (Qe = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), Z.ecmaVersion = 11) : Z.ecmaVersion >= 2015 && (Z.ecmaVersion -= 2009), Z.allowReserved == null && (Z.allowReserved = Z.ecmaVersion < 5), A && A.allowHashBang != null || (Z.allowHashBang = Z.ecmaVersion >= 14), Se(Z.onToken)) {
            var ve = Z.onToken;
            Z.onToken = function(ke) {
              return ve.push(ke);
            };
          }
          return Se(Z.onComment) && (Z.onComment = /* @__PURE__ */ function(ke, Le) {
            return function(je, Ge, lt, gt, ot, kt) {
              var qt = { type: je ? "Block" : "Line", value: Ge, start: lt, end: gt };
              ke.locations && (qt.loc = new et(this, ot, kt)), ke.ranges && (qt.range = [lt, gt]), Le.push(qt);
            };
          }(Z, Z.onComment)), Z;
        }
        function st(A, Z) {
          return 2 | (A ? 4 : 0) | (Z ? 8 : 0);
        }
        var it = function(A, Z, he) {
          this.options = A = He(A), this.sourceFile = A.sourceFile, this.keywords = Ve(K[A.ecmaVersion >= 6 ? 6 : A.sourceType === "module" ? "5module" : 5]);
          var ve = "";
          A.allowReserved !== !0 && (ve = F[A.ecmaVersion >= 6 ? 6 : A.ecmaVersion === 5 ? 5 : 3], A.sourceType === "module" && (ve += " await")), this.reservedWords = Ve(ve);
          var ke = (ve ? ve + " " : "") + F.strict;
          this.reservedWordsStrict = Ve(ke), this.reservedWordsStrictBind = Ve(ke + " " + F.strictBind), this.input = String(Z), this.containsEsc = !1, he ? (this.pos = he, this.lineStart = this.input.lastIndexOf(`
`, he - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(be).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = se.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = A.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && A.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, qe = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
        it.prototype.parse = function() {
          var A = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(A);
        }, qe.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, qe.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, qe.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, qe.canAwait.get = function() {
          for (var A = this.scopeStack.length - 1; A >= 0; A--) {
            var Z = this.scopeStack[A];
            if (Z.inClassFieldInit || 256 & Z.flags) return !1;
            if (2 & Z.flags) return (4 & Z.flags) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, qe.allowSuper.get = function() {
          var A = this.currentThisScope(), Z = A.flags, he = A.inClassFieldInit;
          return (64 & Z) > 0 || he || this.options.allowSuperOutsideMethod;
        }, qe.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, qe.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, qe.allowNewDotTarget.get = function() {
          var A = this.currentThisScope(), Z = A.flags, he = A.inClassFieldInit;
          return (258 & Z) > 0 || he;
        }, qe.inClassStaticBlock.get = function() {
          return (256 & this.currentVarScope().flags) > 0;
        }, it.extend = function() {
          for (var A = [], Z = arguments.length; Z--; ) A[Z] = arguments[Z];
          for (var he = this, ve = 0; ve < A.length; ve++) he = A[ve](he);
          return he;
        }, it.parse = function(A, Z) {
          return new this(Z, A).parse();
        }, it.parseExpressionAt = function(A, Z, he) {
          var ve = new this(he, A, Z);
          return ve.nextToken(), ve.parseExpression();
        }, it.tokenizer = function(A, Z) {
          return new this(Z, A);
        }, Object.defineProperties(it.prototype, qe);
        var rt = it.prototype, bt = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
        rt.strictDirective = function(A) {
          if (this.options.ecmaVersion < 5) return !1;
          for (; ; ) {
            ue.lastIndex = A, A += ue.exec(this.input)[0].length;
            var Z = bt.exec(this.input.slice(A));
            if (!Z) return !1;
            if ((Z[1] || Z[2]) === "use strict") {
              ue.lastIndex = A + Z[0].length;
              var he = ue.exec(this.input), ve = he.index + he[0].length, ke = this.input.charAt(ve);
              return ke === ";" || ke === "}" || be.test(he[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(ke) || ke === "!" && this.input.charAt(ve + 1) === "=");
            }
            A += Z[0].length, ue.lastIndex = A, A += ue.exec(this.input)[0].length, this.input[A] === ";" && A++;
          }
        }, rt.eat = function(A) {
          return this.type === A && (this.next(), !0);
        }, rt.isContextual = function(A) {
          return this.type === se.name && this.value === A && !this.containsEsc;
        }, rt.eatContextual = function(A) {
          return !!this.isContextual(A) && (this.next(), !0);
        }, rt.expectContextual = function(A) {
          this.eatContextual(A) || this.unexpected();
        }, rt.canInsertSemicolon = function() {
          return this.type === se.eof || this.type === se.braceR || be.test(this.input.slice(this.lastTokEnd, this.start));
        }, rt.insertSemicolon = function() {
          if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
        }, rt.semicolon = function() {
          this.eat(se.semi) || this.insertSemicolon() || this.unexpected();
        }, rt.afterTrailingComma = function(A, Z) {
          if (this.type === A) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), Z || this.next(), !0;
        }, rt.expect = function(A) {
          this.eat(A) || this.unexpected();
        }, rt.unexpected = function(A) {
          this.raise(A ?? this.start, "Unexpected token");
        };
        var dt = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        rt.checkPatternErrors = function(A, Z) {
          if (A) {
            A.trailingComma > -1 && this.raiseRecoverable(A.trailingComma, "Comma is not permitted after the rest element");
            var he = Z ? A.parenthesizedAssign : A.parenthesizedBind;
            he > -1 && this.raiseRecoverable(he, Z ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, rt.checkExpressionErrors = function(A, Z) {
          if (!A) return !1;
          var he = A.shorthandAssign, ve = A.doubleProto;
          if (!Z) return he >= 0 || ve >= 0;
          he >= 0 && this.raise(he, "Shorthand property assignments are valid only in destructuring patterns"), ve >= 0 && this.raiseRecoverable(ve, "Redefinition of __proto__ property");
        }, rt.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, rt.isSimpleAssignTarget = function(A) {
          return A.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(A.expression) : A.type === "Identifier" || A.type === "MemberExpression";
        };
        var Je = it.prototype;
        Je.parseTopLevel = function(A) {
          var Z = /* @__PURE__ */ Object.create(null);
          for (A.body || (A.body = []); this.type !== se.eof; ) {
            var he = this.parseStatement(null, !0, Z);
            A.body.push(he);
          }
          if (this.inModule) for (var ve = 0, ke = Object.keys(this.undefinedExports); ve < ke.length; ve += 1) {
            var Le = ke[ve];
            this.raiseRecoverable(this.undefinedExports[Le].start, "Export '" + Le + "' is not defined");
          }
          return this.adaptDirectivePrologue(A.body), this.next(), A.sourceType = this.options.sourceType, this.finishNode(A, "Program");
        };
        var mt = { kind: "loop" }, ut = { kind: "switch" };
        Je.isLet = function(A) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
          ue.lastIndex = this.pos;
          var Z = ue.exec(this.input), he = this.pos + Z[0].length, ve = this.input.charCodeAt(he);
          if (ve === 91 || ve === 92) return !0;
          if (A) return !1;
          if (ve === 123 || ve > 55295 && ve < 56320) return !0;
          if (ce(ve, !0)) {
            for (var ke = he + 1; ee(ve = this.input.charCodeAt(ke), !0); ) ++ke;
            if (ve === 92 || ve > 55295 && ve < 56320) return !0;
            var Le = this.input.slice(he, ke);
            if (!ie.test(Le)) return !0;
          }
          return !1;
        }, Je.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
          ue.lastIndex = this.pos;
          var A, Z = ue.exec(this.input), he = this.pos + Z[0].length;
          return !(be.test(this.input.slice(this.pos, he)) || this.input.slice(he, he + 8) !== "function" || he + 8 !== this.input.length && (ee(A = this.input.charCodeAt(he + 8)) || A > 55295 && A < 56320));
        }, Je.parseStatement = function(A, Z, he) {
          var ve, ke = this.type, Le = this.startNode();
          switch (this.isLet(A) && (ke = se._var, ve = "let"), ke) {
            case se._break:
            case se._continue:
              return this.parseBreakContinueStatement(Le, ke.keyword);
            case se._debugger:
              return this.parseDebuggerStatement(Le);
            case se._do:
              return this.parseDoStatement(Le);
            case se._for:
              return this.parseForStatement(Le);
            case se._function:
              return A && (this.strict || A !== "if" && A !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(Le, !1, !A);
            case se._class:
              return A && this.unexpected(), this.parseClass(Le, !0);
            case se._if:
              return this.parseIfStatement(Le);
            case se._return:
              return this.parseReturnStatement(Le);
            case se._switch:
              return this.parseSwitchStatement(Le);
            case se._throw:
              return this.parseThrowStatement(Le);
            case se._try:
              return this.parseTryStatement(Le);
            case se._const:
            case se._var:
              return ve = ve || this.value, A && ve !== "var" && this.unexpected(), this.parseVarStatement(Le, ve);
            case se._while:
              return this.parseWhileStatement(Le);
            case se._with:
              return this.parseWithStatement(Le);
            case se.braceL:
              return this.parseBlock(!0, Le);
            case se.semi:
              return this.parseEmptyStatement(Le);
            case se._export:
            case se._import:
              if (this.options.ecmaVersion > 10 && ke === se._import) {
                ue.lastIndex = this.pos;
                var je = ue.exec(this.input), Ge = this.pos + je[0].length, lt = this.input.charCodeAt(Ge);
                if (lt === 40 || lt === 46) return this.parseExpressionStatement(Le, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || (Z || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), ke === se._import ? this.parseImport(Le) : this.parseExport(Le, he);
            default:
              if (this.isAsyncFunction()) return A && this.unexpected(), this.next(), this.parseFunctionStatement(Le, !0, !A);
              var gt = this.value, ot = this.parseExpression();
              return ke === se.name && ot.type === "Identifier" && this.eat(se.colon) ? this.parseLabeledStatement(Le, gt, ot, A) : this.parseExpressionStatement(Le, ot);
          }
        }, Je.parseBreakContinueStatement = function(A, Z) {
          var he = Z === "break";
          this.next(), this.eat(se.semi) || this.insertSemicolon() ? A.label = null : this.type !== se.name ? this.unexpected() : (A.label = this.parseIdent(), this.semicolon());
          for (var ve = 0; ve < this.labels.length; ++ve) {
            var ke = this.labels[ve];
            if ((A.label == null || ke.name === A.label.name) && (ke.kind != null && (he || ke.kind === "loop") || A.label && he))
              break;
          }
          return ve === this.labels.length && this.raise(A.start, "Unsyntactic " + Z), this.finishNode(A, he ? "BreakStatement" : "ContinueStatement");
        }, Je.parseDebuggerStatement = function(A) {
          return this.next(), this.semicolon(), this.finishNode(A, "DebuggerStatement");
        }, Je.parseDoStatement = function(A) {
          return this.next(), this.labels.push(mt), A.body = this.parseStatement("do"), this.labels.pop(), this.expect(se._while), A.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(se.semi) : this.semicolon(), this.finishNode(A, "DoWhileStatement");
        }, Je.parseForStatement = function(A) {
          this.next();
          var Z = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(mt), this.enterScope(0), this.expect(se.parenL), this.type === se.semi) return Z > -1 && this.unexpected(Z), this.parseFor(A, null);
          var he = this.isLet();
          if (this.type === se._var || this.type === se._const || he) {
            var ve = this.startNode(), ke = he ? "let" : this.value;
            return this.next(), this.parseVar(ve, !0, ke), this.finishNode(ve, "VariableDeclaration"), (this.type === se._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && ve.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === se._in ? Z > -1 && this.unexpected(Z) : A.await = Z > -1), this.parseForIn(A, ve)) : (Z > -1 && this.unexpected(Z), this.parseFor(A, ve));
          }
          var Le = this.isContextual("let"), je = !1, Ge = new dt(), lt = this.parseExpression(!(Z > -1) || "await", Ge);
          return this.type === se._in || (je = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === se._in ? Z > -1 && this.unexpected(Z) : A.await = Z > -1), Le && je && this.raise(lt.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(lt, !1, Ge), this.checkLValPattern(lt), this.parseForIn(A, lt)) : (this.checkExpressionErrors(Ge, !0), Z > -1 && this.unexpected(Z), this.parseFor(A, lt));
        }, Je.parseFunctionStatement = function(A, Z, he) {
          return this.next(), this.parseFunction(A, Tt | (he ? 0 : St), !1, Z);
        }, Je.parseIfStatement = function(A) {
          return this.next(), A.test = this.parseParenExpression(), A.consequent = this.parseStatement("if"), A.alternate = this.eat(se._else) ? this.parseStatement("if") : null, this.finishNode(A, "IfStatement");
        }, Je.parseReturnStatement = function(A) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(se.semi) || this.insertSemicolon() ? A.argument = null : (A.argument = this.parseExpression(), this.semicolon()), this.finishNode(A, "ReturnStatement");
        }, Je.parseSwitchStatement = function(A) {
          var Z;
          this.next(), A.discriminant = this.parseParenExpression(), A.cases = [], this.expect(se.braceL), this.labels.push(ut), this.enterScope(0);
          for (var he = !1; this.type !== se.braceR; ) if (this.type === se._case || this.type === se._default) {
            var ve = this.type === se._case;
            Z && this.finishNode(Z, "SwitchCase"), A.cases.push(Z = this.startNode()), Z.consequent = [], this.next(), ve ? Z.test = this.parseExpression() : (he && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), he = !0, Z.test = null), this.expect(se.colon);
          } else Z || this.unexpected(), Z.consequent.push(this.parseStatement(null));
          return this.exitScope(), Z && this.finishNode(Z, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(A, "SwitchStatement");
        }, Je.parseThrowStatement = function(A) {
          return this.next(), be.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), A.argument = this.parseExpression(), this.semicolon(), this.finishNode(A, "ThrowStatement");
        };
        var Et = [];
        Je.parseCatchClauseParam = function() {
          var A = this.parseBindingAtom(), Z = A.type === "Identifier";
          return this.enterScope(Z ? 32 : 0), this.checkLValPattern(A, Z ? 4 : 2), this.expect(se.parenR), A;
        }, Je.parseTryStatement = function(A) {
          if (this.next(), A.block = this.parseBlock(), A.handler = null, this.type === se._catch) {
            var Z = this.startNode();
            this.next(), this.eat(se.parenL) ? Z.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), Z.param = null, this.enterScope(0)), Z.body = this.parseBlock(!1), this.exitScope(), A.handler = this.finishNode(Z, "CatchClause");
          }
          return A.finalizer = this.eat(se._finally) ? this.parseBlock() : null, A.handler || A.finalizer || this.raise(A.start, "Missing catch or finally clause"), this.finishNode(A, "TryStatement");
        }, Je.parseVarStatement = function(A, Z, he) {
          return this.next(), this.parseVar(A, !1, Z, he), this.semicolon(), this.finishNode(A, "VariableDeclaration");
        }, Je.parseWhileStatement = function(A) {
          return this.next(), A.test = this.parseParenExpression(), this.labels.push(mt), A.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(A, "WhileStatement");
        }, Je.parseWithStatement = function(A) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), A.object = this.parseParenExpression(), A.body = this.parseStatement("with"), this.finishNode(A, "WithStatement");
        }, Je.parseEmptyStatement = function(A) {
          return this.next(), this.finishNode(A, "EmptyStatement");
        }, Je.parseLabeledStatement = function(A, Z, he, ve) {
          for (var ke = 0, Le = this.labels; ke < Le.length; ke += 1)
            Le[ke].name === Z && this.raise(he.start, "Label '" + Z + "' is already declared");
          for (var je = this.type.isLoop ? "loop" : this.type === se._switch ? "switch" : null, Ge = this.labels.length - 1; Ge >= 0; Ge--) {
            var lt = this.labels[Ge];
            if (lt.statementStart !== A.start) break;
            lt.statementStart = this.start, lt.kind = je;
          }
          return this.labels.push({ name: Z, kind: je, statementStart: this.start }), A.body = this.parseStatement(ve ? ve.indexOf("label") === -1 ? ve + "label" : ve : "label"), this.labels.pop(), A.label = he, this.finishNode(A, "LabeledStatement");
        }, Je.parseExpressionStatement = function(A, Z) {
          return A.expression = Z, this.semicolon(), this.finishNode(A, "ExpressionStatement");
        }, Je.parseBlock = function(A, Z, he) {
          for (A === void 0 && (A = !0), Z === void 0 && (Z = this.startNode()), Z.body = [], this.expect(se.braceL), A && this.enterScope(0); this.type !== se.braceR; ) {
            var ve = this.parseStatement(null);
            Z.body.push(ve);
          }
          return he && (this.strict = !1), this.next(), A && this.exitScope(), this.finishNode(Z, "BlockStatement");
        }, Je.parseFor = function(A, Z) {
          return A.init = Z, this.expect(se.semi), A.test = this.type === se.semi ? null : this.parseExpression(), this.expect(se.semi), A.update = this.type === se.parenR ? null : this.parseExpression(), this.expect(se.parenR), A.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(A, "ForStatement");
        }, Je.parseForIn = function(A, Z) {
          var he = this.type === se._in;
          return this.next(), Z.type === "VariableDeclaration" && Z.declarations[0].init != null && (!he || this.options.ecmaVersion < 8 || this.strict || Z.kind !== "var" || Z.declarations[0].id.type !== "Identifier") && this.raise(Z.start, (he ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), A.left = Z, A.right = he ? this.parseExpression() : this.parseMaybeAssign(), this.expect(se.parenR), A.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(A, he ? "ForInStatement" : "ForOfStatement");
        }, Je.parseVar = function(A, Z, he, ve) {
          for (A.declarations = [], A.kind = he; ; ) {
            var ke = this.startNode();
            if (this.parseVarId(ke, he), this.eat(se.eq) ? ke.init = this.parseMaybeAssign(Z) : ve || he !== "const" || this.type === se._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? ve || ke.id.type === "Identifier" || Z && (this.type === se._in || this.isContextual("of")) ? ke.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), A.declarations.push(this.finishNode(ke, "VariableDeclarator")), !this.eat(se.comma)) break;
          }
          return A;
        }, Je.parseVarId = function(A, Z) {
          A.id = this.parseBindingAtom(), this.checkLValPattern(A.id, Z === "var" ? 1 : 2, !1);
        };
        var Tt = 1, St = 2;
        function Vt(A, Z) {
          var he = Z.key.name, ve = A[he], ke = "true";
          return Z.type !== "MethodDefinition" || Z.kind !== "get" && Z.kind !== "set" || (ke = (Z.static ? "s" : "i") + Z.kind), ve === "iget" && ke === "iset" || ve === "iset" && ke === "iget" || ve === "sget" && ke === "sset" || ve === "sset" && ke === "sget" ? (A[he] = "true", !1) : !!ve || (A[he] = ke, !1);
        }
        function Kt(A, Z) {
          var he = A.computed, ve = A.key;
          return !he && (ve.type === "Identifier" && ve.name === Z || ve.type === "Literal" && ve.value === Z);
        }
        Je.parseFunction = function(A, Z, he, ve, ke) {
          this.initFunction(A), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !ve) && (this.type === se.star && Z & St && this.unexpected(), A.generator = this.eat(se.star)), this.options.ecmaVersion >= 8 && (A.async = !!ve), Z & Tt && (A.id = 4 & Z && this.type !== se.name ? null : this.parseIdent(), !A.id || Z & St || this.checkLValSimple(A.id, this.strict || A.generator || A.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var Le = this.yieldPos, je = this.awaitPos, Ge = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(st(A.async, A.generator)), Z & Tt || (A.id = this.type === se.name ? this.parseIdent() : null), this.parseFunctionParams(A), this.parseFunctionBody(A, he, !1, ke), this.yieldPos = Le, this.awaitPos = je, this.awaitIdentPos = Ge, this.finishNode(A, Z & Tt ? "FunctionDeclaration" : "FunctionExpression");
        }, Je.parseFunctionParams = function(A) {
          this.expect(se.parenL), A.params = this.parseBindingList(se.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, Je.parseClass = function(A, Z) {
          this.next();
          var he = this.strict;
          this.strict = !0, this.parseClassId(A, Z), this.parseClassSuper(A);
          var ve = this.enterClassBody(), ke = this.startNode(), Le = !1;
          for (ke.body = [], this.expect(se.braceL); this.type !== se.braceR; ) {
            var je = this.parseClassElement(A.superClass !== null);
            je && (ke.body.push(je), je.type === "MethodDefinition" && je.kind === "constructor" ? (Le && this.raiseRecoverable(je.start, "Duplicate constructor in the same class"), Le = !0) : je.key && je.key.type === "PrivateIdentifier" && Vt(ve, je) && this.raiseRecoverable(je.key.start, "Identifier '#" + je.key.name + "' has already been declared"));
          }
          return this.strict = he, this.next(), A.body = this.finishNode(ke, "ClassBody"), this.exitClassBody(), this.finishNode(A, Z ? "ClassDeclaration" : "ClassExpression");
        }, Je.parseClassElement = function(A) {
          if (this.eat(se.semi)) return null;
          var Z = this.options.ecmaVersion, he = this.startNode(), ve = "", ke = !1, Le = !1, je = "method", Ge = !1;
          if (this.eatContextual("static")) {
            if (Z >= 13 && this.eat(se.braceL)) return this.parseClassStaticBlock(he), he;
            this.isClassElementNameStart() || this.type === se.star ? Ge = !0 : ve = "static";
          }
          if (he.static = Ge, !ve && Z >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== se.star || this.canInsertSemicolon() ? ve = "async" : Le = !0), !ve && (Z >= 9 || !Le) && this.eat(se.star) && (ke = !0), !ve && !Le && !ke) {
            var lt = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? je = lt : ve = lt);
          }
          if (ve ? (he.computed = !1, he.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), he.key.name = ve, this.finishNode(he.key, "Identifier")) : this.parseClassElementName(he), Z < 13 || this.type === se.parenL || je !== "method" || ke || Le) {
            var gt = !he.static && Kt(he, "constructor"), ot = gt && A;
            gt && je !== "method" && this.raise(he.key.start, "Constructor can't have get/set modifier"), he.kind = gt ? "constructor" : je, this.parseClassMethod(he, ke, Le, ot);
          } else this.parseClassField(he);
          return he;
        }, Je.isClassElementNameStart = function() {
          return this.type === se.name || this.type === se.privateId || this.type === se.num || this.type === se.string || this.type === se.bracketL || this.type.keyword;
        }, Je.parseClassElementName = function(A) {
          this.type === se.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), A.computed = !1, A.key = this.parsePrivateIdent()) : this.parsePropertyName(A);
        }, Je.parseClassMethod = function(A, Z, he, ve) {
          var ke = A.key;
          A.kind === "constructor" ? (Z && this.raise(ke.start, "Constructor can't be a generator"), he && this.raise(ke.start, "Constructor can't be an async method")) : A.static && Kt(A, "prototype") && this.raise(ke.start, "Classes may not have a static property named prototype");
          var Le = A.value = this.parseMethod(Z, he, ve);
          return A.kind === "get" && Le.params.length !== 0 && this.raiseRecoverable(Le.start, "getter should have no params"), A.kind === "set" && Le.params.length !== 1 && this.raiseRecoverable(Le.start, "setter should have exactly one param"), A.kind === "set" && Le.params[0].type === "RestElement" && this.raiseRecoverable(Le.params[0].start, "Setter cannot use rest params"), this.finishNode(A, "MethodDefinition");
        }, Je.parseClassField = function(A) {
          if (Kt(A, "constructor") ? this.raise(A.key.start, "Classes can't have a field named 'constructor'") : A.static && Kt(A, "prototype") && this.raise(A.key.start, "Classes can't have a static field named 'prototype'"), this.eat(se.eq)) {
            var Z = this.currentThisScope(), he = Z.inClassFieldInit;
            Z.inClassFieldInit = !0, A.value = this.parseMaybeAssign(), Z.inClassFieldInit = he;
          } else A.value = null;
          return this.semicolon(), this.finishNode(A, "PropertyDefinition");
        }, Je.parseClassStaticBlock = function(A) {
          A.body = [];
          var Z = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== se.braceR; ) {
            var he = this.parseStatement(null);
            A.body.push(he);
          }
          return this.next(), this.exitScope(), this.labels = Z, this.finishNode(A, "StaticBlock");
        }, Je.parseClassId = function(A, Z) {
          this.type === se.name ? (A.id = this.parseIdent(), Z && this.checkLValSimple(A.id, 2, !1)) : (Z === !0 && this.unexpected(), A.id = null);
        }, Je.parseClassSuper = function(A) {
          A.superClass = this.eat(se._extends) ? this.parseExprSubscripts(null, !1) : null;
        }, Je.enterClassBody = function() {
          var A = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(A), A.declared;
        }, Je.exitClassBody = function() {
          var A = this.privateNameStack.pop(), Z = A.declared, he = A.used;
          if (this.options.checkPrivateFields) for (var ve = this.privateNameStack.length, ke = ve === 0 ? null : this.privateNameStack[ve - 1], Le = 0; Le < he.length; ++Le) {
            var je = he[Le];
            Ee(Z, je.name) || (ke ? ke.used.push(je) : this.raiseRecoverable(je.start, "Private field '#" + je.name + "' must be declared in an enclosing class"));
          }
        }, Je.parseExportAllDeclaration = function(A, Z) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (A.exported = this.parseModuleExportName(), this.checkExport(Z, A.exported, this.lastTokStart)) : A.exported = null), this.expectContextual("from"), this.type !== se.string && this.unexpected(), A.source = this.parseExprAtom(), this.semicolon(), this.finishNode(A, "ExportAllDeclaration");
        }, Je.parseExport = function(A, Z) {
          if (this.next(), this.eat(se.star)) return this.parseExportAllDeclaration(A, Z);
          if (this.eat(se._default)) return this.checkExport(Z, "default", this.lastTokStart), A.declaration = this.parseExportDefaultDeclaration(), this.finishNode(A, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement()) A.declaration = this.parseExportDeclaration(A), A.declaration.type === "VariableDeclaration" ? this.checkVariableExport(Z, A.declaration.declarations) : this.checkExport(Z, A.declaration.id, A.declaration.id.start), A.specifiers = [], A.source = null;
          else {
            if (A.declaration = null, A.specifiers = this.parseExportSpecifiers(Z), this.eatContextual("from")) this.type !== se.string && this.unexpected(), A.source = this.parseExprAtom();
            else {
              for (var he = 0, ve = A.specifiers; he < ve.length; he += 1) {
                var ke = ve[he];
                this.checkUnreserved(ke.local), this.checkLocalExport(ke.local), ke.local.type === "Literal" && this.raise(ke.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              A.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(A, "ExportNamedDeclaration");
        }, Je.parseExportDeclaration = function(A) {
          return this.parseStatement(null);
        }, Je.parseExportDefaultDeclaration = function() {
          var A;
          if (this.type === se._function || (A = this.isAsyncFunction())) {
            var Z = this.startNode();
            return this.next(), A && this.next(), this.parseFunction(Z, 4 | Tt, !1, A);
          }
          if (this.type === se._class) {
            var he = this.startNode();
            return this.parseClass(he, "nullableID");
          }
          var ve = this.parseMaybeAssign();
          return this.semicolon(), ve;
        }, Je.checkExport = function(A, Z, he) {
          A && (typeof Z != "string" && (Z = Z.type === "Identifier" ? Z.name : Z.value), Ee(A, Z) && this.raiseRecoverable(he, "Duplicate export '" + Z + "'"), A[Z] = !0);
        }, Je.checkPatternExport = function(A, Z) {
          var he = Z.type;
          if (he === "Identifier") this.checkExport(A, Z, Z.start);
          else if (he === "ObjectPattern") for (var ve = 0, ke = Z.properties; ve < ke.length; ve += 1) {
            var Le = ke[ve];
            this.checkPatternExport(A, Le);
          }
          else if (he === "ArrayPattern") for (var je = 0, Ge = Z.elements; je < Ge.length; je += 1) {
            var lt = Ge[je];
            lt && this.checkPatternExport(A, lt);
          }
          else he === "Property" ? this.checkPatternExport(A, Z.value) : he === "AssignmentPattern" ? this.checkPatternExport(A, Z.left) : he === "RestElement" && this.checkPatternExport(A, Z.argument);
        }, Je.checkVariableExport = function(A, Z) {
          if (A) for (var he = 0, ve = Z; he < ve.length; he += 1) {
            var ke = ve[he];
            this.checkPatternExport(A, ke.id);
          }
        }, Je.shouldParseExportStatement = function() {
          return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
        }, Je.parseExportSpecifier = function(A) {
          var Z = this.startNode();
          return Z.local = this.parseModuleExportName(), Z.exported = this.eatContextual("as") ? this.parseModuleExportName() : Z.local, this.checkExport(A, Z.exported, Z.exported.start), this.finishNode(Z, "ExportSpecifier");
        }, Je.parseExportSpecifiers = function(A) {
          var Z = [], he = !0;
          for (this.expect(se.braceL); !this.eat(se.braceR); ) {
            if (he) he = !1;
            else if (this.expect(se.comma), this.afterTrailingComma(se.braceR)) break;
            Z.push(this.parseExportSpecifier(A));
          }
          return Z;
        }, Je.parseImport = function(A) {
          return this.next(), this.type === se.string ? (A.specifiers = Et, A.source = this.parseExprAtom()) : (A.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), A.source = this.type === se.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(A, "ImportDeclaration");
        }, Je.parseImportSpecifier = function() {
          var A = this.startNode();
          return A.imported = this.parseModuleExportName(), this.eatContextual("as") ? A.local = this.parseIdent() : (this.checkUnreserved(A.imported), A.local = A.imported), this.checkLValSimple(A.local, 2), this.finishNode(A, "ImportSpecifier");
        }, Je.parseImportDefaultSpecifier = function() {
          var A = this.startNode();
          return A.local = this.parseIdent(), this.checkLValSimple(A.local, 2), this.finishNode(A, "ImportDefaultSpecifier");
        }, Je.parseImportNamespaceSpecifier = function() {
          var A = this.startNode();
          return this.next(), this.expectContextual("as"), A.local = this.parseIdent(), this.checkLValSimple(A.local, 2), this.finishNode(A, "ImportNamespaceSpecifier");
        }, Je.parseImportSpecifiers = function() {
          var A = [], Z = !0;
          if (this.type === se.name && (A.push(this.parseImportDefaultSpecifier()), !this.eat(se.comma))) return A;
          if (this.type === se.star) return A.push(this.parseImportNamespaceSpecifier()), A;
          for (this.expect(se.braceL); !this.eat(se.braceR); ) {
            if (Z) Z = !1;
            else if (this.expect(se.comma), this.afterTrailingComma(se.braceR)) break;
            A.push(this.parseImportSpecifier());
          }
          return A;
        }, Je.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === se.string) {
            var A = this.parseLiteral(this.value);
            return Ye.test(A.value) && this.raise(A.start, "An export name cannot include a lone surrogate."), A;
          }
          return this.parseIdent(!0);
        }, Je.adaptDirectivePrologue = function(A) {
          for (var Z = 0; Z < A.length && this.isDirectiveCandidate(A[Z]); ++Z) A[Z].directive = A[Z].expression.raw.slice(1, -1);
        }, Je.isDirectiveCandidate = function(A) {
          return this.options.ecmaVersion >= 5 && A.type === "ExpressionStatement" && A.expression.type === "Literal" && typeof A.expression.value == "string" && (this.input[A.start] === '"' || this.input[A.start] === "'");
        };
        var xt = it.prototype;
        xt.toAssignable = function(A, Z, he) {
          if (this.options.ecmaVersion >= 6 && A) switch (A.type) {
            case "Identifier":
              this.inAsync && A.name === "await" && this.raise(A.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              A.type = "ObjectPattern", he && this.checkPatternErrors(he, !0);
              for (var ve = 0, ke = A.properties; ve < ke.length; ve += 1) {
                var Le = ke[ve];
                this.toAssignable(Le, Z), Le.type !== "RestElement" || Le.argument.type !== "ArrayPattern" && Le.argument.type !== "ObjectPattern" || this.raise(Le.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              A.kind !== "init" && this.raise(A.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(A.value, Z);
              break;
            case "ArrayExpression":
              A.type = "ArrayPattern", he && this.checkPatternErrors(he, !0), this.toAssignableList(A.elements, Z);
              break;
            case "SpreadElement":
              A.type = "RestElement", this.toAssignable(A.argument, Z), A.argument.type === "AssignmentPattern" && this.raise(A.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              A.operator !== "=" && this.raise(A.left.end, "Only '=' operator can be used for specifying default value."), A.type = "AssignmentPattern", delete A.operator, this.toAssignable(A.left, Z);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(A.expression, Z, he);
              break;
            case "ChainExpression":
              this.raiseRecoverable(A.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!Z) break;
            default:
              this.raise(A.start, "Assigning to rvalue");
          }
          else he && this.checkPatternErrors(he, !0);
          return A;
        }, xt.toAssignableList = function(A, Z) {
          for (var he = A.length, ve = 0; ve < he; ve++) {
            var ke = A[ve];
            ke && this.toAssignable(ke, Z);
          }
          if (he) {
            var Le = A[he - 1];
            this.options.ecmaVersion === 6 && Z && Le && Le.type === "RestElement" && Le.argument.type !== "Identifier" && this.unexpected(Le.argument.start);
          }
          return A;
        }, xt.parseSpread = function(A) {
          var Z = this.startNode();
          return this.next(), Z.argument = this.parseMaybeAssign(!1, A), this.finishNode(Z, "SpreadElement");
        }, xt.parseRestBinding = function() {
          var A = this.startNode();
          return this.next(), this.options.ecmaVersion === 6 && this.type !== se.name && this.unexpected(), A.argument = this.parseBindingAtom(), this.finishNode(A, "RestElement");
        }, xt.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) switch (this.type) {
            case se.bracketL:
              var A = this.startNode();
              return this.next(), A.elements = this.parseBindingList(se.bracketR, !0, !0), this.finishNode(A, "ArrayPattern");
            case se.braceL:
              return this.parseObj(!0);
          }
          return this.parseIdent();
        }, xt.parseBindingList = function(A, Z, he, ve) {
          for (var ke = [], Le = !0; !this.eat(A); ) if (Le ? Le = !1 : this.expect(se.comma), Z && this.type === se.comma) ke.push(null);
          else {
            if (he && this.afterTrailingComma(A)) break;
            if (this.type === se.ellipsis) {
              var je = this.parseRestBinding();
              this.parseBindingListItem(je), ke.push(je), this.type === se.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(A);
              break;
            }
            ke.push(this.parseAssignableListItem(ve));
          }
          return ke;
        }, xt.parseAssignableListItem = function(A) {
          var Z = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(Z), Z;
        }, xt.parseBindingListItem = function(A) {
          return A;
        }, xt.parseMaybeDefault = function(A, Z, he) {
          if (he = he || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(se.eq)) return he;
          var ve = this.startNodeAt(A, Z);
          return ve.left = he, ve.right = this.parseMaybeAssign(), this.finishNode(ve, "AssignmentPattern");
        }, xt.checkLValSimple = function(A, Z, he) {
          Z === void 0 && (Z = 0);
          var ve = Z !== 0;
          switch (A.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(A.name) && this.raiseRecoverable(A.start, (ve ? "Binding " : "Assigning to ") + A.name + " in strict mode"), ve && (Z === 2 && A.name === "let" && this.raiseRecoverable(A.start, "let is disallowed as a lexically bound name"), he && (Ee(he, A.name) && this.raiseRecoverable(A.start, "Argument name clash"), he[A.name] = !0), Z !== 5 && this.declareName(A.name, Z, A.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(A.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              ve && this.raiseRecoverable(A.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return ve && this.raiseRecoverable(A.start, "Binding parenthesized expression"), this.checkLValSimple(A.expression, Z, he);
            default:
              this.raise(A.start, (ve ? "Binding" : "Assigning to") + " rvalue");
          }
        }, xt.checkLValPattern = function(A, Z, he) {
          switch (Z === void 0 && (Z = 0), A.type) {
            case "ObjectPattern":
              for (var ve = 0, ke = A.properties; ve < ke.length; ve += 1) {
                var Le = ke[ve];
                this.checkLValInnerPattern(Le, Z, he);
              }
              break;
            case "ArrayPattern":
              for (var je = 0, Ge = A.elements; je < Ge.length; je += 1) {
                var lt = Ge[je];
                lt && this.checkLValInnerPattern(lt, Z, he);
              }
              break;
            default:
              this.checkLValSimple(A, Z, he);
          }
        }, xt.checkLValInnerPattern = function(A, Z, he) {
          switch (Z === void 0 && (Z = 0), A.type) {
            case "Property":
              this.checkLValInnerPattern(A.value, Z, he);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(A.left, Z, he);
              break;
            case "RestElement":
              this.checkLValPattern(A.argument, Z, he);
              break;
            default:
              this.checkLValPattern(A, Z, he);
          }
        };
        var Jt = function(A, Z, he, ve, ke) {
          this.token = A, this.isExpr = !!Z, this.preserveSpace = !!he, this.override = ve, this.generator = !!ke;
        }, Mt = { b_stat: new Jt("{", !1), b_expr: new Jt("{", !0), b_tmpl: new Jt("${", !1), p_stat: new Jt("(", !1), p_expr: new Jt("(", !0), q_tmpl: new Jt("`", !0, !0, function(A) {
          return A.tryReadTemplateToken();
        }), f_stat: new Jt("function", !1), f_expr: new Jt("function", !0), f_expr_gen: new Jt("function", !0, !1, null, !0), f_gen: new Jt("function", !1, !1, null, !0) }, Bt = it.prototype;
        Bt.initialContext = function() {
          return [Mt.b_stat];
        }, Bt.curContext = function() {
          return this.context[this.context.length - 1];
        }, Bt.braceIsBlock = function(A) {
          var Z = this.curContext();
          return Z === Mt.f_expr || Z === Mt.f_stat || (A !== se.colon || Z !== Mt.b_stat && Z !== Mt.b_expr ? A === se._return || A === se.name && this.exprAllowed ? be.test(this.input.slice(this.lastTokEnd, this.start)) : A === se._else || A === se.semi || A === se.eof || A === se.parenR || A === se.arrow || (A === se.braceL ? Z === Mt.b_stat : A !== se._var && A !== se._const && A !== se.name && !this.exprAllowed) : !Z.isExpr);
        }, Bt.inGeneratorContext = function() {
          for (var A = this.context.length - 1; A >= 1; A--) {
            var Z = this.context[A];
            if (Z.token === "function") return Z.generator;
          }
          return !1;
        }, Bt.updateContext = function(A) {
          var Z, he = this.type;
          he.keyword && A === se.dot ? this.exprAllowed = !1 : (Z = he.updateContext) ? Z.call(this, A) : this.exprAllowed = he.beforeExpr;
        }, Bt.overrideContext = function(A) {
          this.curContext() !== A && (this.context[this.context.length - 1] = A);
        }, se.parenR.updateContext = se.braceR.updateContext = function() {
          if (this.context.length !== 1) {
            var A = this.context.pop();
            A === Mt.b_stat && this.curContext().token === "function" && (A = this.context.pop()), this.exprAllowed = !A.isExpr;
          } else this.exprAllowed = !0;
        }, se.braceL.updateContext = function(A) {
          this.context.push(this.braceIsBlock(A) ? Mt.b_stat : Mt.b_expr), this.exprAllowed = !0;
        }, se.dollarBraceL.updateContext = function() {
          this.context.push(Mt.b_tmpl), this.exprAllowed = !0;
        }, se.parenL.updateContext = function(A) {
          var Z = A === se._if || A === se._for || A === se._with || A === se._while;
          this.context.push(Z ? Mt.p_stat : Mt.p_expr), this.exprAllowed = !0;
        }, se.incDec.updateContext = function() {
        }, se._function.updateContext = se._class.updateContext = function(A) {
          !A.beforeExpr || A === se._else || A === se.semi && this.curContext() !== Mt.p_stat || A === se._return && be.test(this.input.slice(this.lastTokEnd, this.start)) || (A === se.colon || A === se.braceL) && this.curContext() === Mt.b_stat ? this.context.push(Mt.f_stat) : this.context.push(Mt.f_expr), this.exprAllowed = !1;
        }, se.colon.updateContext = function() {
          this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
        }, se.backQuote.updateContext = function() {
          this.curContext() === Mt.q_tmpl ? this.context.pop() : this.context.push(Mt.q_tmpl), this.exprAllowed = !1;
        }, se.star.updateContext = function(A) {
          if (A === se._function) {
            var Z = this.context.length - 1;
            this.context[Z] === Mt.f_expr ? this.context[Z] = Mt.f_expr_gen : this.context[Z] = Mt.f_gen;
          }
          this.exprAllowed = !0;
        }, se.name.updateContext = function(A) {
          var Z = !1;
          this.options.ecmaVersion >= 6 && A !== se.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (Z = !0), this.exprAllowed = Z;
        };
        var It = it.prototype;
        function jr(A) {
          return A.type === "MemberExpression" && A.property.type === "PrivateIdentifier" || A.type === "ChainExpression" && jr(A.expression);
        }
        It.checkPropClash = function(A, Z, he) {
          if (!(this.options.ecmaVersion >= 9 && A.type === "SpreadElement" || this.options.ecmaVersion >= 6 && (A.computed || A.method || A.shorthand))) {
            var ve, ke = A.key;
            switch (ke.type) {
              case "Identifier":
                ve = ke.name;
                break;
              case "Literal":
                ve = String(ke.value);
                break;
              default:
                return;
            }
            var Le = A.kind;
            if (this.options.ecmaVersion >= 6) ve === "__proto__" && Le === "init" && (Z.proto && (he ? he.doubleProto < 0 && (he.doubleProto = ke.start) : this.raiseRecoverable(ke.start, "Redefinition of __proto__ property")), Z.proto = !0);
            else {
              var je = Z[ve = "$" + ve];
              je ? (Le === "init" ? this.strict && je.init || je.get || je.set : je.init || je[Le]) && this.raiseRecoverable(ke.start, "Redefinition of property") : je = Z[ve] = { init: !1, get: !1, set: !1 }, je[Le] = !0;
            }
          }
        }, It.parseExpression = function(A, Z) {
          var he = this.start, ve = this.startLoc, ke = this.parseMaybeAssign(A, Z);
          if (this.type === se.comma) {
            var Le = this.startNodeAt(he, ve);
            for (Le.expressions = [ke]; this.eat(se.comma); ) Le.expressions.push(this.parseMaybeAssign(A, Z));
            return this.finishNode(Le, "SequenceExpression");
          }
          return ke;
        }, It.parseMaybeAssign = function(A, Z, he) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(A);
            this.exprAllowed = !1;
          }
          var ve = !1, ke = -1, Le = -1, je = -1;
          Z ? (ke = Z.parenthesizedAssign, Le = Z.trailingComma, je = Z.doubleProto, Z.parenthesizedAssign = Z.trailingComma = -1) : (Z = new dt(), ve = !0);
          var Ge = this.start, lt = this.startLoc;
          this.type !== se.parenL && this.type !== se.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = A === "await");
          var gt = this.parseMaybeConditional(A, Z);
          if (he && (gt = he.call(this, gt, Ge, lt)), this.type.isAssign) {
            var ot = this.startNodeAt(Ge, lt);
            return ot.operator = this.value, this.type === se.eq && (gt = this.toAssignable(gt, !1, Z)), ve || (Z.parenthesizedAssign = Z.trailingComma = Z.doubleProto = -1), Z.shorthandAssign >= gt.start && (Z.shorthandAssign = -1), this.type === se.eq ? this.checkLValPattern(gt) : this.checkLValSimple(gt), ot.left = gt, this.next(), ot.right = this.parseMaybeAssign(A), je > -1 && (Z.doubleProto = je), this.finishNode(ot, "AssignmentExpression");
          }
          return ve && this.checkExpressionErrors(Z, !0), ke > -1 && (Z.parenthesizedAssign = ke), Le > -1 && (Z.trailingComma = Le), gt;
        }, It.parseMaybeConditional = function(A, Z) {
          var he = this.start, ve = this.startLoc, ke = this.parseExprOps(A, Z);
          if (this.checkExpressionErrors(Z)) return ke;
          if (this.eat(se.question)) {
            var Le = this.startNodeAt(he, ve);
            return Le.test = ke, Le.consequent = this.parseMaybeAssign(), this.expect(se.colon), Le.alternate = this.parseMaybeAssign(A), this.finishNode(Le, "ConditionalExpression");
          }
          return ke;
        }, It.parseExprOps = function(A, Z) {
          var he = this.start, ve = this.startLoc, ke = this.parseMaybeUnary(Z, !1, !1, A);
          return this.checkExpressionErrors(Z) || ke.start === he && ke.type === "ArrowFunctionExpression" ? ke : this.parseExprOp(ke, he, ve, -1, A);
        }, It.parseExprOp = function(A, Z, he, ve, ke) {
          var Le = this.type.binop;
          if (Le != null && (!ke || this.type !== se._in) && Le > ve) {
            var je = this.type === se.logicalOR || this.type === se.logicalAND, Ge = this.type === se.coalesce;
            Ge && (Le = se.logicalAND.binop);
            var lt = this.value;
            this.next();
            var gt = this.start, ot = this.startLoc, kt = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, ke), gt, ot, Le, ke), qt = this.buildBinary(Z, he, A, kt, lt, je || Ge);
            return (je && this.type === se.coalesce || Ge && (this.type === se.logicalOR || this.type === se.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(qt, Z, he, ve, ke);
          }
          return A;
        }, It.buildBinary = function(A, Z, he, ve, ke, Le) {
          ve.type === "PrivateIdentifier" && this.raise(ve.start, "Private identifier can only be left side of binary expression");
          var je = this.startNodeAt(A, Z);
          return je.left = he, je.operator = ke, je.right = ve, this.finishNode(je, Le ? "LogicalExpression" : "BinaryExpression");
        }, It.parseMaybeUnary = function(A, Z, he, ve) {
          var ke, Le = this.start, je = this.startLoc;
          if (this.isContextual("await") && this.canAwait) ke = this.parseAwait(ve), Z = !0;
          else if (this.type.prefix) {
            var Ge = this.startNode(), lt = this.type === se.incDec;
            Ge.operator = this.value, Ge.prefix = !0, this.next(), Ge.argument = this.parseMaybeUnary(null, !0, lt, ve), this.checkExpressionErrors(A, !0), lt ? this.checkLValSimple(Ge.argument) : this.strict && Ge.operator === "delete" && Ge.argument.type === "Identifier" ? this.raiseRecoverable(Ge.start, "Deleting local variable in strict mode") : Ge.operator === "delete" && jr(Ge.argument) ? this.raiseRecoverable(Ge.start, "Private fields can not be deleted") : Z = !0, ke = this.finishNode(Ge, lt ? "UpdateExpression" : "UnaryExpression");
          } else if (Z || this.type !== se.privateId) {
            if (ke = this.parseExprSubscripts(A, ve), this.checkExpressionErrors(A)) return ke;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var gt = this.startNodeAt(Le, je);
              gt.operator = this.value, gt.prefix = !1, gt.argument = ke, this.checkLValSimple(ke), this.next(), ke = this.finishNode(gt, "UpdateExpression");
            }
          } else (ve || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), ke = this.parsePrivateIdent(), this.type !== se._in && this.unexpected();
          return he || !this.eat(se.starstar) ? ke : Z ? void this.unexpected(this.lastTokStart) : this.buildBinary(Le, je, ke, this.parseMaybeUnary(null, !1, !1, ve), "**", !1);
        }, It.parseExprSubscripts = function(A, Z) {
          var he = this.start, ve = this.startLoc, ke = this.parseExprAtom(A, Z);
          if (ke.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return ke;
          var Le = this.parseSubscripts(ke, he, ve, !1, Z);
          return A && Le.type === "MemberExpression" && (A.parenthesizedAssign >= Le.start && (A.parenthesizedAssign = -1), A.parenthesizedBind >= Le.start && (A.parenthesizedBind = -1), A.trailingComma >= Le.start && (A.trailingComma = -1)), Le;
        }, It.parseSubscripts = function(A, Z, he, ve, ke) {
          for (var Le = this.options.ecmaVersion >= 8 && A.type === "Identifier" && A.name === "async" && this.lastTokEnd === A.end && !this.canInsertSemicolon() && A.end - A.start == 5 && this.potentialArrowAt === A.start, je = !1; ; ) {
            var Ge = this.parseSubscript(A, Z, he, ve, Le, je, ke);
            if (Ge.optional && (je = !0), Ge === A || Ge.type === "ArrowFunctionExpression") {
              if (je) {
                var lt = this.startNodeAt(Z, he);
                lt.expression = Ge, Ge = this.finishNode(lt, "ChainExpression");
              }
              return Ge;
            }
            A = Ge;
          }
        }, It.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(se.arrow);
        }, It.parseSubscriptAsyncArrow = function(A, Z, he, ve) {
          return this.parseArrowExpression(this.startNodeAt(A, Z), he, !0, ve);
        }, It.parseSubscript = function(A, Z, he, ve, ke, Le, je) {
          var Ge = this.options.ecmaVersion >= 11, lt = Ge && this.eat(se.questionDot);
          ve && lt && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var gt = this.eat(se.bracketL);
          if (gt || lt && this.type !== se.parenL && this.type !== se.backQuote || this.eat(se.dot)) {
            var ot = this.startNodeAt(Z, he);
            ot.object = A, gt ? (ot.property = this.parseExpression(), this.expect(se.bracketR)) : this.type === se.privateId && A.type !== "Super" ? ot.property = this.parsePrivateIdent() : ot.property = this.parseIdent(this.options.allowReserved !== "never"), ot.computed = !!gt, Ge && (ot.optional = lt), A = this.finishNode(ot, "MemberExpression");
          } else if (!ve && this.eat(se.parenL)) {
            var kt = new dt(), qt = this.yieldPos, hr = this.awaitPos, Lr = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var wn = this.parseExprList(se.parenR, this.options.ecmaVersion >= 8, !1, kt);
            if (ke && !lt && this.shouldParseAsyncArrow()) return this.checkPatternErrors(kt, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = qt, this.awaitPos = hr, this.awaitIdentPos = Lr, this.parseSubscriptAsyncArrow(Z, he, wn, je);
            this.checkExpressionErrors(kt, !0), this.yieldPos = qt || this.yieldPos, this.awaitPos = hr || this.awaitPos, this.awaitIdentPos = Lr || this.awaitIdentPos;
            var qn = this.startNodeAt(Z, he);
            qn.callee = A, qn.arguments = wn, Ge && (qn.optional = lt), A = this.finishNode(qn, "CallExpression");
          } else if (this.type === se.backQuote) {
            (lt || Le) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var Wr = this.startNodeAt(Z, he);
            Wr.tag = A, Wr.quasi = this.parseTemplate({ isTagged: !0 }), A = this.finishNode(Wr, "TaggedTemplateExpression");
          }
          return A;
        }, It.parseExprAtom = function(A, Z, he) {
          this.type === se.slash && this.readRegexp();
          var ve, ke = this.potentialArrowAt === this.start;
          switch (this.type) {
            case se._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), ve = this.startNode(), this.next(), this.type !== se.parenL || this.allowDirectSuper || this.raise(ve.start, "super() call outside constructor of a subclass"), this.type !== se.dot && this.type !== se.bracketL && this.type !== se.parenL && this.unexpected(), this.finishNode(ve, "Super");
            case se._this:
              return ve = this.startNode(), this.next(), this.finishNode(ve, "ThisExpression");
            case se.name:
              var Le = this.start, je = this.startLoc, Ge = this.containsEsc, lt = this.parseIdent(!1);
              if (this.options.ecmaVersion >= 8 && !Ge && lt.name === "async" && !this.canInsertSemicolon() && this.eat(se._function)) return this.overrideContext(Mt.f_expr), this.parseFunction(this.startNodeAt(Le, je), 0, !1, !0, Z);
              if (ke && !this.canInsertSemicolon()) {
                if (this.eat(se.arrow)) return this.parseArrowExpression(this.startNodeAt(Le, je), [lt], !1, Z);
                if (this.options.ecmaVersion >= 8 && lt.name === "async" && this.type === se.name && !Ge && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return lt = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(se.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(Le, je), [lt], !0, Z);
              }
              return lt;
            case se.regexp:
              var gt = this.value;
              return (ve = this.parseLiteral(gt.value)).regex = { pattern: gt.pattern, flags: gt.flags }, ve;
            case se.num:
            case se.string:
              return this.parseLiteral(this.value);
            case se._null:
            case se._true:
            case se._false:
              return (ve = this.startNode()).value = this.type === se._null ? null : this.type === se._true, ve.raw = this.type.keyword, this.next(), this.finishNode(ve, "Literal");
            case se.parenL:
              var ot = this.start, kt = this.parseParenAndDistinguishExpression(ke, Z);
              return A && (A.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(kt) && (A.parenthesizedAssign = ot), A.parenthesizedBind < 0 && (A.parenthesizedBind = ot)), kt;
            case se.bracketL:
              return ve = this.startNode(), this.next(), ve.elements = this.parseExprList(se.bracketR, !0, !0, A), this.finishNode(ve, "ArrayExpression");
            case se.braceL:
              return this.overrideContext(Mt.b_expr), this.parseObj(!1, A);
            case se._function:
              return ve = this.startNode(), this.next(), this.parseFunction(ve, 0);
            case se._class:
              return this.parseClass(this.startNode(), !1);
            case se._new:
              return this.parseNew();
            case se.backQuote:
              return this.parseTemplate();
            case se._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(he) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, It.parseExprAtomDefault = function() {
          this.unexpected();
        }, It.parseExprImport = function(A) {
          var Z = this.startNode();
          if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === se.parenL && !A) return this.parseDynamicImport(Z);
          if (this.type === se.dot) {
            var he = this.startNodeAt(Z.start, Z.loc && Z.loc.start);
            return he.name = "import", Z.meta = this.finishNode(he, "Identifier"), this.parseImportMeta(Z);
          }
          this.unexpected();
        }, It.parseDynamicImport = function(A) {
          if (this.next(), A.source = this.parseMaybeAssign(), !this.eat(se.parenR)) {
            var Z = this.start;
            this.eat(se.comma) && this.eat(se.parenR) ? this.raiseRecoverable(Z, "Trailing comma is not allowed in import()") : this.unexpected(Z);
          }
          return this.finishNode(A, "ImportExpression");
        }, It.parseImportMeta = function(A) {
          this.next();
          var Z = this.containsEsc;
          return A.property = this.parseIdent(!0), A.property.name !== "meta" && this.raiseRecoverable(A.property.start, "The only valid meta property for import is 'import.meta'"), Z && this.raiseRecoverable(A.start, "'import.meta' must not contain escaped characters"), this.options.sourceType === "module" || this.options.allowImportExportEverywhere || this.raiseRecoverable(A.start, "Cannot use 'import.meta' outside a module"), this.finishNode(A, "MetaProperty");
        }, It.parseLiteral = function(A) {
          var Z = this.startNode();
          return Z.value = A, Z.raw = this.input.slice(this.start, this.end), Z.raw.charCodeAt(Z.raw.length - 1) === 110 && (Z.bigint = Z.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(Z, "Literal");
        }, It.parseParenExpression = function() {
          this.expect(se.parenL);
          var A = this.parseExpression();
          return this.expect(se.parenR), A;
        }, It.shouldParseArrow = function(A) {
          return !this.canInsertSemicolon();
        }, It.parseParenAndDistinguishExpression = function(A, Z) {
          var he, ve = this.start, ke = this.startLoc, Le = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var je, Ge = this.start, lt = this.startLoc, gt = [], ot = !0, kt = !1, qt = new dt(), hr = this.yieldPos, Lr = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== se.parenR; ) {
              if (ot ? ot = !1 : this.expect(se.comma), Le && this.afterTrailingComma(se.parenR, !0)) {
                kt = !0;
                break;
              }
              if (this.type === se.ellipsis) {
                je = this.start, gt.push(this.parseParenItem(this.parseRestBinding())), this.type === se.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              gt.push(this.parseMaybeAssign(!1, qt, this.parseParenItem));
            }
            var wn = this.lastTokEnd, qn = this.lastTokEndLoc;
            if (this.expect(se.parenR), A && this.shouldParseArrow(gt) && this.eat(se.arrow)) return this.checkPatternErrors(qt, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = hr, this.awaitPos = Lr, this.parseParenArrowList(ve, ke, gt, Z);
            gt.length && !kt || this.unexpected(this.lastTokStart), je && this.unexpected(je), this.checkExpressionErrors(qt, !0), this.yieldPos = hr || this.yieldPos, this.awaitPos = Lr || this.awaitPos, gt.length > 1 ? ((he = this.startNodeAt(Ge, lt)).expressions = gt, this.finishNodeAt(he, "SequenceExpression", wn, qn)) : he = gt[0];
          } else he = this.parseParenExpression();
          if (this.options.preserveParens) {
            var Wr = this.startNodeAt(ve, ke);
            return Wr.expression = he, this.finishNode(Wr, "ParenthesizedExpression");
          }
          return he;
        }, It.parseParenItem = function(A) {
          return A;
        }, It.parseParenArrowList = function(A, Z, he, ve) {
          return this.parseArrowExpression(this.startNodeAt(A, Z), he, !1, ve);
        };
        var Cn = [];
        It.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var A = this.startNode();
          if (this.next(), this.options.ecmaVersion >= 6 && this.type === se.dot) {
            var Z = this.startNodeAt(A.start, A.loc && A.loc.start);
            Z.name = "new", A.meta = this.finishNode(Z, "Identifier"), this.next();
            var he = this.containsEsc;
            return A.property = this.parseIdent(!0), A.property.name !== "target" && this.raiseRecoverable(A.property.start, "The only valid meta property for new is 'new.target'"), he && this.raiseRecoverable(A.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(A.start, "'new.target' can only be used in functions and class static block"), this.finishNode(A, "MetaProperty");
          }
          var ve = this.start, ke = this.startLoc;
          return A.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), ve, ke, !0, !1), this.eat(se.parenL) ? A.arguments = this.parseExprList(se.parenR, this.options.ecmaVersion >= 8, !1) : A.arguments = Cn, this.finishNode(A, "NewExpression");
        }, It.parseTemplateElement = function(A) {
          var Z = A.isTagged, he = this.startNode();
          return this.type === se.invalidTemplate ? (Z || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), he.value = { raw: this.value, cooked: null }) : he.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value }, this.next(), he.tail = this.type === se.backQuote, this.finishNode(he, "TemplateElement");
        }, It.parseTemplate = function(A) {
          A === void 0 && (A = {});
          var Z = A.isTagged;
          Z === void 0 && (Z = !1);
          var he = this.startNode();
          this.next(), he.expressions = [];
          var ve = this.parseTemplateElement({ isTagged: Z });
          for (he.quasis = [ve]; !ve.tail; ) this.type === se.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(se.dollarBraceL), he.expressions.push(this.parseExpression()), this.expect(se.braceR), he.quasis.push(ve = this.parseTemplateElement({ isTagged: Z }));
          return this.next(), this.finishNode(he, "TemplateLiteral");
        }, It.isAsyncProp = function(A) {
          return !A.computed && A.key.type === "Identifier" && A.key.name === "async" && (this.type === se.name || this.type === se.num || this.type === se.string || this.type === se.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === se.star) && !be.test(this.input.slice(this.lastTokEnd, this.start));
        }, It.parseObj = function(A, Z) {
          var he = this.startNode(), ve = !0, ke = {};
          for (he.properties = [], this.next(); !this.eat(se.braceR); ) {
            if (ve) ve = !1;
            else if (this.expect(se.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(se.braceR)) break;
            var Le = this.parseProperty(A, Z);
            A || this.checkPropClash(Le, ke, Z), he.properties.push(Le);
          }
          return this.finishNode(he, A ? "ObjectPattern" : "ObjectExpression");
        }, It.parseProperty = function(A, Z) {
          var he, ve, ke, Le, je = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(se.ellipsis)) return A ? (je.argument = this.parseIdent(!1), this.type === se.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(je, "RestElement")) : (je.argument = this.parseMaybeAssign(!1, Z), this.type === se.comma && Z && Z.trailingComma < 0 && (Z.trailingComma = this.start), this.finishNode(je, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (je.method = !1, je.shorthand = !1, (A || Z) && (ke = this.start, Le = this.startLoc), A || (he = this.eat(se.star)));
          var Ge = this.containsEsc;
          return this.parsePropertyName(je), !A && !Ge && this.options.ecmaVersion >= 8 && !he && this.isAsyncProp(je) ? (ve = !0, he = this.options.ecmaVersion >= 9 && this.eat(se.star), this.parsePropertyName(je)) : ve = !1, this.parsePropertyValue(je, A, he, ve, ke, Le, Z, Ge), this.finishNode(je, "Property");
        }, It.parseGetterSetter = function(A) {
          A.kind = A.key.name, this.parsePropertyName(A), A.value = this.parseMethod(!1);
          var Z = A.kind === "get" ? 0 : 1;
          if (A.value.params.length !== Z) {
            var he = A.value.start;
            A.kind === "get" ? this.raiseRecoverable(he, "getter should have no params") : this.raiseRecoverable(he, "setter should have exactly one param");
          } else A.kind === "set" && A.value.params[0].type === "RestElement" && this.raiseRecoverable(A.value.params[0].start, "Setter cannot use rest params");
        }, It.parsePropertyValue = function(A, Z, he, ve, ke, Le, je, Ge) {
          (he || ve) && this.type === se.colon && this.unexpected(), this.eat(se.colon) ? (A.value = Z ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, je), A.kind = "init") : this.options.ecmaVersion >= 6 && this.type === se.parenL ? (Z && this.unexpected(), A.kind = "init", A.method = !0, A.value = this.parseMethod(he, ve)) : Z || Ge || !(this.options.ecmaVersion >= 5) || A.computed || A.key.type !== "Identifier" || A.key.name !== "get" && A.key.name !== "set" || this.type === se.comma || this.type === se.braceR || this.type === se.eq ? this.options.ecmaVersion >= 6 && !A.computed && A.key.type === "Identifier" ? ((he || ve) && this.unexpected(), this.checkUnreserved(A.key), A.key.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = ke), A.kind = "init", Z ? A.value = this.parseMaybeDefault(ke, Le, this.copyNode(A.key)) : this.type === se.eq && je ? (je.shorthandAssign < 0 && (je.shorthandAssign = this.start), A.value = this.parseMaybeDefault(ke, Le, this.copyNode(A.key))) : A.value = this.copyNode(A.key), A.shorthand = !0) : this.unexpected() : ((he || ve) && this.unexpected(), this.parseGetterSetter(A));
        }, It.parsePropertyName = function(A) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(se.bracketL)) return A.computed = !0, A.key = this.parseMaybeAssign(), this.expect(se.bracketR), A.key;
            A.computed = !1;
          }
          return A.key = this.type === se.num || this.type === se.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        }, It.initFunction = function(A) {
          A.id = null, this.options.ecmaVersion >= 6 && (A.generator = A.expression = !1), this.options.ecmaVersion >= 8 && (A.async = !1);
        }, It.parseMethod = function(A, Z, he) {
          var ve = this.startNode(), ke = this.yieldPos, Le = this.awaitPos, je = this.awaitIdentPos;
          return this.initFunction(ve), this.options.ecmaVersion >= 6 && (ve.generator = A), this.options.ecmaVersion >= 8 && (ve.async = !!Z), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | st(Z, ve.generator) | (he ? 128 : 0)), this.expect(se.parenL), ve.params = this.parseBindingList(se.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(ve, !1, !0, !1), this.yieldPos = ke, this.awaitPos = Le, this.awaitIdentPos = je, this.finishNode(ve, "FunctionExpression");
        }, It.parseArrowExpression = function(A, Z, he, ve) {
          var ke = this.yieldPos, Le = this.awaitPos, je = this.awaitIdentPos;
          return this.enterScope(16 | st(he, !1)), this.initFunction(A), this.options.ecmaVersion >= 8 && (A.async = !!he), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, A.params = this.toAssignableList(Z, !0), this.parseFunctionBody(A, !0, !1, ve), this.yieldPos = ke, this.awaitPos = Le, this.awaitIdentPos = je, this.finishNode(A, "ArrowFunctionExpression");
        }, It.parseFunctionBody = function(A, Z, he, ve) {
          var ke = Z && this.type !== se.braceL, Le = this.strict, je = !1;
          if (ke) A.body = this.parseMaybeAssign(ve), A.expression = !0, this.checkParams(A, !1);
          else {
            var Ge = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(A.params);
            Le && !Ge || (je = this.strictDirective(this.end)) && Ge && this.raiseRecoverable(A.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var lt = this.labels;
            this.labels = [], je && (this.strict = !0), this.checkParams(A, !Le && !je && !Z && !he && this.isSimpleParamList(A.params)), this.strict && A.id && this.checkLValSimple(A.id, 5), A.body = this.parseBlock(!1, void 0, je && !Le), A.expression = !1, this.adaptDirectivePrologue(A.body.body), this.labels = lt;
          }
          this.exitScope();
        }, It.isSimpleParamList = function(A) {
          for (var Z = 0, he = A; Z < he.length; Z += 1)
            if (he[Z].type !== "Identifier") return !1;
          return !0;
        }, It.checkParams = function(A, Z) {
          for (var he = /* @__PURE__ */ Object.create(null), ve = 0, ke = A.params; ve < ke.length; ve += 1) {
            var Le = ke[ve];
            this.checkLValInnerPattern(Le, 1, Z ? null : he);
          }
        }, It.parseExprList = function(A, Z, he, ve) {
          for (var ke = [], Le = !0; !this.eat(A); ) {
            if (Le) Le = !1;
            else if (this.expect(se.comma), Z && this.afterTrailingComma(A)) break;
            var je = void 0;
            he && this.type === se.comma ? je = null : this.type === se.ellipsis ? (je = this.parseSpread(ve), ve && this.type === se.comma && ve.trailingComma < 0 && (ve.trailingComma = this.start)) : je = this.parseMaybeAssign(!1, ve), ke.push(je);
          }
          return ke;
        }, It.checkUnreserved = function(A) {
          var Z = A.start, he = A.end, ve = A.name;
          this.inGenerator && ve === "yield" && this.raiseRecoverable(Z, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && ve === "await" && this.raiseRecoverable(Z, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && ve === "arguments" && this.raiseRecoverable(Z, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || ve !== "arguments" && ve !== "await" || this.raise(Z, "Cannot use " + ve + " in class static initialization block"), this.keywords.test(ve) && this.raise(Z, "Unexpected keyword '" + ve + "'"), this.options.ecmaVersion < 6 && this.input.slice(Z, he).indexOf("\\") !== -1 || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(ve) && (this.inAsync || ve !== "await" || this.raiseRecoverable(Z, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(Z, "The keyword '" + ve + "' is reserved"));
        }, It.parseIdent = function(A) {
          var Z = this.parseIdentNode();
          return this.next(!!A), this.finishNode(Z, "Identifier"), A || (this.checkUnreserved(Z), Z.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = Z.start)), Z;
        }, It.parseIdentNode = function() {
          var A = this.startNode();
          return this.type === se.name ? A.name = this.value : this.type.keyword ? (A.name = this.type.keyword, A.name !== "class" && A.name !== "function" || this.lastTokEnd === this.lastTokStart + 1 && this.input.charCodeAt(this.lastTokStart) === 46 || this.context.pop(), this.type = se.name) : this.unexpected(), A;
        }, It.parsePrivateIdent = function() {
          var A = this.startNode();
          return this.type === se.privateId ? A.name = this.value : this.unexpected(), this.next(), this.finishNode(A, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(A.start, "Private field '#" + A.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(A)), A;
        }, It.parseYield = function(A) {
          this.yieldPos || (this.yieldPos = this.start);
          var Z = this.startNode();
          return this.next(), this.type === se.semi || this.canInsertSemicolon() || this.type !== se.star && !this.type.startsExpr ? (Z.delegate = !1, Z.argument = null) : (Z.delegate = this.eat(se.star), Z.argument = this.parseMaybeAssign(A)), this.finishNode(Z, "YieldExpression");
        }, It.parseAwait = function(A) {
          this.awaitPos || (this.awaitPos = this.start);
          var Z = this.startNode();
          return this.next(), Z.argument = this.parseMaybeUnary(null, !0, !1, A), this.finishNode(Z, "AwaitExpression");
        };
        var an = it.prototype;
        an.raise = function(A, Z) {
          var he = De(this.input, A);
          Z += " (" + he.line + ":" + he.column + ")";
          var ve = new SyntaxError(Z);
          throw ve.pos = A, ve.loc = he, ve.raisedAt = this.pos, ve;
        }, an.raiseRecoverable = an.raise, an.curPosition = function() {
          if (this.options.locations) return new We(this.curLine, this.pos - this.lineStart);
        };
        var Fr = it.prototype, En = function(A) {
          this.flags = A, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
        };
        Fr.enterScope = function(A) {
          this.scopeStack.push(new En(A));
        }, Fr.exitScope = function() {
          this.scopeStack.pop();
        }, Fr.treatFunctionsAsVarInScope = function(A) {
          return 2 & A.flags || !this.inModule && 1 & A.flags;
        }, Fr.declareName = function(A, Z, he) {
          var ve = !1;
          if (Z === 2) {
            var ke = this.currentScope();
            ve = ke.lexical.indexOf(A) > -1 || ke.functions.indexOf(A) > -1 || ke.var.indexOf(A) > -1, ke.lexical.push(A), this.inModule && 1 & ke.flags && delete this.undefinedExports[A];
          } else if (Z === 4)
            this.currentScope().lexical.push(A);
          else if (Z === 3) {
            var Le = this.currentScope();
            ve = this.treatFunctionsAsVar ? Le.lexical.indexOf(A) > -1 : Le.lexical.indexOf(A) > -1 || Le.var.indexOf(A) > -1, Le.functions.push(A);
          } else for (var je = this.scopeStack.length - 1; je >= 0; --je) {
            var Ge = this.scopeStack[je];
            if (Ge.lexical.indexOf(A) > -1 && !(32 & Ge.flags && Ge.lexical[0] === A) || !this.treatFunctionsAsVarInScope(Ge) && Ge.functions.indexOf(A) > -1) {
              ve = !0;
              break;
            }
            if (Ge.var.push(A), this.inModule && 1 & Ge.flags && delete this.undefinedExports[A], 259 & Ge.flags) break;
          }
          ve && this.raiseRecoverable(he, "Identifier '" + A + "' has already been declared");
        }, Fr.checkLocalExport = function(A) {
          this.scopeStack[0].lexical.indexOf(A.name) === -1 && this.scopeStack[0].var.indexOf(A.name) === -1 && (this.undefinedExports[A.name] = A);
        }, Fr.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, Fr.currentVarScope = function() {
          for (var A = this.scopeStack.length - 1; ; A--) {
            var Z = this.scopeStack[A];
            if (259 & Z.flags) return Z;
          }
        }, Fr.currentThisScope = function() {
          for (var A = this.scopeStack.length - 1; ; A--) {
            var Z = this.scopeStack[A];
            if (259 & Z.flags && !(16 & Z.flags)) return Z;
          }
        };
        var dn = function(A, Z, he) {
          this.type = "", this.start = Z, this.end = 0, A.options.locations && (this.loc = new et(A, he)), A.options.directSourceFile && (this.sourceFile = A.options.directSourceFile), A.options.ranges && (this.range = [Z, 0]);
        }, on = it.prototype;
        function vr(A, Z, he, ve) {
          return A.type = Z, A.end = he, this.options.locations && (A.loc.end = ve), this.options.ranges && (A.range[1] = he), A;
        }
        on.startNode = function() {
          return new dn(this, this.start, this.startLoc);
        }, on.startNodeAt = function(A, Z) {
          return new dn(this, A, Z);
        }, on.finishNode = function(A, Z) {
          return vr.call(this, A, Z, this.lastTokEnd, this.lastTokEndLoc);
        }, on.finishNodeAt = function(A, Z, he, ve) {
          return vr.call(this, A, Z, he, ve);
        }, on.copyNode = function(A) {
          var Z = new dn(this, A.start, this.startLoc);
          for (var he in A) Z[he] = A[he];
          return Z;
        };
        var Vn = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Cr = Vn + " Extended_Pictographic", br = Cr + " EBase EComp EMod EPres ExtPict", _n = { 9: Vn, 10: Cr, 11: Cr, 12: br, 13: br, 14: br }, In = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, pn = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Dr = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Wn = Dr + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", yi = Wn + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", ri = yi + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Nt = ri + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Pi = { 9: Dr, 10: Wn, 11: yi, 12: ri, 13: Nt, 14: Nt + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz" }, ps = {};
        function Gs(A) {
          var Z = ps[A] = { binary: Ve(_n[A] + " " + pn), binaryOfStrings: Ve(In[A]), nonBinary: { General_Category: Ve(pn), Script: Ve(Pi[A]) } };
          Z.nonBinary.Script_Extensions = Z.nonBinary.Script, Z.nonBinary.gc = Z.nonBinary.General_Category, Z.nonBinary.sc = Z.nonBinary.Script, Z.nonBinary.scx = Z.nonBinary.Script_Extensions;
        }
        for (var ca = 0, ni = [9, 10, 11, 12, 13, 14]; ca < ni.length; ca += 1)
          Gs(ni[ca]);
        var tt = it.prototype, pt = function(A) {
          this.parser = A, this.validFlags = "gim" + (A.options.ecmaVersion >= 6 ? "uy" : "") + (A.options.ecmaVersion >= 9 ? "s" : "") + (A.options.ecmaVersion >= 13 ? "d" : "") + (A.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = ps[A.options.ecmaVersion >= 14 ? 14 : A.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
        };
        function Ot(A) {
          return A === 36 || A >= 40 && A <= 43 || A === 46 || A === 63 || A >= 91 && A <= 94 || A >= 123 && A <= 125;
        }
        function Pt(A) {
          return A >= 65 && A <= 90 || A >= 97 && A <= 122;
        }
        pt.prototype.reset = function(A, Z, he) {
          var ve = he.indexOf("v") !== -1, ke = he.indexOf("u") !== -1;
          this.start = 0 | A, this.source = Z + "", this.flags = he, ve && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = ke && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = ke && this.parser.options.ecmaVersion >= 9);
        }, pt.prototype.raise = function(A) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + A);
        }, pt.prototype.at = function(A, Z) {
          Z === void 0 && (Z = !1);
          var he = this.source, ve = he.length;
          if (A >= ve) return -1;
          var ke = he.charCodeAt(A);
          if (!Z && !this.switchU || ke <= 55295 || ke >= 57344 || A + 1 >= ve) return ke;
          var Le = he.charCodeAt(A + 1);
          return Le >= 56320 && Le <= 57343 ? (ke << 10) + Le - 56613888 : ke;
        }, pt.prototype.nextIndex = function(A, Z) {
          Z === void 0 && (Z = !1);
          var he = this.source, ve = he.length;
          if (A >= ve) return ve;
          var ke, Le = he.charCodeAt(A);
          return !Z && !this.switchU || Le <= 55295 || Le >= 57344 || A + 1 >= ve || (ke = he.charCodeAt(A + 1)) < 56320 || ke > 57343 ? A + 1 : A + 2;
        }, pt.prototype.current = function(A) {
          return A === void 0 && (A = !1), this.at(this.pos, A);
        }, pt.prototype.lookahead = function(A) {
          return A === void 0 && (A = !1), this.at(this.nextIndex(this.pos, A), A);
        }, pt.prototype.advance = function(A) {
          A === void 0 && (A = !1), this.pos = this.nextIndex(this.pos, A);
        }, pt.prototype.eat = function(A, Z) {
          return Z === void 0 && (Z = !1), this.current(Z) === A && (this.advance(Z), !0);
        }, pt.prototype.eatChars = function(A, Z) {
          Z === void 0 && (Z = !1);
          for (var he = this.pos, ve = 0, ke = A; ve < ke.length; ve += 1) {
            var Le = ke[ve], je = this.at(he, Z);
            if (je === -1 || je !== Le) return !1;
            he = this.nextIndex(he, Z);
          }
          return this.pos = he, !0;
        }, tt.validateRegExpFlags = function(A) {
          for (var Z = A.validFlags, he = A.flags, ve = !1, ke = !1, Le = 0; Le < he.length; Le++) {
            var je = he.charAt(Le);
            Z.indexOf(je) === -1 && this.raise(A.start, "Invalid regular expression flag"), he.indexOf(je, Le + 1) > -1 && this.raise(A.start, "Duplicate regular expression flag"), je === "u" && (ve = !0), je === "v" && (ke = !0);
          }
          this.options.ecmaVersion >= 15 && ve && ke && this.raise(A.start, "Invalid regular expression flag");
        }, tt.validateRegExpPattern = function(A) {
          this.regexp_pattern(A), !A.switchN && this.options.ecmaVersion >= 9 && A.groupNames.length > 0 && (A.switchN = !0, this.regexp_pattern(A));
        }, tt.regexp_pattern = function(A) {
          A.pos = 0, A.lastIntValue = 0, A.lastStringValue = "", A.lastAssertionIsQuantifiable = !1, A.numCapturingParens = 0, A.maxBackReference = 0, A.groupNames.length = 0, A.backReferenceNames.length = 0, this.regexp_disjunction(A), A.pos !== A.source.length && (A.eat(41) && A.raise("Unmatched ')'"), (A.eat(93) || A.eat(125)) && A.raise("Lone quantifier brackets")), A.maxBackReference > A.numCapturingParens && A.raise("Invalid escape");
          for (var Z = 0, he = A.backReferenceNames; Z < he.length; Z += 1) {
            var ve = he[Z];
            A.groupNames.indexOf(ve) === -1 && A.raise("Invalid named capture referenced");
          }
        }, tt.regexp_disjunction = function(A) {
          for (this.regexp_alternative(A); A.eat(124); ) this.regexp_alternative(A);
          this.regexp_eatQuantifier(A, !0) && A.raise("Nothing to repeat"), A.eat(123) && A.raise("Lone quantifier brackets");
        }, tt.regexp_alternative = function(A) {
          for (; A.pos < A.source.length && this.regexp_eatTerm(A); ) ;
        }, tt.regexp_eatTerm = function(A) {
          return this.regexp_eatAssertion(A) ? (A.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(A) && A.switchU && A.raise("Invalid quantifier"), !0) : !!(A.switchU ? this.regexp_eatAtom(A) : this.regexp_eatExtendedAtom(A)) && (this.regexp_eatQuantifier(A), !0);
        }, tt.regexp_eatAssertion = function(A) {
          var Z = A.pos;
          if (A.lastAssertionIsQuantifiable = !1, A.eat(94) || A.eat(36)) return !0;
          if (A.eat(92)) {
            if (A.eat(66) || A.eat(98)) return !0;
            A.pos = Z;
          }
          if (A.eat(40) && A.eat(63)) {
            var he = !1;
            if (this.options.ecmaVersion >= 9 && (he = A.eat(60)), A.eat(61) || A.eat(33)) return this.regexp_disjunction(A), A.eat(41) || A.raise("Unterminated group"), A.lastAssertionIsQuantifiable = !he, !0;
          }
          return A.pos = Z, !1;
        }, tt.regexp_eatQuantifier = function(A, Z) {
          return Z === void 0 && (Z = !1), !!this.regexp_eatQuantifierPrefix(A, Z) && (A.eat(63), !0);
        }, tt.regexp_eatQuantifierPrefix = function(A, Z) {
          return A.eat(42) || A.eat(43) || A.eat(63) || this.regexp_eatBracedQuantifier(A, Z);
        }, tt.regexp_eatBracedQuantifier = function(A, Z) {
          var he = A.pos;
          if (A.eat(123)) {
            var ve = 0, ke = -1;
            if (this.regexp_eatDecimalDigits(A) && (ve = A.lastIntValue, A.eat(44) && this.regexp_eatDecimalDigits(A) && (ke = A.lastIntValue), A.eat(125))) return ke !== -1 && ke < ve && !Z && A.raise("numbers out of order in {} quantifier"), !0;
            A.switchU && !Z && A.raise("Incomplete quantifier"), A.pos = he;
          }
          return !1;
        }, tt.regexp_eatAtom = function(A) {
          return this.regexp_eatPatternCharacters(A) || A.eat(46) || this.regexp_eatReverseSolidusAtomEscape(A) || this.regexp_eatCharacterClass(A) || this.regexp_eatUncapturingGroup(A) || this.regexp_eatCapturingGroup(A);
        }, tt.regexp_eatReverseSolidusAtomEscape = function(A) {
          var Z = A.pos;
          if (A.eat(92)) {
            if (this.regexp_eatAtomEscape(A)) return !0;
            A.pos = Z;
          }
          return !1;
        }, tt.regexp_eatUncapturingGroup = function(A) {
          var Z = A.pos;
          if (A.eat(40)) {
            if (A.eat(63) && A.eat(58)) {
              if (this.regexp_disjunction(A), A.eat(41)) return !0;
              A.raise("Unterminated group");
            }
            A.pos = Z;
          }
          return !1;
        }, tt.regexp_eatCapturingGroup = function(A) {
          if (A.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(A) : A.current() === 63 && A.raise("Invalid group"), this.regexp_disjunction(A), A.eat(41)) return A.numCapturingParens += 1, !0;
            A.raise("Unterminated group");
          }
          return !1;
        }, tt.regexp_eatExtendedAtom = function(A) {
          return A.eat(46) || this.regexp_eatReverseSolidusAtomEscape(A) || this.regexp_eatCharacterClass(A) || this.regexp_eatUncapturingGroup(A) || this.regexp_eatCapturingGroup(A) || this.regexp_eatInvalidBracedQuantifier(A) || this.regexp_eatExtendedPatternCharacter(A);
        }, tt.regexp_eatInvalidBracedQuantifier = function(A) {
          return this.regexp_eatBracedQuantifier(A, !0) && A.raise("Nothing to repeat"), !1;
        }, tt.regexp_eatSyntaxCharacter = function(A) {
          var Z = A.current();
          return !!Ot(Z) && (A.lastIntValue = Z, A.advance(), !0);
        }, tt.regexp_eatPatternCharacters = function(A) {
          for (var Z = A.pos, he = 0; (he = A.current()) !== -1 && !Ot(he); ) A.advance();
          return A.pos !== Z;
        }, tt.regexp_eatExtendedPatternCharacter = function(A) {
          var Z = A.current();
          return !(Z === -1 || Z === 36 || Z >= 40 && Z <= 43 || Z === 46 || Z === 63 || Z === 91 || Z === 94 || Z === 124) && (A.advance(), !0);
        }, tt.regexp_groupSpecifier = function(A) {
          if (A.eat(63)) {
            if (this.regexp_eatGroupName(A)) return A.groupNames.indexOf(A.lastStringValue) !== -1 && A.raise("Duplicate capture group name"), void A.groupNames.push(A.lastStringValue);
            A.raise("Invalid group");
          }
        }, tt.regexp_eatGroupName = function(A) {
          if (A.lastStringValue = "", A.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(A) && A.eat(62)) return !0;
            A.raise("Invalid capture group name");
          }
          return !1;
        }, tt.regexp_eatRegExpIdentifierName = function(A) {
          if (A.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(A)) {
            for (A.lastStringValue += Xe(A.lastIntValue); this.regexp_eatRegExpIdentifierPart(A); ) A.lastStringValue += Xe(A.lastIntValue);
            return !0;
          }
          return !1;
        }, tt.regexp_eatRegExpIdentifierStart = function(A) {
          var Z = A.pos, he = this.options.ecmaVersion >= 11, ve = A.current(he);
          return A.advance(he), ve === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(A, he) && (ve = A.lastIntValue), function(ke) {
            return ce(ke, !0) || ke === 36 || ke === 95;
          }(ve) ? (A.lastIntValue = ve, !0) : (A.pos = Z, !1);
        }, tt.regexp_eatRegExpIdentifierPart = function(A) {
          var Z = A.pos, he = this.options.ecmaVersion >= 11, ve = A.current(he);
          return A.advance(he), ve === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(A, he) && (ve = A.lastIntValue), function(ke) {
            return ee(ke, !0) || ke === 36 || ke === 95 || ke === 8204 || ke === 8205;
          }(ve) ? (A.lastIntValue = ve, !0) : (A.pos = Z, !1);
        }, tt.regexp_eatAtomEscape = function(A) {
          return !!(this.regexp_eatBackReference(A) || this.regexp_eatCharacterClassEscape(A) || this.regexp_eatCharacterEscape(A) || A.switchN && this.regexp_eatKGroupName(A)) || (A.switchU && (A.current() === 99 && A.raise("Invalid unicode escape"), A.raise("Invalid escape")), !1);
        }, tt.regexp_eatBackReference = function(A) {
          var Z = A.pos;
          if (this.regexp_eatDecimalEscape(A)) {
            var he = A.lastIntValue;
            if (A.switchU) return he > A.maxBackReference && (A.maxBackReference = he), !0;
            if (he <= A.numCapturingParens) return !0;
            A.pos = Z;
          }
          return !1;
        }, tt.regexp_eatKGroupName = function(A) {
          if (A.eat(107)) {
            if (this.regexp_eatGroupName(A)) return A.backReferenceNames.push(A.lastStringValue), !0;
            A.raise("Invalid named reference");
          }
          return !1;
        }, tt.regexp_eatCharacterEscape = function(A) {
          return this.regexp_eatControlEscape(A) || this.regexp_eatCControlLetter(A) || this.regexp_eatZero(A) || this.regexp_eatHexEscapeSequence(A) || this.regexp_eatRegExpUnicodeEscapeSequence(A, !1) || !A.switchU && this.regexp_eatLegacyOctalEscapeSequence(A) || this.regexp_eatIdentityEscape(A);
        }, tt.regexp_eatCControlLetter = function(A) {
          var Z = A.pos;
          if (A.eat(99)) {
            if (this.regexp_eatControlLetter(A)) return !0;
            A.pos = Z;
          }
          return !1;
        }, tt.regexp_eatZero = function(A) {
          return A.current() === 48 && !Ft(A.lookahead()) && (A.lastIntValue = 0, A.advance(), !0);
        }, tt.regexp_eatControlEscape = function(A) {
          var Z = A.current();
          return Z === 116 ? (A.lastIntValue = 9, A.advance(), !0) : Z === 110 ? (A.lastIntValue = 10, A.advance(), !0) : Z === 118 ? (A.lastIntValue = 11, A.advance(), !0) : Z === 102 ? (A.lastIntValue = 12, A.advance(), !0) : Z === 114 && (A.lastIntValue = 13, A.advance(), !0);
        }, tt.regexp_eatControlLetter = function(A) {
          var Z = A.current();
          return !!Pt(Z) && (A.lastIntValue = Z % 32, A.advance(), !0);
        }, tt.regexp_eatRegExpUnicodeEscapeSequence = function(A, Z) {
          Z === void 0 && (Z = !1);
          var he, ve = A.pos, ke = Z || A.switchU;
          if (A.eat(117)) {
            if (this.regexp_eatFixedHexDigits(A, 4)) {
              var Le = A.lastIntValue;
              if (ke && Le >= 55296 && Le <= 56319) {
                var je = A.pos;
                if (A.eat(92) && A.eat(117) && this.regexp_eatFixedHexDigits(A, 4)) {
                  var Ge = A.lastIntValue;
                  if (Ge >= 56320 && Ge <= 57343) return A.lastIntValue = 1024 * (Le - 55296) + (Ge - 56320) + 65536, !0;
                }
                A.pos = je, A.lastIntValue = Le;
              }
              return !0;
            }
            if (ke && A.eat(123) && this.regexp_eatHexDigits(A) && A.eat(125) && (he = A.lastIntValue) >= 0 && he <= 1114111) return !0;
            ke && A.raise("Invalid unicode escape"), A.pos = ve;
          }
          return !1;
        }, tt.regexp_eatIdentityEscape = function(A) {
          if (A.switchU) return !!this.regexp_eatSyntaxCharacter(A) || !!A.eat(47) && (A.lastIntValue = 47, !0);
          var Z = A.current();
          return !(Z === 99 || A.switchN && Z === 107) && (A.lastIntValue = Z, A.advance(), !0);
        }, tt.regexp_eatDecimalEscape = function(A) {
          A.lastIntValue = 0;
          var Z = A.current();
          if (Z >= 49 && Z <= 57) {
            do
              A.lastIntValue = 10 * A.lastIntValue + (Z - 48), A.advance();
            while ((Z = A.current()) >= 48 && Z <= 57);
            return !0;
          }
          return !1;
        };
        function Wt(A) {
          return Pt(A) || A === 95;
        }
        function Xt(A) {
          return Wt(A) || Ft(A);
        }
        function Ft(A) {
          return A >= 48 && A <= 57;
        }
        function ht(A) {
          return A >= 48 && A <= 57 || A >= 65 && A <= 70 || A >= 97 && A <= 102;
        }
        function rr(A) {
          return A >= 65 && A <= 70 ? A - 65 + 10 : A >= 97 && A <= 102 ? A - 97 + 10 : A - 48;
        }
        function sr(A) {
          return A >= 48 && A <= 55;
        }
        tt.regexp_eatCharacterClassEscape = function(A) {
          var Z = A.current();
          if (/* @__PURE__ */ function(ke) {
            return ke === 100 || ke === 68 || ke === 115 || ke === 83 || ke === 119 || ke === 87;
          }(Z)) return A.lastIntValue = -1, A.advance(), 1;
          var he = !1;
          if (A.switchU && this.options.ecmaVersion >= 9 && ((he = Z === 80) || Z === 112)) {
            var ve;
            if (A.lastIntValue = -1, A.advance(), A.eat(123) && (ve = this.regexp_eatUnicodePropertyValueExpression(A)) && A.eat(125)) return he && ve === 2 && A.raise("Invalid property name"), ve;
            A.raise("Invalid property name");
          }
          return 0;
        }, tt.regexp_eatUnicodePropertyValueExpression = function(A) {
          var Z = A.pos;
          if (this.regexp_eatUnicodePropertyName(A) && A.eat(61)) {
            var he = A.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(A)) {
              var ve = A.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(A, he, ve), 1;
            }
          }
          if (A.pos = Z, this.regexp_eatLoneUnicodePropertyNameOrValue(A)) {
            var ke = A.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(A, ke);
          }
          return 0;
        }, tt.regexp_validateUnicodePropertyNameAndValue = function(A, Z, he) {
          Ee(A.unicodeProperties.nonBinary, Z) || A.raise("Invalid property name"), A.unicodeProperties.nonBinary[Z].test(he) || A.raise("Invalid property value");
        }, tt.regexp_validateUnicodePropertyNameOrValue = function(A, Z) {
          return A.unicodeProperties.binary.test(Z) ? 1 : A.switchV && A.unicodeProperties.binaryOfStrings.test(Z) ? 2 : void A.raise("Invalid property name");
        }, tt.regexp_eatUnicodePropertyName = function(A) {
          var Z = 0;
          for (A.lastStringValue = ""; Wt(Z = A.current()); ) A.lastStringValue += Xe(Z), A.advance();
          return A.lastStringValue !== "";
        }, tt.regexp_eatUnicodePropertyValue = function(A) {
          var Z = 0;
          for (A.lastStringValue = ""; Xt(Z = A.current()); ) A.lastStringValue += Xe(Z), A.advance();
          return A.lastStringValue !== "";
        }, tt.regexp_eatLoneUnicodePropertyNameOrValue = function(A) {
          return this.regexp_eatUnicodePropertyValue(A);
        }, tt.regexp_eatCharacterClass = function(A) {
          if (A.eat(91)) {
            var Z = A.eat(94), he = this.regexp_classContents(A);
            return A.eat(93) || A.raise("Unterminated character class"), Z && he === 2 && A.raise("Negated character class may contain strings"), !0;
          }
          return !1;
        }, tt.regexp_classContents = function(A) {
          return A.current() === 93 ? 1 : A.switchV ? this.regexp_classSetExpression(A) : (this.regexp_nonEmptyClassRanges(A), 1);
        }, tt.regexp_nonEmptyClassRanges = function(A) {
          for (; this.regexp_eatClassAtom(A); ) {
            var Z = A.lastIntValue;
            if (A.eat(45) && this.regexp_eatClassAtom(A)) {
              var he = A.lastIntValue;
              !A.switchU || Z !== -1 && he !== -1 || A.raise("Invalid character class"), Z !== -1 && he !== -1 && Z > he && A.raise("Range out of order in character class");
            }
          }
        }, tt.regexp_eatClassAtom = function(A) {
          var Z = A.pos;
          if (A.eat(92)) {
            if (this.regexp_eatClassEscape(A)) return !0;
            if (A.switchU) {
              var he = A.current();
              (he === 99 || sr(he)) && A.raise("Invalid class escape"), A.raise("Invalid escape");
            }
            A.pos = Z;
          }
          var ve = A.current();
          return ve !== 93 && (A.lastIntValue = ve, A.advance(), !0);
        }, tt.regexp_eatClassEscape = function(A) {
          var Z = A.pos;
          if (A.eat(98)) return A.lastIntValue = 8, !0;
          if (A.switchU && A.eat(45)) return A.lastIntValue = 45, !0;
          if (!A.switchU && A.eat(99)) {
            if (this.regexp_eatClassControlLetter(A)) return !0;
            A.pos = Z;
          }
          return this.regexp_eatCharacterClassEscape(A) || this.regexp_eatCharacterEscape(A);
        }, tt.regexp_classSetExpression = function(A) {
          var Z, he = 1;
          if (!this.regexp_eatClassSetRange(A)) if (Z = this.regexp_eatClassSetOperand(A)) {
            Z === 2 && (he = 2);
            for (var ve = A.pos; A.eatChars([38, 38]); ) A.current() !== 38 && (Z = this.regexp_eatClassSetOperand(A)) ? Z !== 2 && (he = 1) : A.raise("Invalid character in character class");
            if (ve !== A.pos) return he;
            for (; A.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(A) || A.raise("Invalid character in character class");
            if (ve !== A.pos) return he;
          } else A.raise("Invalid character in character class");
          for (; ; ) if (!this.regexp_eatClassSetRange(A)) {
            if (!(Z = this.regexp_eatClassSetOperand(A))) return he;
            Z === 2 && (he = 2);
          }
        }, tt.regexp_eatClassSetRange = function(A) {
          var Z = A.pos;
          if (this.regexp_eatClassSetCharacter(A)) {
            var he = A.lastIntValue;
            if (A.eat(45) && this.regexp_eatClassSetCharacter(A)) {
              var ve = A.lastIntValue;
              return he !== -1 && ve !== -1 && he > ve && A.raise("Range out of order in character class"), !0;
            }
            A.pos = Z;
          }
          return !1;
        }, tt.regexp_eatClassSetOperand = function(A) {
          return this.regexp_eatClassSetCharacter(A) ? 1 : this.regexp_eatClassStringDisjunction(A) || this.regexp_eatNestedClass(A);
        }, tt.regexp_eatNestedClass = function(A) {
          var Z = A.pos;
          if (A.eat(91)) {
            var he = A.eat(94), ve = this.regexp_classContents(A);
            if (A.eat(93)) return he && ve === 2 && A.raise("Negated character class may contain strings"), ve;
            A.pos = Z;
          }
          if (A.eat(92)) {
            var ke = this.regexp_eatCharacterClassEscape(A);
            if (ke) return ke;
            A.pos = Z;
          }
          return null;
        }, tt.regexp_eatClassStringDisjunction = function(A) {
          var Z = A.pos;
          if (A.eatChars([92, 113])) {
            if (A.eat(123)) {
              var he = this.regexp_classStringDisjunctionContents(A);
              if (A.eat(125)) return he;
            } else A.raise("Invalid escape");
            A.pos = Z;
          }
          return null;
        }, tt.regexp_classStringDisjunctionContents = function(A) {
          for (var Z = this.regexp_classString(A); A.eat(124); ) this.regexp_classString(A) === 2 && (Z = 2);
          return Z;
        }, tt.regexp_classString = function(A) {
          for (var Z = 0; this.regexp_eatClassSetCharacter(A); ) Z++;
          return Z === 1 ? 1 : 2;
        }, tt.regexp_eatClassSetCharacter = function(A) {
          var Z = A.pos;
          if (A.eat(92)) return !(!this.regexp_eatCharacterEscape(A) && !this.regexp_eatClassSetReservedPunctuator(A)) || (A.eat(98) ? (A.lastIntValue = 8, !0) : (A.pos = Z, !1));
          var he = A.current();
          return !(he < 0 || he === A.lookahead() && function(ve) {
            return ve === 33 || ve >= 35 && ve <= 38 || ve >= 42 && ve <= 44 || ve === 46 || ve >= 58 && ve <= 64 || ve === 94 || ve === 96 || ve === 126;
          }(he)) && !function(ve) {
            return ve === 40 || ve === 41 || ve === 45 || ve === 47 || ve >= 91 && ve <= 93 || ve >= 123 && ve <= 125;
          }(he) && (A.advance(), A.lastIntValue = he, !0);
        }, tt.regexp_eatClassSetReservedPunctuator = function(A) {
          var Z = A.current();
          return !!function(he) {
            return he === 33 || he === 35 || he === 37 || he === 38 || he === 44 || he === 45 || he >= 58 && he <= 62 || he === 64 || he === 96 || he === 126;
          }(Z) && (A.lastIntValue = Z, A.advance(), !0);
        }, tt.regexp_eatClassControlLetter = function(A) {
          var Z = A.current();
          return !(!Ft(Z) && Z !== 95) && (A.lastIntValue = Z % 32, A.advance(), !0);
        }, tt.regexp_eatHexEscapeSequence = function(A) {
          var Z = A.pos;
          if (A.eat(120)) {
            if (this.regexp_eatFixedHexDigits(A, 2)) return !0;
            A.switchU && A.raise("Invalid escape"), A.pos = Z;
          }
          return !1;
        }, tt.regexp_eatDecimalDigits = function(A) {
          var Z = A.pos, he = 0;
          for (A.lastIntValue = 0; Ft(he = A.current()); ) A.lastIntValue = 10 * A.lastIntValue + (he - 48), A.advance();
          return A.pos !== Z;
        }, tt.regexp_eatHexDigits = function(A) {
          var Z = A.pos, he = 0;
          for (A.lastIntValue = 0; ht(he = A.current()); ) A.lastIntValue = 16 * A.lastIntValue + rr(he), A.advance();
          return A.pos !== Z;
        }, tt.regexp_eatLegacyOctalEscapeSequence = function(A) {
          if (this.regexp_eatOctalDigit(A)) {
            var Z = A.lastIntValue;
            if (this.regexp_eatOctalDigit(A)) {
              var he = A.lastIntValue;
              Z <= 3 && this.regexp_eatOctalDigit(A) ? A.lastIntValue = 64 * Z + 8 * he + A.lastIntValue : A.lastIntValue = 8 * Z + he;
            } else A.lastIntValue = Z;
            return !0;
          }
          return !1;
        }, tt.regexp_eatOctalDigit = function(A) {
          var Z = A.current();
          return sr(Z) ? (A.lastIntValue = Z - 48, A.advance(), !0) : (A.lastIntValue = 0, !1);
        }, tt.regexp_eatFixedHexDigits = function(A, Z) {
          var he = A.pos;
          A.lastIntValue = 0;
          for (var ve = 0; ve < Z; ++ve) {
            var ke = A.current();
            if (!ht(ke)) return A.pos = he, !1;
            A.lastIntValue = 16 * A.lastIntValue + rr(ke), A.advance();
          }
          return !0;
        };
        var wr = function(A) {
          this.type = A.type, this.value = A.value, this.start = A.start, this.end = A.end, A.options.locations && (this.loc = new et(A, A.startLoc, A.endLoc)), A.options.ranges && (this.range = [A.start, A.end]);
        }, At = it.prototype;
        function Er(A) {
          return typeof BigInt != "function" ? null : BigInt(A.replace(/_/g, ""));
        }
        At.next = function(A) {
          !A && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new wr(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, At.getToken = function() {
          return this.next(), new wr(this);
        }, typeof Symbol < "u" && (At[Symbol.iterator] = function() {
          var A = this;
          return { next: function() {
            var Z = A.getToken();
            return { done: Z.type === se.eof, value: Z };
          } };
        }), At.nextToken = function() {
          var A = this.curContext();
          return A && A.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(se.eof) : A.override ? A.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, At.readToken = function(A) {
          return ce(A, this.options.ecmaVersion >= 6) || A === 92 ? this.readWord() : this.getTokenFromCode(A);
        }, At.fullCharCodeAtPos = function() {
          var A = this.input.charCodeAt(this.pos);
          if (A <= 55295 || A >= 56320) return A;
          var Z = this.input.charCodeAt(this.pos + 1);
          return Z <= 56319 || Z >= 57344 ? A : (A << 10) + Z - 56613888;
        }, At.skipBlockComment = function() {
          var A = this.options.onComment && this.curPosition(), Z = this.pos, he = this.input.indexOf("*/", this.pos += 2);
          if (he === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = he + 2, this.options.locations) for (var ve = void 0, ke = Z; (ve = Be(this.input, ke, this.pos)) > -1; ) ++this.curLine, ke = this.lineStart = ve;
          this.options.onComment && this.options.onComment(!0, this.input.slice(Z + 2, he), Z, this.pos, A, this.curPosition());
        }, At.skipLineComment = function(A) {
          for (var Z = this.pos, he = this.options.onComment && this.curPosition(), ve = this.input.charCodeAt(this.pos += A); this.pos < this.input.length && !Oe(ve); ) ve = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(!1, this.input.slice(Z + A, this.pos), Z, this.pos, he, this.curPosition());
        }, At.skipSpace = function() {
          e: for (; this.pos < this.input.length; ) {
            var A = this.input.charCodeAt(this.pos);
            switch (A) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break e;
                }
                break;
              default:
                if (!(A > 8 && A < 14 || A >= 5760 && Fe.test(String.fromCharCode(A)))) break e;
                ++this.pos;
            }
          }
        }, At.finishToken = function(A, Z) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var he = this.type;
          this.type = A, this.value = Z, this.updateContext(he);
        }, At.readToken_dot = function() {
          var A = this.input.charCodeAt(this.pos + 1);
          if (A >= 48 && A <= 57) return this.readNumber(!0);
          var Z = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && A === 46 && Z === 46 ? (this.pos += 3, this.finishToken(se.ellipsis)) : (++this.pos, this.finishToken(se.dot));
        }, At.readToken_slash = function() {
          var A = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : A === 61 ? this.finishOp(se.assign, 2) : this.finishOp(se.slash, 1);
        }, At.readToken_mult_modulo_exp = function(A) {
          var Z = this.input.charCodeAt(this.pos + 1), he = 1, ve = A === 42 ? se.star : se.modulo;
          return this.options.ecmaVersion >= 7 && A === 42 && Z === 42 && (++he, ve = se.starstar, Z = this.input.charCodeAt(this.pos + 2)), Z === 61 ? this.finishOp(se.assign, he + 1) : this.finishOp(ve, he);
        }, At.readToken_pipe_amp = function(A) {
          var Z = this.input.charCodeAt(this.pos + 1);
          return Z === A ? this.options.ecmaVersion >= 12 && this.input.charCodeAt(this.pos + 2) === 61 ? this.finishOp(se.assign, 3) : this.finishOp(A === 124 ? se.logicalOR : se.logicalAND, 2) : Z === 61 ? this.finishOp(se.assign, 2) : this.finishOp(A === 124 ? se.bitwiseOR : se.bitwiseAND, 1);
        }, At.readToken_caret = function() {
          return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(se.assign, 2) : this.finishOp(se.bitwiseXOR, 1);
        }, At.readToken_plus_min = function(A) {
          var Z = this.input.charCodeAt(this.pos + 1);
          return Z === A ? Z !== 45 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 62 || this.lastTokEnd !== 0 && !be.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(se.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : Z === 61 ? this.finishOp(se.assign, 2) : this.finishOp(se.plusMin, 1);
        }, At.readToken_lt_gt = function(A) {
          var Z = this.input.charCodeAt(this.pos + 1), he = 1;
          return Z === A ? (he = A === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + he) === 61 ? this.finishOp(se.assign, he + 1) : this.finishOp(se.bitShift, he)) : Z !== 33 || A !== 60 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 45 || this.input.charCodeAt(this.pos + 3) !== 45 ? (Z === 61 && (he = 2), this.finishOp(se.relational, he)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, At.readToken_eq_excl = function(A) {
          var Z = this.input.charCodeAt(this.pos + 1);
          return Z === 61 ? this.finishOp(se.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : A === 61 && Z === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(se.arrow)) : this.finishOp(A === 61 ? se.eq : se.prefix, 1);
        }, At.readToken_question = function() {
          var A = this.options.ecmaVersion;
          if (A >= 11) {
            var Z = this.input.charCodeAt(this.pos + 1);
            if (Z === 46) {
              var he = this.input.charCodeAt(this.pos + 2);
              if (he < 48 || he > 57) return this.finishOp(se.questionDot, 2);
            }
            if (Z === 63)
              return A >= 12 && this.input.charCodeAt(this.pos + 2) === 61 ? this.finishOp(se.assign, 3) : this.finishOp(se.coalesce, 2);
          }
          return this.finishOp(se.question, 1);
        }, At.readToken_numberSign = function() {
          var A = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, ce(A = this.fullCharCodeAtPos(), !0) || A === 92)) return this.finishToken(se.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + Xe(A) + "'");
        }, At.getTokenFromCode = function(A) {
          switch (A) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(se.parenL);
            case 41:
              return ++this.pos, this.finishToken(se.parenR);
            case 59:
              return ++this.pos, this.finishToken(se.semi);
            case 44:
              return ++this.pos, this.finishToken(se.comma);
            case 91:
              return ++this.pos, this.finishToken(se.bracketL);
            case 93:
              return ++this.pos, this.finishToken(se.bracketR);
            case 123:
              return ++this.pos, this.finishToken(se.braceL);
            case 125:
              return ++this.pos, this.finishToken(se.braceR);
            case 58:
              return ++this.pos, this.finishToken(se.colon);
            case 96:
              if (this.options.ecmaVersion < 6) break;
              return ++this.pos, this.finishToken(se.backQuote);
            case 48:
              var Z = this.input.charCodeAt(this.pos + 1);
              if (Z === 120 || Z === 88) return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (Z === 111 || Z === 79) return this.readRadixNumber(8);
                if (Z === 98 || Z === 66) return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(!1);
            case 34:
            case 39:
              return this.readString(A);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(A);
            case 124:
            case 38:
              return this.readToken_pipe_amp(A);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(A);
            case 60:
            case 62:
              return this.readToken_lt_gt(A);
            case 61:
            case 33:
              return this.readToken_eq_excl(A);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(se.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + Xe(A) + "'");
        }, At.finishOp = function(A, Z) {
          var he = this.input.slice(this.pos, this.pos + Z);
          return this.pos += Z, this.finishToken(A, he);
        }, At.readRegexp = function() {
          for (var A, Z, he = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(he, "Unterminated regular expression");
            var ve = this.input.charAt(this.pos);
            if (be.test(ve) && this.raise(he, "Unterminated regular expression"), A) A = !1;
            else {
              if (ve === "[") Z = !0;
              else if (ve === "]" && Z) Z = !1;
              else if (ve === "/" && !Z) break;
              A = ve === "\\";
            }
            ++this.pos;
          }
          var ke = this.input.slice(he, this.pos);
          ++this.pos;
          var Le = this.pos, je = this.readWord1();
          this.containsEsc && this.unexpected(Le);
          var Ge = this.regexpState || (this.regexpState = new pt(this));
          Ge.reset(he, ke, je), this.validateRegExpFlags(Ge), this.validateRegExpPattern(Ge);
          var lt = null;
          try {
            lt = new RegExp(ke, je);
          } catch {
          }
          return this.finishToken(se.regexp, { pattern: ke, flags: je, value: lt });
        }, At.readInt = function(A, Z, he) {
          for (var ve = this.options.ecmaVersion >= 12 && Z === void 0, ke = he && this.input.charCodeAt(this.pos) === 48, Le = this.pos, je = 0, Ge = 0, lt = 0, gt = Z ?? 1 / 0; lt < gt; ++lt, ++this.pos) {
            var ot = this.input.charCodeAt(this.pos), kt = void 0;
            if (ve && ot === 95) ke && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), Ge === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), lt === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), Ge = ot;
            else {
              if ((kt = ot >= 97 ? ot - 97 + 10 : ot >= 65 ? ot - 65 + 10 : ot >= 48 && ot <= 57 ? ot - 48 : 1 / 0) >= A) break;
              Ge = ot, je = je * A + kt;
            }
          }
          return ve && Ge === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === Le || Z != null && this.pos - Le !== Z ? null : je;
        }, At.readRadixNumber = function(A) {
          var Z = this.pos;
          this.pos += 2;
          var he = this.readInt(A);
          return he == null && this.raise(this.start + 2, "Expected number in radix " + A), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (he = Er(this.input.slice(Z, this.pos)), ++this.pos) : ce(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(se.num, he);
        }, At.readNumber = function(A) {
          var Z = this.pos;
          A || this.readInt(10, void 0, !0) !== null || this.raise(Z, "Invalid number");
          var he = this.pos - Z >= 2 && this.input.charCodeAt(Z) === 48;
          he && this.strict && this.raise(Z, "Invalid number");
          var ve = this.input.charCodeAt(this.pos);
          if (!he && !A && this.options.ecmaVersion >= 11 && ve === 110) {
            var ke = Er(this.input.slice(Z, this.pos));
            return ++this.pos, ce(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(se.num, ke);
          }
          he && /[89]/.test(this.input.slice(Z, this.pos)) && (he = !1), ve !== 46 || he || (++this.pos, this.readInt(10), ve = this.input.charCodeAt(this.pos)), ve !== 69 && ve !== 101 || he || ((ve = this.input.charCodeAt(++this.pos)) !== 43 && ve !== 45 || ++this.pos, this.readInt(10) === null && this.raise(Z, "Invalid number")), ce(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var Le, je = (Le = this.input.slice(Z, this.pos), he ? parseInt(Le, 8) : parseFloat(Le.replace(/_/g, "")));
          return this.finishToken(se.num, je);
        }, At.readCodePoint = function() {
          var A;
          if (this.input.charCodeAt(this.pos) === 123) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var Z = ++this.pos;
            A = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, A > 1114111 && this.invalidStringToken(Z, "Code point out of bounds");
          } else A = this.readHexChar(4);
          return A;
        }, At.readString = function(A) {
          for (var Z = "", he = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var ve = this.input.charCodeAt(this.pos);
            if (ve === A) break;
            ve === 92 ? (Z += this.input.slice(he, this.pos), Z += this.readEscapedChar(!1), he = this.pos) : ve === 8232 || ve === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Oe(ve) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return Z += this.input.slice(he, this.pos++), this.finishToken(se.string, Z);
        };
        var On = {};
        At.tryReadTemplateToken = function() {
          this.inTemplateElement = !0;
          try {
            this.readTmplToken();
          } catch (A) {
            if (A !== On) throw A;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = !1;
        }, At.invalidStringToken = function(A, Z) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw On;
          this.raise(A, Z);
        }, At.readTmplToken = function() {
          for (var A = "", Z = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var he = this.input.charCodeAt(this.pos);
            if (he === 96 || he === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos !== this.start || this.type !== se.template && this.type !== se.invalidTemplate ? (A += this.input.slice(Z, this.pos), this.finishToken(se.template, A)) : he === 36 ? (this.pos += 2, this.finishToken(se.dollarBraceL)) : (++this.pos, this.finishToken(se.backQuote));
            if (he === 92) A += this.input.slice(Z, this.pos), A += this.readEscapedChar(!0), Z = this.pos;
            else if (Oe(he)) {
              switch (A += this.input.slice(Z, this.pos), ++this.pos, he) {
                case 13:
                  this.input.charCodeAt(this.pos) === 10 && ++this.pos;
                case 10:
                  A += `
`;
                  break;
                default:
                  A += String.fromCharCode(he);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), Z = this.pos;
            } else ++this.pos;
          }
        }, At.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") break;
            case "`":
              return this.finishToken(se.invalidTemplate, this.input.slice(this.start, this.pos));
          }
          this.raise(this.start, "Unterminated template");
        }, At.readEscapedChar = function(A) {
          var Z = this.input.charCodeAt(++this.pos);
          switch (++this.pos, Z) {
            case 110:
              return `
`;
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return Xe(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              this.input.charCodeAt(this.pos) === 10 && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), A) {
                var he = this.pos - 1;
                this.invalidStringToken(he, "Invalid escape sequence in template string");
              }
            default:
              if (Z >= 48 && Z <= 55) {
                var ve = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], ke = parseInt(ve, 8);
                return ke > 255 && (ve = ve.slice(0, -1), ke = parseInt(ve, 8)), this.pos += ve.length - 1, Z = this.input.charCodeAt(this.pos), ve === "0" && Z !== 56 && Z !== 57 || !this.strict && !A || this.invalidStringToken(this.pos - 1 - ve.length, A ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(ke);
              }
              return Oe(Z) ? "" : String.fromCharCode(Z);
          }
        }, At.readHexChar = function(A) {
          var Z = this.pos, he = this.readInt(16, A);
          return he === null && this.invalidStringToken(Z, "Bad character escape sequence"), he;
        }, At.readWord1 = function() {
          this.containsEsc = !1;
          for (var A = "", Z = !0, he = this.pos, ve = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var ke = this.fullCharCodeAtPos();
            if (ee(ke, ve)) this.pos += ke <= 65535 ? 1 : 2;
            else {
              if (ke !== 92) break;
              this.containsEsc = !0, A += this.input.slice(he, this.pos);
              var Le = this.pos;
              this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var je = this.readCodePoint();
              (Z ? ce : ee)(je, ve) || this.invalidStringToken(Le, "Invalid Unicode escape"), A += Xe(je), he = this.pos;
            }
            Z = !1;
          }
          return A + this.input.slice(he, this.pos);
        }, At.readWord = function() {
          var A = this.readWord1(), Z = se.name;
          return this.keywords.test(A) && (Z = we[A]), this.finishToken(Z, A);
        }, it.acorn = { Parser: it, version: "8.11.3", defaultOptions: Me, Position: We, SourceLocation: et, getLineInfo: De, Node: dn, TokenType: ae, tokTypes: se, keywordTypes: we, TokContext: Jt, tokContexts: Mt, isIdentifierChar: ee, isIdentifierStart: ce, Token: wr, isNewLine: Oe, lineBreak: be, lineBreakG: Ie, nonASCIIwhitespace: Fe };
        const Sn = Rr, fr = oi, en = /^\.?\//;
        function bi(A = "", Z) {
          return A.endsWith("/") ? A : A + "/";
        }
        function fa(A) {
          return A && A !== "/";
        }
        function So(A, ...Z) {
          let he = A || "";
          for (const ve of Z.filter((ke) => fa(ke))) if (he) {
            const ke = ve.replace(en, "");
            he = bi(he) + ke;
          } else he = ve;
          return he;
        }
        const Lt = Ns, ii = Su(), Ci = ky, La = Qr, Kp = Rr, wo = Fi, xo = new Set(Sn.builtinModules);
        function $l(A) {
          return A.replace(/\\/g, "/");
        }
        const Tc = {}.hasOwnProperty, Yp = /^([A-Z][a-z\d]*)+$/, ja = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), kn = {};
        function Te(A, Z = "and") {
          return A.length < 3 ? A.join(` ${Z} `) : `${A.slice(0, -1).join(", ")}, ${Z} ${A[A.length - 1]}`;
        }
        const p = /* @__PURE__ */ new Map();
        let w;
        function q(A, Z, he) {
          return p.set(A, Z), /* @__PURE__ */ function(ve, ke) {
            return Le;
            function Le(...je) {
              const Ge = Error.stackTraceLimit;
              ne() && (Error.stackTraceLimit = 0);
              const lt = new ve();
              ne() && (Error.stackTraceLimit = Ge);
              const gt = function(ot, kt, qt) {
                const hr = p.get(ot);
                if (ii(hr !== void 0, "expected `message` to be found"), typeof hr == "function") return ii(hr.length <= kt.length, `Code: ${ot}; The provided arguments length (${kt.length}) does not match the required ones (${hr.length}).`), Reflect.apply(hr, qt, kt);
                const Lr = /%[dfijoOs]/g;
                let wn = 0;
                for (; Lr.exec(hr) !== null; ) wn++;
                return ii(wn === kt.length, `Code: ${ot}; The provided arguments length (${kt.length}) does not match the required ones (${wn}).`), kt.length === 0 ? hr : (kt.unshift(hr), Reflect.apply(wo.format, null, kt));
              }(ke, je, lt);
              return Object.defineProperties(lt, { message: { value: gt, enumerable: !1, writable: !0, configurable: !0 }, toString: { value() {
                return `${this.name} [${ke}]: ${this.message}`;
              }, enumerable: !1, writable: !0, configurable: !0 } }), pe(lt), lt.code = ke, lt;
            }
          }(he, A);
        }
        function ne() {
          try {
            if (Kp.startupSnapshot.isBuildingSnapshot()) return !1;
          } catch {
          }
          const A = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return A === void 0 ? Object.isExtensible(Error) : Tc.call(A, "writable") && A.writable !== void 0 ? A.writable : A.set !== void 0;
        }
        kn.ERR_INVALID_ARG_TYPE = q("ERR_INVALID_ARG_TYPE", (A, Z, he) => {
          ii(typeof A == "string", "'name' must be a string"), Array.isArray(Z) || (Z = [Z]);
          let ve = "The ";
          if (A.endsWith(" argument")) ve += `${A} `;
          else {
            const Ge = A.includes(".") ? "property" : "argument";
            ve += `"${A}" ${Ge} `;
          }
          ve += "must be ";
          const ke = [], Le = [], je = [];
          for (const Ge of Z) ii(typeof Ge == "string", "All expected entries have to be of type string"), ja.has(Ge) ? ke.push(Ge.toLowerCase()) : Yp.exec(Ge) === null ? (ii(Ge !== "object", 'The value "object" should be written as "Object"'), je.push(Ge)) : Le.push(Ge);
          if (Le.length > 0) {
            const Ge = ke.indexOf("object");
            Ge !== -1 && (ke.slice(Ge, 1), Le.push("Object"));
          }
          return ke.length > 0 && (ve += `${ke.length > 1 ? "one of type" : "of type"} ${Te(ke, "or")}`, (Le.length > 0 || je.length > 0) && (ve += " or ")), Le.length > 0 && (ve += `an instance of ${Te(Le, "or")}`, je.length > 0 && (ve += " or ")), je.length > 0 && (je.length > 1 ? ve += `one of ${Te(je, "or")}` : (je[0].toLowerCase() !== je[0] && (ve += "an "), ve += `${je[0]}`)), ve += `. Received ${function(Ge) {
            if (Ge == null) return String(Ge);
            if (typeof Ge == "function" && Ge.name) return `function ${Ge.name}`;
            if (typeof Ge == "object") return Ge.constructor && Ge.constructor.name ? `an instance of ${Ge.constructor.name}` : `${(0, wo.inspect)(Ge, { depth: -1 })}`;
            let lt = (0, wo.inspect)(Ge, { colors: !1 });
            return lt.length > 28 && (lt = `${lt.slice(0, 25)}...`), `type ${typeof Ge} (${lt})`;
          }(he)}`, ve;
        }, TypeError), kn.ERR_INVALID_MODULE_SPECIFIER = q("ERR_INVALID_MODULE_SPECIFIER", (A, Z, he = void 0) => `Invalid module "${A}" ${Z}${he ? ` imported from ${he}` : ""}`, TypeError), kn.ERR_INVALID_PACKAGE_CONFIG = q("ERR_INVALID_PACKAGE_CONFIG", (A, Z, he) => `Invalid package config ${A}${Z ? ` while importing ${Z}` : ""}${he ? `. ${he}` : ""}`, Error), kn.ERR_INVALID_PACKAGE_TARGET = q("ERR_INVALID_PACKAGE_TARGET", (A, Z, he, ve = !1, ke = void 0) => {
          const Le = typeof he == "string" && !ve && he.length > 0 && !he.startsWith("./");
          return Z === "." ? (ii(ve === !1), `Invalid "exports" main target ${JSON.stringify(he)} defined in the package config ${A}package.json${ke ? ` imported from ${ke}` : ""}${Le ? '; targets must start with "./"' : ""}`) : `Invalid "${ve ? "imports" : "exports"}" target ${JSON.stringify(he)} defined for '${Z}' in the package config ${A}package.json${ke ? ` imported from ${ke}` : ""}${Le ? '; targets must start with "./"' : ""}`;
        }, Error), kn.ERR_MODULE_NOT_FOUND = q("ERR_MODULE_NOT_FOUND", (A, Z, he = !1) => `Cannot find ${he ? "module" : "package"} '${A}' imported from ${Z}`, Error), kn.ERR_NETWORK_IMPORT_DISALLOWED = q("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), kn.ERR_PACKAGE_IMPORT_NOT_DEFINED = q("ERR_PACKAGE_IMPORT_NOT_DEFINED", (A, Z, he) => `Package import specifier "${A}" is not defined${Z ? ` in package ${Z}package.json` : ""} imported from ${he}`, TypeError), kn.ERR_PACKAGE_PATH_NOT_EXPORTED = q("ERR_PACKAGE_PATH_NOT_EXPORTED", (A, Z, he = void 0) => Z === "." ? `No "exports" main defined in ${A}package.json${he ? ` imported from ${he}` : ""}` : `Package subpath '${Z}' is not defined by "exports" in ${A}package.json${he ? ` imported from ${he}` : ""}`, Error), kn.ERR_UNSUPPORTED_DIR_IMPORT = q("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), kn.ERR_UNSUPPORTED_RESOLVE_REQUEST = q("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), kn.ERR_UNKNOWN_FILE_EXTENSION = q("ERR_UNKNOWN_FILE_EXTENSION", (A, Z) => `Unknown file extension "${A}" for ${Z}`, TypeError), kn.ERR_INVALID_ARG_VALUE = q("ERR_INVALID_ARG_VALUE", (A, Z, he = "is invalid") => {
          let ve = (0, wo.inspect)(Z);
          return ve.length > 128 && (ve = `${ve.slice(0, 128)}...`), `The ${A.includes(".") ? "property" : "argument"} '${A}' ${he}. Received ${ve}`;
        }, TypeError);
        const pe = function(A) {
          const Z = "__node_internal_" + A.name;
          return Object.defineProperty(A, "name", { value: Z }), A;
        }(function(A) {
          const Z = ne();
          return Z && (w = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(A), Z && (Error.stackTraceLimit = w), A;
        }), xe = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: Ce } = kn, Re = /* @__PURE__ */ new Map();
        function Ue(A, { base: Z, specifier: he }) {
          const ve = Re.get(A);
          if (ve) return ve;
          let ke;
          try {
            ke = fr.readFileSync(La.toNamespacedPath(A), "utf8");
          } catch (je) {
            const Ge = je;
            if (Ge.code !== "ENOENT") throw Ge;
          }
          const Le = { exists: !1, pjsonPath: A, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (ke !== void 0) {
            let je;
            try {
              je = JSON.parse(ke);
            } catch (Ge) {
              const lt = Ge, gt = new Ce(A, (Z ? `"${he}" from ` : "") + (0, Lt.fileURLToPath)(Z || he), lt.message);
              throw gt.cause = lt, gt;
            }
            Le.exists = !0, xe.call(je, "name") && typeof je.name == "string" && (Le.name = je.name), xe.call(je, "main") && typeof je.main == "string" && (Le.main = je.main), xe.call(je, "exports") && (Le.exports = je.exports), xe.call(je, "imports") && (Le.imports = je.imports), !xe.call(je, "type") || je.type !== "commonjs" && je.type !== "module" || (Le.type = je.type);
          }
          return Re.set(A, Le), Le;
        }
        function Ke(A) {
          let Z = new URL("package.json", A);
          for (; !Z.pathname.endsWith("node_modules/package.json"); ) {
            const he = Ue((0, Lt.fileURLToPath)(Z), { specifier: A });
            if (he.exists) return he;
            const ve = Z;
            if (Z = new URL("../package.json", Z), Z.pathname === ve.pathname) break;
          }
          return { pjsonPath: (0, Lt.fileURLToPath)(Z), exists: !1, type: "none" };
        }
        function yt(A) {
          return Ke(A).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: $t } = kn, wt = {}.hasOwnProperty, Ht = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" }, Gr = { __proto__: null, "data:": function(A) {
          const { 1: Z } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(A.pathname) || [null, null, null];
          return function(he) {
            return he && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(he) ? "module" : he === "application/json" ? "json" : null;
          }(Z);
        }, "file:": function(A, Z, he) {
          const ve = function(je) {
            const Ge = je.pathname;
            let lt = Ge.length;
            for (; lt--; ) {
              const gt = Ge.codePointAt(lt);
              if (gt === 47) return "";
              if (gt === 46) return Ge.codePointAt(lt - 1) === 47 ? "" : Ge.slice(lt);
            }
            return "";
          }(A);
          if (ve === ".js") {
            const je = yt(A);
            return je !== "none" ? je : "commonjs";
          }
          if (ve === "") {
            const je = yt(A);
            return je === "none" || je === "commonjs" ? "commonjs" : "module";
          }
          const ke = Ht[ve];
          if (ke) return ke;
          if (he) return;
          const Le = (0, Lt.fileURLToPath)(A);
          throw new $t(ve, Le);
        }, "http:": Vr, "https:": Vr, "node:": () => "builtin" };
        function Vr() {
        }
        const ur = RegExp.prototype[Symbol.replace], { ERR_NETWORK_IMPORT_DISALLOWED: hn, ERR_INVALID_MODULE_SPECIFIER: To, ERR_INVALID_PACKAGE_CONFIG: Ao, ERR_INVALID_PACKAGE_TARGET: BI, ERR_MODULE_NOT_FOUND: Xp, ERR_PACKAGE_IMPORT_NOT_DEFINED: $I, ERR_PACKAGE_PATH_NOT_EXPORTED: UI, ERR_UNSUPPORTED_DIR_IMPORT: VI, ERR_UNSUPPORTED_RESOLVE_REQUEST: ev } = kn, tv = {}.hasOwnProperty, rv = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, nv = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, WI = /^\.|%|\\/, Ac = /\*/g, qI = /%2f|%5c/i, iv = /* @__PURE__ */ new Set(), HI = /[/\\]{2}/;
        function sv(A, Z, he, ve, ke, Le, je) {
          if (Ci.noDeprecation) return;
          const Ge = (0, Lt.fileURLToPath)(ve), lt = HI.exec(je ? A : Z) !== null;
          Ci.emitWarning(`Use of deprecated ${lt ? "double slash" : "leading or trailing slash matching"} resolving "${A}" for module request "${Z}" ${Z === he ? "" : `matched to "${he}" `}in the "${ke ? "imports" : "exports"}" field module resolution of the package at ${Ge}${Le ? ` imported from ${(0, Lt.fileURLToPath)(Le)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function av(A, Z, he, ve) {
          if (Ci.noDeprecation || function(lt, gt) {
            const ot = lt.protocol;
            return wt.call(Gr, ot) && Gr[ot](lt, gt, !0) || null;
          }(A, { parentURL: he.href }) !== "module") return;
          const Le = (0, Lt.fileURLToPath)(A.href), je = (0, Lt.fileURLToPath)(new Lt.URL(".", Z)), Ge = (0, Lt.fileURLToPath)(he);
          ve ? La.resolve(je, ve) !== Le && Ci.emitWarning(`Package ${je} has a "main" field set to "${ve}", excluding the full filename and extension to the resolved file at "${Le.slice(je.length)}", imported from ${Ge}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : Ci.emitWarning(`No "main" or "exports" field defined in the package.json for ${je} resolving the main entry point "${Le.slice(je.length)}", imported from ${Ge}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function ov(A) {
          try {
            return (0, fr.statSync)(A);
          } catch {
          }
        }
        function Jp(A) {
          const Z = (0, fr.statSync)(A, { throwIfNoEntry: !1 }), he = Z ? Z.isFile() : void 0;
          return he != null && he;
        }
        function GI(A, Z, he) {
          let ve;
          if (Z.main !== void 0) {
            if (ve = new Lt.URL(Z.main, A), Jp(ve)) return ve;
            const je = [`./${Z.main}.js`, `./${Z.main}.json`, `./${Z.main}.node`, `./${Z.main}/index.js`, `./${Z.main}/index.json`, `./${Z.main}/index.node`];
            let Ge = -1;
            for (; ++Ge < je.length && (ve = new Lt.URL(je[Ge], A), !Jp(ve)); ) ve = void 0;
            if (ve) return av(ve, A, he, Z.main), ve;
          }
          const ke = ["./index.js", "./index.json", "./index.node"];
          let Le = -1;
          for (; ++Le < ke.length && (ve = new Lt.URL(ke[Le], A), !Jp(ve)); ) ve = void 0;
          if (ve) return av(ve, A, he, Z.main), ve;
          throw new Xp((0, Lt.fileURLToPath)(new Lt.URL(".", A)), (0, Lt.fileURLToPath)(he));
        }
        function Qp(A, Z, he) {
          return new UI((0, Lt.fileURLToPath)(new Lt.URL(".", Z)), A, he && (0, Lt.fileURLToPath)(he));
        }
        function Ul(A, Z, he, ve, ke) {
          return Z = typeof Z == "object" && Z !== null ? JSON.stringify(Z, null, "") : `${Z}`, new BI((0, Lt.fileURLToPath)(new Lt.URL(".", he)), A, Z, ve, ke && (0, Lt.fileURLToPath)(ke));
        }
        function zI(A, Z, he, ve, ke, Le, je, Ge, lt) {
          if (Z !== "" && !Le && A[A.length - 1] !== "/") throw Ul(he, A, ve, je, ke);
          if (!A.startsWith("./")) {
            if (je && !A.startsWith("../") && !A.startsWith("/")) {
              let qt = !1;
              try {
                new Lt.URL(A), qt = !0;
              } catch {
              }
              if (!qt)
                return cv(Le ? ur.call(Ac, A, () => Z) : A + Z, ve, lt);
            }
            throw Ul(he, A, ve, je, ke);
          }
          if (rv.exec(A.slice(2)) !== null) {
            if (nv.exec(A.slice(2)) !== null) throw Ul(he, A, ve, je, ke);
            if (!Ge) {
              const qt = Le ? he.replace("*", () => Z) : he + Z;
              sv(Le ? ur.call(Ac, A, () => Z) : A, qt, he, ve, je, ke, !0);
            }
          }
          const gt = new Lt.URL(A, ve), ot = gt.pathname, kt = new Lt.URL(".", ve).pathname;
          if (!ot.startsWith(kt)) throw Ul(he, A, ve, je, ke);
          if (Z === "") return gt;
          if (rv.exec(Z) !== null) {
            const qt = Le ? he.replace("*", () => Z) : he + Z;
            nv.exec(Z) === null ? Ge || sv(Le ? ur.call(Ac, A, () => Z) : A, qt, he, ve, je, ke, !1) : function(hr, Lr, wn, qn, Wr) {
              const Fa = `request is not a valid match in pattern "${Lr}" for the "${qn ? "imports" : "exports"}" resolution of ${(0, Lt.fileURLToPath)(wn)}`;
              throw new To(hr, Fa, Wr && (0, Lt.fileURLToPath)(Wr));
            }(qt, he, ve, je, ke);
          }
          return Le ? new Lt.URL(ur.call(Ac, gt.href, () => Z)) : new Lt.URL(Z, gt);
        }
        function KI(A) {
          const Z = Number(A);
          return `${Z}` === A && Z >= 0 && Z < 4294967295;
        }
        function Po(A, Z, he, ve, ke, Le, je, Ge, lt) {
          if (typeof Z == "string") return zI(Z, he, ve, A, ke, Le, je, Ge, lt);
          if (Array.isArray(Z)) {
            const gt = Z;
            if (gt.length === 0) return null;
            let ot, kt = -1;
            for (; ++kt < gt.length; ) {
              const qt = gt[kt];
              let hr;
              try {
                hr = Po(A, qt, he, ve, ke, Le, je, Ge, lt);
              } catch (Lr) {
                if (ot = Lr, Lr.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                throw Lr;
              }
              if (hr !== void 0) {
                if (hr !== null) return hr;
                ot = null;
              }
            }
            if (ot == null) return null;
            throw ot;
          }
          if (typeof Z == "object" && Z !== null) {
            const gt = Object.getOwnPropertyNames(Z);
            let ot = -1;
            for (; ++ot < gt.length; )
              if (KI(gt[ot])) throw new Ao((0, Lt.fileURLToPath)(A), ke, '"exports" cannot contain numeric property keys.');
            for (ot = -1; ++ot < gt.length; ) {
              const kt = gt[ot];
              if (kt === "default" || lt && lt.has(kt)) {
                const qt = Po(A, Z[kt], he, ve, ke, Le, je, Ge, lt);
                if (qt === void 0) continue;
                return qt;
              }
            }
            return null;
          }
          if (Z === null) return null;
          throw Ul(ve, Z, A, je, ke);
        }
        function YI(A, Z, he) {
          if (Ci.noDeprecation) return;
          const ve = (0, Lt.fileURLToPath)(Z);
          iv.has(ve + "|" + A) || (iv.add(ve + "|" + A), Ci.emitWarning(`Use of deprecated trailing slash pattern mapping "${A}" in the "exports" field module resolution of the package at ${ve}${he ? ` imported from ${(0, Lt.fileURLToPath)(he)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function lv(A, Z, he, ve, ke) {
          let Le = he.exports;
          if (function(ot, kt, qt) {
            if (typeof ot == "string" || Array.isArray(ot)) return !0;
            if (typeof ot != "object" || ot === null) return !1;
            const hr = Object.getOwnPropertyNames(ot);
            let Lr = !1, wn = 0, qn = -1;
            for (; ++qn < hr.length; ) {
              const Wr = hr[qn], Fa = Wr === "" || Wr[0] !== ".";
              if (wn++ == 0) Lr = Fa;
              else if (Lr !== Fa) throw new Ao((0, Lt.fileURLToPath)(kt), qt, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return Lr;
          }(Le, A, ve) && (Le = { ".": Le }), tv.call(Le, Z) && !Z.includes("*") && !Z.endsWith("/")) {
            const ot = Po(A, Le[Z], "", Z, ve, !1, !1, !1, ke);
            if (ot == null) throw Qp(Z, A, ve);
            return ot;
          }
          let je = "", Ge = "";
          const lt = Object.getOwnPropertyNames(Le);
          let gt = -1;
          for (; ++gt < lt.length; ) {
            const ot = lt[gt], kt = ot.indexOf("*");
            if (kt !== -1 && Z.startsWith(ot.slice(0, kt))) {
              Z.endsWith("/") && YI(Z, A, ve);
              const qt = ot.slice(kt + 1);
              Z.length >= ot.length && Z.endsWith(qt) && uv(je, ot) === 1 && ot.lastIndexOf("*") === kt && (je = ot, Ge = Z.slice(kt, Z.length - qt.length));
            }
          }
          if (je) {
            const ot = Po(A, Le[je], Ge, je, ve, !0, !1, Z.endsWith("/"), ke);
            if (ot == null) throw Qp(Z, A, ve);
            return ot;
          }
          throw Qp(Z, A, ve);
        }
        function uv(A, Z) {
          const he = A.indexOf("*"), ve = Z.indexOf("*"), ke = he === -1 ? A.length : he + 1, Le = ve === -1 ? Z.length : ve + 1;
          return ke > Le ? -1 : Le > ke || he === -1 ? 1 : ve === -1 || A.length > Z.length ? -1 : Z.length > A.length ? 1 : 0;
        }
        function XI(A, Z, he) {
          if (A === "#" || A.startsWith("#/") || A.endsWith("/"))
            throw new To(A, "is not a valid internal imports specifier name", (0, Lt.fileURLToPath)(Z));
          let ve;
          const ke = Ke(Z);
          if (ke.exists) {
            ve = (0, Lt.pathToFileURL)(ke.pjsonPath);
            const Le = ke.imports;
            if (Le) if (tv.call(Le, A) && !A.includes("*")) {
              const je = Po(ve, Le[A], "", A, Z, !1, !0, !1, he);
              if (je != null) return je;
            } else {
              let je = "", Ge = "";
              const lt = Object.getOwnPropertyNames(Le);
              let gt = -1;
              for (; ++gt < lt.length; ) {
                const ot = lt[gt], kt = ot.indexOf("*");
                if (kt !== -1 && A.startsWith(ot.slice(0, -1))) {
                  const qt = ot.slice(kt + 1);
                  A.length >= ot.length && A.endsWith(qt) && uv(je, ot) === 1 && ot.lastIndexOf("*") === kt && (je = ot, Ge = A.slice(kt, A.length - qt.length));
                }
              }
              if (je) {
                const ot = Po(ve, Le[je], Ge, je, Z, !0, !0, !1, he);
                if (ot != null) return ot;
              }
            }
          }
          throw function(Le, je, Ge) {
            return new $I(Le, je && (0, Lt.fileURLToPath)(new Lt.URL(".", je)), (0, Lt.fileURLToPath)(Ge));
          }(A, ve, Z);
        }
        function cv(A, Z, he) {
          if (Sn.builtinModules.includes(A)) return new Lt.URL("node:" + A);
          const { packageName: ve, packageSubpath: ke, isScoped: Le } = function(ot, kt) {
            let qt = ot.indexOf("/"), hr = !0, Lr = !1;
            ot[0] === "@" && (Lr = !0, qt === -1 || ot.length === 0 ? hr = !1 : qt = ot.indexOf("/", qt + 1));
            const wn = qt === -1 ? ot : ot.slice(0, qt);
            if (WI.exec(wn) !== null && (hr = !1), !hr) throw new To(ot, "is not a valid package name", (0, Lt.fileURLToPath)(kt));
            return { packageName: wn, packageSubpath: "." + (qt === -1 ? "" : ot.slice(qt)), isScoped: Lr };
          }(A, Z), je = Ke(Z);
          if (je.exists) {
            const ot = (0, Lt.pathToFileURL)(je.pjsonPath);
            if (je.name === ve && je.exports !== void 0 && je.exports !== null) return lv(ot, ke, je, Z, he);
          }
          let Ge, lt = new Lt.URL("./node_modules/" + ve + "/package.json", Z), gt = (0, Lt.fileURLToPath)(lt);
          do {
            const ot = ov(gt.slice(0, -13));
            if (!ot || !ot.isDirectory()) {
              Ge = gt, lt = new Lt.URL((Le ? "../../../../node_modules/" : "../../../node_modules/") + ve + "/package.json", lt), gt = (0, Lt.fileURLToPath)(lt);
              continue;
            }
            const kt = Ue(gt, { base: Z, specifier: A });
            return kt.exports !== void 0 && kt.exports !== null ? lv(lt, ke, kt, Z, he) : ke === "." ? GI(lt, kt, Z) : new Lt.URL(ke, lt);
          } while (gt.length !== Ge.length);
          throw new Xp(ve, (0, Lt.fileURLToPath)(Z), !1);
        }
        function JI(A, Z, he, ve) {
          const ke = Z.protocol, Le = ke === "data:" || ke === "http:" || ke === "https:";
          let je;
          if (function(Ge) {
            return Ge !== "" && (Ge[0] === "/" || function(lt) {
              return lt[0] === "." && (lt.length === 1 || lt[1] === "/" || lt[1] === "." && (lt.length === 2 || lt[2] === "/"));
            }(Ge));
          }(A)) try {
            je = new Lt.URL(A, Z);
          } catch (Ge) {
            const lt = new ev(A, Z);
            throw lt.cause = Ge, lt;
          }
          else if (ke === "file:" && A[0] === "#") je = XI(A, Z, he);
          else try {
            je = new Lt.URL(A);
          } catch (Ge) {
            if (Le && !Sn.builtinModules.includes(A)) {
              const lt = new ev(A, Z);
              throw lt.cause = Ge, lt;
            }
            je = cv(A, Z, he);
          }
          return ii(je !== void 0, "expected to be defined"), je.protocol !== "file:" ? je : function(Ge, lt, gt) {
            if (qI.exec(Ge.pathname) !== null) throw new To(Ge.pathname, 'must not include encoded "/" or "\\" characters', (0, Lt.fileURLToPath)(lt));
            let ot;
            try {
              ot = (0, Lt.fileURLToPath)(Ge);
            } catch (qt) {
              const hr = qt;
              throw Object.defineProperty(hr, "input", { value: String(Ge) }), Object.defineProperty(hr, "module", { value: String(lt) }), hr;
            }
            const kt = ov(ot.endsWith("/") ? ot.slice(-1) : ot);
            if (kt && kt.isDirectory()) {
              const qt = new VI(ot, (0, Lt.fileURLToPath)(lt));
              throw qt.url = String(Ge), qt;
            }
            if (!kt || !kt.isFile()) {
              const qt = new Xp(ot || Ge.pathname, lt && (0, Lt.fileURLToPath)(lt), !0);
              throw qt.url = String(Ge), qt;
            }
            {
              const qt = (0, fr.realpathSync)(ot), { search: hr, hash: Lr } = Ge;
              (Ge = (0, Lt.pathToFileURL)(qt + (ot.endsWith(La.sep) ? "/" : ""))).search = hr, Ge.hash = Lr;
            }
            return Ge;
          }(je, Z);
        }
        function Pc(A) {
          return typeof A != "string" || A.startsWith("file://") ? $l((0, Lt.fileURLToPath)(A)) : $l(A);
        }
        function Zp(A) {
          return (0, Lt.pathToFileURL)(Pc(A)).toString();
        }
        const QI = /* @__PURE__ */ new Set(["node", "import"]), ZI = [".mjs", ".cjs", ".js", ".json"], e6 = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND", "ERR_PACKAGE_PATH_NOT_EXPORTED"]);
        function fv(A, Z, he) {
          try {
            return JI(A, Z, he);
          } catch (ve) {
            if (!e6.has(ve == null ? void 0 : ve.code)) throw ve;
          }
        }
        function t6(A, Z = {}) {
          if (typeof A != "string") {
            if (!(A instanceof URL)) throw new TypeError("input must be a `string` or `URL`");
            A = Pc(A);
          }
          if (/(node|data|http|https):/.test(A)) return A;
          if (xo.has(A)) return "node:" + A;
          if (A.startsWith("file://") && (A = Pc(A)), O(A)) try {
            if ((0, fr.statSync)(A).isFile()) return Zp(A);
          } catch (je) {
            if ((je == null ? void 0 : je.code) !== "ENOENT") throw je;
          }
          const he = Z.conditions ? new Set(Z.conditions) : QI, ve = (Array.isArray(Z.url) ? Z.url : [Z.url]).filter(Boolean).map((je) => new URL(function(Ge) {
            return typeof Ge != "string" && (Ge = Ge.toString()), /(node|data|http|https|file):/.test(Ge) ? Ge : xo.has(Ge) ? "node:" + Ge : "file://" + encodeURI($l(Ge));
          }(je.toString())));
          ve.length === 0 && ve.push(new URL(Zp(Ze.cwd())));
          const ke = [...ve];
          for (const je of ve) je.protocol === "file:" && ke.push(new URL("./", je), new URL(So(je.pathname, "_index.js"), je), new URL("node_modules", je));
          let Le;
          for (const je of ke) {
            if (Le = fv(A, je, he), Le) break;
            for (const Ge of ["", "/index"]) {
              for (const lt of Z.extensions || ZI) if (Le = fv(A + Ge + lt, je, he), Le) break;
              if (Le) break;
            }
            if (Le) break;
          }
          if (!Le) {
            const je = new Error(`Cannot find module ${A} imported from ${ke.join(", ")}`);
            throw je.code = "ERR_MODULE_NOT_FOUND", je;
          }
          return Zp(Le);
        }
        function r6(A, Z) {
          return t6(A, Z);
        }
        function n6(A, Z) {
          return Pc(r6(A, Z));
        }
        const i6 = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m, s6 = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
        function a6(A, Z = {}) {
          return Z.stripComments && (A = A.replace(s6, "")), i6.test(A);
        }
        var o6 = l("crypto");
        function dv(A, Z = 8) {
          return (0, o6.createHash)("md5").update(A).digest("hex").slice(0, Z);
        }
        var l6 = function(A, Z, he, ve) {
          return new (he || (he = Promise))(function(ke, Le) {
            function je(gt) {
              try {
                lt(ve.next(gt));
              } catch (ot) {
                Le(ot);
              }
            }
            function Ge(gt) {
              try {
                lt(ve.throw(gt));
              } catch (ot) {
                Le(ot);
              }
            }
            function lt(gt) {
              var ot;
              gt.done ? ke(gt.value) : (ot = gt.value, ot instanceof he ? ot : new he(function(kt) {
                kt(ot);
              })).then(je, Ge);
            }
            lt((ve = ve.apply(A, [])).next());
          });
        };
        const u6 = S(Ze.env.JITI_DEBUG), pv = S(Ze.env.JITI_CACHE), c6 = S(Ze.env.JITI_ESM_RESOLVE), hv = S(Ze.env.JITI_REQUIRE_CACHE), mv = S(Ze.env.JITI_SOURCE_MAPS), f6 = S(Ze.env.JITI_ALIAS), d6 = S(Ze.env.JITI_TRANSFORM_MODULES), p6 = S(Ze.env.JITI_NATIVE_MODULES), yv = S(Ze.env.JITI_EXPERIMENTAL_BUN), h6 = (0, i.platform)() === "win32", m6 = { debug: u6, cache: pv === void 0 || !!pv, requireCache: hv === void 0 || !!hv, sourceMaps: mv !== void 0 && !!mv, interopDefault: !1, esmResolve: c6 || !1, cacheVersion: "7", legacy: (0, z.lt)(Ze.version || "0.0.0", "14.0.0"), extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts", ".json"], alias: f6, nativeModules: p6 || [], transformModules: d6 || [], experimentalBun: yv === void 0 ? !!e.bun : !!yv }, y6 = /\.(c|m)?j(sx?)$/, b6 = /\.(c|m)?t(sx?)$/;
        function bv(A, Z = {}, he, ve) {
          (Z = Object.assign(Object.assign({}, m6), Z)).legacy && (Z.cacheVersion += "-legacy"), Z.transformOptions && (Z.cacheVersion += "-" + re()(Z.transformOptions));
          const ke = Z.alias && Object.keys(Z.alias).length > 0 ? W(Z.alias || {}) : null, Le = ["typescript", "jiti", ...Z.nativeModules || []], je = [...Z.transformModules || []], Ge = new RegExp(`node_modules/(${Le.map((Ct) => C(Ct)).join("|")})/`), lt = new RegExp(`node_modules/(${je.map((Ct) => C(Ct)).join("|")})/`);
          function gt(...Ct) {
            Z.debug && console.log("[jiti]", ...Ct);
          }
          if (A || (A = Ze.cwd()), function(Ct) {
            try {
              return (0, h.lstatSync)(Ct).isDirectory();
            } catch {
              return !1;
            }
          }(A) && (A = T(A, "index.js")), Z.cache === !0 && (Z.cache = function() {
            let Ct = (0, i.tmpdir)();
            if (Ze.env.TMPDIR && Ct === Ze.cwd() && !Ze.env.JITI_RESPECT_TMPDIR_ENV) {
              const dr = Ze.env.TMPDIR;
              delete Ze.env.TMPDIR, Ct = (0, i.tmpdir)(), Ze.env.TMPDIR = dr;
            }
            return T(Ct, "node-jiti");
          }()), Z.cache) try {
            if ((0, h.mkdirSync)(Z.cache, { recursive: !0 }), !function(Ct) {
              try {
                return (0, h.accessSync)(Ct, h.constants.W_OK), !0;
              } catch {
                return !1;
              }
            }(Z.cache)) throw new Error("directory is not writable");
          } catch (Ct) {
            gt("Error creating cache directory at ", Z.cache, Ct), Z.cache = !1;
          }
          const ot = H()(h6 ? A.replace(/\//g, "\\") : A), kt = (Ct, dr) => {
            try {
              return ot.resolve(Ct, dr);
            } catch {
            }
          }, qt = (0, s.pathToFileURL)(A), hr = [...Z.extensions].filter((Ct) => Ct !== ".js"), Lr = (Ct, dr) => {
            let _r, xn;
            if (ke && (Ct = function(ar, xr) {
              const tn = y(ar);
              xr = W(xr);
              for (const [rn, da] of Object.entries(xr)) {
                if (!tn.startsWith(rn)) continue;
                const Co = B(rn) ? rn.slice(0, -1) : rn;
                if (B(tn[Co.length])) return T(da, tn.slice(rn.length));
              }
              return tn;
            }(Ct, ke)), Z.esmResolve) {
              const ar = [["node", "require"], ["node", "import"]];
              for (const xr of ar) {
                try {
                  _r = n6(Ct, { url: qt, conditions: xr, extensions: Z.extensions });
                } catch (tn) {
                  xn = tn;
                }
                if (_r) return _r;
              }
            }
            try {
              return ot.resolve(Ct, dr);
            } catch (ar) {
              xn = ar;
            }
            for (const ar of hr)
              if (_r = kt(Ct + ar, dr) || kt(Ct + "/index" + ar, dr), _r || b6.test((he == null ? void 0 : he.filename) || "") && (_r = kt(Ct.replace(y6, ".$1t$2"), dr), _r)) return _r;
            throw xn;
          };
          function wn(Ct) {
            let dr = function(_r, xn, ar) {
              if (!Z.cache || !_r) return ar();
              const xr = ` /* v${Z.cacheVersion}-${dv(xn, 16)} */`, tn = k(I(_r)) + "-" + k(_r), rn = T(Z.cache, tn + "." + dv(_r) + ".js");
              if ((0, h.existsSync)(rn)) {
                const Co = (0, h.readFileSync)(rn, "utf8");
                if (Co.endsWith(xr)) return gt("[cache hit]", _r, "~>", rn), Co;
              }
              gt("[cache miss]", _r);
              const da = ar();
              return da.includes("__JITI_ERROR__") || (0, h.writeFileSync)(rn, da + xr, "utf8"), da;
            }(Ct.filename, Ct.source, () => {
              var _r;
              const xn = Z.transform(Object.assign(Object.assign(Object.assign({ legacy: Z.legacy }, Z.transformOptions), { babel: Object.assign(Object.assign({}, Z.sourceMaps ? { sourceFileName: Ct.filename, sourceMaps: "inline" } : {}), (_r = Z.transformOptions) === null || _r === void 0 ? void 0 : _r.babel) }), Ct));
              return xn.error && Z.debug && gt(xn.error), xn.code;
            });
            return dr.startsWith("#!") && (dr = "// " + dr), dr;
          }
          function qn(Ct) {
            return Z.interopDefault ? function(dr, _r = {}) {
              if ((xn = dr) === null || typeof xn != "object" || !("default" in dr)) return dr;
              var xn;
              const ar = dr.default;
              if (ar == null) return dr;
              const xr = typeof ar;
              if (xr !== "object" && (xr !== "function" || _r.preferNamespace)) return _r.preferNamespace ? dr : ar;
              for (const tn in dr) try {
                tn in ar || Object.defineProperty(ar, tn, { enumerable: tn !== "default", configurable: tn !== "default", get: () => dr[tn] });
              } catch {
              }
              return ar;
            }(Ct) : Ct;
          }
          function Wr(Ct, dr) {
            var _r, xn;
            const ar = ve || {};
            if (Ct.startsWith("node:") ? Ct = Ct.slice(5) : Ct.startsWith("file:") && (Ct = (0, s.fileURLToPath)(Ct)), n.builtinModules.includes(Ct) || Ct === ".pnp.js") return ot(Ct);
            if (Z.experimentalBun && !Z.transformOptions) try {
              gt(`[bun] [native] ${Ct}`);
              const rn = ot(Ct);
              return Z.requireCache === !1 && delete ot.cache[Ct], qn(rn);
            } catch (rn) {
              gt(`[bun] Using fallback for ${Ct} because of an error:`, rn);
            }
            const xr = Lr(Ct), tn = $(xr);
            if (tn === ".json") {
              gt("[json]", xr);
              const rn = ot(Ct);
              return Object.defineProperty(rn, "default", { value: rn }), rn;
            }
            return tn && !Z.extensions.includes(tn) ? (gt("[unknown]", xr), ot(Ct)) : Ge.test(xr) ? (gt("[native]", xr), ot(Ct)) : ar[xr] && (ar[xr].loaded === !0 || (he == null ? void 0 : he.loaded) === !1) ? qn((_r = ar[xr]) === null || _r === void 0 ? void 0 : _r.exports) : Z.requireCache && ot.cache[xr] ? qn((xn = ot.cache[xr]) === null || xn === void 0 ? void 0 : xn.exports) : Fa((0, h.readFileSync)(xr, "utf8"), { id: Ct, filename: xr, ext: tn, cache: ar });
          }
          function Fa(Ct, dr = {}) {
            var _r;
            const xn = dr.id || (dr.filename ? k(dr.filename) : `_jitiEval.${dr.ext || ".js"}`), ar = dr.filename || Lr(xn), xr = dr.ext || $(ar), tn = dr.cache || ve || {}, rn = xr === ".ts" || xr === ".mts" || xr === ".cts", da = xr === ".mjs" || xr === ".js" && ((_r = function(ui) {
              for (; ui && ui !== "." && ui !== "/"; ) {
                ui = T(ui, "..");
                try {
                  const Cc = (0, h.readFileSync)(T(ui, "package.json"), "utf8");
                  try {
                    return JSON.parse(Cc);
                  } catch {
                  }
                  break;
                } catch {
                }
              }
            }(ar)) === null || _r === void 0 ? void 0 : _r.type) === "module", Co = xr !== ".cjs" && (rn || da || lt.test(ar) || a6(Ct) || Z.legacy && Ct.match(/\?\.|\?\?/)), g6 = u.performance.now();
            if (Co)
              Ct = wn({ filename: ar, source: Ct, ts: rn }), gt("[transpile]" + (da ? " [esm]" : ""), ar, `(${Math.round(1e3 * (u.performance.now() - g6)) / 1e3}ms)`);
            else try {
              return gt("[native]", ar), qn(ot(xn));
            } catch (ui) {
              gt("Native require error:", ui), gt("[fallback]", ar), Ct = wn({ filename: ar, source: Ct, ts: rn });
            }
            const ln = new n.Module(ar);
            let gv;
            ln.filename = ar, he && (ln.parent = he, Array.isArray(he.children) && !he.children.includes(ln) && he.children.push(ln)), ln.require = bv(ar, Z, ln, tn), ln.path = I(ar), ln.paths = n.Module._nodeModulePaths(ln.path), tn[ar] = ln, Z.requireCache && (ot.cache[ar] = ln);
            try {
              gv = f().runInThisContext(n.Module.wrap(Ct), { filename: ar, lineOffset: 0, displayErrors: !1 });
            } catch (ui) {
              Z.requireCache && delete ot.cache[ar], Z.onError(ui);
            }
            try {
              gv(ln.exports, ln.require, ln, ln.filename, I(ln.filename));
            } catch (ui) {
              Z.requireCache && delete ot.cache[ar], Z.onError(ui);
            }
            if (ln.exports && ln.exports.__JITI_ERROR__) {
              const { filename: ui, line: Cc, column: vv, code: v6, message: E6 } = ln.exports.__JITI_ERROR__, Ev = new Error(`${v6}: ${E6} 
 ${`${ui}:${Cc}:${vv}`}`);
              Error.captureStackTrace(Ev, Wr), Z.onError(Ev);
            }
            return ln.loaded = !0, qn(ln.exports);
          }
          return Lr.paths = ot.resolve.paths, Wr.resolve = Lr, Wr.cache = Z.requireCache ? ot.cache : {}, Wr.extensions = ot.extensions, Wr.main = ot.main, Wr.transform = wn, Wr.register = function() {
            return (0, Q.addHook)((Ct, dr) => Wr.transform({ source: Ct, filename: dr, ts: !!/\.[cm]?ts$/.test(dr) }), { exts: Z.extensions });
          }, Wr.evalModule = Fa, Wr.import = (Ct, dr) => l6(this, void 0, void 0, function* () {
            return yield Wr(Ct);
          }), Wr;
        }
      })(), t.exports = d.default;
    })();
  }(t0)), t0.exports;
}
var r0 = { exports: {} }, nu = {}, yw;
function HK() {
  if (yw) return nu;
  yw = 1, nu.isatty = function() {
    return !1;
  };
  function t() {
    throw new Error("tty.ReadStream is not implemented");
  }
  nu.ReadStream = t;
  function e() {
    throw new Error("tty.WriteStream is not implemented");
  }
  return nu.WriteStream = e, nu;
}
var bw;
function GK() {
  return bw || (bw = 1, function(t) {
    var e = { node: "18.18.2" };
    (() => {
      var r = { "./node_modules/.pnpm/@ampproject+remapping@2.3.0/node_modules/@ampproject/remapping/dist/remapping.umd.js": function(h, n, u) {
        h.exports = function(i, c) {
          const f = o("", -1, -1, "", null, !1), s = [];
          function o(I, k, L, M, x, _) {
            return { source: I, line: k, column: L, name: M, content: x, ignore: _ };
          }
          function y(I, k, L, M, x) {
            return { map: I, sources: k, source: L, content: M, ignore: x };
          }
          function m(I, k) {
            return y(I, k, "", null, !1);
          }
          function g(I, k, L) {
            return y(null, s, I, k, L);
          }
          function b(I) {
            const k = new c.GenMapping({ file: I.map.file }), { sources: L, map: M } = I, x = M.names, _ = i.decodedMappings(M);
            for (let S = 0; S < _.length; S++) {
              const C = _[S];
              for (let R = 0; R < C.length; R++) {
                const H = C[R], z = H[0];
                let U = f;
                if (H.length !== 1 && (U = v(L[H[1]], H[2], H[3], H.length === 5 ? x[H[4]] : ""), U == null)) continue;
                const { column: P, line: W, name: B, content: Q, source: J, ignore: re } = U;
                c.maybeAddSegment(k, S, z, J, W, P, B), J && Q != null && c.setSourceContent(k, J, Q), re && c.setIgnore(k, J, !0);
              }
            }
            return k;
          }
          function v(I, k, L, M) {
            if (!I.map) return o(I.source, k, L, M, I.content, I.ignore);
            const x = i.traceSegment(I.map, k, L);
            return x == null ? null : x.length === 1 ? f : v(I.sources[x[1]], x[2], x[3], x.length === 5 ? I.map.names[x[4]] : M);
          }
          function T(I) {
            return Array.isArray(I) ? I : [I];
          }
          function E(I, k) {
            const L = T(I).map((_) => new i.TraceMap(_, "")), M = L.pop();
            for (let _ = 0; _ < L.length; _++) if (L[_].sources.length > 1) throw new Error(`Transformation map ${_} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
            let x = O(M, k, "", 0);
            for (let _ = L.length - 1; _ >= 0; _--) x = m(L[_], [x]);
            return x;
          }
          function O(I, k, L, M) {
            const { resolvedSources: x, sourcesContent: _, ignoreList: S } = I, C = M + 1;
            return m(I, x.map((R, H) => {
              const z = { importer: L, depth: C, source: R || "", content: void 0, ignore: void 0 }, U = k(z.source, z), { source: P, content: W, ignore: B } = z;
              return U ? O(new i.TraceMap(U, P), k, P, C) : g(P, W !== void 0 ? W : _ ? _[H] : null, B !== void 0 ? B : !!S && S.includes(H));
            }));
          }
          class D {
            constructor(k, L) {
              const M = L.decodedMappings ? c.toDecodedMap(k) : c.toEncodedMap(k);
              this.version = M.version, this.file = M.file, this.mappings = M.mappings, this.names = M.names, this.ignoreList = M.ignoreList, this.sourceRoot = M.sourceRoot, this.sources = M.sources, L.excludeContent || (this.sourcesContent = M.sourcesContent);
            }
            toString() {
              return JSON.stringify(this);
            }
          }
          function $(I, k, L) {
            const M = typeof L == "object" ? L : { excludeContent: !!L, decodedMappings: !1 }, x = E(I, k);
            return new D(b(x), M);
          }
          return $;
        }(u("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"), u("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.5/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"));
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files lazy recursive": (h) => {
        function n(u) {
          return Promise.resolve().then(() => {
            var i = new Error("Cannot find module '" + u + "'");
            throw i.code = "MODULE_NOT_FOUND", i;
          });
        }
        n.keys = () => [], n.resolve = n, n.id = "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files lazy recursive", h.exports = n;
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive": (h) => {
        function n(u) {
          var i = new Error("Cannot find module '" + u + "'");
          throw i.code = "MODULE_NOT_FOUND", i;
        }
        n.keys = () => [], n.resolve = n, n.id = "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive", h.exports = n;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-class-properties/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = (0, u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((c) => (c.assertVersion(7), { name: "syntax-class-properties", manipulateOptions(f, s) {
          s.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        } }));
        n.default = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-export-namespace-from@7.8.3_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-export-namespace-from/lib/index.js": (h, n, u) => {
        n.A = void 0;
        var i = (0, u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((c) => (c.assertVersion(7), { name: "syntax-export-namespace-from", manipulateOptions(f, s) {
          s.plugins.push("exportNamespaceFrom");
        } }));
        n.A = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-nullish-coalescing-operator@7.8.3_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js": (h, n, u) => {
        n.A = void 0;
        var i = (0, u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((c) => (c.assertVersion(7), { name: "syntax-nullish-coalescing-operator", manipulateOptions(f, s) {
          s.plugins.push("nullishCoalescingOperator");
        } }));
        n.A = i;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-optional-chaining@7.8.3_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js": (h, n, u) => {
        n.A = void 0;
        var i = (0, u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((c) => (c.assertVersion(7), { name: "syntax-optional-chaining", manipulateOptions(f, s) {
          s.plugins.push("optionalChaining");
        } }));
        n.A = i;
      }, "./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.5/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js": function(h, n, u) {
        (function(i, c, f, s) {
          class T {
            constructor({ file: re, sourceRoot: G } = {}) {
              this._names = new c.SetArray(), this._sources = new c.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = re, this.sourceRoot = G, this._ignoreList = new c.SetArray();
            }
          }
          function E(J) {
            return J;
          }
          function O(J, re, G, N, V, F, X, K) {
            return C(!1, J, re, G, N, V, F, X, K);
          }
          function D(J, re) {
            return Q(!1, J, re);
          }
          const $ = (J, re, G, N, V, F, X, K) => C(!0, J, re, G, N, V, F, X, K), I = (J, re) => Q(!0, J, re);
          function k(J, re, G) {
            const { _sources: N, _sourcesContent: V } = J;
            V[c.put(N, re)] = G;
          }
          function L(J, re, G = !0) {
            const { _sources: N, _sourcesContent: V, _ignoreList: F } = J, X = c.put(N, re);
            X === V.length && (V[X] = null), G ? c.put(F, X) : c.remove(F, X);
          }
          function M(J) {
            const { _mappings: re, _sources: G, _sourcesContent: N, _names: V, _ignoreList: F } = J;
            return U(re), { version: 3, file: J.file || void 0, names: V.array, sourceRoot: J.sourceRoot || void 0, sources: G.array, sourcesContent: N, mappings: re, ignoreList: F.array };
          }
          function x(J) {
            const re = M(J);
            return Object.assign(Object.assign({}, re), { mappings: f.encode(re.mappings) });
          }
          function _(J) {
            const re = new s.TraceMap(J), G = new T({ file: re.file, sourceRoot: re.sourceRoot });
            return P(G._names, re.names), P(G._sources, re.sources), G._sourcesContent = re.sourcesContent || re.sources.map(() => null), G._mappings = s.decodedMappings(re), re.ignoreList && P(G._ignoreList, re.ignoreList), G;
          }
          function S(J) {
            const re = [], { _mappings: G, _sources: N, _names: V } = J;
            for (let F = 0; F < G.length; F++) {
              const X = G[F];
              for (let K = 0; K < X.length; K++) {
                const ie = X[K], fe = { line: F + 1, column: ie[0] };
                let _e, Ae, ce;
                ie.length !== 1 && (_e = N.array[ie[1]], Ae = { line: ie[2] + 1, column: ie[3] }, ie.length === 5 && (ce = V.array[ie[4]])), re.push({ generated: fe, source: _e, original: Ae, name: ce });
              }
            }
            return re;
          }
          function C(J, re, G, N, V, F, X, K, ie) {
            const { _mappings: fe, _sources: _e, _sourcesContent: Ae, _names: ce } = re, ee = R(fe, G), ae = H(ee, N);
            if (!V)
              return J && W(ee, ae) ? void 0 : z(ee, ae, [N]);
            const oe = c.put(_e, V), me = K ? c.put(ce, K) : -1;
            if (oe === Ae.length && (Ae[oe] = ie ?? null), !J || !B(ee, ae, oe, F, X, me)) return z(ee, ae, K ? [N, oe, F, X, me] : [N, oe, F, X]);
          }
          function R(J, re) {
            for (let G = J.length; G <= re; G++) J[G] = [];
            return J[re];
          }
          function H(J, re) {
            let G = J.length;
            for (let N = G - 1; N >= 0 && !(re >= J[N][0]); G = N--) ;
            return G;
          }
          function z(J, re, G) {
            for (let N = J.length; N > re; N--) J[N] = J[N - 1];
            J[re] = G;
          }
          function U(J) {
            const { length: re } = J;
            let G = re;
            for (let N = G - 1; N >= 0 && !(J[N].length > 0); G = N, N--) ;
            G < re && (J.length = G);
          }
          function P(J, re) {
            for (let G = 0; G < re.length; G++) c.put(J, re[G]);
          }
          function W(J, re) {
            return re === 0 || J[re - 1].length === 1;
          }
          function B(J, re, G, N, V, F) {
            if (re === 0) return !1;
            const X = J[re - 1];
            return X.length !== 1 && G === X[1] && N === X[2] && V === X[3] && F === (X.length === 5 ? X[4] : -1);
          }
          function Q(J, re, G) {
            const { generated: N, source: V, original: F, name: X, content: K } = G;
            return V ? C(J, re, N.line - 1, N.column, V, F.line - 1, F.column, X, K) : C(J, re, N.line - 1, N.column, null, null, null, null, null);
          }
          i.GenMapping = T, i.addMapping = D, i.addSegment = O, i.allMappings = S, i.fromMap = _, i.maybeAddMapping = I, i.maybeAddSegment = $, i.setIgnore = L, i.setSourceContent = k, i.toDecodedMap = M, i.toEncodedMap = x, Object.defineProperty(i, "__esModule", { value: !0 });
        })(n, u("./node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.umd.js"), u("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), u("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"));
      }, "./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js": function(h) {
        h.exports = /* @__PURE__ */ function() {
          const n = /^[\w+.-]+:\/\//, u = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, i = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
          function c($) {
            return n.test($);
          }
          function f($) {
            return $.startsWith("//");
          }
          function s($) {
            return $.startsWith("/");
          }
          function o($) {
            return $.startsWith("file:");
          }
          function y($) {
            return /^[.?#]/.test($);
          }
          function m($) {
            const I = u.exec($);
            return b(I[1], I[2] || "", I[3], I[4] || "", I[5] || "/", I[6] || "", I[7] || "");
          }
          function g($) {
            const I = i.exec($), k = I[2];
            return b("file:", "", I[1] || "", "", s(k) ? k : "/" + k, I[3] || "", I[4] || "");
          }
          function b($, I, k, L, M, x, _) {
            return { scheme: $, user: I, host: k, port: L, path: M, query: x, hash: _, type: 7 };
          }
          function v($) {
            if (f($)) {
              const k = m("http:" + $);
              return k.scheme = "", k.type = 6, k;
            }
            if (s($)) {
              const k = m("http://foo.com" + $);
              return k.scheme = "", k.host = "", k.type = 5, k;
            }
            if (o($)) return g($);
            if (c($)) return m($);
            const I = m("http://foo.com/" + $);
            return I.scheme = "", I.host = "", I.type = $ ? $.startsWith("?") ? 3 : $.startsWith("#") ? 2 : 4 : 1, I;
          }
          function T($) {
            if ($.endsWith("/..")) return $;
            const I = $.lastIndexOf("/");
            return $.slice(0, I + 1);
          }
          function E($, I) {
            O(I, I.type), $.path === "/" ? $.path = I.path : $.path = T(I.path) + $.path;
          }
          function O($, I) {
            const k = I <= 4, L = $.path.split("/");
            let M = 1, x = 0, _ = !1;
            for (let C = 1; C < L.length; C++) {
              const R = L[C];
              R ? (_ = !1, R !== "." && (R !== ".." ? (L[M++] = R, x++) : x ? (_ = !0, x--, M--) : k && (L[M++] = R))) : _ = !0;
            }
            let S = "";
            for (let C = 1; C < M; C++) S += "/" + L[C];
            (!S || _ && !S.endsWith("/..")) && (S += "/"), $.path = S;
          }
          function D($, I) {
            if (!$ && !I) return "";
            const k = v($);
            let L = k.type;
            if (I && L !== 7) {
              const x = v(I), _ = x.type;
              switch (L) {
                case 1:
                  k.hash = x.hash;
                case 2:
                  k.query = x.query;
                case 3:
                case 4:
                  E(k, x);
                case 5:
                  k.user = x.user, k.host = x.host, k.port = x.port;
                case 6:
                  k.scheme = x.scheme;
              }
              _ > L && (L = _);
            }
            O(k, L);
            const M = k.query + k.hash;
            switch (L) {
              case 2:
              case 3:
                return M;
              case 4: {
                const x = k.path.slice(1);
                return x ? y(I || $) && !y(x) ? "./" + x + M : x + M : M || ".";
              }
              case 5:
                return k.path + M;
              default:
                return k.scheme + "//" + k.user + k.host + k.port + k.path + M;
            }
          }
          return D;
        }();
      }, "./node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.umd.js": function(h, n) {
        (function(u) {
          class i {
            constructor() {
              this._indexes = { __proto__: null }, this.array = [];
            }
          }
          function c(m) {
            return m;
          }
          function f(m, g) {
            return m._indexes[g];
          }
          function s(m, g) {
            const b = f(m, g);
            if (b !== void 0) return b;
            const { array: v, _indexes: T } = m, E = v.push(g);
            return T[g] = E - 1;
          }
          function o(m) {
            const { array: g, _indexes: b } = m;
            g.length !== 0 && (b[g.pop()] = void 0);
          }
          function y(m, g) {
            const b = f(m, g);
            if (b === void 0) return;
            const { array: v, _indexes: T } = m;
            for (let E = b + 1; E < v.length; E++) {
              const O = v[E];
              v[E - 1] = O, T[O]--;
            }
            T[g] = void 0, v.pop();
          }
          u.SetArray = i, u.get = f, u.pop = o, u.put = s, u.remove = y, Object.defineProperty(u, "__esModule", { value: !0 });
        })(n);
      }, "./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js": function(h, n) {
        (function(u) {
          const f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = new Uint8Array(64), o = new Uint8Array(128);
          for (let $ = 0; $ < f.length; $++) {
            const I = f.charCodeAt($);
            s[$] = I, o[I] = $;
          }
          const y = typeof TextDecoder < "u" ? new TextDecoder() : typeof Gt < "u" ? { decode: ($) => Gt.from($.buffer, $.byteOffset, $.byteLength).toString() } : { decode($) {
            let I = "";
            for (let k = 0; k < $.length; k++) I += String.fromCharCode($[k]);
            return I;
          } };
          function m($) {
            const I = new Int32Array(5), k = [];
            let L = 0;
            do {
              const M = g($, L), x = [];
              let _ = !0, S = 0;
              I[0] = 0;
              for (let C = L; C < M; C++) {
                let R;
                C = b($, C, I, 0);
                const H = I[0];
                H < S && (_ = !1), S = H, v($, C, M) ? (C = b($, C, I, 1), C = b($, C, I, 2), C = b($, C, I, 3), v($, C, M) ? (C = b($, C, I, 4), R = [H, I[1], I[2], I[3], I[4]]) : R = [H, I[1], I[2], I[3]]) : R = [H], x.push(R);
              }
              _ || T(x), k.push(x), L = M + 1;
            } while (L <= $.length);
            return k;
          }
          function g($, I) {
            const k = $.indexOf(";", I);
            return k === -1 ? $.length : k;
          }
          function b($, I, k, L) {
            let M = 0, x = 0, _ = 0;
            do {
              const C = $.charCodeAt(I++);
              _ = o[C], M |= (31 & _) << x, x += 5;
            } while (32 & _);
            const S = 1 & M;
            return M >>>= 1, S && (M = -2147483648 | -M), k[L] += M, I;
          }
          function v($, I, k) {
            return !(I >= k) && $.charCodeAt(I) !== 44;
          }
          function T($) {
            $.sort(E);
          }
          function E($, I) {
            return $[0] - I[0];
          }
          function O($) {
            const I = new Int32Array(5), k = 16384, L = k - 36, M = new Uint8Array(k), x = M.subarray(0, L);
            let _ = 0, S = "";
            for (let C = 0; C < $.length; C++) {
              const R = $[C];
              if (C > 0 && (_ === k && (S += y.decode(M), _ = 0), M[_++] = 59), R.length !== 0) {
                I[0] = 0;
                for (let H = 0; H < R.length; H++) {
                  const z = R[H];
                  _ > L && (S += y.decode(x), M.copyWithin(0, L, _), _ -= L), H > 0 && (M[_++] = 44), _ = D(M, _, I, z, 0), z.length !== 1 && (_ = D(M, _, I, z, 1), _ = D(M, _, I, z, 2), _ = D(M, _, I, z, 3), z.length !== 4 && (_ = D(M, _, I, z, 4)));
                }
              }
            }
            return S + y.decode(M.subarray(0, _));
          }
          function D($, I, k, L, M) {
            const x = L[M];
            let _ = x - k[M];
            k[M] = x, _ = _ < 0 ? -_ << 1 | 1 : _ << 1;
            do {
              let S = 31 & _;
              _ >>>= 5, _ > 0 && (S |= 32), $[I++] = s[S];
            } while (_ > 0);
            return I;
          }
          u.decode = m, u.encode = O, Object.defineProperty(u, "__esModule", { value: !0 });
        })(n);
      }, "./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js": function(h, n, u) {
        (function(i, c, f) {
          function s(ue, te) {
            return te && !te.endsWith("/") && (te += "/"), f(ue, te);
          }
          function o(ue) {
            if (!ue) return "";
            const te = ue.lastIndexOf("/");
            return ue.slice(0, te + 1);
          }
          const y = 0, m = 1, g = 2, b = 3, v = 4, T = 1, E = 2;
          function O(ue, te) {
            const Y = D(ue, 0);
            if (Y === ue.length) return ue;
            te || (ue = ue.slice());
            for (let le = Y; le < ue.length; le = D(ue, le + 1)) ue[le] = I(ue[le], te);
            return ue;
          }
          function D(ue, te) {
            for (let Y = te; Y < ue.length; Y++) if (!$(ue[Y])) return Y;
            return ue.length;
          }
          function $(ue) {
            for (let te = 1; te < ue.length; te++) if (ue[te][y] < ue[te - 1][y]) return !1;
            return !0;
          }
          function I(ue, te) {
            return te || (ue = ue.slice()), ue.sort(k);
          }
          function k(ue, te) {
            return ue[y] - te[y];
          }
          let L = !1;
          function M(ue, te, Y, le) {
            for (; Y <= le; ) {
              const Ee = Y + (le - Y >> 1), Se = ue[Ee][y] - te;
              if (Se === 0) return L = !0, Ee;
              Se < 0 ? Y = Ee + 1 : le = Ee - 1;
            }
            return L = !1, Y - 1;
          }
          function x(ue, te, Y) {
            for (let le = Y + 1; le < ue.length && ue[le][y] === te; Y = le++) ;
            return Y;
          }
          function _(ue, te, Y) {
            for (let le = Y - 1; le >= 0 && ue[le][y] === te; Y = le--) ;
            return Y;
          }
          function S() {
            return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
          }
          function C(ue, te, Y, le) {
            const { lastKey: Ee, lastNeedle: Se, lastIndex: Pe } = Y;
            let Ve = 0, Xe = ue.length - 1;
            if (le === Ee) {
              if (te === Se) return L = Pe !== -1 && ue[Pe][y] === te, Pe;
              te >= Se ? Ve = Pe === -1 ? 0 : Pe : Xe = Pe;
            }
            return Y.lastKey = le, Y.lastNeedle = te, Y.lastIndex = M(ue, te, Ve, Xe);
          }
          function R(ue, te) {
            const Y = te.map(z);
            for (let le = 0; le < ue.length; le++) {
              const Ee = ue[le];
              for (let Se = 0; Se < Ee.length; Se++) {
                const Pe = Ee[Se];
                if (Pe.length === 1) continue;
                const Ve = Pe[m], Xe = Pe[g], Ye = Pe[b], We = Y[Ve], et = We[Xe] || (We[Xe] = []), De = te[Ve];
                let Me = x(et, Ye, C(et, Ye, De, Xe));
                De.lastIndex = ++Me, H(et, Me, [Ye, le, Pe[y]]);
              }
            }
            return Y;
          }
          function H(ue, te, Y) {
            for (let le = ue.length; le > te; le--) ue[le] = ue[le - 1];
            ue[te] = Y;
          }
          function z() {
            return { __proto__: null };
          }
          const U = function(ue, te) {
            const Y = P(ue);
            if (!("sections" in Y)) return new F(Y, te);
            const le = [], Ee = [], Se = [], Pe = [], Ve = [];
            return W(Y, te, le, Ee, Se, Pe, Ve, 0, 0, 1 / 0, 1 / 0), ye({ version: 3, file: Y.file, names: Pe, sources: Ee, sourcesContent: Se, mappings: le, ignoreList: Ve });
          };
          function P(ue) {
            return typeof ue == "string" ? JSON.parse(ue) : ue;
          }
          function W(ue, te, Y, le, Ee, Se, Pe, Ve, Xe, Ye, We) {
            const { sections: et } = ue;
            for (let De = 0; De < et.length; De++) {
              const { map: Me, offset: Qe } = et[De];
              let He = Ye, st = We;
              if (De + 1 < et.length) {
                const it = et[De + 1].offset;
                He = Math.min(Ye, Ve + it.line), He === Ye ? st = Math.min(We, Xe + it.column) : He < Ye && (st = Xe + it.column);
              }
              B(Me, te, Y, le, Ee, Se, Pe, Ve + Qe.line, Xe + Qe.column, He, st);
            }
          }
          function B(ue, te, Y, le, Ee, Se, Pe, Ve, Xe, Ye, We) {
            const et = P(ue);
            if ("sections" in et) return W(...arguments);
            const De = new F(et, te), Me = le.length, Qe = Se.length, He = ie(De), { resolvedSources: st, sourcesContent: it, ignoreList: qe } = De;
            if (Q(le, st), Q(Se, De.names), it) Q(Ee, it);
            else for (let rt = 0; rt < st.length; rt++) Ee.push(null);
            if (qe) for (let rt = 0; rt < qe.length; rt++) Pe.push(qe[rt] + Me);
            for (let rt = 0; rt < He.length; rt++) {
              const bt = Ve + rt;
              if (bt > Ye) return;
              const dt = J(Y, bt), Je = rt === 0 ? Xe : 0, mt = He[rt];
              for (let ut = 0; ut < mt.length; ut++) {
                const Et = mt[ut], Tt = Je + Et[y];
                if (bt === Ye && Tt >= We) return;
                if (Et.length === 1) {
                  dt.push([Tt]);
                  continue;
                }
                const St = Me + Et[m], Vt = Et[g], Kt = Et[b];
                dt.push(Et.length === 4 ? [Tt, St, Vt, Kt] : [Tt, St, Vt, Kt, Qe + Et[v]]);
              }
            }
          }
          function Q(ue, te) {
            for (let Y = 0; Y < te.length; Y++) ue.push(te[Y]);
          }
          function J(ue, te) {
            for (let Y = ue.length; Y <= te; Y++) ue[Y] = [];
            return ue[te];
          }
          const re = "`line` must be greater than 0 (lines start at line 1)", G = "`column` must be greater than or equal to 0 (columns start at column 0)", N = -1, V = 1;
          class F {
            constructor(te, Y) {
              const le = typeof te == "string";
              if (!le && te._decodedMemo) return te;
              const Ee = le ? JSON.parse(te) : te, { version: Se, file: Pe, names: Ve, sourceRoot: Xe, sources: Ye, sourcesContent: We } = Ee;
              this.version = Se, this.file = Pe, this.names = Ve || [], this.sourceRoot = Xe, this.sources = Ye, this.sourcesContent = We, this.ignoreList = Ee.ignoreList || Ee.x_google_ignoreList || void 0;
              const et = s(Xe || "", o(Y));
              this.resolvedSources = Ye.map((Me) => s(Me || "", et));
              const { mappings: De } = Ee;
              typeof De == "string" ? (this._encoded = De, this._decoded = void 0) : (this._encoded = void 0, this._decoded = O(De, le)), this._decodedMemo = S(), this._bySources = void 0, this._bySourceMemos = void 0;
            }
          }
          function X(ue) {
            return ue;
          }
          function K(ue) {
            var te, Y;
            return (te = (Y = ue)._encoded) !== null && te !== void 0 ? te : Y._encoded = c.encode(ue._decoded);
          }
          function ie(ue) {
            var te;
            return (te = ue)._decoded || (te._decoded = c.decode(ue._encoded));
          }
          function fe(ue, te, Y) {
            const le = ie(ue);
            if (te >= le.length) return null;
            const Ee = le[te], Se = Oe(Ee, ue._decodedMemo, te, Y, V);
            return Se === -1 ? null : Ee[Se];
          }
          function _e(ue, te) {
            let { line: Y, column: le, bias: Ee } = te;
            if (Y--, Y < 0) throw new Error(re);
            if (le < 0) throw new Error(G);
            const Se = ie(ue);
            if (Y >= Se.length) return be(null, null, null, null);
            const Pe = Se[Y], Ve = Oe(Pe, ue._decodedMemo, Y, le, Ee || V);
            if (Ve === -1) return be(null, null, null, null);
            const Xe = Pe[Ve];
            if (Xe.length === 1) return be(null, null, null, null);
            const { names: Ye, resolvedSources: We } = ue;
            return be(We[Xe[m]], Xe[g] + 1, Xe[b], Xe.length === 5 ? Ye[Xe[v]] : null);
          }
          function Ae(ue, te) {
            const { source: Y, line: le, column: Ee, bias: Se } = te;
            return Fe(ue, Y, le, Ee, Se || V, !1);
          }
          function ce(ue, te) {
            const { source: Y, line: le, column: Ee, bias: Se } = te;
            return Fe(ue, Y, le, Ee, Se || N, !0);
          }
          function ee(ue, te) {
            const Y = ie(ue), { names: le, resolvedSources: Ee } = ue;
            for (let Se = 0; Se < Y.length; Se++) {
              const Pe = Y[Se];
              for (let Ve = 0; Ve < Pe.length; Ve++) {
                const Xe = Pe[Ve], Ye = Se + 1, We = Xe[0];
                let et = null, De = null, Me = null, Qe = null;
                Xe.length !== 1 && (et = Ee[Xe[1]], De = Xe[2] + 1, Me = Xe[3]), Xe.length === 5 && (Qe = le[Xe[4]]), te({ generatedLine: Ye, generatedColumn: We, source: et, originalLine: De, originalColumn: Me, name: Qe });
              }
            }
          }
          function ae(ue, te) {
            const { sources: Y, resolvedSources: le } = ue;
            let Ee = Y.indexOf(te);
            return Ee === -1 && (Ee = le.indexOf(te)), Ee;
          }
          function oe(ue, te) {
            const { sourcesContent: Y } = ue;
            if (Y == null) return null;
            const le = ae(ue, te);
            return le === -1 ? null : Y[le];
          }
          function me(ue, te) {
            const { ignoreList: Y } = ue;
            if (Y == null) return !1;
            const le = ae(ue, te);
            return le !== -1 && Y.includes(le);
          }
          function ye(ue, te) {
            const Y = new F(se(ue, []), te);
            return Y._decoded = ue.mappings, Y;
          }
          function we(ue) {
            return se(ue, ie(ue));
          }
          function ge(ue) {
            return se(ue, K(ue));
          }
          function se(ue, te) {
            return { version: ue.version, file: ue.file, names: ue.names, sourceRoot: ue.sourceRoot, sources: ue.sources, sourcesContent: ue.sourcesContent, mappings: te, ignoreList: ue.ignoreList || ue.x_google_ignoreList };
          }
          function be(ue, te, Y, le) {
            return { source: ue, line: te, column: Y, name: le };
          }
          function Ie(ue, te) {
            return { line: ue, column: te };
          }
          function Oe(ue, te, Y, le, Ee) {
            let Se = C(ue, le, te, Y);
            return L ? Se = (Ee === N ? x : _)(ue, le, Se) : Ee === N && Se++, Se === -1 || Se === ue.length ? -1 : Se;
          }
          function Be(ue, te, Y, le, Ee) {
            let Se = Oe(ue, te, Y, le, V);
            if (L || Ee !== N || Se++, Se === -1 || Se === ue.length) return [];
            const Pe = L ? le : ue[Se][y];
            L || (Se = _(ue, Pe, Se));
            const Ve = x(ue, Pe, Se), Xe = [];
            for (; Se <= Ve; Se++) {
              const Ye = ue[Se];
              Xe.push(Ie(Ye[T] + 1, Ye[E]));
            }
            return Xe;
          }
          function Fe(ue, te, Y, le, Ee, Se) {
            var Pe;
            if (--Y < 0) throw new Error(re);
            if (le < 0) throw new Error(G);
            const { sources: Ve, resolvedSources: Xe } = ue;
            let Ye = Ve.indexOf(te);
            if (Ye === -1 && (Ye = Xe.indexOf(te)), Ye === -1) return Se ? [] : Ie(null, null);
            const We = ((Pe = ue)._bySources || (Pe._bySources = R(ie(ue), ue._bySourceMemos = Ve.map(S))))[Ye][Y];
            if (We == null) return Se ? [] : Ie(null, null);
            const et = ue._bySourceMemos[Ye];
            if (Se) return Be(We, et, Y, le, Ee);
            const De = Oe(We, et, Y, le, Ee);
            if (De === -1) return Ie(null, null);
            const Me = We[De];
            return Ie(Me[T] + 1, Me[E]);
          }
          i.AnyMap = U, i.GREATEST_LOWER_BOUND = V, i.LEAST_UPPER_BOUND = N, i.TraceMap = F, i.allGeneratedPositionsFor = ce, i.decodedMap = we, i.decodedMappings = ie, i.eachMapping = ee, i.encodedMap = ge, i.encodedMappings = K, i.generatedPositionFor = Ae, i.isIgnored = me, i.originalPositionFor = _e, i.presortedDecodedMap = ye, i.sourceContentFor = oe, i.traceSegment = fe;
        })(n, u("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), u("./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"));
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          var f = (0, i.createDynamicImportTransform)(c);
          return { manipulateOptions: function(s, o) {
            o.plugins.push("dynamicImport");
          }, visitor: { Import: function(s) {
            f(this, s);
          } } };
        };
        var i = u("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js");
        h.exports = n.default;
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 });
        var u = function(c, f) {
          if (Array.isArray(c)) return c;
          if (Symbol.iterator in Object(c)) return function(s, o) {
            var y = [], m = !0, g = !1, b = void 0;
            try {
              for (var v, T = s[Symbol.iterator](); !(m = (v = T.next()).done) && (y.push(v.value), !o || y.length !== o); m = !0) ;
            } catch (E) {
              g = !0, b = E;
            } finally {
              try {
                !m && T.return && T.return();
              } finally {
                if (g) throw b;
              }
            }
            return y;
          }(c, f);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
        function i(c, f) {
          var s = f.arguments, o = u(s, 1)[0];
          return c.isStringLiteral(o) || c.isTemplateLiteral(o) ? (c.removeComments(o), o) : c.templateLiteral([c.templateElement({ raw: "", cooked: "" }), c.templateElement({ raw: "", cooked: "" }, !0)], s);
        }
        n.getImportSource = i, n.createDynamicImportTransform = function(c) {
          var f = c.template, s = c.types, o = { static: { interop: f("Promise.resolve().then(() => INTEROP(require(SOURCE)))"), noInterop: f("Promise.resolve().then(() => require(SOURCE))") }, dynamic: { interop: f("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"), noInterop: f("Promise.resolve(SOURCE).then(s => require(s))") } }, y = typeof WeakSet == "function" && /* @__PURE__ */ new WeakSet();
          return function(m, g) {
            if (y) {
              if (y.has(g)) return;
              y.add(g);
            }
            var b, v = i(s, g.parent), T = (b = v, s.isStringLiteral(b) || s.isTemplateLiteral(b) && b.expressions.length === 0 ? o.static : o.dynamic), E = m.opts.noInterop ? T.noInterop({ SOURCE: v }) : T.interop({ SOURCE: v, INTEROP: m.addHelper("interopRequireWildcard") });
            g.parentPath.replaceWith(E);
          };
        };
      }, "./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js": (h, n, u) => {
        var i = u("path");
        function c(f) {
          switch (f.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return !0;
            default:
              return !1;
          }
        }
        h.exports = function(f) {
          var s = f.types, o = function(m, g) {
            return function(b) {
              var v = s.callExpression(m.expression, [s.Identifier(b), s.Identifier("undefined"), s.NumericLiteral(g.key)]), T = s.logicalExpression("||", v, s.Identifier(b)), E = s.assignmentExpression("=", s.Identifier(b), T);
              return s.expressionStatement(E);
            };
          }, y = function(m, g) {
            return function(b, v) {
              var T = s.callExpression(m.expression, [s.Identifier("".concat(b, ".prototype")), s.StringLiteral(v), s.NumericLiteral(g.key)]);
              return s.expressionStatement(T);
            };
          };
          return { visitor: { Program: function(m, g) {
            var b = (0, i.extname)(g.file.opts.filename);
            b !== ".ts" && b !== ".tsx" || function() {
              var v = /* @__PURE__ */ Object.create(null);
              m.node.body.filter(function(C) {
                var R = C.type, H = C.declaration;
                switch (R) {
                  case "ClassDeclaration":
                    return !0;
                  case "ExportNamedDeclaration":
                  case "ExportDefaultDeclaration":
                    return H && H.type === "ClassDeclaration";
                  default:
                    return !1;
                }
              }).map(function(C) {
                return C.type === "ClassDeclaration" ? C : C.declaration;
              }).forEach(function(C) {
                C.body.body.forEach(function(R) {
                  (R.params || []).forEach(function(H) {
                    (H.decorators || []).forEach(function(z) {
                      z.expression.callee ? v[z.expression.callee.name] = z : v[z.expression.name] = z;
                    });
                  });
                });
              });
              var T = !0, E = !1, O = void 0;
              try {
                for (var D, $ = m.get("body")[Symbol.iterator](); !(T = (D = $.next()).done); T = !0) {
                  var I = D.value;
                  if (I.node.type === "ImportDeclaration") {
                    if (I.node.specifiers.length === 0) continue;
                    var k = !0, L = !1, M = void 0;
                    try {
                      for (var x, _ = function() {
                        var C = x.value, R = I.scope.getBinding(C.local.name);
                        R.referencePaths.length ? R.referencePaths.reduce(function(H, z) {
                          return H || c(z);
                        }, !1) && Object.keys(v).forEach(function(H) {
                          var z = v[H];
                          (z.expression.arguments || []).forEach(function(U) {
                            U.name === C.local.name && R.referencePaths.push({ parent: z.expression });
                          });
                        }) : v[C.local.name] && R.referencePaths.push({ parent: v[C.local.name] });
                      }, S = I.node.specifiers[Symbol.iterator](); !(k = (x = S.next()).done); k = !0) _();
                    } catch (C) {
                      L = !0, M = C;
                    } finally {
                      try {
                        k || S.return == null || S.return();
                      } finally {
                        if (L) throw M;
                      }
                    }
                  }
                }
              } catch (C) {
                E = !0, O = C;
              } finally {
                try {
                  T || $.return == null || $.return();
                } finally {
                  if (E) throw O;
                }
              }
            }();
          }, Function: function(m) {
            var g = "";
            m.node.id ? g = m.node.id.name : m.node.key && (g = m.node.key.name), (m.get("params") || []).slice().forEach(function(b) {
              var v = b.node.decorators || [], T = v.length;
              if (v.slice().forEach(function(O) {
                if (m.type === "ClassMethod") {
                  var D, $ = m.parentPath.parentPath, I = m.findParent(function(C) {
                    return C.type === "ClassDeclaration";
                  });
                  if (I ? D = I.node.id.name : ($.insertAfter(null), D = function(C) {
                    var R = C.findParent(function(H) {
                      return H.node.type === "AssignmentExpression";
                    });
                    return R.node.right.type === "SequenceExpression" ? R.node.right.expressions[1].name : R.node.right.type === "ClassExpression" ? R.node.left.name : null;
                  }(m)), g === "constructor") {
                    var k = o(O, b)(D);
                    $.insertAfter(k);
                  } else {
                    var L = y(O, b)(D, g);
                    $.insertAfter(L);
                  }
                } else {
                  var M = m.findParent(function(C) {
                    return C.node.type === "VariableDeclarator";
                  }).node.id.name;
                  if (g === M) {
                    var x = o(O, b)(M);
                    m.parentKey === "body" ? m.insertAfter(x) : m.findParent(function(C) {
                      return C.parentKey === "body";
                    }).insertAfter(x);
                  } else {
                    var _ = m.findParent(function(C) {
                      return C.node.type === "CallExpression";
                    }), S = y(O, b)(M, g);
                    _.insertAfter(S);
                  }
                }
              }), T) {
                var E = function(O) {
                  switch (O.node.type) {
                    case "ObjectPattern":
                      return s.ObjectPattern(O.node.properties);
                    case "AssignmentPattern":
                      return s.AssignmentPattern(O.node.left, O.node.right);
                    case "TSParameterProperty":
                      return s.Identifier(O.node.parameter.name);
                    default:
                      return s.Identifier(O.node.name);
                  }
                }(b);
                b.replaceWith(E);
              }
            });
          } } };
        };
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.metadataVisitor = function(s, o) {
          const y = o.node, m = s.node;
          switch (y.type) {
            case "ClassMethod":
              const g = y.kind === "constructor" ? m.decorators : y.decorators;
              if (!g || g.length === 0) return;
              g.push(f("design:type", i.types.identifier("Function"))), g.push(f("design:paramtypes", i.types.arrayExpression(y.params.map((b) => (0, c.serializeType)(s, b)))));
              break;
            case "ClassProperty":
              if (!y.decorators || y.decorators.length === 0 || !y.typeAnnotation || y.typeAnnotation.type !== "TSTypeAnnotation") return;
              y.decorators.push(f("design:type", (0, c.serializeType)(s, y)));
          }
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js");
        function f(s, o) {
          return i.types.decorator(i.types.callExpression(i.types.memberExpression(i.types.identifier("Reflect"), i.types.identifier("metadata")), [i.types.stringLiteral(s), o]));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.serializeType = function(b, v) {
          const T = f(v);
          if (T == null || !T.typeAnnotation || T.typeAnnotation.type !== "TSTypeAnnotation") return c();
          const E = T.typeAnnotation.typeAnnotation;
          return m(b.node.id ? b.node.id.name : "", E);
        }, n.isClassType = o;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        function c() {
          return i.types.unaryExpression("void", i.types.numericLiteral(0));
        }
        function f(b) {
          return b == null ? null : b.type === "ClassProperty" || b.type === "Identifier" || b.type === "ObjectPattern" ? b : b.type === "AssignmentPattern" && b.left.type === "Identifier" ? b.left : b.type === "TSParameterProperty" ? f(b.parameter) : null;
        }
        function s(b, v) {
          const T = y(v.typeName);
          return o(b, T) ? i.types.identifier("Object") : i.types.conditionalExpression(i.types.binaryExpression("===", i.types.unaryExpression("typeof", T), i.types.stringLiteral("undefined")), i.types.identifier("Object"), i.types.cloneDeep(T));
        }
        function o(b, v) {
          switch (v.type) {
            case "Identifier":
              return v.name === b;
            case "MemberExpression":
              return o(b, v.object);
            default:
              throw new Error(`The property expression at ${v.start} is not valid as a Type to be used in Reflect.metadata`);
          }
        }
        function y(b) {
          return b.type === "Identifier" ? i.types.identifier(b.name) : i.types.memberExpression(y(b.left), b.right);
        }
        function m(b, v) {
          if (v === void 0) return i.types.identifier("Object");
          switch (v.type) {
            case "TSVoidKeyword":
            case "TSUndefinedKeyword":
            case "TSNullKeyword":
            case "TSNeverKeyword":
              return c();
            case "TSParenthesizedType":
              return m(b, v.typeAnnotation);
            case "TSFunctionType":
            case "TSConstructorType":
              return i.types.identifier("Function");
            case "TSArrayType":
            case "TSTupleType":
              return i.types.identifier("Array");
            case "TSTypePredicate":
            case "TSBooleanKeyword":
              return i.types.identifier("Boolean");
            case "TSStringKeyword":
              return i.types.identifier("String");
            case "TSObjectKeyword":
              return i.types.identifier("Object");
            case "TSLiteralType":
              switch (v.literal.type) {
                case "StringLiteral":
                  return i.types.identifier("String");
                case "NumericLiteral":
                  return i.types.identifier("Number");
                case "BooleanLiteral":
                  return i.types.identifier("Boolean");
                default:
                  throw new Error("Bad type for decorator" + v.literal);
              }
            case "TSNumberKeyword":
            case "TSBigIntKeyword":
              return i.types.identifier("Number");
            case "TSSymbolKeyword":
              return i.types.identifier("Symbol");
            case "TSTypeReference":
              return s(b, v);
            case "TSIntersectionType":
            case "TSUnionType":
              return g(b, v.types);
            case "TSConditionalType":
              return g(b, [v.trueType, v.falseType]);
            case "TSTypeQuery":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTypeLiteral":
            case "TSAnyKeyword":
            case "TSUnknownKeyword":
            case "TSThisType":
              break;
            default:
              throw new Error("Bad type for decorator");
          }
          return i.types.identifier("Object");
        }
        function g(b, v) {
          let T;
          for (let E of v) {
            for (; E.type === "TSParenthesizedType"; ) E = E.typeAnnotation;
            if (E.type === "TSNeverKeyword" || E.type === "TSNullKeyword" || E.type === "TSUndefinedKeyword") continue;
            const O = m(b, E);
            if (i.types.isIdentifier(O) && O.name === "Object") return O;
            if (T) {
              if (!i.types.isIdentifier(T) || !i.types.isIdentifier(O) || T.name !== O.name) return i.types.identifier("Object");
            } else T = O;
          }
          return T || c();
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.parameterVisitor = function(f, s) {
          if (s.type !== "ClassMethod" || s.node.type !== "ClassMethod" || s.node.key.type !== "Identifier") return;
          const o = s;
          (o.get("params") || []).slice().forEach(function(y) {
            let m;
            (y.node.type === "Identifier" || y.node.type === "ObjectPattern" ? y.node : y.node.type === "TSParameterProperty" && y.node.parameter.type === "Identifier" ? y.node.parameter : null) != null && ((y.node.decorators || []).slice().forEach(function(g) {
              o.node.kind === "constructor" ? (m = c(y.key, g.expression, !0), f.node.decorators || (f.node.decorators = []), f.node.decorators.push(m)) : (m = c(y.key, g.expression, !1), o.node.decorators || (o.node.decorators = []), o.node.decorators.push(m));
            }), m && (y.node.decorators = null));
          });
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        function c(f, s, o = !1) {
          return i.types.decorator(i.types.functionExpression(null, [i.types.identifier("target"), i.types.identifier("key")], i.types.blockStatement([i.types.returnStatement(i.types.callExpression(s, [i.types.identifier("target"), i.types.identifier(o ? "undefined" : "key"), i.types.numericLiteral(f)]))])));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js"), f = u("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js"), s = (0, i.declare)((o) => (o.assertVersion(7), { visitor: { Program(y) {
          y.traverse({ ClassDeclaration(m) {
            for (const g of m.get("body").get("body")) g.type !== "ClassMethod" && g.type !== "ClassProperty" || ((0, c.parameterVisitor)(m, g), (0, f.metadataVisitor)(m, g));
            m.parentPath.scope.crawl();
          } });
        } } }));
        n.default = s;
      }, "./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js": (h, n) => {
        var u;
        function i(f, s) {
          (s = s || {}).hasComment && (f = function(o) {
            return o.split(",").pop();
          }(f)), s.encoding === "base64" ? f = u(f) : s.encoding === "uri" && (f = decodeURIComponent(f)), (s.isJSON || s.encoding) && (f = JSON.parse(f)), this.sourcemap = f;
        }
        function c(f) {
          return new i(f, { isJSON: !0 });
        }
        Object.defineProperty(n, "commentRegex", { get: function() {
          return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
        } }), Object.defineProperty(n, "mapFileCommentRegex", { get: function() {
          return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/gm;
        } }), u = typeof Gt < "u" ? typeof Gt.from == "function" ? function(f) {
          return Gt.from(f, "base64").toString();
        } : function(f) {
          if (typeof value == "number") throw new TypeError("The value to decode must not be of type number.");
          return new Gt(f, "base64").toString();
        } : function(f) {
          return decodeURIComponent(escape(atob(f)));
        }, i.prototype.toJSON = function(f) {
          return JSON.stringify(this.sourcemap, null, f);
        }, typeof Gt < "u" ? typeof Gt.from == "function" ? i.prototype.toBase64 = function() {
          var f = this.toJSON();
          return Gt.from(f, "utf8").toString("base64");
        } : i.prototype.toBase64 = function() {
          var f = this.toJSON();
          if (typeof f == "number") throw new TypeError("The json to encode must not be of type number.");
          return new Gt(f, "utf8").toString("base64");
        } : i.prototype.toBase64 = function() {
          var f = this.toJSON();
          return btoa(unescape(encodeURIComponent(f)));
        }, i.prototype.toURI = function() {
          var f = this.toJSON();
          return encodeURIComponent(f);
        }, i.prototype.toComment = function(f) {
          var s, o, y;
          return f != null && f.encoding === "uri" ? (s = "", o = this.toURI()) : (s = ";base64", o = this.toBase64()), y = "sourceMappingURL=data:application/json;charset=utf-8" + s + "," + o, f != null && f.multiline ? "/*# " + y + " */" : "//# " + y;
        }, i.prototype.toObject = function() {
          return JSON.parse(this.toJSON());
        }, i.prototype.addProperty = function(f, s) {
          if (this.sourcemap.hasOwnProperty(f)) throw new Error('property "' + f + '" already exists on the sourcemap, use set property instead');
          return this.setProperty(f, s);
        }, i.prototype.setProperty = function(f, s) {
          return this.sourcemap[f] = s, this;
        }, i.prototype.getProperty = function(f) {
          return this.sourcemap[f];
        }, n.fromObject = function(f) {
          return new i(f);
        }, n.fromJSON = function(f) {
          return new i(f, { isJSON: !0 });
        }, n.fromURI = function(f) {
          return new i(f, { encoding: "uri" });
        }, n.fromBase64 = function(f) {
          return new i(f, { encoding: "base64" });
        }, n.fromComment = function(f) {
          var s;
          return new i(f = f.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), { encoding: (s = n.commentRegex.exec(f)) && s[4] || "uri", hasComment: !0 });
        }, n.fromMapFileComment = function(f, s) {
          if (typeof s == "string") throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
          var o = function(y, m) {
            var g = n.mapFileCommentRegex.exec(y), b = g[1] || g[2];
            try {
              return (y = m(b)) != null && typeof y.catch == "function" ? y.catch(v) : y;
            } catch (T) {
              v(T);
            }
            function v(T) {
              throw new Error("An error occurred while trying to read the map file at " + b + `
` + T.stack);
            }
          }(f, s);
          return o != null && typeof o.then == "function" ? o.then(c) : c(o);
        }, n.fromSource = function(f) {
          var s = f.match(n.commentRegex);
          return s ? n.fromComment(s.pop()) : null;
        }, n.fromMapFileSource = function(f, s) {
          if (typeof s == "string") throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
          var o = f.match(n.mapFileCommentRegex);
          return o ? n.fromMapFileComment(o.pop(), s) : null;
        }, n.removeComments = function(f) {
          return f.replace(n.commentRegex, "");
        }, n.removeMapFileComments = function(f) {
          return f.replace(n.mapFileCommentRegex, "");
        }, n.generateMapFileComment = function(f, s) {
          var o = "sourceMappingURL=" + f;
          return s && s.multiline ? "/*# " + o + " */" : "//# " + o;
        };
      }, "./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/browser.js": (h, n, u) => {
        n.formatArgs = function(c) {
          if (c[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + c[0] + (this.useColors ? "%c " : " ") + "+" + h.exports.humanize(this.diff), !this.useColors) return;
          const f = "color: " + this.color;
          c.splice(1, 0, f, "color: inherit");
          let s = 0, o = 0;
          c[0].replace(/%[a-zA-Z%]/g, (y) => {
            y !== "%%" && (s++, y === "%c" && (o = s));
          }), c.splice(o, 0, f);
        }, n.save = function(c) {
          try {
            c ? n.storage.setItem("debug", c) : n.storage.removeItem("debug");
          } catch {
          }
        }, n.load = function() {
          let c;
          try {
            c = n.storage.getItem("debug");
          } catch {
          }
          return !c && typeof Ze < "u" && "env" in Ze && (c = Ze.env.DEBUG), c;
        }, n.useColors = function() {
          return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, n.storage = function() {
          try {
            return localStorage;
          } catch {
          }
        }(), n.destroy = /* @__PURE__ */ (() => {
          let c = !1;
          return () => {
            c || (c = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), n.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n.log = console.debug || console.log || (() => {
        }), h.exports = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/common.js")(n);
        const { formatters: i } = h.exports;
        i.j = function(c) {
          try {
            return JSON.stringify(c);
          } catch (f) {
            return "[UnexpectedJSONParseError]: " + f.message;
          }
        };
      }, "./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/common.js": (h, n, u) => {
        h.exports = function(i) {
          function c(o) {
            let y, m, g, b = null;
            function v(...T) {
              if (!v.enabled) return;
              const E = v, O = Number(/* @__PURE__ */ new Date()), D = O - (y || O);
              E.diff = D, E.prev = y, E.curr = O, y = O, T[0] = c.coerce(T[0]), typeof T[0] != "string" && T.unshift("%O");
              let $ = 0;
              T[0] = T[0].replace(/%([a-zA-Z%])/g, (I, k) => {
                if (I === "%%") return "%";
                $++;
                const L = c.formatters[k];
                if (typeof L == "function") {
                  const M = T[$];
                  I = L.call(E, M), T.splice($, 1), $--;
                }
                return I;
              }), c.formatArgs.call(E, T), (E.log || c.log).apply(E, T);
            }
            return v.namespace = o, v.useColors = c.useColors(), v.color = c.selectColor(o), v.extend = f, v.destroy = c.destroy, Object.defineProperty(v, "enabled", { enumerable: !0, configurable: !1, get: () => b !== null ? b : (m !== c.namespaces && (m = c.namespaces, g = c.enabled(o)), g), set: (T) => {
              b = T;
            } }), typeof c.init == "function" && c.init(v), v;
          }
          function f(o, y) {
            const m = c(this.namespace + (y === void 0 ? ":" : y) + o);
            return m.log = this.log, m;
          }
          function s(o) {
            return o.toString().substring(2, o.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return c.debug = c, c.default = c, c.coerce = function(o) {
            return o instanceof Error ? o.stack || o.message : o;
          }, c.disable = function() {
            const o = [...c.names.map(s), ...c.skips.map(s).map((y) => "-" + y)].join(",");
            return c.enable(""), o;
          }, c.enable = function(o) {
            let y;
            c.save(o), c.namespaces = o, c.names = [], c.skips = [];
            const m = (typeof o == "string" ? o : "").split(/[\s,]+/), g = m.length;
            for (y = 0; y < g; y++) m[y] && ((o = m[y].replace(/\*/g, ".*?"))[0] === "-" ? c.skips.push(new RegExp("^" + o.slice(1) + "$")) : c.names.push(new RegExp("^" + o + "$")));
          }, c.enabled = function(o) {
            if (o[o.length - 1] === "*") return !0;
            let y, m;
            for (y = 0, m = c.skips.length; y < m; y++) if (c.skips[y].test(o)) return !1;
            for (y = 0, m = c.names.length; y < m; y++) if (c.names[y].test(o)) return !0;
            return !1;
          }, c.humanize = u("./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"), c.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(i).forEach((o) => {
            c[o] = i[o];
          }), c.names = [], c.skips = [], c.formatters = {}, c.selectColor = function(o) {
            let y = 0;
            for (let m = 0; m < o.length; m++) y = (y << 5) - y + o.charCodeAt(m), y |= 0;
            return c.colors[Math.abs(y) % c.colors.length];
          }, c.enable(c.load()), c;
        };
      }, "./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js": (h, n, u) => {
        typeof Ze > "u" || Ze.type === "renderer" || Ze.browser === !0 || Ze.__nwjs ? h.exports = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/browser.js") : h.exports = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/node.js");
      }, "./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/node.js": (h, n, u) => {
        const i = u("tty"), c = u("util");
        n.init = function(s) {
          s.inspectOpts = {};
          const o = Object.keys(n.inspectOpts);
          for (let y = 0; y < o.length; y++) s.inspectOpts[o[y]] = n.inspectOpts[o[y]];
        }, n.log = function(...s) {
          return Ze.stderr.write(c.formatWithOptions(n.inspectOpts, ...s) + `
`);
        }, n.formatArgs = function(s) {
          const { namespace: o, useColors: y } = this;
          if (y) {
            const m = this.color, g = "\x1B[3" + (m < 8 ? m : "8;5;" + m), b = `  ${g};1m${o} \x1B[0m`;
            s[0] = b + s[0].split(`
`).join(`
` + b), s.push(g + "m+" + h.exports.humanize(this.diff) + "\x1B[0m");
          } else s[0] = function() {
            return n.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
          }() + o + " " + s[0];
        }, n.save = function(s) {
          s ? Ze.env.DEBUG = s : delete Ze.env.DEBUG;
        }, n.load = function() {
          return Ze.env.DEBUG;
        }, n.useColors = function() {
          return "colors" in n.inspectOpts ? !!n.inspectOpts.colors : i.isatty(Ze.stderr.fd);
        }, n.destroy = c.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), n.colors = [6, 2, 3, 4, 5, 1];
        try {
          const s = u("./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
          s && (s.stderr || s).level >= 2 && (n.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch {
        }
        n.inspectOpts = Object.keys(Ze.env).filter((s) => /^debug_/i.test(s)).reduce((s, o) => {
          const y = o.substring(6).toLowerCase().replace(/_([a-z])/g, (g, b) => b.toUpperCase());
          let m = Ze.env[o];
          return m = !!/^(yes|on|true|enabled)$/i.test(m) || !/^(no|off|false|disabled)$/i.test(m) && (m === "null" ? null : Number(m)), s[y] = m, s;
        }, {}), h.exports = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/common.js")(n);
        const { formatters: f } = h.exports;
        f.o = function(s) {
          return this.inspectOpts.colors = this.useColors, c.inspect(s, this.inspectOpts).split(`
`).map((o) => o.trim()).join(" ");
        }, f.O = function(s) {
          return this.inspectOpts.colors = this.useColors, c.inspect(s, this.inspectOpts);
        };
      }, "./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js": (h) => {
        const n = Symbol.for("gensync:v1:start"), u = Symbol.for("gensync:v1:suspend"), i = "GENSYNC_EXPECTED_START", c = "GENSYNC_EXPECTED_SUSPEND", f = "GENSYNC_OPTIONS_ERROR";
        function s(O, D, $, I) {
          if (typeof $ === O || I && $ === void 0) return;
          let k;
          throw k = I ? `Expected opts.${D} to be either a ${O}, or undefined.` : `Expected opts.${D} to be a ${O}.`, o(k, f);
        }
        function o(O, D) {
          return Object.assign(new Error(O), { code: D });
        }
        function y({ name: O, arity: D, sync: $, async: I }) {
          return E(O, D, function* (...k) {
            const L = yield n;
            if (!L)
              return $.call(this, k);
            let M;
            try {
              I.call(this, k, (x) => {
                M || (M = { value: x }, L());
              }, (x) => {
                M || (M = { err: x }, L());
              });
            } catch (x) {
              M = { err: x }, L();
            }
            if (yield u, M.hasOwnProperty("err")) throw M.err;
            return M.value;
          });
        }
        function m(O) {
          let D;
          for (; !({ value: D } = O.next()).done; ) b(D, O);
          return D;
        }
        function g(O, D, $) {
          (function I() {
            try {
              let k;
              for (; !({ value: k } = O.next()).done; ) {
                b(k, O);
                let L = !0, M = !1;
                const x = O.next(() => {
                  L ? M = !0 : I();
                });
                if (L = !1, v(x, O), !M) return;
              }
              return D(k);
            } catch (k) {
              return $(k);
            }
          })();
        }
        function b(O, D) {
          O !== n && T(D, o(`Got unexpected yielded value in gensync generator: ${JSON.stringify(O)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, i));
        }
        function v({ value: O, done: D }, $) {
          (D || O !== u) && T($, o(D ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(O)}. If you get this, it is probably a gensync bug.`, c));
        }
        function T(O, D) {
          throw O.throw && O.throw(D), D;
        }
        function E(O, D, $) {
          if (typeof O == "string") {
            const I = Object.getOwnPropertyDescriptor($, "name");
            I && !I.configurable || Object.defineProperty($, "name", Object.assign(I || {}, { configurable: !0, value: O }));
          }
          if (typeof D == "number") {
            const I = Object.getOwnPropertyDescriptor($, "length");
            I && !I.configurable || Object.defineProperty($, "length", Object.assign(I || {}, { configurable: !0, value: D }));
          }
          return $;
        }
        h.exports = Object.assign(function(O) {
          let D = O;
          return D = typeof O != "function" ? function({ name: $, arity: I, sync: k, async: L, errback: M }) {
            if (s("string", "name", $, !0), s("number", "arity", I, !0), s("function", "sync", k), s("function", "async", L, !0), s("function", "errback", M, !0), L && M) throw o("Expected one of either opts.async or opts.errback, but got _both_.", f);
            if (typeof $ != "string") {
              let x;
              M && M.name && M.name !== "errback" && (x = M.name), L && L.name && L.name !== "async" && (x = L.name.replace(/Async$/, "")), k && k.name && k.name !== "sync" && (x = k.name.replace(/Sync$/, "")), typeof x == "string" && ($ = x);
            }
            return typeof I != "number" && (I = k.length), y({ name: $, arity: I, sync: function(x) {
              return k.apply(this, x);
            }, async: function(x, _, S) {
              L ? L.apply(this, x).then(_, S) : M ? M.call(this, ...x, (C, R) => {
                C == null ? _(R) : S(C);
              }) : _(k.apply(this, x));
            } });
          }(O) : function($) {
            return E($.name, $.length, function(...I) {
              return $.apply(this, I);
            });
          }(O), Object.assign(D, /* @__PURE__ */ function($) {
            return { sync: function(...k) {
              return m($.apply(this, k));
            }, async: function(...k) {
              return new Promise((L, M) => {
                g($.apply(this, k), L, M);
              });
            }, errback: function(...k) {
              const L = k.pop();
              if (typeof L != "function") throw o("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
              let M;
              try {
                M = $.apply(this, k);
              } catch (x) {
                return void L(x);
              }
              g(M, (x) => L(void 0, x), (x) => L(x));
            } };
          }(D));
        }, { all: y({ name: "all", arity: 1, sync: function(O) {
          return Array.from(O[0]).map((D) => m(D));
        }, async: function(O, D, $) {
          const I = Array.from(O[0]);
          if (I.length === 0) return void Promise.resolve().then(() => D([]));
          let k = 0;
          const L = I.map(() => {
          });
          I.forEach((M, x) => {
            g(M, (_) => {
              L[x] = _, k += 1, k === L.length && D(L);
            }, $);
          });
        } }), race: y({ name: "race", arity: 1, sync: function(O) {
          const D = Array.from(O[0]);
          if (D.length === 0) throw o("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          return m(D[0]);
        }, async: function(O, D, $) {
          const I = Array.from(O[0]);
          if (I.length === 0) throw o("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          for (const k of I) g(k, D, $);
        } }) });
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js": (h, n, u) => {
        h.exports = u("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json");
      }, "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": (h) => {
        h.exports = (n, u = Ze.argv) => {
          const i = n.startsWith("-") ? "" : n.length === 1 ? "-" : "--", c = u.indexOf(i + n), f = u.indexOf("--");
          return c !== -1 && (f === -1 || c < f);
        };
      }, "./node_modules/.pnpm/jsesc@2.5.2/node_modules/jsesc/jsesc.js": (h) => {
        const n = {}, u = n.hasOwnProperty, i = (v, T) => {
          for (const E in v) u.call(v, E) && T(E, v[E]);
        }, c = n.toString, f = Array.isArray, s = Gt.isBuffer, o = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, y = /["'\\\b\f\n\r\t]/, m = /[0-9]/, g = /[ !#-&\(-\[\]-_a-~]/, b = (v, T) => {
          const E = () => {
            _ = x, ++T.indentLevel, x = T.indent.repeat(T.indentLevel);
          }, O = { escapeEverything: !1, minimal: !1, isScriptContext: !1, quotes: "single", wrap: !1, es6: !1, json: !1, compact: !0, lowercaseHex: !1, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: !1, __inline2__: !1 }, D = T && T.json;
          var $, I;
          D && (O.quotes = "double", O.wrap = !0), $ = O, (T = ((I = T) && i(I, (G, N) => {
            $[G] = N;
          }), $)).quotes != "single" && T.quotes != "double" && T.quotes != "backtick" && (T.quotes = "single");
          const k = T.quotes == "double" ? '"' : T.quotes == "backtick" ? "`" : "'", L = T.compact, M = T.lowercaseHex;
          let x = T.indent.repeat(T.indentLevel), _ = "";
          const S = T.__inline1__, C = T.__inline2__, R = L ? "" : `
`;
          let H, z = !0;
          const U = T.numbers == "binary", P = T.numbers == "octal", W = T.numbers == "decimal", B = T.numbers == "hexadecimal";
          if (D && v && /* @__PURE__ */ ((G) => typeof G == "function")(v.toJSON) && (v = v.toJSON()), !((G) => typeof G == "string" || c.call(G) == "[object String]")(v)) {
            if (((G) => c.call(G) == "[object Map]")(v)) return v.size == 0 ? "new Map()" : (L || (T.__inline1__ = !0, T.__inline2__ = !1), "new Map(" + b(Array.from(v), T) + ")");
            if (((G) => c.call(G) == "[object Set]")(v)) return v.size == 0 ? "new Set()" : "new Set(" + b(Array.from(v), T) + ")";
            if (s(v)) return v.length == 0 ? "Buffer.from([])" : "Buffer.from(" + b(Array.from(v), T) + ")";
            if (f(v)) return H = [], T.wrap = !0, S && (T.__inline1__ = !1, T.__inline2__ = !0), C || E(), ((G, N) => {
              const V = G.length;
              let F = -1;
              for (; ++F < V; ) N(G[F]);
            })(v, (G) => {
              z = !1, C && (T.__inline2__ = !1), H.push((L || C ? "" : x) + b(G, T));
            }), z ? "[]" : C ? "[" + H.join(", ") + "]" : "[" + R + H.join("," + R) + R + (L ? "" : _) + "]";
            if (!((G) => typeof G == "number" || c.call(G) == "[object Number]")(v)) return ((G) => c.call(G) == "[object Object]")(v) ? (H = [], T.wrap = !0, E(), i(v, (G, N) => {
              z = !1, H.push((L ? "" : x) + b(G, T) + ":" + (L ? "" : " ") + b(N, T));
            }), z ? "{}" : "{" + R + H.join("," + R) + R + (L ? "" : _) + "}") : D ? JSON.stringify(v) || "null" : String(v);
            if (D) return JSON.stringify(v);
            if (W) return String(v);
            if (B) {
              let G = v.toString(16);
              return M || (G = G.toUpperCase()), "0x" + G;
            }
            if (U) return "0b" + v.toString(2);
            if (P) return "0o" + v.toString(8);
          }
          const Q = v;
          let J = -1;
          const re = Q.length;
          for (H = ""; ++J < re; ) {
            const G = Q.charAt(J);
            if (T.es6) {
              const K = Q.charCodeAt(J);
              if (K >= 55296 && K <= 56319 && re > J + 1) {
                const ie = Q.charCodeAt(J + 1);
                if (ie >= 56320 && ie <= 57343) {
                  let fe = (1024 * (K - 55296) + ie - 56320 + 65536).toString(16);
                  M || (fe = fe.toUpperCase()), H += "\\u{" + fe + "}", ++J;
                  continue;
                }
              }
            }
            if (!T.escapeEverything) {
              if (g.test(G)) {
                H += G;
                continue;
              }
              if (G == '"') {
                H += k == G ? '\\"' : G;
                continue;
              }
              if (G == "`") {
                H += k == G ? "\\`" : G;
                continue;
              }
              if (G == "'") {
                H += k == G ? "\\'" : G;
                continue;
              }
            }
            if (G == "\0" && !D && !m.test(Q.charAt(J + 1))) {
              H += "\\0";
              continue;
            }
            if (y.test(G)) {
              H += o[G];
              continue;
            }
            const N = G.charCodeAt(0);
            if (T.minimal && N != 8232 && N != 8233) {
              H += G;
              continue;
            }
            let V = N.toString(16);
            M || (V = V.toUpperCase());
            const F = V.length > 2 || D, X = "\\" + (F ? "u" : "x") + ("0000" + V).slice(F ? -4 : -2);
            H += X;
          }
          return T.wrap && (H = k + H + k), k == "`" && (H = H.replace(/\$\{/g, "\\${")), T.isScriptContext ? H.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, D ? "\\u003C!--" : "\\x3C!--") : H;
        };
        b.version = "2.5.2", h.exports = b;
      }, "./node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js": (h) => {
        var n = 1e3, u = 60 * n, i = 60 * u, c = 24 * i, f = 7 * c, s = 365.25 * c;
        function o(y, m, g, b) {
          var v = m >= 1.5 * g;
          return Math.round(y / g) + " " + b + (v ? "s" : "");
        }
        h.exports = function(y, m) {
          m = m || {};
          var g = typeof y;
          if (g === "string" && y.length > 0) return function(b) {
            if (!((b = String(b)).length > 100)) {
              var v = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(b);
              if (v) {
                var T = parseFloat(v[1]);
                switch ((v[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return T * s;
                  case "weeks":
                  case "week":
                  case "w":
                    return T * f;
                  case "days":
                  case "day":
                  case "d":
                    return T * c;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return T * i;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return T * u;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return T * n;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return T;
                  default:
                    return;
                }
              }
            }
          }(y);
          if (g === "number" && isFinite(y)) return m.long ? function(b) {
            var v = Math.abs(b);
            return v >= c ? o(b, v, c, "day") : v >= i ? o(b, v, i, "hour") : v >= u ? o(b, v, u, "minute") : v >= n ? o(b, v, n, "second") : b + " ms";
          }(y) : function(b) {
            var v = Math.abs(b);
            return v >= c ? Math.round(b / c) + "d" : v >= i ? Math.round(b / i) + "h" : v >= u ? Math.round(b / u) + "m" : v >= n ? Math.round(b / n) + "s" : b + "ms";
          }(y);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(y));
        };
      }, "./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js": (h, n) => {
        var u;
        n = h.exports = D, u = typeof Ze == "object" && Ze.env && Ze.env.NODE_DEBUG && /\bsemver\b/i.test(Ze.env.NODE_DEBUG) ? function() {
          var G = Array.prototype.slice.call(arguments, 0);
          G.unshift("SEMVER"), console.log.apply(console, G);
        } : function() {
        }, n.SEMVER_SPEC_VERSION = "2.0.0";
        var i = 256, c = Number.MAX_SAFE_INTEGER || 9007199254740991, f = i - 6, s = n.re = [], o = n.safeRe = [], y = n.src = [], m = n.tokens = {}, g = 0;
        function b(G) {
          m[G] = g++;
        }
        var v = [["\\s", 1], ["\\d", i], ["[a-zA-Z0-9-]", f]];
        function T(G) {
          for (var N = 0; N < v.length; N++) {
            var V = v[N][0], F = v[N][1];
            G = G.split(V + "*").join(V + "{0," + F + "}").split(V + "+").join(V + "{1," + F + "}");
          }
          return G;
        }
        b("NUMERICIDENTIFIER"), y[m.NUMERICIDENTIFIER] = "0|[1-9]\\d*", b("NUMERICIDENTIFIERLOOSE"), y[m.NUMERICIDENTIFIERLOOSE] = "\\d+", b("NONNUMERICIDENTIFIER"), y[m.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", b("MAINVERSION"), y[m.MAINVERSION] = "(" + y[m.NUMERICIDENTIFIER] + ")\\.(" + y[m.NUMERICIDENTIFIER] + ")\\.(" + y[m.NUMERICIDENTIFIER] + ")", b("MAINVERSIONLOOSE"), y[m.MAINVERSIONLOOSE] = "(" + y[m.NUMERICIDENTIFIERLOOSE] + ")\\.(" + y[m.NUMERICIDENTIFIERLOOSE] + ")\\.(" + y[m.NUMERICIDENTIFIERLOOSE] + ")", b("PRERELEASEIDENTIFIER"), y[m.PRERELEASEIDENTIFIER] = "(?:" + y[m.NUMERICIDENTIFIER] + "|" + y[m.NONNUMERICIDENTIFIER] + ")", b("PRERELEASEIDENTIFIERLOOSE"), y[m.PRERELEASEIDENTIFIERLOOSE] = "(?:" + y[m.NUMERICIDENTIFIERLOOSE] + "|" + y[m.NONNUMERICIDENTIFIER] + ")", b("PRERELEASE"), y[m.PRERELEASE] = "(?:-(" + y[m.PRERELEASEIDENTIFIER] + "(?:\\." + y[m.PRERELEASEIDENTIFIER] + ")*))", b("PRERELEASELOOSE"), y[m.PRERELEASELOOSE] = "(?:-?(" + y[m.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + y[m.PRERELEASEIDENTIFIERLOOSE] + ")*))", b("BUILDIDENTIFIER"), y[m.BUILDIDENTIFIER] = "[a-zA-Z0-9-]+", b("BUILD"), y[m.BUILD] = "(?:\\+(" + y[m.BUILDIDENTIFIER] + "(?:\\." + y[m.BUILDIDENTIFIER] + ")*))", b("FULL"), b("FULLPLAIN"), y[m.FULLPLAIN] = "v?" + y[m.MAINVERSION] + y[m.PRERELEASE] + "?" + y[m.BUILD] + "?", y[m.FULL] = "^" + y[m.FULLPLAIN] + "$", b("LOOSEPLAIN"), y[m.LOOSEPLAIN] = "[v=\\s]*" + y[m.MAINVERSIONLOOSE] + y[m.PRERELEASELOOSE] + "?" + y[m.BUILD] + "?", b("LOOSE"), y[m.LOOSE] = "^" + y[m.LOOSEPLAIN] + "$", b("GTLT"), y[m.GTLT] = "((?:<|>)?=?)", b("XRANGEIDENTIFIERLOOSE"), y[m.XRANGEIDENTIFIERLOOSE] = y[m.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", b("XRANGEIDENTIFIER"), y[m.XRANGEIDENTIFIER] = y[m.NUMERICIDENTIFIER] + "|x|X|\\*", b("XRANGEPLAIN"), y[m.XRANGEPLAIN] = "[v=\\s]*(" + y[m.XRANGEIDENTIFIER] + ")(?:\\.(" + y[m.XRANGEIDENTIFIER] + ")(?:\\.(" + y[m.XRANGEIDENTIFIER] + ")(?:" + y[m.PRERELEASE] + ")?" + y[m.BUILD] + "?)?)?", b("XRANGEPLAINLOOSE"), y[m.XRANGEPLAINLOOSE] = "[v=\\s]*(" + y[m.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + y[m.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + y[m.XRANGEIDENTIFIERLOOSE] + ")(?:" + y[m.PRERELEASELOOSE] + ")?" + y[m.BUILD] + "?)?)?", b("XRANGE"), y[m.XRANGE] = "^" + y[m.GTLT] + "\\s*" + y[m.XRANGEPLAIN] + "$", b("XRANGELOOSE"), y[m.XRANGELOOSE] = "^" + y[m.GTLT] + "\\s*" + y[m.XRANGEPLAINLOOSE] + "$", b("COERCE"), y[m.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", b("COERCERTL"), s[m.COERCERTL] = new RegExp(y[m.COERCE], "g"), o[m.COERCERTL] = new RegExp(T(y[m.COERCE]), "g"), b("LONETILDE"), y[m.LONETILDE] = "(?:~>?)", b("TILDETRIM"), y[m.TILDETRIM] = "(\\s*)" + y[m.LONETILDE] + "\\s+", s[m.TILDETRIM] = new RegExp(y[m.TILDETRIM], "g"), o[m.TILDETRIM] = new RegExp(T(y[m.TILDETRIM]), "g"), b("TILDE"), y[m.TILDE] = "^" + y[m.LONETILDE] + y[m.XRANGEPLAIN] + "$", b("TILDELOOSE"), y[m.TILDELOOSE] = "^" + y[m.LONETILDE] + y[m.XRANGEPLAINLOOSE] + "$", b("LONECARET"), y[m.LONECARET] = "(?:\\^)", b("CARETTRIM"), y[m.CARETTRIM] = "(\\s*)" + y[m.LONECARET] + "\\s+", s[m.CARETTRIM] = new RegExp(y[m.CARETTRIM], "g"), o[m.CARETTRIM] = new RegExp(T(y[m.CARETTRIM]), "g"), b("CARET"), y[m.CARET] = "^" + y[m.LONECARET] + y[m.XRANGEPLAIN] + "$", b("CARETLOOSE"), y[m.CARETLOOSE] = "^" + y[m.LONECARET] + y[m.XRANGEPLAINLOOSE] + "$", b("COMPARATORLOOSE"), y[m.COMPARATORLOOSE] = "^" + y[m.GTLT] + "\\s*(" + y[m.LOOSEPLAIN] + ")$|^$", b("COMPARATOR"), y[m.COMPARATOR] = "^" + y[m.GTLT] + "\\s*(" + y[m.FULLPLAIN] + ")$|^$", b("COMPARATORTRIM"), y[m.COMPARATORTRIM] = "(\\s*)" + y[m.GTLT] + "\\s*(" + y[m.LOOSEPLAIN] + "|" + y[m.XRANGEPLAIN] + ")", s[m.COMPARATORTRIM] = new RegExp(y[m.COMPARATORTRIM], "g"), o[m.COMPARATORTRIM] = new RegExp(T(y[m.COMPARATORTRIM]), "g"), b("HYPHENRANGE"), y[m.HYPHENRANGE] = "^\\s*(" + y[m.XRANGEPLAIN] + ")\\s+-\\s+(" + y[m.XRANGEPLAIN] + ")\\s*$", b("HYPHENRANGELOOSE"), y[m.HYPHENRANGELOOSE] = "^\\s*(" + y[m.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + y[m.XRANGEPLAINLOOSE] + ")\\s*$", b("STAR"), y[m.STAR] = "(<|>)?=?\\s*\\*";
        for (var E = 0; E < g; E++) u(E, y[E]), s[E] || (s[E] = new RegExp(y[E]), o[E] = new RegExp(T(y[E])));
        function O(G, N) {
          if (N && typeof N == "object" || (N = { loose: !!N, includePrerelease: !1 }), G instanceof D) return G;
          if (typeof G != "string" || G.length > i || !(N.loose ? o[m.LOOSE] : o[m.FULL]).test(G)) return null;
          try {
            return new D(G, N);
          } catch {
            return null;
          }
        }
        function D(G, N) {
          if (N && typeof N == "object" || (N = { loose: !!N, includePrerelease: !1 }), G instanceof D) {
            if (G.loose === N.loose) return G;
            G = G.version;
          } else if (typeof G != "string") throw new TypeError("Invalid Version: " + G);
          if (G.length > i) throw new TypeError("version is longer than " + i + " characters");
          if (!(this instanceof D)) return new D(G, N);
          u("SemVer", G, N), this.options = N, this.loose = !!N.loose;
          var V = G.trim().match(N.loose ? o[m.LOOSE] : o[m.FULL]);
          if (!V) throw new TypeError("Invalid Version: " + G);
          if (this.raw = G, this.major = +V[1], this.minor = +V[2], this.patch = +V[3], this.major > c || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > c || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > c || this.patch < 0) throw new TypeError("Invalid patch version");
          V[4] ? this.prerelease = V[4].split(".").map(function(F) {
            if (/^[0-9]+$/.test(F)) {
              var X = +F;
              if (X >= 0 && X < c) return X;
            }
            return F;
          }) : this.prerelease = [], this.build = V[5] ? V[5].split(".") : [], this.format();
        }
        n.parse = O, n.valid = function(G, N) {
          var V = O(G, N);
          return V ? V.version : null;
        }, n.clean = function(G, N) {
          var V = O(G.trim().replace(/^[=v]+/, ""), N);
          return V ? V.version : null;
        }, n.SemVer = D, D.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, D.prototype.toString = function() {
          return this.version;
        }, D.prototype.compare = function(G) {
          return u("SemVer.compare", this.version, this.options, G), G instanceof D || (G = new D(G, this.options)), this.compareMain(G) || this.comparePre(G);
        }, D.prototype.compareMain = function(G) {
          return G instanceof D || (G = new D(G, this.options)), I(this.major, G.major) || I(this.minor, G.minor) || I(this.patch, G.patch);
        }, D.prototype.comparePre = function(G) {
          if (G instanceof D || (G = new D(G, this.options)), this.prerelease.length && !G.prerelease.length) return -1;
          if (!this.prerelease.length && G.prerelease.length) return 1;
          if (!this.prerelease.length && !G.prerelease.length) return 0;
          var N = 0;
          do {
            var V = this.prerelease[N], F = G.prerelease[N];
            if (u("prerelease compare", N, V, F), V === void 0 && F === void 0) return 0;
            if (F === void 0) return 1;
            if (V === void 0) return -1;
            if (V !== F) return I(V, F);
          } while (++N);
        }, D.prototype.compareBuild = function(G) {
          G instanceof D || (G = new D(G, this.options));
          var N = 0;
          do {
            var V = this.build[N], F = G.build[N];
            if (u("prerelease compare", N, V, F), V === void 0 && F === void 0) return 0;
            if (F === void 0) return 1;
            if (V === void 0) return -1;
            if (V !== F) return I(V, F);
          } while (++N);
        }, D.prototype.inc = function(G, N) {
          switch (G) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", N);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", N);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", N), this.inc("pre", N);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", N), this.inc("pre", N);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) this.prerelease = [0];
              else {
                for (var V = this.prerelease.length; --V >= 0; ) typeof this.prerelease[V] == "number" && (this.prerelease[V]++, V = -2);
                V === -1 && this.prerelease.push(0);
              }
              N && (this.prerelease[0] === N ? isNaN(this.prerelease[1]) && (this.prerelease = [N, 0]) : this.prerelease = [N, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + G);
          }
          return this.format(), this.raw = this.version, this;
        }, n.inc = function(G, N, V, F) {
          typeof V == "string" && (F = V, V = void 0);
          try {
            return new D(G, V).inc(N, F).version;
          } catch {
            return null;
          }
        }, n.diff = function(G, N) {
          if (x(G, N)) return null;
          var V = O(G), F = O(N), X = "";
          if (V.prerelease.length || F.prerelease.length) {
            X = "pre";
            var K = "prerelease";
          }
          for (var ie in V) if ((ie === "major" || ie === "minor" || ie === "patch") && V[ie] !== F[ie]) return X + ie;
          return K;
        }, n.compareIdentifiers = I;
        var $ = /^[0-9]+$/;
        function I(G, N) {
          var V = $.test(G), F = $.test(N);
          return V && F && (G = +G, N = +N), G === N ? 0 : V && !F ? -1 : F && !V ? 1 : G < N ? -1 : 1;
        }
        function k(G, N, V) {
          return new D(G, V).compare(new D(N, V));
        }
        function L(G, N, V) {
          return k(G, N, V) > 0;
        }
        function M(G, N, V) {
          return k(G, N, V) < 0;
        }
        function x(G, N, V) {
          return k(G, N, V) === 0;
        }
        function _(G, N, V) {
          return k(G, N, V) !== 0;
        }
        function S(G, N, V) {
          return k(G, N, V) >= 0;
        }
        function C(G, N, V) {
          return k(G, N, V) <= 0;
        }
        function R(G, N, V, F) {
          switch (N) {
            case "===":
              return typeof G == "object" && (G = G.version), typeof V == "object" && (V = V.version), G === V;
            case "!==":
              return typeof G == "object" && (G = G.version), typeof V == "object" && (V = V.version), G !== V;
            case "":
            case "=":
            case "==":
              return x(G, V, F);
            case "!=":
              return _(G, V, F);
            case ">":
              return L(G, V, F);
            case ">=":
              return S(G, V, F);
            case "<":
              return M(G, V, F);
            case "<=":
              return C(G, V, F);
            default:
              throw new TypeError("Invalid operator: " + N);
          }
        }
        function H(G, N) {
          if (N && typeof N == "object" || (N = { loose: !!N, includePrerelease: !1 }), G instanceof H) {
            if (G.loose === !!N.loose) return G;
            G = G.value;
          }
          if (!(this instanceof H)) return new H(G, N);
          G = G.trim().split(/\s+/).join(" "), u("comparator", G, N), this.options = N, this.loose = !!N.loose, this.parse(G), this.semver === z ? this.value = "" : this.value = this.operator + this.semver.version, u("comp", this);
        }
        n.rcompareIdentifiers = function(G, N) {
          return I(N, G);
        }, n.major = function(G, N) {
          return new D(G, N).major;
        }, n.minor = function(G, N) {
          return new D(G, N).minor;
        }, n.patch = function(G, N) {
          return new D(G, N).patch;
        }, n.compare = k, n.compareLoose = function(G, N) {
          return k(G, N, !0);
        }, n.compareBuild = function(G, N, V) {
          var F = new D(G, V), X = new D(N, V);
          return F.compare(X) || F.compareBuild(X);
        }, n.rcompare = function(G, N, V) {
          return k(N, G, V);
        }, n.sort = function(G, N) {
          return G.sort(function(V, F) {
            return n.compareBuild(V, F, N);
          });
        }, n.rsort = function(G, N) {
          return G.sort(function(V, F) {
            return n.compareBuild(F, V, N);
          });
        }, n.gt = L, n.lt = M, n.eq = x, n.neq = _, n.gte = S, n.lte = C, n.cmp = R, n.Comparator = H;
        var z = {};
        function U(G, N) {
          if (N && typeof N == "object" || (N = { loose: !!N, includePrerelease: !1 }), G instanceof U) return G.loose === !!N.loose && G.includePrerelease === !!N.includePrerelease ? G : new U(G.raw, N);
          if (G instanceof H) return new U(G.value, N);
          if (!(this instanceof U)) return new U(G, N);
          if (this.options = N, this.loose = !!N.loose, this.includePrerelease = !!N.includePrerelease, this.raw = G.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function(V) {
            return this.parseRange(V.trim());
          }, this).filter(function(V) {
            return V.length;
          }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
          this.format();
        }
        function P(G, N) {
          for (var V = !0, F = G.slice(), X = F.pop(); V && F.length; ) V = F.every(function(K) {
            return X.intersects(K, N);
          }), X = F.pop();
          return V;
        }
        function W(G) {
          return !G || G.toLowerCase() === "x" || G === "*";
        }
        function B(G, N, V, F, X, K, ie, fe, _e, Ae, ce, ee, ae) {
          return ((N = W(V) ? "" : W(F) ? ">=" + V + ".0.0" : W(X) ? ">=" + V + "." + F + ".0" : ">=" + N) + " " + (fe = W(_e) ? "" : W(Ae) ? "<" + (+_e + 1) + ".0.0" : W(ce) ? "<" + _e + "." + (+Ae + 1) + ".0" : ee ? "<=" + _e + "." + Ae + "." + ce + "-" + ee : "<=" + fe)).trim();
        }
        function Q(G, N, V) {
          for (var F = 0; F < G.length; F++) if (!G[F].test(N)) return !1;
          if (N.prerelease.length && !V.includePrerelease) {
            for (F = 0; F < G.length; F++) if (u(G[F].semver), G[F].semver !== z && G[F].semver.prerelease.length > 0) {
              var X = G[F].semver;
              if (X.major === N.major && X.minor === N.minor && X.patch === N.patch) return !0;
            }
            return !1;
          }
          return !0;
        }
        function J(G, N, V) {
          try {
            N = new U(N, V);
          } catch {
            return !1;
          }
          return N.test(G);
        }
        function re(G, N, V, F) {
          var X, K, ie, fe, _e;
          switch (G = new D(G, F), N = new U(N, F), V) {
            case ">":
              X = L, K = C, ie = M, fe = ">", _e = ">=";
              break;
            case "<":
              X = M, K = S, ie = L, fe = "<", _e = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (J(G, N, F)) return !1;
          for (var Ae = 0; Ae < N.set.length; ++Ae) {
            var ce = N.set[Ae], ee = null, ae = null;
            if (ce.forEach(function(oe) {
              oe.semver === z && (oe = new H(">=0.0.0")), ee = ee || oe, ae = ae || oe, X(oe.semver, ee.semver, F) ? ee = oe : ie(oe.semver, ae.semver, F) && (ae = oe);
            }), ee.operator === fe || ee.operator === _e || (!ae.operator || ae.operator === fe) && K(G, ae.semver) || ae.operator === _e && ie(G, ae.semver)) return !1;
          }
          return !0;
        }
        H.prototype.parse = function(G) {
          var N = this.options.loose ? o[m.COMPARATORLOOSE] : o[m.COMPARATOR], V = G.match(N);
          if (!V) throw new TypeError("Invalid comparator: " + G);
          this.operator = V[1] !== void 0 ? V[1] : "", this.operator === "=" && (this.operator = ""), V[2] ? this.semver = new D(V[2], this.options.loose) : this.semver = z;
        }, H.prototype.toString = function() {
          return this.value;
        }, H.prototype.test = function(G) {
          if (u("Comparator.test", G, this.options.loose), this.semver === z || G === z) return !0;
          if (typeof G == "string") try {
            G = new D(G, this.options);
          } catch {
            return !1;
          }
          return R(G, this.operator, this.semver, this.options);
        }, H.prototype.intersects = function(G, N) {
          if (!(G instanceof H)) throw new TypeError("a Comparator is required");
          var V;
          if (N && typeof N == "object" || (N = { loose: !!N, includePrerelease: !1 }), this.operator === "") return this.value === "" || (V = new U(G.value, N), J(this.value, V, N));
          if (G.operator === "") return G.value === "" || (V = new U(this.value, N), J(G.semver, V, N));
          var F = !(this.operator !== ">=" && this.operator !== ">" || G.operator !== ">=" && G.operator !== ">"), X = !(this.operator !== "<=" && this.operator !== "<" || G.operator !== "<=" && G.operator !== "<"), K = this.semver.version === G.semver.version, ie = !(this.operator !== ">=" && this.operator !== "<=" || G.operator !== ">=" && G.operator !== "<="), fe = R(this.semver, "<", G.semver, N) && (this.operator === ">=" || this.operator === ">") && (G.operator === "<=" || G.operator === "<"), _e = R(this.semver, ">", G.semver, N) && (this.operator === "<=" || this.operator === "<") && (G.operator === ">=" || G.operator === ">");
          return F || X || K && ie || fe || _e;
        }, n.Range = U, U.prototype.format = function() {
          return this.range = this.set.map(function(G) {
            return G.join(" ").trim();
          }).join("||").trim(), this.range;
        }, U.prototype.toString = function() {
          return this.range;
        }, U.prototype.parseRange = function(G) {
          var N = this.options.loose, V = N ? o[m.HYPHENRANGELOOSE] : o[m.HYPHENRANGE];
          G = G.replace(V, B), u("hyphen replace", G), G = G.replace(o[m.COMPARATORTRIM], "$1$2$3"), u("comparator trim", G, o[m.COMPARATORTRIM]), G = (G = (G = G.replace(o[m.TILDETRIM], "$1~")).replace(o[m.CARETTRIM], "$1^")).split(/\s+/).join(" ");
          var F = N ? o[m.COMPARATORLOOSE] : o[m.COMPARATOR], X = G.split(" ").map(function(K) {
            return function(ie, fe) {
              return u("comp", ie, fe), ie = function(_e, Ae) {
                return _e.trim().split(/\s+/).map(function(ce) {
                  return function(ee, ae) {
                    u("caret", ee, ae);
                    var oe = ae.loose ? o[m.CARETLOOSE] : o[m.CARET];
                    return ee.replace(oe, function(me, ye, we, ge, se) {
                      var be;
                      return u("caret", ee, me, ye, we, ge, se), W(ye) ? be = "" : W(we) ? be = ">=" + ye + ".0.0 <" + (+ye + 1) + ".0.0" : W(ge) ? be = ye === "0" ? ">=" + ye + "." + we + ".0 <" + ye + "." + (+we + 1) + ".0" : ">=" + ye + "." + we + ".0 <" + (+ye + 1) + ".0.0" : se ? (u("replaceCaret pr", se), be = ye === "0" ? we === "0" ? ">=" + ye + "." + we + "." + ge + "-" + se + " <" + ye + "." + we + "." + (+ge + 1) : ">=" + ye + "." + we + "." + ge + "-" + se + " <" + ye + "." + (+we + 1) + ".0" : ">=" + ye + "." + we + "." + ge + "-" + se + " <" + (+ye + 1) + ".0.0") : (u("no pr"), be = ye === "0" ? we === "0" ? ">=" + ye + "." + we + "." + ge + " <" + ye + "." + we + "." + (+ge + 1) : ">=" + ye + "." + we + "." + ge + " <" + ye + "." + (+we + 1) + ".0" : ">=" + ye + "." + we + "." + ge + " <" + (+ye + 1) + ".0.0"), u("caret return", be), be;
                    });
                  }(ce, Ae);
                }).join(" ");
              }(ie, fe), u("caret", ie), ie = function(_e, Ae) {
                return _e.trim().split(/\s+/).map(function(ce) {
                  return function(ee, ae) {
                    var oe = ae.loose ? o[m.TILDELOOSE] : o[m.TILDE];
                    return ee.replace(oe, function(me, ye, we, ge, se) {
                      var be;
                      return u("tilde", ee, me, ye, we, ge, se), W(ye) ? be = "" : W(we) ? be = ">=" + ye + ".0.0 <" + (+ye + 1) + ".0.0" : W(ge) ? be = ">=" + ye + "." + we + ".0 <" + ye + "." + (+we + 1) + ".0" : se ? (u("replaceTilde pr", se), be = ">=" + ye + "." + we + "." + ge + "-" + se + " <" + ye + "." + (+we + 1) + ".0") : be = ">=" + ye + "." + we + "." + ge + " <" + ye + "." + (+we + 1) + ".0", u("tilde return", be), be;
                    });
                  }(ce, Ae);
                }).join(" ");
              }(ie, fe), u("tildes", ie), ie = function(_e, Ae) {
                return u("replaceXRanges", _e, Ae), _e.split(/\s+/).map(function(ce) {
                  return function(ee, ae) {
                    ee = ee.trim();
                    var oe = ae.loose ? o[m.XRANGELOOSE] : o[m.XRANGE];
                    return ee.replace(oe, function(me, ye, we, ge, se, be) {
                      u("xRange", ee, me, ye, we, ge, se, be);
                      var Ie = W(we), Oe = Ie || W(ge), Be = Oe || W(se), Fe = Be;
                      return ye === "=" && Fe && (ye = ""), be = ae.includePrerelease ? "-0" : "", Ie ? me = ye === ">" || ye === "<" ? "<0.0.0-0" : "*" : ye && Fe ? (Oe && (ge = 0), se = 0, ye === ">" ? (ye = ">=", Oe ? (we = +we + 1, ge = 0, se = 0) : (ge = +ge + 1, se = 0)) : ye === "<=" && (ye = "<", Oe ? we = +we + 1 : ge = +ge + 1), me = ye + we + "." + ge + "." + se + be) : Oe ? me = ">=" + we + ".0.0" + be + " <" + (+we + 1) + ".0.0" + be : Be && (me = ">=" + we + "." + ge + ".0" + be + " <" + we + "." + (+ge + 1) + ".0" + be), u("xRange return", me), me;
                    });
                  }(ce, Ae);
                }).join(" ");
              }(ie, fe), u("xrange", ie), ie = function(_e, Ae) {
                return u("replaceStars", _e, Ae), _e.trim().replace(o[m.STAR], "");
              }(ie, fe), u("stars", ie), ie;
            }(K, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (X = X.filter(function(K) {
            return !!K.match(F);
          })), X = X.map(function(K) {
            return new H(K, this.options);
          }, this);
        }, U.prototype.intersects = function(G, N) {
          if (!(G instanceof U)) throw new TypeError("a Range is required");
          return this.set.some(function(V) {
            return P(V, N) && G.set.some(function(F) {
              return P(F, N) && V.every(function(X) {
                return F.every(function(K) {
                  return X.intersects(K, N);
                });
              });
            });
          });
        }, n.toComparators = function(G, N) {
          return new U(G, N).set.map(function(V) {
            return V.map(function(F) {
              return F.value;
            }).join(" ").trim().split(" ");
          });
        }, U.prototype.test = function(G) {
          if (!G) return !1;
          if (typeof G == "string") try {
            G = new D(G, this.options);
          } catch {
            return !1;
          }
          for (var N = 0; N < this.set.length; N++) if (Q(this.set[N], G, this.options)) return !0;
          return !1;
        }, n.satisfies = J, n.maxSatisfying = function(G, N, V) {
          var F = null, X = null;
          try {
            var K = new U(N, V);
          } catch {
            return null;
          }
          return G.forEach(function(ie) {
            K.test(ie) && (F && X.compare(ie) !== -1 || (X = new D(F = ie, V)));
          }), F;
        }, n.minSatisfying = function(G, N, V) {
          var F = null, X = null;
          try {
            var K = new U(N, V);
          } catch {
            return null;
          }
          return G.forEach(function(ie) {
            K.test(ie) && (F && X.compare(ie) !== 1 || (X = new D(F = ie, V)));
          }), F;
        }, n.minVersion = function(G, N) {
          G = new U(G, N);
          var V = new D("0.0.0");
          if (G.test(V) || (V = new D("0.0.0-0"), G.test(V))) return V;
          V = null;
          for (var F = 0; F < G.set.length; ++F)
            G.set[F].forEach(function(X) {
              var K = new D(X.semver.version);
              switch (X.operator) {
                case ">":
                  K.prerelease.length === 0 ? K.patch++ : K.prerelease.push(0), K.raw = K.format();
                case "":
                case ">=":
                  V && !L(V, K) || (V = K);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + X.operator);
              }
            });
          return V && G.test(V) ? V : null;
        }, n.validRange = function(G, N) {
          try {
            return new U(G, N).range || "*";
          } catch {
            return null;
          }
        }, n.ltr = function(G, N, V) {
          return re(G, N, "<", V);
        }, n.gtr = function(G, N, V) {
          return re(G, N, ">", V);
        }, n.outside = re, n.prerelease = function(G, N) {
          var V = O(G, N);
          return V && V.prerelease.length ? V.prerelease : null;
        }, n.intersects = function(G, N, V) {
          return G = new U(G, V), N = new U(N, V), G.intersects(N);
        }, n.coerce = function(G, N) {
          if (G instanceof D) return G;
          if (typeof G == "number" && (G = String(G)), typeof G != "string") return null;
          var V = null;
          if ((N = N || {}).rtl) {
            for (var F; (F = o[m.COERCERTL].exec(G)) && (!V || V.index + V[0].length !== G.length); ) V && F.index + F[0].length === V.index + V[0].length || (V = F), o[m.COERCERTL].lastIndex = F.index + F[1].length + F[2].length;
            o[m.COERCERTL].lastIndex = -1;
          } else V = G.match(o[m.COERCE]);
          return V === null ? null : O(V[2] + "." + (V[3] || "0") + "." + (V[4] || "0"), N);
        };
      }, "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": (h, n, u) => {
        const i = u("os"), c = u("tty"), f = u("./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"), { env: s } = Ze;
        let o;
        function y(g) {
          return g !== 0 && { level: g, hasBasic: !0, has256: g >= 2, has16m: g >= 3 };
        }
        function m(g, b) {
          if (o === 0) return 0;
          if (f("color=16m") || f("color=full") || f("color=truecolor")) return 3;
          if (f("color=256")) return 2;
          if (g && !b && o === void 0) return 0;
          const v = o || 0;
          if (s.TERM === "dumb") return v;
          if (Ze.platform === "win32") {
            const T = i.release().split(".");
            return Number(T[0]) >= 10 && Number(T[2]) >= 10586 ? Number(T[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in s) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((T) => T in s) || s.CI_NAME === "codeship" ? 1 : v;
          if ("TEAMCITY_VERSION" in s) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(s.TEAMCITY_VERSION) ? 1 : 0;
          if (s.COLORTERM === "truecolor") return 3;
          if ("TERM_PROGRAM" in s) {
            const T = parseInt((s.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (s.TERM_PROGRAM) {
              case "iTerm.app":
                return T >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(s.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(s.TERM) || "COLORTERM" in s ? 1 : v;
        }
        f("no-color") || f("no-colors") || f("color=false") || f("color=never") ? o = 0 : (f("color") || f("colors") || f("color=true") || f("color=always")) && (o = 1), "FORCE_COLOR" in s && (o = s.FORCE_COLOR === "true" ? 1 : s.FORCE_COLOR === "false" ? 0 : s.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(s.FORCE_COLOR, 10), 3)), h.exports = { supportsColor: function(g) {
          return y(m(g, g && g.isTTY));
        }, stdout: y(m(!0, c.isatty(1))), stderr: y(m(!0, c.isatty(2))) };
      }, "./node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js": (h) => {
        let n = null;
        function u(i) {
          if (n !== null && (n.property, 1)) {
            const c = n;
            return n = u.prototype = null, c;
          }
          return n = u.prototype = i ?? /* @__PURE__ */ Object.create(null), new u();
        }
        u(), h.exports = function(i) {
          return u(i);
        };
      }, "./stubs/babel-codeframe.js": (h, n, u) => {
        function i() {
          return "";
        }
        u.r(n), u.d(n, { codeFrameColumns: () => i });
      }, "./stubs/helper-compilation-targets.js": (h, n, u) => {
        function i() {
          return {};
        }
        u.r(n), u.d(n, { default: () => i });
      }, assert: (h) => {
        h.exports = Su();
      }, fs: (h) => {
        h.exports = oi;
      }, module: (h) => {
        h.exports = Rr;
      }, os: (h) => {
        h.exports = Zr;
      }, path: (h) => {
        h.exports = Qr;
      }, process: (h) => {
        h.exports = ky;
      }, tty: (h) => {
        h.exports = HK();
      }, url: (h) => {
        h.exports = Ns;
      }, util: (h) => {
        h.exports = Fi;
      }, v8: (h) => {
        h.exports = Rr;
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js": (h, n, u) => {
        function i() {
          const D = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return D;
          }, D;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.assertSimpleType = E, n.makeStrongCache = m, n.makeStrongCacheSync = function(D) {
          return s(m(D));
        }, n.makeWeakCache = y, n.makeWeakCacheSync = function(D) {
          return s(y(D));
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/async.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/util.js");
        const s = (D) => i()(D).sync;
        function* o() {
          return !0;
        }
        function y(D) {
          return g(WeakMap, D);
        }
        function m(D) {
          return g(Map, D);
        }
        function g(D, $) {
          const I = new D(), k = new D(), L = new D();
          return function* (M, x) {
            const _ = yield* (0, c.isAsync)(), S = _ ? k : I, C = yield* function* (P, W, B, Q, J) {
              const re = yield* b(W, Q, J);
              if (re.valid) return re;
              if (P) {
                const G = yield* b(B, Q, J);
                if (G.valid)
                  return { valid: !0, value: yield* (0, c.waitFor)(G.value.promise) };
              }
              return { valid: !1, value: null };
            }(_, S, L, M, x);
            if (C.valid) return C.value;
            const R = new T(x), H = $(M, R);
            let z, U;
            return U = (0, f.isIterableIterator)(H) ? yield* (0, c.onFirstPause)(H, () => {
              z = function(P, W, B) {
                const Q = new O();
                return v(W, P, B, Q), Q;
              }(R, L, M);
            }) : H, v(S, R, M, U), z && (L.delete(M), z.release(U)), U;
          };
        }
        function* b(D, $, I) {
          const k = D.get($);
          if (k) {
            for (const { value: L, valid: M } of k) if (yield* M(I)) return { valid: !0, value: L };
          }
          return { valid: !1, value: null };
        }
        function v(D, $, I, k) {
          $.configured() || $.forever();
          let L = D.get(I);
          switch ($.deactivate(), $.mode()) {
            case "forever":
              L = [{ value: k, valid: o }], D.set(I, L);
              break;
            case "invalidate":
              L = [{ value: k, valid: $.validator() }], D.set(I, L);
              break;
            case "valid":
              L ? L.push({ value: k, valid: $.validator() }) : (L = [{ value: k, valid: $.validator() }], D.set(I, L));
          }
        }
        class T {
          constructor($) {
            this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0, this._data = $;
          }
          simple() {
            return function($) {
              function I(k) {
                if (typeof k != "boolean") return $.using(() => E(k()));
                k ? $.forever() : $.never();
              }
              return I.forever = () => $.forever(), I.never = () => $.never(), I.using = (k) => $.using(() => E(k())), I.invalidate = (k) => $.invalidate(() => E(k())), I;
            }(this);
          }
          mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
          }
          forever() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never) throw new Error("Caching has already been configured with .never()");
            this._forever = !0, this._configured = !0;
          }
          never() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever) throw new Error("Caching has already been configured with .forever()");
            this._never = !0, this._configured = !0;
          }
          using($) {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = !0;
            const I = $(this._data), k = (0, c.maybeAsync)($, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, c.isThenable)(I) ? I.then((L) => (this._pairs.push([L, k]), L)) : (this._pairs.push([I, k]), I);
          }
          invalidate($) {
            return this._invalidate = !0, this.using($);
          }
          validator() {
            const $ = this._pairs;
            return function* (I) {
              for (const [k, L] of $) if (k !== (yield* L(I))) return !1;
              return !0;
            };
          }
          deactivate() {
            this._active = !1;
          }
          configured() {
            return this._configured;
          }
        }
        function E(D) {
          if ((0, c.isThenable)(D)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
          if (D != null && typeof D != "string" && typeof D != "boolean" && typeof D != "number") throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
          return D;
        }
        class O {
          constructor() {
            this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise(($) => {
              this._resolve = $;
            });
          }
          release($) {
            this.released = !0, this._resolve($);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/config-chain.js": (h, n, u) => {
        function i() {
          const ce = u("path");
          return i = function() {
            return ce;
          }, ce;
        }
        function c() {
          const ce = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js");
          return c = function() {
            return ce;
          }, ce;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.buildPresetChain = function* (ce, ee) {
          const ae = yield* E(ce, ee);
          return ae ? { plugins: F(ae.plugins), presets: F(ae.presets), options: ae.options.map((oe) => V(oe)), files: /* @__PURE__ */ new Set() } : null;
        }, n.buildPresetChainWalker = void 0, n.buildRootChain = function* (ce, ee) {
          let ae, oe;
          const me = new o.ConfigPrinter(), ye = yield* x({ options: ce, dirname: ee.cwd }, ee, void 0, me);
          if (!ye) return null;
          const we = yield* me.output();
          let ge;
          typeof ce.configFile == "string" ? ge = yield* (0, g.loadConfig)(ce.configFile, ee.cwd, ee.envName, ee.caller) : ce.configFile !== !1 && (ge = yield* (0, g.findRootConfig)(ee.root, ee.envName, ee.caller));
          let { babelrc: se, babelrcRoots: be } = ce, Ie = ee.cwd;
          const Oe = N(), Be = new o.ConfigPrinter();
          if (ge) {
            const Ee = k(ge), Se = yield* S(Ee, ee, void 0, Be);
            if (!Se) return null;
            ae = yield* Be.output(), se === void 0 && (se = Ee.options.babelrc), be === void 0 && (Ie = Ee.dirname, be = Ee.options.babelrcRoots), re(Oe, Se);
          }
          let Fe, ue, te = !1;
          const Y = N();
          if ((se === !0 || se === void 0) && typeof ee.filename == "string") {
            const Ee = yield* (0, g.findPackageData)(ee.filename);
            if (Ee && function(Se, Pe, Ve, Xe) {
              if (typeof Ve == "boolean") return Ve;
              const Ye = Se.root;
              if (Ve === void 0) return Pe.directories.indexOf(Ye) !== -1;
              let We = Ve;
              return Array.isArray(We) || (We = [We]), We = We.map((et) => typeof et == "string" ? i().resolve(Xe, et) : et), We.length === 1 && We[0] === Ye ? Pe.directories.indexOf(Ye) !== -1 : We.some((et) => (typeof et == "string" && (et = (0, s.default)(et, Xe)), Pe.directories.some((De) => Ae(et, Xe, De, Se))));
            }(ee, Ee, be, Ie)) {
              if ({ ignore: Fe, config: ue } = yield* (0, g.findRelativeConfig)(Ee, ee.envName, ee.caller), Fe && Y.files.add(Fe.filepath), Fe && fe(ee, Fe.ignore, null, Fe.dirname) && (te = !0), ue && !te) {
                const Se = L(ue), Pe = new o.ConfigPrinter(), Ve = yield* S(Se, ee, void 0, Pe);
                Ve ? (oe = yield* Pe.output(), re(Y, Ve)) : te = !0;
              }
              ue && te && Y.files.add(ue.filepath);
            }
          }
          ee.showConfig && console.log(`Babel configs on "${ee.filename}" (ascending priority):
` + [ae, oe, we].filter((Ee) => !!Ee).join(`

`) + `
-----End Babel configs-----`);
          const le = re(re(re(N(), Oe), Y), ye);
          return { plugins: te ? [] : F(le.plugins), presets: te ? [] : F(le.presets), options: te ? [] : le.options.map((Ee) => V(Ee)), fileHandling: te ? "ignored" : "transpile", ignore: Fe || void 0, babelrc: ue || void 0, config: ge || void 0, files: le.files };
        };
        var f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/options.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/pattern-to-regex.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/printer.js"), y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js"), g = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/index.js"), b = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js"), v = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/config-descriptors.js");
        const T = c()("babel:config:config-chain"), E = n.buildPresetChainWalker = Q({ root: (ce) => O(ce), env: (ce, ee) => D(ce)(ee), overrides: (ce, ee) => $(ce)(ee), overridesEnv: (ce, ee, ae) => I(ce)(ee)(ae), createLogger: () => () => {
        } }), O = (0, b.makeWeakCacheSync)((ce) => U(ce, ce.alias, v.createUncachedDescriptors)), D = (0, b.makeWeakCacheSync)((ce) => (0, b.makeStrongCacheSync)((ee) => P(ce, ce.alias, v.createUncachedDescriptors, ee))), $ = (0, b.makeWeakCacheSync)((ce) => (0, b.makeStrongCacheSync)((ee) => W(ce, ce.alias, v.createUncachedDescriptors, ee))), I = (0, b.makeWeakCacheSync)((ce) => (0, b.makeStrongCacheSync)((ee) => (0, b.makeStrongCacheSync)((ae) => B(ce, ce.alias, v.createUncachedDescriptors, ee, ae)))), k = (0, b.makeWeakCacheSync)((ce) => ({ filepath: ce.filepath, dirname: ce.dirname, options: (0, f.validate)("configfile", ce.options, ce.filepath) })), L = (0, b.makeWeakCacheSync)((ce) => ({ filepath: ce.filepath, dirname: ce.dirname, options: (0, f.validate)("babelrcfile", ce.options, ce.filepath) })), M = (0, b.makeWeakCacheSync)((ce) => ({ filepath: ce.filepath, dirname: ce.dirname, options: (0, f.validate)("extendsfile", ce.options, ce.filepath) })), x = Q({ root: (ce) => U(ce, "base", v.createCachedDescriptors), env: (ce, ee) => P(ce, "base", v.createCachedDescriptors, ee), overrides: (ce, ee) => W(ce, "base", v.createCachedDescriptors, ee), overridesEnv: (ce, ee, ae) => B(ce, "base", v.createCachedDescriptors, ee, ae), createLogger: (ce, ee, ae) => function(oe, me, ye) {
          var we;
          return ye ? ye.configure(me.showConfig, o.ChainFormatter.Programmatic, { callerName: (we = me.caller) == null ? void 0 : we.name }) : () => {
          };
        }(0, ee, ae) }), _ = Q({ root: (ce) => C(ce), env: (ce, ee) => R(ce)(ee), overrides: (ce, ee) => H(ce)(ee), overridesEnv: (ce, ee, ae) => z(ce)(ee)(ae), createLogger: (ce, ee, ae) => function(oe, me, ye) {
          return ye ? ye.configure(me.showConfig, o.ChainFormatter.Config, { filepath: oe }) : () => {
          };
        }(ce.filepath, ee, ae) });
        function* S(ce, ee, ae, oe) {
          const me = yield* _(ce, ee, ae, oe);
          return me == null || me.files.add(ce.filepath), me;
        }
        const C = (0, b.makeWeakCacheSync)((ce) => U(ce, ce.filepath, v.createUncachedDescriptors)), R = (0, b.makeWeakCacheSync)((ce) => (0, b.makeStrongCacheSync)((ee) => P(ce, ce.filepath, v.createUncachedDescriptors, ee))), H = (0, b.makeWeakCacheSync)((ce) => (0, b.makeStrongCacheSync)((ee) => W(ce, ce.filepath, v.createUncachedDescriptors, ee))), z = (0, b.makeWeakCacheSync)((ce) => (0, b.makeStrongCacheSync)((ee) => (0, b.makeStrongCacheSync)((ae) => B(ce, ce.filepath, v.createUncachedDescriptors, ee, ae))));
        function U({ dirname: ce, options: ee }, ae, oe) {
          return oe(ce, ee, ae);
        }
        function P({ dirname: ce, options: ee }, ae, oe, me) {
          var ye;
          const we = (ye = ee.env) == null ? void 0 : ye[me];
          return we ? oe(ce, we, `${ae}.env["${me}"]`) : null;
        }
        function W({ dirname: ce, options: ee }, ae, oe, me) {
          var ye;
          const we = (ye = ee.overrides) == null ? void 0 : ye[me];
          if (!we) throw new Error("Assertion failure - missing override");
          return oe(ce, we, `${ae}.overrides[${me}]`);
        }
        function B({ dirname: ce, options: ee }, ae, oe, me, ye) {
          var we, ge;
          const se = (we = ee.overrides) == null ? void 0 : we[me];
          if (!se) throw new Error("Assertion failure - missing override");
          const be = (ge = se.env) == null ? void 0 : ge[ye];
          return be ? oe(ce, be, `${ae}.overrides[${me}].env["${ye}"]`) : null;
        }
        function Q({ root: ce, env: ee, overrides: ae, overridesEnv: oe, createLogger: me }) {
          return function* (ye, we, ge = /* @__PURE__ */ new Set(), se) {
            const { dirname: be } = ye, Ie = [], Oe = ce(ye);
            if (X(Oe, be, we, ye.filepath)) {
              Ie.push({ config: Oe, envName: void 0, index: void 0 });
              const ue = ee(ye, we.envName);
              ue && X(ue, be, we, ye.filepath) && Ie.push({ config: ue, envName: we.envName, index: void 0 }), (Oe.options.overrides || []).forEach((te, Y) => {
                const le = ae(ye, Y);
                if (X(le, be, we, ye.filepath)) {
                  Ie.push({ config: le, index: Y, envName: void 0 });
                  const Ee = oe(ye, Y, we.envName);
                  Ee && X(Ee, be, we, ye.filepath) && Ie.push({ config: Ee, index: Y, envName: we.envName });
                }
              });
            }
            if (Ie.some(({ config: { options: { ignore: ue, only: te } } }) => fe(we, ue, te, be))) return null;
            const Be = N(), Fe = me(ye, we, se);
            for (const { config: ue, index: te, envName: Y } of Ie) {
              if (!(yield* J(Be, ue.options, be, we, ge, se))) return null;
              Fe(ue, te, Y), yield* G(Be, ue);
            }
            return Be;
          };
        }
        function* J(ce, ee, ae, oe, me, ye) {
          if (ee.extends === void 0) return !0;
          const we = yield* (0, g.loadConfig)(ee.extends, ae, oe.envName, oe.caller);
          if (me.has(we)) throw new Error(`Configuration cycle detected loading ${we.filepath}.
File already loaded following the config chain:
` + Array.from(me, (se) => ` - ${se.filepath}`).join(`
`));
          me.add(we);
          const ge = yield* S(M(we), oe, me, ye);
          return me.delete(we), !!ge && (re(ce, ge), !0);
        }
        function re(ce, ee) {
          ce.options.push(...ee.options), ce.plugins.push(...ee.plugins), ce.presets.push(...ee.presets);
          for (const ae of ee.files) ce.files.add(ae);
          return ce;
        }
        function* G(ce, { options: ee, plugins: ae, presets: oe }) {
          return ce.options.push(ee), ce.plugins.push(...yield* ae()), ce.presets.push(...yield* oe()), ce;
        }
        function N() {
          return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
        }
        function V(ce) {
          const ee = Object.assign({}, ce);
          return delete ee.extends, delete ee.env, delete ee.overrides, delete ee.plugins, delete ee.presets, delete ee.passPerPreset, delete ee.ignore, delete ee.only, delete ee.test, delete ee.include, delete ee.exclude, hasOwnProperty.call(ee, "sourceMap") && (ee.sourceMaps = ee.sourceMap, delete ee.sourceMap), ee;
        }
        function F(ce) {
          const ee = /* @__PURE__ */ new Map(), ae = [];
          for (const oe of ce) if (typeof oe.value == "function") {
            const me = oe.value;
            let ye = ee.get(me);
            ye || (ye = /* @__PURE__ */ new Map(), ee.set(me, ye));
            let we = ye.get(oe.name);
            we ? we.value = oe : (we = { value: oe }, ae.push(we), oe.ownPass || ye.set(oe.name, we));
          } else ae.push({ value: oe });
          return ae.reduce((oe, me) => (oe.push(me.value), oe), []);
        }
        function X({ options: ce }, ee, ae, oe) {
          return (ce.test === void 0 || K(ae, ce.test, ee, oe)) && (ce.include === void 0 || K(ae, ce.include, ee, oe)) && (ce.exclude === void 0 || !K(ae, ce.exclude, ee, oe));
        }
        function K(ce, ee, ae, oe) {
          return _e(ce, Array.isArray(ee) ? ee : [ee], ae, oe);
        }
        function ie(ce, ee) {
          return ee instanceof RegExp ? String(ee) : ee;
        }
        function fe(ce, ee, ae, oe) {
          if (ee && _e(ce, ee, oe)) {
            var me;
            const we = `No config is applied to "${(me = ce.filename) != null ? me : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ee, ie)}\` from "${oe}"`;
            return T(we), ce.showConfig && console.log(we), !0;
          }
          if (ae && !_e(ce, ae, oe)) {
            var ye;
            const we = `No config is applied to "${(ye = ce.filename) != null ? ye : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(ae, ie)}\` from "${oe}"`;
            return T(we), ce.showConfig && console.log(we), !0;
          }
          return !1;
        }
        function _e(ce, ee, ae, oe) {
          return ee.some((me) => Ae(me, ae, ce.filename, ce, oe));
        }
        function Ae(ce, ee, ae, oe, me) {
          if (typeof ce == "function") return !!(0, y.endHiddenCallStack)(ce)(ae, { dirname: ee, envName: oe.envName, caller: oe.caller });
          if (typeof ae != "string") throw new m.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", me);
          return typeof ce == "string" && (ce = (0, s.default)(ce, ee)), ce.test(ae);
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/config-descriptors.js": (h, n, u) => {
        function i() {
          const M = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return M;
          }, M;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.createCachedDescriptors = function(M, x, _) {
          const { plugins: S, presets: C, passPerPreset: R } = x;
          return { options: g(x, M), plugins: S ? () => E(S, M)(_) : () => m([]), presets: C ? () => v(C, M)(_)(!!R) : () => m([]) };
        }, n.createDescriptor = L, n.createUncachedDescriptors = function(M, x, _) {
          return { options: g(x, M), plugins: (0, c.once)(() => I(x.plugins || [], M, _)), presets: (0, c.once)(() => $(x.presets || [], M, _, !!x.passPerPreset)) };
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/functional.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/item.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js"), y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/resolve-targets.js");
        function* m(M) {
          return M;
        }
        function g(M, x) {
          return typeof M.browserslistConfigFile == "string" && (M.browserslistConfigFile = (0, y.resolveBrowserslistConfigFile)(M.browserslistConfigFile, x)), M;
        }
        const b = /* @__PURE__ */ new WeakMap(), v = (0, o.makeWeakCacheSync)((M, x) => {
          const _ = x.using((S) => S);
          return (0, o.makeStrongCacheSync)((S) => (0, o.makeStrongCache)(function* (C) {
            return (yield* $(M, _, S, C)).map((R) => D(b, R));
          }));
        }), T = /* @__PURE__ */ new WeakMap(), E = (0, o.makeWeakCacheSync)((M, x) => {
          const _ = x.using((S) => S);
          return (0, o.makeStrongCache)(function* (S) {
            return (yield* I(M, _, S)).map((C) => D(T, C));
          });
        }), O = {};
        function D(M, x) {
          const { value: _, options: S = O } = x;
          if (S === !1) return x;
          let C = M.get(_);
          C || (C = /* @__PURE__ */ new WeakMap(), M.set(_, C));
          let R = C.get(S);
          if (R || (R = [], C.set(S, R)), R.indexOf(x) === -1) {
            const H = R.filter((z) => {
              return P = x, (U = z).name === P.name && U.value === P.value && U.options === P.options && U.dirname === P.dirname && U.alias === P.alias && U.ownPass === P.ownPass && ((W = U.file) == null ? void 0 : W.request) === ((B = P.file) == null ? void 0 : B.request) && ((Q = U.file) == null ? void 0 : Q.resolved) === ((J = P.file) == null ? void 0 : J.resolved);
              var U, P, W, B, Q, J;
            });
            if (H.length > 0) return H[0];
            R.push(x);
          }
          return x;
        }
        function* $(M, x, _, S) {
          return yield* k("preset", M, x, _, S);
        }
        function* I(M, x, _) {
          return yield* k("plugin", M, x, _);
        }
        function* k(M, x, _, S, C) {
          const R = yield* i().all(x.map((H, z) => L(H, _, { type: M, alias: `${S}$${z}`, ownPass: !!C })));
          return function(H) {
            const z = /* @__PURE__ */ new Map();
            for (const U of H) {
              if (typeof U.value != "function") continue;
              let P = z.get(U.value);
              if (P || (P = /* @__PURE__ */ new Set(), z.set(U.value, P)), P.has(U.name)) {
                const W = H.filter((B) => B.value === U.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(W, null, 2)}`].join(`
`));
              }
              P.add(U.name);
            }
          }(R), R;
        }
        function* L(M, x, { type: _, alias: S, ownPass: C }) {
          const R = (0, s.getItemDescriptor)(M);
          if (R) return R;
          let H, z, U, P = M;
          Array.isArray(P) && (P.length === 3 ? [P, z, H] = P : [P, z] = P);
          let W = null;
          if (typeof P == "string") {
            if (typeof _ != "string") throw new Error("To resolve a string-based item, the type of item must be given");
            const B = _ === "plugin" ? f.loadPlugin : f.loadPreset, Q = P;
            ({ filepath: W, value: P } = yield* B(P, x)), U = { request: Q, resolved: W };
          }
          if (!P) throw new Error(`Unexpected falsy value: ${String(P)}`);
          if (typeof P == "object" && P.__esModule) {
            if (!P.default) throw new Error("Must export a default export when using ES6 modules.");
            P = P.default;
          }
          if (typeof P != "object" && typeof P != "function") throw new Error(`Unsupported format: ${typeof P}. Expected an object or a function.`);
          if (W !== null && typeof P == "object" && P) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${W}`);
          return { name: H, alias: W || S, value: P, options: z, dirname: x, ownPass: C, file: U };
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/configuration.js": (h, n, u) => {
        function i() {
          const z = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js");
          return i = function() {
            return z;
          }, z;
        }
        function c() {
          const z = u("fs");
          return c = function() {
            return z;
          }, z;
        }
        function f() {
          const z = u("path");
          return f = function() {
            return z;
          }, z;
        }
        function s() {
          const z = u("./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs");
          return s = function() {
            return z;
          }, z;
        }
        function o() {
          const z = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return o = function() {
            return z;
          }, z;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ROOT_CONFIG_FILENAMES = void 0, n.findConfigUpwards = function(z) {
          let U = z;
          for (; ; ) {
            for (const W of $) if (c().existsSync(f().join(U, W))) return U;
            const P = f().dirname(U);
            if (U === P) break;
            U = P;
          }
          return null;
        }, n.findRelativeConfig = function* (z, U, P) {
          let W = null, B = null;
          const Q = f().dirname(z.filepath);
          for (const re of z.directories) {
            var J;
            if (W || (W = yield* R(I, re, U, P, ((J = z.pkg) == null ? void 0 : J.dirname) === re ? _(z.pkg) : null)), !B) {
              const G = f().join(re, k);
              B = yield* C(G), B && D("Found ignore %o from %o.", B.filepath, Q);
            }
          }
          return { config: W, ignore: B };
        }, n.findRootConfig = function(z, U, P) {
          return R($, z, U, P);
        }, n.loadConfig = function* (z, U, P, W) {
          const B = (J = e.node, re = "8.9", J = J.split("."), re = re.split("."), +J[0] > +re[0] || J[0] == re[0] && +J[1] >= +re[1] ? u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").resolve : (G, { paths: [N] }, V = u("module")) => {
            let F = V._findPath(G, V._nodeModulePaths(N).concat(N));
            if (F) return F;
            throw F = new Error(`Cannot resolve module '${G}'`), F.code = "MODULE_NOT_FOUND", F;
          })(z, { paths: [U] }), Q = yield* H(B, P, W);
          var J, re;
          if (!Q) throw new T.default("Config file contains no configuration data", B);
          return D("Loaded config %o from %o.", z, U), Q;
        }, n.resolveShowConfigPath = function* (z) {
          const U = Ze.env.BABEL_SHOW_CONFIG_FOR;
          if (U != null) {
            const P = f().resolve(z, U);
            if (!(yield* E.stat(P)).isFile()) throw new Error(`${P}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return P;
          }
          return null;
        };
        var y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/config-api.js"), g = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/utils.js"), b = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/module-types.js"), v = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/pattern-to-regex.js"), T = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js"), E = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/fs.js"), O = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const D = i()("babel:config:loading:files:configuration"), $ = n.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"], I = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], k = ".babelignore", L = (0, y.makeWeakCache)(function* (z, U) {
          return yield* [], { options: (0, O.endHiddenCallStack)(z)((0, m.makeConfigAPI)(U)), cacheNeedsConfiguration: !U.configured() };
        });
        function* M(z, U) {
          if (!c().existsSync(z)) return null;
          let P = yield* (0, b.default)(z, "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously."), W = !1;
          if (typeof P == "function" && ({ options: P, cacheNeedsConfiguration: W } = yield* L(P, U)), !P || typeof P != "object" || Array.isArray(P)) throw new T.default("Configuration should be an exported JavaScript object.", z);
          if (typeof P.then == "function") throw P.catch == null || P.catch(() => {
          }), new T.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", z);
          return W && function(B) {
            throw new T.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, B);
          }(z), function(B, Q) {
            let J = x.get(B);
            J || x.set(B, J = /* @__PURE__ */ new Map());
            let re = J.get(Q);
            return re || (re = { filepath: Q, dirname: f().dirname(Q), options: B }, J.set(Q, re)), re;
          }(P, z);
        }
        const x = /* @__PURE__ */ new WeakMap(), _ = (0, y.makeWeakCacheSync)((z) => {
          const U = z.options.babel;
          if (U === void 0) return null;
          if (typeof U != "object" || Array.isArray(U) || U === null) throw new T.default(".babel property must be an object", z.filepath);
          return { filepath: z.filepath, dirname: z.dirname, options: U };
        }), S = (0, g.makeStaticFileCache)((z, U) => {
          let P;
          try {
            P = s().parse(U);
          } catch (W) {
            throw new T.default(`Error while parsing config - ${W.message}`, z);
          }
          if (!P) throw new T.default("No config detected", z);
          if (typeof P != "object") throw new T.default("Config returned typeof " + typeof P, z);
          if (Array.isArray(P)) throw new T.default("Expected config object but found array", z);
          return delete P.$schema, { filepath: z, dirname: f().dirname(z), options: P };
        }), C = (0, g.makeStaticFileCache)((z, U) => {
          const P = f().dirname(z), W = U.split(`
`).map((B) => B.replace(/#(.*?)$/, "").trim()).filter((B) => !!B);
          for (const B of W) if (B[0] === "!") throw new T.default("Negation of file paths is not supported.", z);
          return { filepath: z, dirname: f().dirname(z), ignore: W.map((B) => (0, v.default)(B, P)) };
        });
        function* R(z, U, P, W, B = null) {
          const Q = (yield* o().all(z.map((J) => H(f().join(U, J), P, W)))).reduce((J, re) => {
            if (re && J) throw new T.default(`Multiple configuration files found. Please remove one:
 - ${f().basename(J.filepath)}
 - ${re.filepath}
from ${U}`);
            return re || J;
          }, B);
          return Q && D("Found configuration %o from %o.", Q.filepath, U), Q;
        }
        function H(z, U, P) {
          switch (f().extname(z)) {
            case ".js":
            case ".cjs":
            case ".mjs":
            case ".cts":
              return M(z, { envName: U, caller: P });
            default:
              return S(z);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/import.cjs": (h, n, u) => {
        h.exports = function(i) {
          return u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files lazy recursive")(i);
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "ROOT_CONFIG_FILENAMES", { enumerable: !0, get: function() {
          return c.ROOT_CONFIG_FILENAMES;
        } }), Object.defineProperty(n, "findConfigUpwards", { enumerable: !0, get: function() {
          return c.findConfigUpwards;
        } }), Object.defineProperty(n, "findPackageData", { enumerable: !0, get: function() {
          return i.findPackageData;
        } }), Object.defineProperty(n, "findRelativeConfig", { enumerable: !0, get: function() {
          return c.findRelativeConfig;
        } }), Object.defineProperty(n, "findRootConfig", { enumerable: !0, get: function() {
          return c.findRootConfig;
        } }), Object.defineProperty(n, "loadConfig", { enumerable: !0, get: function() {
          return c.loadConfig;
        } }), Object.defineProperty(n, "loadPlugin", { enumerable: !0, get: function() {
          return f.loadPlugin;
        } }), Object.defineProperty(n, "loadPreset", { enumerable: !0, get: function() {
          return f.loadPreset;
        } }), Object.defineProperty(n, "resolvePlugin", { enumerable: !0, get: function() {
          return f.resolvePlugin;
        } }), Object.defineProperty(n, "resolvePreset", { enumerable: !0, get: function() {
          return f.resolvePreset;
        } }), Object.defineProperty(n, "resolveShowConfigPath", { enumerable: !0, get: function() {
          return c.resolveShowConfigPath;
        } });
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/package.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/configuration.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/plugins.js");
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/module-types.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function* (L, M) {
          switch (c().extname(L)) {
            case ".cjs":
              return O(L, arguments[2]);
            case ".mjs":
              break;
            case ".cts":
              return function(x) {
                const _ = ".cts", S = !!(u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[".ts"] || u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[".cts"] || u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[".mts"]);
                let C;
                if (!S) {
                  const R = { babelrc: !1, configFile: !1, sourceType: "unambiguous", sourceMaps: "inline", sourceFileName: c().basename(x), presets: [[k(x), Object.assign({ onlyRemoveTypeImports: !0, optimizeConstEnums: !0 }, { allowDeclareFields: !0 })]] };
                  C = function(H, z) {
                    if (C && z.endsWith(_)) try {
                      return H._compile((0, g.transformFileSync)(z, Object.assign({}, R, { filename: z })).code, z);
                    } catch (U) {
                      if (!S) {
                        const P = u("./node_modules/.pnpm/@babel+preset-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/preset-typescript/package.json");
                        s().lt(P.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                      }
                      throw U;
                    }
                    return u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[".js"](H, z);
                  }, u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[_] = C;
                }
                try {
                  return O(x);
                } finally {
                  S || (u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[_] === C && delete u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").extensions[_], C = void 0);
                }
              }(L);
            default:
              try {
                return O(L, arguments[2]);
              } catch (x) {
                if (x.code !== "ERR_REQUIRE_ESM") throw x;
              }
          }
          if (yield* (0, i.isAsync)()) return yield* (0, i.waitFor)(D(L));
          throw new m.default(M, L);
        }, n.supportsESM = void 0;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/async.js");
        function c() {
          const L = u("path");
          return c = function() {
            return L;
          }, L;
        }
        function f() {
          const L = u("url");
          return f = function() {
            return L;
          }, L;
        }
        function s() {
          const L = u("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return s = function() {
            return L;
          }, L;
        }
        function o() {
          const L = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js");
          return o = function() {
            return L;
          }, L;
        }
        var y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js"), g = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform-file.js");
        function b(L, M, x, _, S, C, R) {
          try {
            var H = L[C](R), z = H.value;
          } catch (U) {
            return void x(U);
          }
          H.done ? M(z) : Promise.resolve(z).then(_, S);
        }
        const v = o()("babel:config:loading:files:module-types");
        try {
          var T = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/import.cjs");
        } catch {
        }
        n.supportsESM = s().satisfies(e.node, "^12.17 || >=13.2");
        const E = /* @__PURE__ */ new Set();
        function O(L) {
          if (E.has(L)) return v("Auto-ignoring usage of config %o.", L), {};
          let M;
          try {
            E.add(L), M = (0, y.endHiddenCallStack)(u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive"))(L);
          } finally {
            E.delete(L);
          }
          var x;
          return (x = M) != null && x.__esModule ? M.default || (arguments[1] ? M : void 0) : M;
        }
        const D = (0, y.endHiddenCallStack)(($ = function* (L) {
          const M = (0, f().pathToFileURL)(L).toString();
          if (!T) throw new m.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, L);
          return (yield T(M)).default;
        }, I = function() {
          var L = this, M = arguments;
          return new Promise(function(x, _) {
            var S = $.apply(L, M);
            function C(H) {
              b(S, x, _, C, R, "next", H);
            }
            function R(H) {
              b(S, x, _, C, R, "throw", H);
            }
            C(void 0);
          });
        }, function(L) {
          return I.apply(this, arguments);
        }));
        var $, I;
        function k(L) {
          try {
            return u("./node_modules/.pnpm/@babel+preset-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/preset-typescript/lib/index.js");
          } catch (M) {
            if (M.code !== "MODULE_NOT_FOUND") throw M;
            let x = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
            throw e.pnp && (x += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new m.default(x, L);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/package.js": (h, n, u) => {
        function i() {
          const y = u("path");
          return i = function() {
            return y;
          }, y;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.findPackageData = function* (y) {
          let m = null;
          const g = [];
          let b = !0, v = i().dirname(y);
          for (; !m && i().basename(v) !== "node_modules"; ) {
            g.push(v), m = yield* o(i().join(v, s));
            const T = i().dirname(v);
            if (v === T) {
              b = !1;
              break;
            }
            v = T;
          }
          return { filepath: y, directories: g, pkg: m, isPackage: b };
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/utils.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js");
        const s = "package.json", o = (0, c.makeStaticFileCache)((y, m) => {
          let g;
          try {
            g = JSON.parse(m);
          } catch (b) {
            throw new f.default(`Error while parsing JSON - ${b.message}`, y);
          }
          if (!g) throw new Error(`${y}: No config detected`);
          if (typeof g != "object") throw new f.default("Config returned typeof " + typeof g, y);
          if (Array.isArray(g)) throw new f.default("Expected config object but found array", y);
          return { filepath: y, dirname: i().dirname(y), options: g };
        });
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/plugins.js": (h, n, u) => {
        function i() {
          const U = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js");
          return i = function() {
            return U;
          }, U;
        }
        function c() {
          const U = u("path");
          return c = function() {
            return U;
          }, U;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.loadPlugin = function* (U, P) {
          const W = k(U, P, yield* (0, f.isAsync)()), B = yield* z("plugin", W);
          return g("Loaded plugin %o from %o.", U, P), { filepath: W, value: B };
        }, n.loadPreset = function* (U, P) {
          const W = L(U, P, yield* (0, f.isAsync)()), B = yield* z("preset", W);
          return g("Loaded preset %o from %o.", U, P), { filepath: W, value: B };
        }, n.resolvePreset = n.resolvePlugin = void 0;
        var f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/async.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/module-types.js");
        function o() {
          const U = u("url");
          return o = function() {
            return U;
          }, U;
        }
        var y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/vendor/import-meta-resolve.js");
        function m() {
          const U = u("fs");
          return m = function() {
            return U;
          }, U;
        }
        const g = i()("babel:config:loading:files:plugins"), b = /^module:/, v = /^(?!@|module:|[^/]+\/|babel-plugin-)/, T = /^(?!@|module:|[^/]+\/|babel-preset-)/, E = /^(@babel\/)(?!plugin-|[^/]+\/)/, O = /^(@babel\/)(?!preset-|[^/]+\/)/, D = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, $ = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, I = /^(@(?!babel$)[^/]+)$/, k = n.resolvePlugin = R.bind(null, "plugin"), L = n.resolvePreset = R.bind(null, "preset");
        function M(U, P) {
          if (c().isAbsolute(P)) return P;
          const W = U === "preset";
          return P.replace(W ? T : v, `babel-${U}-`).replace(W ? O : E, `$1${U}-`).replace(W ? $ : D, `$1babel-${U}-`).replace(I, `$1/babel-${U}`).replace(b, "");
        }
        function* x(U, P) {
          const W = M(U, P), { error: B, value: Q } = yield W;
          if (!B) return Q;
          if (B.code !== "MODULE_NOT_FOUND") throw B;
          W === P || (yield P).error || (B.message += `
- If you want to resolve "${P}", use "module:${P}"`), (yield M(U, "@babel/" + P)).error || (B.message += `
- Did you mean "@babel/${P}"?`);
          const J = U === "preset" ? "plugin" : "preset";
          if ((yield M(J, P)).error || (B.message += `
- Did you accidentally pass a ${J} as a ${U}?`), U === "plugin") {
            const re = W.replace("-proposal-", "-transform-");
            re === W || (yield re).error || (B.message += `
- Did you mean "${re}"?`);
          }
          throw B.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, B;
        }
        function _(U, P) {
          try {
            return P ? { error: null, value: (W = e.node, B = "8.9", W = W.split("."), B = B.split("."), +W[0] > +B[0] || W[0] == B[0] && +W[1] >= +B[1] ? u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").resolve : (Q, { paths: [J] }, re = u("module")) => {
              let G = re._findPath(Q, re._nodeModulePaths(J).concat(J));
              if (G) return G;
              throw G = new Error(`Cannot resolve module '${Q}'`), G.code = "MODULE_NOT_FOUND", G;
            })(U, { paths: [P] }) } : { error: null, value: u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files sync recursive").resolve(U) };
          } catch (Q) {
            return { error: Q, value: null };
          }
          var W, B;
        }
        function S(U, P) {
          try {
            return { error: null, value: (0, y.resolve)(U, P) };
          } catch (W) {
            return { error: W, value: null };
          }
        }
        function C(U, P, W) {
          const B = x(U, P);
          let Q = B.next();
          for (; !Q.done; ) Q = B.next(_(Q.value, W));
          return Q.value;
        }
        function R(U, P, W, B) {
          if (!s.supportsESM || !B) return C(U, P, W);
          try {
            const Q = function(J, re, G) {
              const N = (0, o().pathToFileURL)(c().join(G, "./babel-virtual-resolve-base.js")).href, V = x(J, re);
              let F = V.next();
              for (; !F.done; ) F = V.next(S(F.value, N));
              return (0, o().fileURLToPath)(F.value);
            }(U, P, W);
            if (!(0, m().existsSync)(Q)) throw Object.assign(new Error(`Could not resolve "${P}" in file ${W}.`), { type: "MODULE_NOT_FOUND" });
            return Q;
          } catch (Q) {
            try {
              return C(U, P, W);
            } catch (J) {
              throw Q.type === "MODULE_NOT_FOUND" ? Q : J.type === "MODULE_NOT_FOUND" ? J : Q;
            }
          }
        }
        var H = /* @__PURE__ */ new Set();
        function* z(U, P) {
          if (!(yield* (0, f.isAsync)()) && H.has(P)) throw new Error(`Reentrant ${U} detected trying to load "${P}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
          try {
            return H.add(P), yield* (0, s.default)(P, `You appear to be using a native ECMAScript module ${U}, which is only supported when running Babel asynchronously.`, !0);
          } catch (W) {
            throw W.message = `[BABEL]: ${W.message} (While processing: ${P})`, W;
          } finally {
            H.delete(P);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/utils.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.makeStaticFileCache = function(s) {
          return (0, i.makeStrongCache)(function* (o, y) {
            return y.invalidate(() => function(g) {
              if (!f().existsSync(g)) return null;
              try {
                return +f().statSync(g).mtime;
              } catch (b) {
                if (b.code !== "ENOENT" && b.code !== "ENOTDIR") throw b;
              }
              return null;
            }(o)) === null ? null : s(o, yield* c.readFile(o, "utf8"));
          });
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/fs.js");
        function f() {
          const s = u("fs");
          return f = function() {
            return s;
          }, s;
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/full.js": (h, n, u) => {
        function i() {
          const P = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return P;
          }, P;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/async.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/util.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/plugin.js"), y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/item.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/config-chain.js"), g = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function b() {
          const P = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js");
          return b = function() {
            return P;
          }, P;
        }
        var v = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js"), T = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/options.js"), E = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/plugins.js"), O = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/config-api.js"), D = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/partial.js"), $ = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js");
        n.default = i()(function* (P) {
          var W;
          const B = yield* (0, D.default)(P);
          if (!B) return null;
          const { options: Q, context: J, fileHandling: re } = B;
          if (re === "ignored") return null;
          const G = {}, { plugins: N, presets: V } = Q;
          if (!N || !V) throw new Error("Assertion failure - plugins and presets exist");
          const F = Object.assign({}, J, { targets: Q.targets }), X = (oe) => {
            const me = (0, y.getItemDescriptor)(oe);
            if (!me) throw new Error("Assertion failure - must be config item");
            return me;
          }, K = V.map(X), ie = N.map(X), fe = [[]], _e = [], Ae = [];
          if (yield* I(J, function* oe(me, ye) {
            const we = [];
            for (let se = 0; se < me.length; se++) {
              const be = me[se];
              if (be.options !== !1) {
                try {
                  var ge = yield* z(be, F);
                } catch (Ie) {
                  throw Ie.code === "BABEL_UNKNOWN_OPTION" && (0, T.checkNoUnwrappedItemOptionPairs)(me, se, "preset", Ie), Ie;
                }
                Ae.push(ge.externalDependencies), be.ownPass ? we.push({ preset: ge.chain, pass: [] }) : we.unshift({ preset: ge.chain, pass: ye });
              }
            }
            if (we.length > 0) {
              fe.splice(1, 0, ...we.map((se) => se.pass).filter((se) => se !== ye));
              for (const { preset: se, pass: be } of we) {
                if (!se || (be.push(...se.plugins), yield* oe(se.presets, be))) return !0;
                se.options.forEach((Ie) => {
                  (0, f.mergeOptions)(G, Ie);
                });
              }
            }
          })(K, fe[0])) return null;
          const ee = G;
          (0, f.mergeOptions)(ee, Q);
          const ae = Object.assign({}, F, { assumptions: (W = ee.assumptions) != null ? W : {} });
          return yield* I(J, function* () {
            fe[0].unshift(...ie);
            for (const me of fe) {
              const ye = [];
              _e.push(ye);
              for (let we = 0; we < me.length; we++) {
                const ge = me[we];
                if (ge.options !== !1) {
                  try {
                    var oe = yield* _(ge, ae);
                  } catch (se) {
                    throw se.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, T.checkNoUnwrappedItemOptionPairs)(me, we, "plugin", se), se;
                  }
                  ye.push(oe), Ae.push(oe.externalDependencies);
                }
              }
            }
          })(), ee.plugins = _e[0], ee.presets = _e.slice(1).filter((oe) => oe.length > 0).map((oe) => ({ plugins: oe })), ee.passPerPreset = ee.presets.length > 0, { options: ee, passes: _e, externalDependencies: (0, g.finalize)(Ae) };
        });
        function I(P, W) {
          return function* (B, Q) {
            try {
              return yield* W(B, Q);
            } catch (re) {
              var J;
              throw /^\[BABEL\]/.test(re.message) || (re.message = `[BABEL] ${(J = P.filename) != null ? J : "unknown file"}: ${re.message}`), re;
            }
          };
        }
        const k = (P) => (0, v.makeWeakCache)(function* ({ value: W, options: B, dirname: Q, alias: J }, re) {
          if (B === !1) throw new Error("Assertion failure");
          B = B || {};
          const G = [];
          let N = W;
          if (typeof W == "function") {
            const V = (0, c.maybeAsync)(W, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), F = Object.assign({}, s, P(re, G));
            try {
              N = yield* V(F, B, Q);
            } catch (X) {
              throw J && (X.message += ` (While processing: ${JSON.stringify(J)})`), X;
            }
          }
          if (!N || typeof N != "object") throw new Error("Plugin/Preset did not return an object.");
          if ((0, c.isThenable)(N)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(J)})`);
          if (G.length > 0 && (!re.configured() || re.mode() === "forever")) {
            let V = `A plugin/preset has external untracked dependencies (${G[0]}), but the cache `;
            throw re.configured() ? V += " has been configured to never be invalidated. " : V += "has not been configured to be invalidated when the external dependencies change. ", V += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(J)})`, new Error(V);
          }
          return { value: N, options: B, dirname: Q, alias: J, externalDependencies: (0, g.finalize)(G) };
        }), L = k(O.makePluginAPI), M = k(O.makePresetAPI), x = (0, v.makeWeakCache)(function* ({ value: P, options: W, dirname: B, alias: Q, externalDependencies: J }, re) {
          const G = (0, E.validatePluginObject)(P), N = Object.assign({}, G);
          if (N.visitor && (N.visitor = b().default.explode(Object.assign({}, N.visitor))), N.inherits) {
            const V = { name: void 0, alias: `${Q}$inherits`, value: N.inherits, options: W, dirname: B }, F = yield* (0, c.forwardAsync)(_, (X) => re.invalidate((K) => X(V, K)));
            N.pre = U(F.pre, N.pre), N.post = U(F.post, N.post), N.manipulateOptions = U(F.manipulateOptions, N.manipulateOptions), N.visitor = b().default.visitors.merge([F.visitor || {}, N.visitor || {}]), F.externalDependencies.length > 0 && (J = J.length === 0 ? F.externalDependencies : (0, g.finalize)([J, F.externalDependencies]));
          }
          return new o.default(N, W, Q, J);
        });
        function* _(P, W) {
          if (P.value instanceof o.default) {
            if (P.options) throw new Error("Passed options to an existing Plugin instance will not work.");
            return P.value;
          }
          return yield* x(yield* L(P, W), W);
        }
        const S = (P) => P && typeof P != "function", C = (P, W) => {
          if (S(P.test) || S(P.include) || S(P.exclude)) {
            const B = W.name ? `"${W.name}"` : "/* your preset */";
            throw new $.default([`Preset ${B} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${B}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
          }
        }, R = (P, W, B) => {
          if (!W.filename) {
            var Q;
            const { options: J } = P;
            C(J, B), (Q = J.overrides) == null || Q.forEach((re) => C(re, B));
          }
        }, H = (0, v.makeWeakCacheSync)(({ value: P, dirname: W, alias: B, externalDependencies: Q }) => ({ options: (0, T.validate)("preset", P), alias: B, dirname: W, externalDependencies: Q }));
        function* z(P, W) {
          const B = H(yield* M(P, W));
          return R(B, W, P), { chain: yield* (0, m.buildPresetChain)(B, W), externalDependencies: B.externalDependencies };
        }
        function U(P, W) {
          const B = [P, W].filter(Boolean);
          return B.length <= 1 ? B[0] : function(...Q) {
            for (const J of B) J.apply(this, Q);
          };
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/config-api.js": (h, n, u) => {
        function i() {
          const m = u("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.makeConfigAPI = s, n.makePluginAPI = function(m, g) {
          return Object.assign({}, o(m, g), { assumption: (b) => m.using((v) => v.assumptions[b]) });
        }, n.makePresetAPI = o;
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/caching.js");
        function s(m) {
          return { version: c.version, cache: m.simple(), env: (g) => m.using((b) => g === void 0 ? b.envName : typeof g == "function" ? (0, f.assertSimpleType)(g(b.envName)) : (Array.isArray(g) ? g : [g]).some((v) => {
            if (typeof v != "string") throw new Error("Unexpected non-string value");
            return v === b.envName;
          })), async: () => !1, caller: (g) => m.using((b) => (0, f.assertSimpleType)(g(b.caller))), assertVersion: y };
        }
        function o(m, g) {
          return Object.assign({}, s(m), { targets: () => JSON.parse(m.using((b) => JSON.stringify(b.targets))), addExternalDependency: (b) => {
            g.push(b);
          } });
        }
        function y(m) {
          if (typeof m == "number") {
            if (!Number.isInteger(m)) throw new Error("Expected string or integer value.");
            m = `^${m}.0.0-0`;
          }
          if (typeof m != "string") throw new Error("Expected string or integer value.");
          if (m === "*" || i().satisfies(c.version, m)) return;
          const g = Error.stackTraceLimit;
          typeof g == "number" && g < 25 && (Error.stackTraceLimit = 25);
          const b = new Error(`Requires Babel "${m}", but was loaded with "${c.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          throw typeof g == "number" && (Error.stackTraceLimit = g), Object.assign(b, { code: "BABEL_VERSION_UNSUPPORTED", version: c.version, range: m });
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/deep-array.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.finalize = function(u) {
          return Object.freeze(u);
        }, n.flattenToSet = function(u) {
          const i = /* @__PURE__ */ new Set(), c = [u];
          for (; c.length > 0; ) for (const f of c.pop()) Array.isArray(f) ? c.push(f) : i.add(f);
          return i;
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/environment.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.getEnv = function(u = "development") {
          return Ze.env.BABEL_ENV || Ze.env.NODE_ENV || u;
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/index.js": (h, n, u) => {
        function i() {
          const E = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return E;
          }, E;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.createConfigItem = function(E, O, D) {
          if (D !== void 0) (0, o.beginHiddenCallStack)(v.errback)(E, O, D);
          else {
            if (typeof O != "function") return T(E, O);
            (0, o.beginHiddenCallStack)(v.errback)(E, void 0, D);
          }
        }, n.createConfigItemAsync = function(...E) {
          return (0, o.beginHiddenCallStack)(v.async)(...E);
        }, n.createConfigItemSync = T, Object.defineProperty(n, "default", { enumerable: !0, get: function() {
          return c.default;
        } }), n.loadOptions = function(E, O) {
          if (O !== void 0) (0, o.beginHiddenCallStack)(g.errback)(E, O);
          else {
            if (typeof E != "function") return b(E);
            (0, o.beginHiddenCallStack)(g.errback)(void 0, E);
          }
        }, n.loadOptionsAsync = function(...E) {
          return (0, o.beginHiddenCallStack)(g.async)(...E);
        }, n.loadOptionsSync = b, n.loadPartialConfig = function(E, O) {
          if (O !== void 0) (0, o.beginHiddenCallStack)(y.errback)(E, O);
          else {
            if (typeof E != "function") return m(E);
            (0, o.beginHiddenCallStack)(y.errback)(void 0, E);
          }
        }, n.loadPartialConfigAsync = function(...E) {
          return (0, o.beginHiddenCallStack)(y.async)(...E);
        }, n.loadPartialConfigSync = m;
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/full.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/partial.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/item.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const y = i()(f.loadPartialConfig);
        function m(...E) {
          return (0, o.beginHiddenCallStack)(y.sync)(...E);
        }
        const g = i()(function* (E) {
          var O;
          const D = yield* (0, c.default)(E);
          return (O = D == null ? void 0 : D.options) != null ? O : null;
        });
        function b(...E) {
          return (0, o.beginHiddenCallStack)(g.sync)(...E);
        }
        const v = i()(s.createConfigItem);
        function T(...E) {
          return (0, o.beginHiddenCallStack)(v.sync)(...E);
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/item.js": (h, n, u) => {
        function i() {
          const y = u("path");
          return i = function() {
            return y;
          }, y;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.createConfigItem = function* (y, { dirname: m = ".", type: g } = {}) {
          return f(yield* (0, c.createDescriptor)(y, i().resolve(m), { type: g, alias: "programmatic item" }));
        }, n.createItemFromDescriptor = f, n.getItemDescriptor = function(y) {
          if (y != null && y[s]) return y._descriptor;
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/config-descriptors.js");
        function f(y) {
          return new o(y);
        }
        const s = Symbol.for("@babel/core@7 - ConfigItem");
        class o {
          constructor(m) {
            this._descriptor = void 0, this[s] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = m, Object.defineProperty(this, "_descriptor", { enumerable: !1 }), Object.defineProperty(this, s, { enumerable: !1 }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
          }
        }
        Object.freeze(o.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/partial.js": (h, n, u) => {
        function i() {
          const O = u("path");
          return i = function() {
            return O;
          }, O;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = T, n.loadPartialConfig = function* (O) {
          let D = !1;
          if (typeof O == "object" && O !== null && !Array.isArray(O)) {
            var $ = O;
            ({ showIgnoredFiles: D } = $), O = function(C, R) {
              if (C == null) return {};
              var H, z, U = {}, P = Object.keys(C);
              for (z = 0; z < P.length; z++) H = P[z], R.indexOf(H) >= 0 || (U[H] = C[H]);
              return U;
            }($, v);
          }
          const I = yield* T(O);
          if (!I) return null;
          const { options: k, babelrc: L, ignore: M, config: x, fileHandling: _, files: S } = I;
          return _ === "ignored" && !D ? null : ((k.plugins || []).forEach((C) => {
            if (C.value instanceof c.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
          }), new E(k, L ? L.filepath : void 0, M ? M.filepath : void 0, x ? x.filepath : void 0, _, S));
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/plugin.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/util.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/item.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/config-chain.js"), y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/environment.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/options.js"), g = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/index.js"), b = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/resolve-targets.js");
        const v = ["showIgnoredFiles"];
        function* T(O) {
          if (O != null && (typeof O != "object" || Array.isArray(O))) throw new Error("Babel options must be an object, null, or undefined");
          const D = O ? (0, m.validate)("arguments", O) : {}, { envName: $ = (0, y.getEnv)(), cwd: I = ".", root: k = ".", rootMode: L = "root", caller: M, cloneInputAst: x = !0 } = D, _ = i().resolve(I), S = function(U, P) {
            switch (P) {
              case "root":
                return U;
              case "upward-optional": {
                const W = (0, g.findConfigUpwards)(U);
                return W === null ? U : W;
              }
              case "upward": {
                const W = (0, g.findConfigUpwards)(U);
                if (W !== null) return W;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${U}".
One of the following config files must be in the directory tree: "${g.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: U });
              }
              default:
                throw new Error("Assertion failure - unknown rootMode value.");
            }
          }(i().resolve(_, k), L), C = typeof D.filename == "string" ? i().resolve(I, D.filename) : void 0, R = { filename: C, cwd: _, root: S, envName: $, caller: M, showConfig: (yield* (0, g.resolveShowConfigPath)(_)) === C }, H = yield* (0, o.buildRootChain)(D, R);
          if (!H) return null;
          const z = { assumptions: {} };
          return H.options.forEach((U) => {
            (0, f.mergeOptions)(z, U);
          }), { options: Object.assign({}, z, { targets: (0, b.resolveTargets)(z, S), cloneInputAst: x, babelrc: !1, configFile: !1, browserslistConfigFile: !1, passPerPreset: !1, envName: R.envName, cwd: R.cwd, root: R.root, rootMode: "root", filename: typeof R.filename == "string" ? R.filename : void 0, plugins: H.plugins.map((U) => (0, s.createItemFromDescriptor)(U)), presets: H.presets.map((U) => (0, s.createItemFromDescriptor)(U)) }), context: R, fileHandling: H.fileHandling, ignore: H.ignore, babelrc: H.babelrc, config: H.config, files: H.files };
        }
        class E {
          constructor(D, $, I, k, L, M) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = D, this.babelignore = I, this.babelrc = $, this.config = k, this.fileHandling = L, this.files = M, Object.freeze(this);
          }
          hasFilesystemConfig() {
            return this.babelrc !== void 0 || this.config !== void 0;
          }
        }
        Object.freeze(E.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/pattern-to-regex.js": (h, n, u) => {
        function i() {
          const v = u("path");
          return i = function() {
            return v;
          }, v;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(v, T) {
          const E = i().resolve(T, v).split(i().sep);
          return new RegExp(["^", ...E.map((O, D) => {
            const $ = D === E.length - 1;
            return O === "**" ? $ ? g : m : O === "*" ? $ ? y : o : O.indexOf("*.") === 0 ? s + b(O.slice(1)) + ($ ? f : c) : b(O) + ($ ? f : c);
          })].join(""));
        };
        const c = `\\${i().sep}`, f = `(?:${c}|$)`, s = `[^${c}]+`, o = `(?:${s}${c})`, y = `(?:${s}${f})`, m = `${o}*?`, g = `${o}*?${y}?`;
        function b(v) {
          return v.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/plugin.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        n.default = class {
          constructor(c, f, s, o = (0, i.finalize)([])) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = c.name || s, this.manipulateOptions = c.manipulateOptions, this.post = c.post, this.pre = c.pre, this.visitor = c.visitor || {}, this.parserOverride = c.parserOverride, this.generatorOverride = c.generatorOverride, this.options = f, this.externalDependencies = o;
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/printer.js": (h, n, u) => {
        function i() {
          const y = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return y;
          }, y;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ConfigPrinter = n.ChainFormatter = void 0;
        const c = n.ChainFormatter = { Programmatic: 0, Config: 1 }, f = { title(y, m, g) {
          let b = "";
          return y === c.Programmatic ? (b = "programmatic options", m && (b += " from " + m)) : b = "config " + g, b;
        }, loc(y, m) {
          let g = "";
          return y != null && (g += `.overrides[${y}]`), m != null && (g += `.env["${m}"]`), g;
        }, *optionsAndDescriptors(y) {
          const m = Object.assign({}, y.options);
          delete m.overrides, delete m.env;
          const g = [...yield* y.plugins()];
          g.length && (m.plugins = g.map((v) => s(v)));
          const b = [...yield* y.presets()];
          return b.length && (m.presets = [...b].map((v) => s(v))), JSON.stringify(m, void 0, 2);
        } };
        function s(y) {
          var m;
          let g = (m = y.file) == null ? void 0 : m.request;
          return g == null && (typeof y.value == "object" ? g = y.value : typeof y.value == "function" && (g = `[Function: ${y.value.toString().slice(0, 50)} ... ]`)), g == null && (g = "[Unknown]"), y.options === void 0 ? g : y.name == null ? [g, y.options] : [g, y.options, y.name];
        }
        class o {
          constructor() {
            this._stack = [];
          }
          configure(m, g, { callerName: b, filepath: v }) {
            return m ? (T, E, O) => {
              this._stack.push({ type: g, callerName: b, filepath: v, content: T, index: E, envName: O });
            } : () => {
            };
          }
          static *format(m) {
            let g = f.title(m.type, m.callerName, m.filepath);
            const b = f.loc(m.index, m.envName);
            return b && (g += ` ${b}`), `${g}
${yield* f.optionsAndDescriptors(m.content)}`;
          }
          *output() {
            return this._stack.length === 0 ? "" : (yield* i().all(this._stack.map((m) => o.format(m)))).join(`

`);
          }
        }
        n.ConfigPrinter = o;
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/resolve-targets.js": (h, n, u) => {
        function i() {
          const f = u("path");
          return i = function() {
            return f;
          }, f;
        }
        function c() {
          const f = u("./stubs/helper-compilation-targets.js");
          return c = function() {
            return f;
          }, f;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.resolveBrowserslistConfigFile = function(f, s) {
          return i().resolve(s, f);
        }, n.resolveTargets = function(f, s) {
          const o = f.targets;
          let y;
          typeof o == "string" || Array.isArray(o) ? y = { browsers: o } : o && (y = "esmodules" in o ? Object.assign({}, o, { esmodules: "intersect" }) : o);
          const { browserslistConfigFile: m } = f;
          let g, b = !1;
          return typeof m == "string" ? g = m : b = m === !1, (0, c().default)(y, { ignoreBrowserslistConfig: b, configFile: g, configPath: s, browserslistEnv: f.browserslistEnv });
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/util.js": (h, n) => {
        function u(i, c) {
          for (const f of Object.keys(c)) {
            const s = c[f];
            s !== void 0 && (i[f] = s);
          }
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isIterableIterator = function(i) {
          return !!i && typeof i.next == "function" && typeof i[Symbol.iterator] == "function";
        }, n.mergeOptions = function(i, c) {
          for (const f of Object.keys(c)) if (f !== "parserOpts" && f !== "generatorOpts" && f !== "assumptions" || !c[f]) {
            const s = c[f];
            s !== void 0 && (i[f] = s);
          } else {
            const s = c[f];
            u(i[f] || (i[f] = {}), s);
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/option-assertions.js": (h, n, u) => {
        function i() {
          const E = u("./stubs/helper-compilation-targets.js");
          return i = function() {
            return E;
          }, E;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.access = s, n.assertArray = m, n.assertAssumptions = function(E, O) {
          if (O === void 0) return;
          if (typeof O != "object" || O === null) throw new Error(`${f(E)} must be an object or undefined.`);
          let D = E;
          do
            D = D.parent;
          while (D.type !== "root");
          const $ = D.source === "preset";
          for (const I of Object.keys(O)) {
            const k = s(E, I);
            if (!c.assumptionsNames.has(I)) throw new Error(`${f(k)} is not a supported assumption.`);
            if (typeof O[I] != "boolean") throw new Error(`${f(k)} must be a boolean.`);
            if ($ && O[I] === !1) throw new Error(`${f(k)} cannot be set to 'false' inside presets.`);
          }
          return O;
        }, n.assertBabelrcSearch = function(E, O) {
          if (O === void 0 || typeof O == "boolean") return O;
          if (Array.isArray(O)) O.forEach((D, $) => {
            if (!g(D)) throw new Error(`${f(s(E, $))} must be a string/Function/RegExp.`);
          });
          else if (!g(O)) throw new Error(`${f(E)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(O)}`);
          return O;
        }, n.assertBoolean = o, n.assertCallerMetadata = function(E, O) {
          const D = y(E, O);
          if (D) {
            if (typeof D.name != "string") throw new Error(`${f(E)} set but does not contain "name" property string`);
            for (const $ of Object.keys(D)) {
              const I = s(E, $), k = D[$];
              if (k != null && typeof k != "boolean" && typeof k != "string" && typeof k != "number") throw new Error(`${f(I)} must be null, undefined, a boolean, a string, or a number.`);
            }
          }
          return O;
        }, n.assertCompact = function(E, O) {
          if (O !== void 0 && typeof O != "boolean" && O !== "auto") throw new Error(`${f(E)} must be a boolean, "auto", or undefined`);
          return O;
        }, n.assertConfigApplicableTest = function(E, O) {
          if (O === void 0) return O;
          if (Array.isArray(O)) O.forEach((D, $) => {
            if (!g(D)) throw new Error(`${f(s(E, $))} must be a string/Function/RegExp.`);
          });
          else if (!g(O)) throw new Error(`${f(E)} must be a string/Function/RegExp, or an array of those`);
          return O;
        }, n.assertConfigFileSearch = function(E, O) {
          if (O !== void 0 && typeof O != "boolean" && typeof O != "string") throw new Error(`${f(E)} must be a undefined, a boolean, a string, got ${JSON.stringify(O)}`);
          return O;
        }, n.assertFunction = function(E, O) {
          if (O !== void 0 && typeof O != "function") throw new Error(`${f(E)} must be a function, or undefined`);
          return O;
        }, n.assertIgnoreList = function(E, O) {
          const D = m(E, O);
          return D == null || D.forEach(($, I) => function(k, L) {
            if (typeof L != "string" && typeof L != "function" && !(L instanceof RegExp)) throw new Error(`${f(k)} must be an array of string/Function/RegExp values, or undefined`);
            return L;
          }(s(E, I), $)), D;
        }, n.assertInputSourceMap = function(E, O) {
          if (O !== void 0 && typeof O != "boolean" && (typeof O != "object" || !O)) throw new Error(`${f(E)} must be a boolean, object, or undefined`);
          return O;
        }, n.assertObject = y, n.assertPluginList = function(E, O) {
          const D = m(E, O);
          return D && D.forEach(($, I) => function(k, L) {
            if (Array.isArray(L)) {
              if (L.length === 0) throw new Error(`${f(k)} must include an object`);
              if (L.length > 3) throw new Error(`${f(k)} may only be a two-tuple or three-tuple`);
              if (b(s(k, 0), L[0]), L.length > 1) {
                const M = L[1];
                if (M !== void 0 && M !== !1 && (typeof M != "object" || Array.isArray(M) || M === null)) throw new Error(`${f(s(k, 1))} must be an object, false, or undefined`);
              }
              if (L.length === 3) {
                const M = L[2];
                if (M !== void 0 && typeof M != "string") throw new Error(`${f(s(k, 2))} must be a string, or undefined`);
              }
            } else b(k, L);
            return L;
          }(s(E, I), $)), D;
        }, n.assertRootMode = function(E, O) {
          if (O !== void 0 && O !== "root" && O !== "upward" && O !== "upward-optional") throw new Error(`${f(E)} must be a "root", "upward", "upward-optional" or undefined`);
          return O;
        }, n.assertSourceMaps = function(E, O) {
          if (O !== void 0 && typeof O != "boolean" && O !== "inline" && O !== "both") throw new Error(`${f(E)} must be a boolean, "inline", "both", or undefined`);
          return O;
        }, n.assertSourceType = function(E, O) {
          if (O !== void 0 && O !== "module" && O !== "script" && O !== "unambiguous") throw new Error(`${f(E)} must be "module", "script", "unambiguous", or undefined`);
          return O;
        }, n.assertString = function(E, O) {
          if (O !== void 0 && typeof O != "string") throw new Error(`${f(E)} must be a string, or undefined`);
          return O;
        }, n.assertTargets = function(E, O) {
          if ((0, i().isBrowsersQueryValid)(O)) return O;
          if (typeof O != "object" || !O || Array.isArray(O)) throw new Error(`${f(E)} must be a string, an array of strings or an object`);
          const D = s(E, "browsers"), $ = s(E, "esmodules");
          v(D, O.browsers), o($, O.esmodules);
          for (const I of Object.keys(O)) {
            const k = O[I], L = s(E, I);
            if (I === "esmodules") o(L, k);
            else if (I === "browsers") v(L, k);
            else {
              if (!hasOwnProperty.call(i().TargetNames, I)) {
                const M = Object.keys(i().TargetNames).join(", ");
                throw new Error(`${f(L)} is not a valid target. Supported targets are ${M}`);
              }
              T(L, k);
            }
          }
          return O;
        }, n.msg = f;
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/options.js");
        function f(E) {
          switch (E.type) {
            case "root":
              return "";
            case "env":
              return `${f(E.parent)}.env["${E.name}"]`;
            case "overrides":
              return `${f(E.parent)}.overrides[${E.index}]`;
            case "option":
              return `${f(E.parent)}.${E.name}`;
            case "access":
              return `${f(E.parent)}[${JSON.stringify(E.name)}]`;
            default:
              throw new Error(`Assertion failure: Unknown type ${E.type}`);
          }
        }
        function s(E, O) {
          return { type: "access", name: O, parent: E };
        }
        function o(E, O) {
          if (O !== void 0 && typeof O != "boolean") throw new Error(`${f(E)} must be a boolean, or undefined`);
          return O;
        }
        function y(E, O) {
          if (O !== void 0 && (typeof O != "object" || Array.isArray(O) || !O)) throw new Error(`${f(E)} must be an object, or undefined`);
          return O;
        }
        function m(E, O) {
          if (O != null && !Array.isArray(O)) throw new Error(`${f(E)} must be an array, or undefined`);
          return O;
        }
        function g(E) {
          return typeof E == "string" || typeof E == "function" || E instanceof RegExp;
        }
        function b(E, O) {
          if ((typeof O != "object" || !O) && typeof O != "string" && typeof O != "function") throw new Error(`${f(E)} must be a string, object, function`);
          return O;
        }
        function v(E, O) {
          if (O !== void 0 && !(0, i().isBrowsersQueryValid)(O)) throw new Error(`${f(E)} must be undefined, a string or an array of strings`);
        }
        function T(E, O) {
          if ((typeof O != "number" || Math.round(O) !== O) && typeof O != "string") throw new Error(`${f(E)} must be a string or an integer number`);
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/options.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.assumptionsNames = void 0, n.checkNoUnwrappedItemOptionPairs = function(T, E, O, D) {
          if (E === 0) return;
          const $ = T[E - 1], I = T[E];
          $.file && $.options === void 0 && typeof I.value == "object" && (D.message += `
- Maybe you meant to use
"${O}s": [
  ["${$.file.request}", ${JSON.stringify(I.value, void 0, 2)}]
]
To be a valid ${O}, its name and options should be wrapped in a pair of brackets`);
        }, n.validate = function(T, E, O) {
          try {
            return b({ type: "root", source: T }, E);
          } catch (D) {
            const $ = new f.default(D.message, O);
            throw D.code && ($.code = D.code), $;
          }
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/removed.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/option-assertions.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js");
        const s = { cwd: c.assertString, root: c.assertString, rootMode: c.assertRootMode, configFile: c.assertConfigFileSearch, caller: c.assertCallerMetadata, filename: c.assertString, filenameRelative: c.assertString, code: c.assertBoolean, ast: c.assertBoolean, cloneInputAst: c.assertBoolean, envName: c.assertString }, o = { babelrc: c.assertBoolean, babelrcRoots: c.assertBabelrcSearch }, y = { extends: c.assertString, ignore: c.assertIgnoreList, only: c.assertIgnoreList, targets: c.assertTargets, browserslistConfigFile: c.assertConfigFileSearch, browserslistEnv: c.assertString }, m = { inputSourceMap: c.assertInputSourceMap, presets: c.assertPluginList, plugins: c.assertPluginList, passPerPreset: c.assertBoolean, assumptions: c.assertAssumptions, env: function(T, E) {
          if (T.parent.type === "env") throw new Error(`${(0, c.msg)(T)} is not allowed inside of another .env block`);
          const O = T.parent, D = (0, c.assertObject)(T, E);
          if (D) for (const $ of Object.keys(D)) {
            const I = (0, c.assertObject)((0, c.access)(T, $), D[$]);
            I && b({ type: "env", name: $, parent: O }, I);
          }
          return D;
        }, overrides: function(T, E) {
          if (T.parent.type === "env") throw new Error(`${(0, c.msg)(T)} is not allowed inside an .env block`);
          if (T.parent.type === "overrides") throw new Error(`${(0, c.msg)(T)} is not allowed inside an .overrides block`);
          const O = T.parent, D = (0, c.assertArray)(T, E);
          if (D) for (const [$, I] of D.entries()) {
            const k = (0, c.access)(T, $), L = (0, c.assertObject)(k, I);
            if (!L) throw new Error(`${(0, c.msg)(k)} must be an object`);
            b({ type: "overrides", index: $, parent: O }, L);
          }
          return D;
        }, test: c.assertConfigApplicableTest, include: c.assertConfigApplicableTest, exclude: c.assertConfigApplicableTest, retainLines: c.assertBoolean, comments: c.assertBoolean, shouldPrintComment: c.assertFunction, compact: c.assertCompact, minified: c.assertBoolean, auxiliaryCommentBefore: c.assertString, auxiliaryCommentAfter: c.assertString, sourceType: c.assertSourceType, wrapPluginVisitorMethod: c.assertFunction, highlightCode: c.assertBoolean, sourceMaps: c.assertSourceMaps, sourceMap: c.assertSourceMaps, sourceFileName: c.assertString, sourceRoot: c.assertString, parserOpts: c.assertObject, generatorOpts: c.assertObject };
        Object.assign(m, { getModuleId: c.assertFunction, moduleRoot: c.assertString, moduleIds: c.assertBoolean, moduleId: c.assertString }), n.assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
        function g(T) {
          return T.type === "root" ? T.source : g(T.parent);
        }
        function b(T, E) {
          const O = g(T);
          return function(D) {
            if (hasOwnProperty.call(D, "sourceMap") && hasOwnProperty.call(D, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
          }(E), Object.keys(E).forEach((D) => {
            const $ = { type: "option", name: D, parent: T };
            if (O === "preset" && y[D]) throw new Error(`${(0, c.msg)($)} is not allowed in preset options`);
            if (O !== "arguments" && s[D]) throw new Error(`${(0, c.msg)($)} is only allowed in root programmatic options`);
            if (O !== "arguments" && O !== "configfile" && o[D])
              throw O === "babelrcfile" || O === "extendsfile" ? new Error(`${(0, c.msg)($)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, c.msg)($)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            (m[D] || y[D] || o[D] || s[D] || v)($, E[D]);
          }), E;
        }
        function v(T) {
          const E = T.name;
          if (i.default[E]) {
            const { message: O, version: D = 5 } = i.default[E];
            throw new Error(`Using removed Babel ${D} option: ${(0, c.msg)(T)} - ${O}`);
          }
          {
            const O = new Error(`Unknown option: ${(0, c.msg)(T)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw O.code = "BABEL_UNKNOWN_OPTION", O;
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/plugins.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.validatePluginObject = function(f) {
          const s = { type: "root", source: "plugin" };
          return Object.keys(f).forEach((o) => {
            const y = c[o];
            if (!y) {
              const m = new Error(`.${o} is not a valid Plugin property`);
              throw m.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", m;
            }
            y({ type: "option", name: o, parent: s }, f[o]);
          }), f;
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const c = { name: i.assertString, manipulateOptions: i.assertFunction, pre: i.assertFunction, post: i.assertFunction, inherits: i.assertFunction, visitor: function(f, s) {
          const o = (0, i.assertObject)(f, s);
          if (o && (Object.keys(o).forEach((y) => {
            y !== "_exploded" && y !== "_verified" && function(m, g) {
              if (g && typeof g == "object") Object.keys(g).forEach((b) => {
                if (b !== "enter" && b !== "exit") throw new Error(`.visitor["${m}"] may only have .enter and/or .exit handlers.`);
              });
              else if (typeof g != "function") throw new Error(`.visitor["${m}"] must be a function`);
            }(y, o[y]);
          }), o.enter || o.exit)) throw new Error(`${(0, i.msg)(f)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
          return o;
        }, parserOverride: i.assertFunction, generatorOverride: i.assertFunction };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/validation/removed.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, n.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/config-error.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        class c extends Error {
          constructor(s, o) {
            super(s), (0, i.expectedError)(this), o && (0, i.injectVirtualStackFrame)(this, o);
          }
        }
        n.default = c;
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js": (h, n) => {
        var u;
        Object.defineProperty(n, "__esModule", { value: !0 }), n.beginHiddenCallStack = function(b) {
          return c ? Object.defineProperty(function(...v) {
            return m(), b(...v);
          }, "name", { value: s }) : b;
        }, n.endHiddenCallStack = function(b) {
          return c ? Object.defineProperty(function(...v) {
            return b(...v);
          }, "name", { value: f }) : b;
        }, n.expectedError = function(b) {
          if (c)
            return o.add(b), b;
        }, n.injectVirtualStackFrame = function(b, v) {
          if (!c) return;
          let T = y.get(b);
          return T || y.set(b, T = []), T.push(/* @__PURE__ */ function(E) {
            return /* @__PURE__ */ Object.create({ isNative: () => !1, isConstructor: () => !1, isToplevel: () => !0, getFileName: () => E, getLineNumber: () => {
            }, getColumnNumber: () => {
            }, getFunctionName: () => {
            }, getMethodName: () => {
            }, getTypeName: () => {
            }, toString: () => E });
          }(v)), b;
        };
        const i = Function.call.bind(Error.prototype.toString), c = !!Error.captureStackTrace && ((u = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : u.writable) === !0, f = "startHiding - secret - don't use this - v1", s = "stopHiding - secret - don't use this - v1", o = /* @__PURE__ */ new WeakSet(), y = /* @__PURE__ */ new WeakMap();
        function m() {
          m = () => {
          };
          const { prepareStackTrace: b = g } = Error;
          Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(v, T) {
            let E = [], O = o.has(v) ? "hiding" : "unknown";
            for (let D = 0; D < T.length; D++) {
              const $ = T[D].getFunctionName();
              if ($ === f) O = "hiding";
              else if ($ === s) {
                if (O === "hiding") O = "showing", y.has(v) && E.unshift(...y.get(v));
                else if (O === "unknown") {
                  E = T;
                  break;
                }
              } else O !== "hiding" && E.push(T[D]);
            }
            return b(v, E);
          };
        }
        function g(b, v) {
          return v.length === 0 ? i(b) : `${i(b)}
    at ${v.join(`
    at `)}`;
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/async.js": (h, n, u) => {
        function i() {
          const b = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return b;
          }, b;
        }
        function c(b, v, T, E, O, D, $) {
          try {
            var I = b[D]($), k = I.value;
          } catch (L) {
            return void T(L);
          }
          I.done ? v(k) : Promise.resolve(k).then(E, O);
        }
        function f(b) {
          return function() {
            var v = this, T = arguments;
            return new Promise(function(E, O) {
              var D = b.apply(v, T);
              function $(k) {
                c(D, E, O, $, I, "next", k);
              }
              function I(k) {
                c(D, E, O, $, I, "throw", k);
              }
              $(void 0);
            });
          };
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.forwardAsync = function(b, v) {
          const T = i()(b);
          return o((E) => {
            const O = T[E];
            return v(O);
          });
        }, n.isAsync = void 0, n.isThenable = g, n.maybeAsync = function(b, v) {
          return i()({ sync(...T) {
            const E = b.apply(this, T);
            if (g(E)) throw new Error(v);
            return E;
          }, async(...T) {
            return Promise.resolve(b.apply(this, T));
          } });
        }, n.waitFor = n.onFirstPause = void 0;
        const s = i()(function* (b) {
          return yield* b;
        });
        n.isAsync = i()({ sync: () => !1, errback: (b) => b(null, !0) });
        const o = i()({ sync: (b) => b("sync"), async: (y = f(function* (b) {
          return b("async");
        }), function(b) {
          return y.apply(this, arguments);
        }) });
        var y;
        n.onFirstPause = i()({ name: "onFirstPause", arity: 2, sync: function(b) {
          return s.sync(b);
        }, errback: function(b, v, T) {
          let E = !1;
          s.errback(b, (O, D) => {
            E = !0, T(O, D);
          }), E || v();
        } }), n.waitFor = i()({ sync: (b) => b, async: (m = f(function* (b) {
          return b;
        }), function(b) {
          return m.apply(this, arguments);
        }) });
        var m;
        function g(b) {
          return !(!b || typeof b != "object" && typeof b != "function" || !b.then || typeof b.then != "function");
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/fs.js": (h, n, u) => {
        function i() {
          const f = u("fs");
          return i = function() {
            return f;
          }, f;
        }
        function c() {
          const f = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return c = function() {
            return f;
          }, f;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.stat = n.readFile = void 0, n.readFile = c()({ sync: i().readFileSync, errback: i().readFile }), n.stat = c()({ sync: i().statSync, errback: i().stat });
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/functional.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.once = function(c) {
          let f, s, o = !1;
          return function* () {
            if (!f) {
              if (s) return o = !0, yield* (0, i.waitFor)(s);
              if (yield* (0, i.isAsync)()) {
                let y, m;
                s = new Promise((g, b) => {
                  y = g, m = b;
                });
                try {
                  f = { ok: !0, value: yield* c() }, s = null, o && y(f.value);
                } catch (g) {
                  f = { ok: !1, value: g }, s = null, o && m(g);
                }
              } else try {
                f = { ok: !0, value: yield* c() };
              } catch (y) {
                f = { ok: !1, value: y };
              }
            }
            if (f.ok) return f.value;
            throw f.value;
          };
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(n, "File", { enumerable: !0, get: function() {
          return i.default;
        } }), Object.defineProperty(n, "buildExternalHelpers", { enumerable: !0, get: function() {
          return c.default;
        } }), Object.defineProperty(n, "createConfigItem", { enumerable: !0, get: function() {
          return b.createConfigItem;
        } }), Object.defineProperty(n, "createConfigItemAsync", { enumerable: !0, get: function() {
          return b.createConfigItemAsync;
        } }), Object.defineProperty(n, "createConfigItemSync", { enumerable: !0, get: function() {
          return b.createConfigItemSync;
        } }), Object.defineProperty(n, "getEnv", { enumerable: !0, get: function() {
          return s.getEnv;
        } }), Object.defineProperty(n, "loadOptions", { enumerable: !0, get: function() {
          return b.loadOptions;
        } }), Object.defineProperty(n, "loadOptionsAsync", { enumerable: !0, get: function() {
          return b.loadOptionsAsync;
        } }), Object.defineProperty(n, "loadOptionsSync", { enumerable: !0, get: function() {
          return b.loadOptionsSync;
        } }), Object.defineProperty(n, "loadPartialConfig", { enumerable: !0, get: function() {
          return b.loadPartialConfig;
        } }), Object.defineProperty(n, "loadPartialConfigAsync", { enumerable: !0, get: function() {
          return b.loadPartialConfigAsync;
        } }), Object.defineProperty(n, "loadPartialConfigSync", { enumerable: !0, get: function() {
          return b.loadPartialConfigSync;
        } }), Object.defineProperty(n, "parse", { enumerable: !0, get: function() {
          return O.parse;
        } }), Object.defineProperty(n, "parseAsync", { enumerable: !0, get: function() {
          return O.parseAsync;
        } }), Object.defineProperty(n, "parseSync", { enumerable: !0, get: function() {
          return O.parseSync;
        } }), Object.defineProperty(n, "resolvePlugin", { enumerable: !0, get: function() {
          return f.resolvePlugin;
        } }), Object.defineProperty(n, "resolvePreset", { enumerable: !0, get: function() {
          return f.resolvePreset;
        } }), Object.defineProperty(n, "template", { enumerable: !0, get: function() {
          return g().default;
        } }), Object.defineProperty(n, "tokTypes", { enumerable: !0, get: function() {
          return y().tokTypes;
        } }), Object.defineProperty(n, "transform", { enumerable: !0, get: function() {
          return v.transform;
        } }), Object.defineProperty(n, "transformAsync", { enumerable: !0, get: function() {
          return v.transformAsync;
        } }), Object.defineProperty(n, "transformFile", { enumerable: !0, get: function() {
          return T.transformFile;
        } }), Object.defineProperty(n, "transformFileAsync", { enumerable: !0, get: function() {
          return T.transformFileAsync;
        } }), Object.defineProperty(n, "transformFileSync", { enumerable: !0, get: function() {
          return T.transformFileSync;
        } }), Object.defineProperty(n, "transformFromAst", { enumerable: !0, get: function() {
          return E.transformFromAst;
        } }), Object.defineProperty(n, "transformFromAstAsync", { enumerable: !0, get: function() {
          return E.transformFromAstAsync;
        } }), Object.defineProperty(n, "transformFromAstSync", { enumerable: !0, get: function() {
          return E.transformFromAstSync;
        } }), Object.defineProperty(n, "transformSync", { enumerable: !0, get: function() {
          return v.transformSync;
        } }), Object.defineProperty(n, "traverse", { enumerable: !0, get: function() {
          return m().default;
        } }), n.version = n.types = void 0;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/file.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/tools/build-external-helpers.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/files/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/environment.js");
        function o() {
          const D = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
          return o = function() {
            return D;
          }, D;
        }
        function y() {
          const D = u("./node_modules/.pnpm/@babel+parser@7.24.7/node_modules/@babel/parser/lib/index.js");
          return y = function() {
            return D;
          }, D;
        }
        function m() {
          const D = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js");
          return m = function() {
            return D;
          }, D;
        }
        function g() {
          const D = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/index.js");
          return g = function() {
            return D;
          }, D;
        }
        Object.defineProperty(n, "types", { enumerable: !0, get: function() {
          return o();
        } });
        var b = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/index.js"), v = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform.js"), T = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform-file.js"), E = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform-ast.js"), O = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parse.js");
        u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), n.version = "7.24.7", n.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]), n.OptionManager = class {
          init(D) {
            return (0, b.loadOptionsSync)(D);
          }
        }, n.Plugin = function(D) {
          throw new Error(`The (${D}) Babel 5 plugin is being run with an unsupported Babel version.`);
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parse.js": (h, n, u) => {
        function i() {
          const m = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.parse = void 0, n.parseAsync = function(...m) {
          return (0, o.beginHiddenCallStack)(y.async)(...m);
        }, n.parseSync = function(...m) {
          return (0, o.beginHiddenCallStack)(y.sync)(...m);
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/index.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parser/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/normalize-opts.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const y = i()(function* (m, g) {
          const b = yield* (0, c.default)(g);
          return b === null ? null : yield* (0, f.default)(b.passes, (0, s.default)(b), m);
        });
        n.parse = function(m, g, b) {
          if (typeof g == "function" && (b = g, g = void 0), b === void 0) return (0, o.beginHiddenCallStack)(y.sync)(m, g);
          (0, o.beginHiddenCallStack)(y.errback)(m, g, b);
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parser/index.js": (h, n, u) => {
        function i() {
          const s = u("./node_modules/.pnpm/@babel+parser@7.24.7/node_modules/@babel/parser/lib/index.js");
          return i = function() {
            return s;
          }, s;
        }
        function c() {
          const s = u("./stubs/babel-codeframe.js");
          return c = function() {
            return s;
          }, s;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function* (s, { parserOpts: o, highlightCode: y = !0, filename: m = "unknown" }, g) {
          try {
            const b = [];
            for (const v of s) for (const T of v) {
              const { parserOverride: E } = T;
              if (E) {
                const O = E(g, o, i().parse);
                O !== void 0 && b.push(O);
              }
            }
            if (b.length === 0) return (0, i().parse)(g, o);
            if (b.length === 1) {
              if (yield* [], typeof b[0].then == "function") throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              return b[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
          } catch (b) {
            b.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (b.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
            const { loc: v, missingPlugin: T } = b;
            if (v) {
              const E = (0, c().codeFrameColumns)(g, { start: { line: v.line, column: v.column + 1 } }, { highlightCode: y });
              b.message = T ? `${m}: ` + (0, f.default)(T[0], v, E, m) : `${m}: ${b.message}

` + E, b.code = "BABEL_PARSE_ERROR";
            }
            throw b;
          }
        };
        var f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f, s, o) {
          let y = `Support for the experimental syntax '${c}' isn't currently enabled (${f.line}:${f.column + 1}):

` + s;
          const m = u[c];
          if (m) {
            const { syntax: g, transform: b } = m;
            if (g) {
              const v = i(g);
              b ? y += `

Add ${i(b)} to the '${b.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${v} to the 'plugins' section to enable parsing.` : y += `

Add ${v} to the 'plugins' section of your Babel config to enable parsing.`;
            }
          }
          return y += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${o === "unknown" ? "<name of the input file>" : o} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, y;
        };
        const u = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
        Object.assign(u, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
        const i = ({ name: c, url: f }) => `${c} (${f})`;
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/tools/build-external-helpers.js": (h, n, u) => {
        function i() {
          const B = u("./node_modules/.pnpm/@babel+helpers@7.24.7/node_modules/@babel/helpers/lib/index.js");
          return i = function() {
            return B;
          }, B;
        }
        function c() {
          const B = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/index.js");
          return c = function() {
            return B;
          }, B;
        }
        function f() {
          const B = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/index.js");
          return f = function() {
            return B;
          }, B;
        }
        function s() {
          const B = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
          return s = function() {
            return B;
          }, B;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(B, Q = "global") {
          let J;
          const re = { global: H, module: z, umd: U, var: P }[Q];
          if (!re) throw new Error(`Unsupported output type ${Q}`);
          return J = re(B), (0, c().default)(J).code;
        };
        const { arrayExpression: o, assignmentExpression: y, binaryExpression: m, blockStatement: g, callExpression: b, cloneNode: v, conditionalExpression: T, exportNamedDeclaration: E, exportSpecifier: O, expressionStatement: D, functionExpression: $, identifier: I, memberExpression: k, objectExpression: L, program: M, stringLiteral: x, unaryExpression: _, variableDeclaration: S, variableDeclarator: C } = s(), R = (B) => f().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(B);
        function H(B) {
          const Q = I("babelHelpers"), J = [], re = $(null, [I("global")], g(J)), G = M([D(b(re, [T(m("===", _("typeof", I("global")), x("undefined")), I("self"), I("global"))]))]);
          return J.push(S("var", [C(Q, y("=", k(I("global"), Q), L([])))])), W(J, Q, B), G;
        }
        function z(B) {
          const Q = [], J = W(Q, null, B);
          return Q.unshift(E(null, Object.keys(J).map((re) => O(v(J[re]), I(re))))), M(Q, [], "module");
        }
        function U(B) {
          const Q = I("babelHelpers"), J = [];
          return J.push(S("var", [C(Q, I("global"))])), W(J, Q, B), M([R({ FACTORY_PARAMETERS: I("global"), BROWSER_ARGUMENTS: y("=", k(I("root"), Q), L([])), COMMON_ARGUMENTS: I("exports"), AMD_ARGUMENTS: o([x("exports")]), FACTORY_BODY: J, UMD_ROOT: I("this") })]);
        }
        function P(B) {
          const Q = I("babelHelpers"), J = [];
          J.push(S("var", [C(Q, L([]))]));
          const re = M(J);
          return W(J, Q, B), J.push(D(Q)), re;
        }
        function W(B, Q, J) {
          const re = (N) => Q ? k(Q, I(N)) : I(`_${N}`), G = {};
          return i().list.forEach(function(N) {
            if (J && J.indexOf(N) < 0) return;
            const V = G[N] = re(N), { nodes: F } = i().get(N, re, Q ? null : `_${N}`, [], Q ? (X, K, ie) => {
              ie((fe) => y("=", V, fe)), X.body.push(D(y("=", V, I(K))));
            } : null);
            B.push(...F);
          }), G;
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform-ast.js": (h, n, u) => {
        function i() {
          const y = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return y;
          }, y;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.transformFromAst = void 0, n.transformFromAstAsync = function(...y) {
          return (0, s.beginHiddenCallStack)(o.async)(...y);
        }, n.transformFromAstSync = function(...y) {
          return (0, s.beginHiddenCallStack)(o.sync)(...y);
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/index.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const o = i()(function* (y, m, g) {
          const b = yield* (0, c.default)(g);
          if (b === null) return null;
          if (!y) throw new Error("No AST given");
          return yield* (0, f.run)(b, m, y);
        });
        n.transformFromAst = function(y, m, g, b) {
          let v, T;
          if (typeof g == "function" ? (T = g, v = void 0) : (v = g, T = b), T === void 0) return (0, s.beginHiddenCallStack)(o.sync)(y, m, v);
          (0, s.beginHiddenCallStack)(o.errback)(y, m, v, T);
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform-file.js": (h, n, u) => {
        function i() {
          const y = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return y;
          }, y;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.transformFile = function(...y) {
          o.errback(...y);
        }, n.transformFileAsync = function(...y) {
          return o.async(...y);
        }, n.transformFileSync = function(...y) {
          return o.sync(...y);
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/index.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/gensync-utils/fs.js");
        const o = i()(function* (y, m) {
          const g = Object.assign({}, m, { filename: y }), b = yield* (0, c.default)(g);
          if (b === null) return null;
          const v = yield* s.readFile(y, "utf8");
          return yield* (0, f.run)(b, v);
        });
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transform.js": (h, n, u) => {
        function i() {
          const y = u("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return i = function() {
            return y;
          }, y;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.transform = void 0, n.transformAsync = function(...y) {
          return (0, s.beginHiddenCallStack)(o.async)(...y);
        }, n.transformSync = function(...y) {
          return (0, s.beginHiddenCallStack)(o.sync)(...y);
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/index.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const o = i()(function* (y, m) {
          const g = yield* (0, c.default)(m);
          return g === null ? null : yield* (0, f.run)(g, y);
        });
        n.transform = function(y, m, g) {
          let b, v;
          if (typeof m == "function" ? (v = m, b = void 0) : (b = m, v = g), v === void 0) return (0, s.beginHiddenCallStack)(o.sync)(y, b);
          (0, s.beginHiddenCallStack)(o.errback)(y, b, v);
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js": (h, n, u) => {
        function i() {
          const m = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js");
          return i = function() {
            return m;
          }, m;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function() {
          return f || (f = new c.default(Object.assign({}, s, { visitor: i().default.explode(s.visitor) }), {})), f;
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/plugin.js");
        let f;
        const s = { name: "internal.blockHoist", visitor: { Block: { exit({ node: m }) {
          m.body = o(m.body);
        } }, SwitchCase: { exit({ node: m }) {
          m.consequent = o(m.consequent);
        } } } };
        function o(m) {
          let g = Math.pow(2, 30) - 1, b = !1;
          for (let v = 0; v < m.length; v++) {
            const T = y(m[v]);
            if (T > g) {
              b = !0;
              break;
            }
            g = T;
          }
          return b ? function(v) {
            const T = /* @__PURE__ */ Object.create(null);
            for (let D = 0; D < v.length; D++) {
              const $ = v[D], I = y($);
              (T[I] || (T[I] = [])).push($);
            }
            const E = Object.keys(T).map((D) => +D).sort((D, $) => $ - D);
            let O = 0;
            for (const D of E) {
              const $ = T[D];
              for (const I of $) v[O++] = I;
            }
            return v;
          }(m.slice()) : m;
        }
        function y(m) {
          const g = m == null ? void 0 : m._blockHoist;
          return g == null ? 1 : g === !0 ? 2 : g;
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/file.js": (h, n, u) => {
        function i() {
          const T = u("./node_modules/.pnpm/@babel+helpers@7.24.7/node_modules/@babel/helpers/lib/index.js");
          return i = function() {
            return T;
          }, T;
        }
        function c() {
          const T = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js");
          return c = function() {
            return T;
          }, T;
        }
        function f() {
          const T = u("./stubs/babel-codeframe.js");
          return f = function() {
            return T;
          }, T;
        }
        function s() {
          const T = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
          return s = function() {
            return T;
          }, T;
        }
        function o() {
          const T = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/index.js");
          return o = function() {
            return T;
          }, T;
        }
        function y() {
          const T = u("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return y = function() {
            return T;
          }, T;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        const { cloneNode: m, interpreterDirective: g } = s(), b = { enter(T, E) {
          const O = T.node.loc;
          O && (E.loc = O, T.stop());
        } };
        class v {
          constructor(E, { code: O, ast: D, inputMap: $ }) {
            this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = E, this.code = O, this.ast = D, this.inputMap = $, this.path = c().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
          }
          get shebang() {
            const { interpreter: E } = this.path.node;
            return E ? E.value : "";
          }
          set shebang(E) {
            E ? this.path.get("interpreter").replaceWith(g(E)) : this.path.get("interpreter").remove();
          }
          set(E, O) {
            if (E === "helpersNamespace") throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(E, O);
          }
          get(E) {
            return this._map.get(E);
          }
          has(E) {
            return this._map.has(E);
          }
          getModuleName() {
            return (0, o().getModuleName)(this.opts, this.opts);
          }
          availableHelper(E, O) {
            let D;
            try {
              D = i().minVersion(E);
            } catch ($) {
              if ($.code !== "BABEL_HELPER_UNKNOWN") throw $;
              return !1;
            }
            return typeof O != "string" || (y().valid(O) && (O = `^${O}`), !y().intersects(`<${D}`, O) && !y().intersects(">=8.0.0", O));
          }
          addHelper(E) {
            const O = this.declarations[E];
            if (O) return m(O);
            const D = this.get("helperGenerator");
            if (D) {
              const x = D(E);
              if (x) return x;
            }
            i().minVersion(E);
            const $ = this.declarations[E] = this.scope.generateUidIdentifier(E), I = {};
            for (const x of i().getDependencies(E)) I[x] = this.addHelper(x);
            const { nodes: k, globals: L } = i().get(E, (x) => I[x], $.name, Object.keys(this.scope.getAllBindings()));
            L.forEach((x) => {
              this.path.scope.hasBinding(x, !0) && this.path.scope.rename(x);
            }), k.forEach((x) => {
              x._compact = !0;
            });
            const M = this.path.unshiftContainer("body", k);
            for (const x of M) x.isVariableDeclaration() && this.scope.registerDeclaration(x);
            return $;
          }
          buildCodeFrameError(E, O, D = SyntaxError) {
            let $ = E == null ? void 0 : E.loc;
            if (!$ && E) {
              const I = { loc: null };
              (0, c().default)(E, b, this.scope, I), $ = I.loc;
              let k = "This is an error on an internal node. Probably an internal error.";
              $ && (k += " Location has been estimated."), O += ` (${k})`;
            }
            if ($) {
              const { highlightCode: I = !0 } = this.opts;
              O += `
` + (0, f().codeFrameColumns)(this.code, { start: { line: $.start.line, column: $.start.column + 1 }, end: $.end && $.start.line === $.end.line ? { line: $.end.line, column: $.end.column + 1 } : void 0 }, { highlightCode: I });
            }
            return new D(O);
          }
        }
        n.default = v, v.prototype.addImport = function() {
          throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
        }, v.prototype.addTemplateObject = function() {
          throw new Error("This function has been moved into the template literal transform itself.");
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/generate.js": (h, n, u) => {
        function i() {
          const s = u("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");
          return i = function() {
            return s;
          }, s;
        }
        function c() {
          const s = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/index.js");
          return c = function() {
            return s;
          }, s;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o) {
          const { opts: y, ast: m, code: g, inputMap: b } = o, { generatorOpts: v } = y;
          v.inputSourceMap = b == null ? void 0 : b.toObject();
          const T = [];
          for (const $ of s) for (const I of $) {
            const { generatorOverride: k } = I;
            if (k) {
              const L = k(m, v, g, c().default);
              L !== void 0 && T.push(L);
            }
          }
          let E;
          if (T.length === 0) E = (0, c().default)(m, v, g);
          else {
            if (T.length !== 1) throw new Error("More than one plugin attempted to override codegen.");
            if (E = T[0], typeof E.then == "function") throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          let { code: O, decodedMap: D = E.map } = E;
          return E.__mergedMap ? D = Object.assign({}, E.map) : D && (D = b ? (0, f.default)(b.toObject(), D, v.sourceFileName) : E.map), y.sourceMaps !== "inline" && y.sourceMaps !== "both" || (O += `
` + i().fromObject(D).toComment()), y.sourceMaps === "inline" && (D = null), { outputCode: O, outputMap: D };
        };
        var f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/merge-map.js");
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/merge-map.js": (h, n, u) => {
        function i() {
          const f = u("./node_modules/.pnpm/@ampproject+remapping@2.3.0/node_modules/@ampproject/remapping/dist/remapping.umd.js");
          return i = function() {
            return f;
          }, f;
        }
        function c(f) {
          return Object.assign({}, f, { sourceRoot: null });
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s, o) {
          const y = o.replace(/\\/g, "/");
          let m = !1;
          const g = i()(c(s), (b, v) => b !== y || m ? null : (m = !0, v.source = "", c(f)));
          return typeof f.sourceRoot == "string" && (g.sourceRoot = f.sourceRoot), Object.assign({}, g);
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/index.js": (h, n, u) => {
        function i() {
          const b = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js");
          return i = function() {
            return b;
          }, b;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.run = function* (b, v, T) {
          const E = yield* (0, o.default)(b.passes, (0, s.default)(b), v, T), O = E.opts;
          try {
            yield* function* (L, M) {
              for (const x of M) {
                const _ = [], S = [], C = [];
                for (const H of x.concat([(0, f.default)()])) {
                  const z = new c.default(L, H.key, H.options);
                  _.push([H, z]), S.push(z), C.push(H.visitor);
                }
                for (const [H, z] of _) {
                  const U = H.pre;
                  if (U) {
                    const P = U.call(z, L);
                    if (yield* [], g(P)) throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
                const R = i().default.visitors.merge(C, S, L.opts.wrapPluginVisitorMethod);
                (0, i().default)(L.ast, R, L.scope);
                for (const [H, z] of _) {
                  const U = H.post;
                  if (U) {
                    const P = U.call(z, L);
                    if (yield* [], g(P)) throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  }
                }
              }
            }(E, b.passes);
          } catch (L) {
            var D;
            throw L.message = `${(D = O.filename) != null ? D : "unknown file"}: ${L.message}`, L.code || (L.code = "BABEL_TRANSFORM_ERROR"), L;
          }
          let $, I;
          try {
            O.code !== !1 && ({ outputCode: $, outputMap: I } = (0, y.default)(b.passes, E));
          } catch (L) {
            var k;
            throw L.message = `${(k = O.filename) != null ? k : "unknown file"}: ${L.message}`, L.code || (L.code = "BABEL_GENERATE_ERROR"), L;
          }
          return { metadata: E.metadata, options: O, ast: O.ast === !0 ? E.ast : null, code: $ === void 0 ? null : $, map: I === void 0 ? null : I, sourceType: E.ast.program.sourceType, externalDependencies: (0, m.flattenToSet)(b.externalDependencies) };
        };
        var c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/plugin-pass.js"), f = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/normalize-opts.js"), o = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/normalize-file.js"), y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/generate.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function g(b) {
          return !(!b || typeof b != "object" && typeof b != "function" || !b.then || typeof b.then != "function");
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/normalize-file.js": (h, n, u) => {
        function i() {
          const I = u("fs");
          return i = function() {
            return I;
          }, I;
        }
        function c() {
          const I = u("path");
          return c = function() {
            return I;
          }, I;
        }
        function f() {
          const I = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js");
          return f = function() {
            return I;
          }, I;
        }
        function s() {
          const I = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
          return s = function() {
            return I;
          }, I;
        }
        function o() {
          const I = u("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");
          return o = function() {
            return I;
          }, I;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function* (I, k, L, M) {
          if (L = `${L || ""}`, M) {
            if (M.type === "Program") M = b(M, [], []);
            else if (M.type !== "File") throw new Error("AST root must be a Program or File node");
            k.cloneInputAst && (M = (0, g.default)(M));
          } else M = yield* (0, m.default)(I, k, L);
          let x = null;
          if (k.inputSourceMap !== !1) {
            if (typeof k.inputSourceMap == "object" && (x = o().fromObject(k.inputSourceMap)), !x) {
              const _ = $(E, M);
              if (_) try {
                x = o().fromComment("//" + _);
              } catch {
                T("discarding unknown inline input sourcemap");
              }
            }
            if (!x) {
              const _ = $(O, M);
              if (typeof k.filename == "string" && _) try {
                const S = O.exec(_), C = i().readFileSync(c().resolve(c().dirname(k.filename), S[1]), "utf8");
                x = o().fromJSON(C);
              } catch (S) {
                T("discarding unknown file input sourcemap", S);
              }
              else _ && T("discarding un-loadable file input sourcemap");
            }
          }
          return new y.default(k, { code: L, ast: M, inputMap: x });
        };
        var y = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/file/file.js"), m = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/parser/index.js"), g = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/util/clone-deep.js");
        const { file: b, traverseFast: v } = s(), T = f()("babel:transform:file"), E = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, O = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
        function D(I, k, L) {
          return k && (k = k.filter(({ value: M }) => !I.test(M) || (L = M, !1))), [k, L];
        }
        function $(I, k) {
          let L = null;
          return v(k, (M) => {
            [M.leadingComments, L] = D(I, M.leadingComments, L), [M.innerComments, L] = D(I, M.innerComments, L), [M.trailingComments, L] = D(I, M.trailingComments, L);
          }), L;
        }
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/normalize-opts.js": (h, n, u) => {
        function i() {
          const c = u("path");
          return i = function() {
            return c;
          }, c;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          const { filename: f, cwd: s, filenameRelative: o = typeof f == "string" ? i().relative(s, f) : "unknown", sourceType: y = "module", inputSourceMap: m, sourceMaps: g = !!m, sourceRoot: b = c.options.moduleRoot, sourceFileName: v = i().basename(o), comments: T = !0, compact: E = "auto" } = c.options, O = c.options, D = Object.assign({}, O, { parserOpts: Object.assign({ sourceType: i().extname(o) === ".mjs" ? "module" : y, sourceFileName: f, plugins: [] }, O.parserOpts), generatorOpts: Object.assign({ filename: f, auxiliaryCommentBefore: O.auxiliaryCommentBefore, auxiliaryCommentAfter: O.auxiliaryCommentAfter, retainLines: O.retainLines, comments: T, shouldPrintComment: O.shouldPrintComment, compact: E, minified: O.minified, sourceMaps: g, sourceRoot: b, sourceFileName: v }, O.generatorOpts) });
          for (const $ of c.passes) for (const I of $) I.manipulateOptions && I.manipulateOptions(D, D.parserOpts);
          return D;
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/plugin-pass.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        class u {
          constructor(c, f, s) {
            this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = f, this.file = c, this.opts = s || {}, this.cwd = c.opts.cwd, this.filename = c.opts.filename;
          }
          set(c, f) {
            this._map.set(c, f);
          }
          get(c) {
            return this._map.get(c);
          }
          availableHelper(c, f) {
            return this.file.availableHelper(c, f);
          }
          addHelper(c) {
            return this.file.addHelper(c);
          }
          buildCodeFrameError(c, f, s) {
            return this.file.buildCodeFrameError(c, f, s);
          }
        }
        n.default = u, u.prototype.getModuleName = function() {
          return this.file.getModuleName();
        }, u.prototype.addImport = function() {
          this.file.addImport();
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/transformation/util/clone-deep.js": (h, n) => {
        function u(i, c) {
          if (i !== null) {
            if (c.has(i)) return c.get(i);
            let f;
            if (Array.isArray(i)) {
              f = new Array(i.length), c.set(i, f);
              for (let s = 0; s < i.length; s++) f[s] = typeof i[s] != "object" ? i[s] : u(i[s], c);
            } else {
              f = {}, c.set(i, f);
              const s = Object.keys(i);
              for (let o = 0; o < s.length; o++) {
                const y = s[o];
                f[y] = typeof i[y] != "object" ? i[y] : u(i[y], c);
              }
            }
            return f;
          }
          return i;
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(i) {
          return typeof i != "object" ? i : u(i, /* @__PURE__ */ new Map());
        };
      }, "./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/vendor/import-meta-resolve.js": (h, n, u) => {
        function i() {
          const De = u("assert");
          return i = function() {
            return De;
          }, De;
        }
        function c() {
          const De = function(Me, Qe) {
            if (Me === null || typeof Me != "object" && typeof Me != "function") return { default: Me };
            var He = b(Qe);
            if (He && He.has(Me)) return He.get(Me);
            var st = { __proto__: null }, it = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var qe in Me) if (qe !== "default" && {}.hasOwnProperty.call(Me, qe)) {
              var rt = it ? Object.getOwnPropertyDescriptor(Me, qe) : null;
              rt && (rt.get || rt.set) ? Object.defineProperty(st, qe, rt) : st[qe] = Me[qe];
            }
            return st.default = Me, He && He.set(Me, st), st;
          }(u("fs"), !0);
          return c = function() {
            return De;
          }, De;
        }
        function f() {
          const De = u("process");
          return f = function() {
            return De;
          }, De;
        }
        function s() {
          const De = u("url");
          return s = function() {
            return De;
          }, De;
        }
        function o() {
          const De = u("path");
          return o = function() {
            return De;
          }, De;
        }
        function y() {
          const De = u("module");
          return y = function() {
            return De;
          }, De;
        }
        function m() {
          const De = u("v8");
          return m = function() {
            return De;
          }, De;
        }
        function g() {
          const De = u("util");
          return g = function() {
            return De;
          }, De;
        }
        function b(De) {
          if (typeof WeakMap != "function") return null;
          var Me = /* @__PURE__ */ new WeakMap(), Qe = /* @__PURE__ */ new WeakMap();
          return (b = function(He) {
            return He ? Qe : Me;
          })(De);
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.moduleResolve = et, n.resolve = function(De, Me) {
          if (!Me) throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
          try {
            return function(Qe, He = {}) {
              const { parentURL: st } = He;
              let it, qe, rt;
              if (i()(st !== void 0, "expected `parentURL` to be defined"), function(mt) {
                if (mt !== void 0) {
                  if (typeof mt != "string" && (ut = mt, !(ut && typeof ut == "object" && "href" in ut && typeof ut.href == "string" && "protocol" in ut && typeof ut.protocol == "string" && ut.href && ut.protocol))) throw new O.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], mt);
                  var ut;
                }
              }(st), st) try {
                it = new (s()).URL(st);
              } catch {
              }
              try {
                if (qe = We(Qe) ? new (s()).URL(Qe, it) : new (s()).URL(Qe), rt = qe.protocol, rt === "data:") return { url: qe.href, format: null };
              } catch {
              }
              const bt = function(mt, ut, Et) {
                if (Et) {
                  const Tt = Et.protocol;
                  if (Tt === "http:" || Tt === "https:") {
                    if (We(mt)) {
                      const St = ut == null ? void 0 : ut.protocol;
                      if (St && St !== "https:" && St !== "http:") throw new V(mt, Et, "remote imports cannot import from a local location.");
                      return { url: (ut == null ? void 0 : ut.href) || "" };
                    }
                    throw y().builtinModules.includes(mt) ? new V(mt, Et, "remote imports cannot import from a local location.") : new V(mt, Et, "only relative and absolute specifiers are supported.");
                  }
                }
              }(Qe, qe, it);
              if (bt) return bt;
              if (rt === void 0 && qe && (rt = qe.protocol), rt === "node:") return { url: Qe };
              if (qe && qe.protocol === "node:") return { url: Qe };
              const dt = function(mt) {
                if (mt !== void 0 && mt !== re) {
                  if (!Array.isArray(mt)) throw new J("conditions", mt, "expected an array");
                  return new Set(mt);
                }
                return G;
              }(He.conditions), Je = et(Qe, new (s()).URL(st), dt, !1);
              return { url: Je.href, format: Q(Je, { parentURL: st }) };
            }(De, { parentURL: Me }).url;
          } catch (Qe) {
            const He = Qe;
            if ((He.code === "ERR_UNSUPPORTED_DIR_IMPORT" || He.code === "ERR_MODULE_NOT_FOUND") && typeof He.url == "string") return He.url;
            throw Qe;
          }
        };
        const v = {}.hasOwnProperty, T = /^([A-Z][a-z\d]*)+$/, E = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), O = {};
        function D(De, Me = "and") {
          return De.length < 3 ? De.join(` ${Me} `) : `${De.slice(0, -1).join(", ")}, ${Me} ${De[De.length - 1]}`;
        }
        const $ = /* @__PURE__ */ new Map();
        let I;
        function k(De, Me, Qe) {
          return $.set(De, Me), /* @__PURE__ */ function(He, st) {
            return it;
            function it(...qe) {
              const rt = Error.stackTraceLimit;
              L() && (Error.stackTraceLimit = 0);
              const bt = new He();
              L() && (Error.stackTraceLimit = rt);
              const dt = function(Je, mt, ut) {
                const Et = $.get(Je);
                if (i()(Et !== void 0, "expected `message` to be found"), typeof Et == "function") return i()(Et.length <= mt.length, `Code: ${Je}; The provided arguments length (${mt.length}) does not match the required ones (${Et.length}).`), Reflect.apply(Et, ut, mt);
                const Tt = /%[dfijoOs]/g;
                let St = 0;
                for (; Tt.exec(Et) !== null; ) St++;
                return i()(St === mt.length, `Code: ${Je}; The provided arguments length (${mt.length}) does not match the required ones (${St}).`), mt.length === 0 ? Et : (mt.unshift(Et), Reflect.apply(g().format, null, mt));
              }(st, qe, bt);
              return Object.defineProperties(bt, { message: { value: dt, enumerable: !1, writable: !0, configurable: !0 }, toString: { value() {
                return `${this.name} [${st}]: ${this.message}`;
              }, enumerable: !1, writable: !0, configurable: !0 } }), M(bt), bt.code = st, bt;
            }
          }(Qe, De);
        }
        function L() {
          try {
            if (m().startupSnapshot.isBuildingSnapshot()) return !1;
          } catch {
          }
          const De = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return De === void 0 ? Object.isExtensible(Error) : v.call(De, "writable") && De.writable !== void 0 ? De.writable : De.set !== void 0;
        }
        O.ERR_INVALID_ARG_TYPE = k("ERR_INVALID_ARG_TYPE", (De, Me, Qe) => {
          i()(typeof De == "string", "'name' must be a string"), Array.isArray(Me) || (Me = [Me]);
          let He = "The ";
          if (De.endsWith(" argument")) He += `${De} `;
          else {
            const rt = De.includes(".") ? "property" : "argument";
            He += `"${De}" ${rt} `;
          }
          He += "must be ";
          const st = [], it = [], qe = [];
          for (const rt of Me) i()(typeof rt == "string", "All expected entries have to be of type string"), E.has(rt) ? st.push(rt.toLowerCase()) : T.exec(rt) === null ? (i()(rt !== "object", 'The value "object" should be written as "Object"'), qe.push(rt)) : it.push(rt);
          if (it.length > 0) {
            const rt = st.indexOf("object");
            rt !== -1 && (st.slice(rt, 1), it.push("Object"));
          }
          return st.length > 0 && (He += `${st.length > 1 ? "one of type" : "of type"} ${D(st, "or")}`, (it.length > 0 || qe.length > 0) && (He += " or ")), it.length > 0 && (He += `an instance of ${D(it, "or")}`, qe.length > 0 && (He += " or ")), qe.length > 0 && (qe.length > 1 ? He += `one of ${D(qe, "or")}` : (qe[0].toLowerCase() !== qe[0] && (He += "an "), He += `${qe[0]}`)), He += `. Received ${function(rt) {
            if (rt == null) return String(rt);
            if (typeof rt == "function" && rt.name) return `function ${rt.name}`;
            if (typeof rt == "object") return rt.constructor && rt.constructor.name ? `an instance of ${rt.constructor.name}` : `${(0, g().inspect)(rt, { depth: -1 })}`;
            let bt = (0, g().inspect)(rt, { colors: !1 });
            return bt.length > 28 && (bt = `${bt.slice(0, 25)}...`), `type ${typeof rt} (${bt})`;
          }(Qe)}`, He;
        }, TypeError), O.ERR_INVALID_MODULE_SPECIFIER = k("ERR_INVALID_MODULE_SPECIFIER", (De, Me, Qe = void 0) => `Invalid module "${De}" ${Me}${Qe ? ` imported from ${Qe}` : ""}`, TypeError), O.ERR_INVALID_PACKAGE_CONFIG = k("ERR_INVALID_PACKAGE_CONFIG", (De, Me, Qe) => `Invalid package config ${De}${Me ? ` while importing ${Me}` : ""}${Qe ? `. ${Qe}` : ""}`, Error), O.ERR_INVALID_PACKAGE_TARGET = k("ERR_INVALID_PACKAGE_TARGET", (De, Me, Qe, He = !1, st = void 0) => {
          const it = typeof Qe == "string" && !He && Qe.length > 0 && !Qe.startsWith("./");
          return Me === "." ? (i()(He === !1), `Invalid "exports" main target ${JSON.stringify(Qe)} defined in the package config ${De}package.json${st ? ` imported from ${st}` : ""}${it ? '; targets must start with "./"' : ""}`) : `Invalid "${He ? "imports" : "exports"}" target ${JSON.stringify(Qe)} defined for '${Me}' in the package config ${De}package.json${st ? ` imported from ${st}` : ""}${it ? '; targets must start with "./"' : ""}`;
        }, Error), O.ERR_MODULE_NOT_FOUND = k("ERR_MODULE_NOT_FOUND", (De, Me, Qe = !1) => `Cannot find ${Qe ? "module" : "package"} '${De}' imported from ${Me}`, Error), O.ERR_NETWORK_IMPORT_DISALLOWED = k("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), O.ERR_PACKAGE_IMPORT_NOT_DEFINED = k("ERR_PACKAGE_IMPORT_NOT_DEFINED", (De, Me, Qe) => `Package import specifier "${De}" is not defined${Me ? ` in package ${Me}package.json` : ""} imported from ${Qe}`, TypeError), O.ERR_PACKAGE_PATH_NOT_EXPORTED = k("ERR_PACKAGE_PATH_NOT_EXPORTED", (De, Me, Qe = void 0) => Me === "." ? `No "exports" main defined in ${De}package.json${Qe ? ` imported from ${Qe}` : ""}` : `Package subpath '${Me}' is not defined by "exports" in ${De}package.json${Qe ? ` imported from ${Qe}` : ""}`, Error), O.ERR_UNSUPPORTED_DIR_IMPORT = k("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), O.ERR_UNSUPPORTED_RESOLVE_REQUEST = k("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), O.ERR_UNKNOWN_FILE_EXTENSION = k("ERR_UNKNOWN_FILE_EXTENSION", (De, Me) => `Unknown file extension "${De}" for ${Me}`, TypeError), O.ERR_INVALID_ARG_VALUE = k("ERR_INVALID_ARG_VALUE", (De, Me, Qe = "is invalid") => {
          let He = (0, g().inspect)(Me);
          return He.length > 128 && (He = `${He.slice(0, 128)}...`), `The ${De.includes(".") ? "property" : "argument"} '${De}' ${Qe}. Received ${He}`;
        }, TypeError);
        const M = function(De) {
          const Me = "__node_internal_" + De.name;
          return Object.defineProperty(De, "name", { value: Me }), De;
        }(function(De) {
          const Me = L();
          return Me && (I = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(De), Me && (Error.stackTraceLimit = I), De;
        }), x = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: _ } = O, S = /* @__PURE__ */ new Map();
        function C(De, { base: Me, specifier: Qe }) {
          const He = S.get(De);
          if (He) return He;
          let st;
          try {
            st = c().default.readFileSync(o().toNamespacedPath(De), "utf8");
          } catch (qe) {
            const rt = qe;
            if (rt.code !== "ENOENT") throw rt;
          }
          const it = { exists: !1, pjsonPath: De, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (st !== void 0) {
            let qe;
            try {
              qe = JSON.parse(st);
            } catch (rt) {
              const bt = rt, dt = new _(De, (Me ? `"${Qe}" from ` : "") + (0, s().fileURLToPath)(Me || Qe), bt.message);
              throw dt.cause = bt, dt;
            }
            it.exists = !0, x.call(qe, "name") && typeof qe.name == "string" && (it.name = qe.name), x.call(qe, "main") && typeof qe.main == "string" && (it.main = qe.main), x.call(qe, "exports") && (it.exports = qe.exports), x.call(qe, "imports") && (it.imports = qe.imports), !x.call(qe, "type") || qe.type !== "commonjs" && qe.type !== "module" || (it.type = qe.type);
          }
          return S.set(De, it), it;
        }
        function R(De) {
          let Me = new URL("package.json", De);
          for (; !Me.pathname.endsWith("node_modules/package.json"); ) {
            const Qe = C((0, s().fileURLToPath)(Me), { specifier: De });
            if (Qe.exists) return Qe;
            const He = Me;
            if (Me = new URL("../package.json", Me), Me.pathname === He.pathname) break;
          }
          return { pjsonPath: (0, s().fileURLToPath)(Me), exists: !1, type: "none" };
        }
        function H(De) {
          return R(De).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: z } = O, U = {}.hasOwnProperty, P = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" }, W = { __proto__: null, "data:": function(De) {
          const { 1: Me } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(De.pathname) || [null, null, null];
          return function(Qe) {
            return Qe && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(Qe) ? "module" : Qe === "application/json" ? "json" : null;
          }(Me);
        }, "file:": function(De, Me, Qe) {
          const He = function(qe) {
            const rt = qe.pathname;
            let bt = rt.length;
            for (; bt--; ) {
              const dt = rt.codePointAt(bt);
              if (dt === 47) return "";
              if (dt === 46) return rt.codePointAt(bt - 1) === 47 ? "" : rt.slice(bt);
            }
            return "";
          }(De);
          if (He === ".js") {
            const qe = H(De);
            return qe !== "none" ? qe : "commonjs";
          }
          if (He === "") {
            const qe = H(De);
            return qe === "none" || qe === "commonjs" ? "commonjs" : "module";
          }
          const st = P[He];
          if (st) return st;
          if (Qe) return;
          const it = (0, s().fileURLToPath)(De);
          throw new z(He, it);
        }, "http:": B, "https:": B, "node:": () => "builtin" };
        function B() {
        }
        function Q(De, Me) {
          const Qe = De.protocol;
          return U.call(W, Qe) && W[Qe](De, Me, !0) || null;
        }
        const { ERR_INVALID_ARG_VALUE: J } = O, re = Object.freeze(["node", "import"]), G = new Set(re), N = RegExp.prototype[Symbol.replace], { ERR_NETWORK_IMPORT_DISALLOWED: V, ERR_INVALID_MODULE_SPECIFIER: F, ERR_INVALID_PACKAGE_CONFIG: X, ERR_INVALID_PACKAGE_TARGET: K, ERR_MODULE_NOT_FOUND: ie, ERR_PACKAGE_IMPORT_NOT_DEFINED: fe, ERR_PACKAGE_PATH_NOT_EXPORTED: _e, ERR_UNSUPPORTED_DIR_IMPORT: Ae, ERR_UNSUPPORTED_RESOLVE_REQUEST: ce } = O, ee = {}.hasOwnProperty, ae = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, oe = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, me = /^\.|%|\\/, ye = /\*/g, we = /%2f|%5c/i, ge = /* @__PURE__ */ new Set(), se = /[/\\]{2}/;
        function be(De, Me, Qe, He, st, it, qe) {
          if (f().noDeprecation) return;
          const rt = (0, s().fileURLToPath)(He), bt = se.exec(qe ? De : Me) !== null;
          f().emitWarning(`Use of deprecated ${bt ? "double slash" : "leading or trailing slash matching"} resolving "${De}" for module request "${Me}" ${Me === Qe ? "" : `matched to "${Qe}" `}in the "${st ? "imports" : "exports"}" field module resolution of the package at ${rt}${it ? ` imported from ${(0, s().fileURLToPath)(it)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function Ie(De, Me, Qe, He) {
          if (f().noDeprecation || Q(De, { parentURL: Qe.href }) !== "module") return;
          const st = (0, s().fileURLToPath)(De.href), it = (0, s().fileURLToPath)(new (s()).URL(".", Me)), qe = (0, s().fileURLToPath)(Qe);
          He ? o().resolve(it, He) !== st && f().emitWarning(`Package ${it} has a "main" field set to "${He}", excluding the full filename and extension to the resolved file at "${st.slice(it.length)}", imported from ${qe}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : f().emitWarning(`No "main" or "exports" field defined in the package.json for ${it} resolving the main entry point "${st.slice(it.length)}", imported from ${qe}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function Oe(De) {
          try {
            return (0, c().statSync)(De);
          } catch {
          }
        }
        function Be(De) {
          const Me = (0, c().statSync)(De, { throwIfNoEntry: !1 }), Qe = Me ? Me.isFile() : void 0;
          return Qe != null && Qe;
        }
        function Fe(De, Me, Qe) {
          let He;
          if (Me.main !== void 0) {
            if (He = new (s()).URL(Me.main, De), Be(He)) return He;
            const qe = [`./${Me.main}.js`, `./${Me.main}.json`, `./${Me.main}.node`, `./${Me.main}/index.js`, `./${Me.main}/index.json`, `./${Me.main}/index.node`];
            let rt = -1;
            for (; ++rt < qe.length && (He = new (s()).URL(qe[rt], De), !Be(He)); ) He = void 0;
            if (He) return Ie(He, De, Qe, Me.main), He;
          }
          const st = ["./index.js", "./index.json", "./index.node"];
          let it = -1;
          for (; ++it < st.length && (He = new (s()).URL(st[it], De), !Be(He)); ) He = void 0;
          if (He) return Ie(He, De, Qe, Me.main), He;
          throw new ie((0, s().fileURLToPath)(new (s()).URL(".", De)), (0, s().fileURLToPath)(Qe));
        }
        function ue(De, Me, Qe) {
          return new _e((0, s().fileURLToPath)(new (s()).URL(".", Me)), De, Qe && (0, s().fileURLToPath)(Qe));
        }
        function te(De, Me, Qe, He, st) {
          return Me = typeof Me == "object" && Me !== null ? JSON.stringify(Me, null, "") : `${Me}`, new K((0, s().fileURLToPath)(new (s()).URL(".", Qe)), De, Me, He, st && (0, s().fileURLToPath)(st));
        }
        function Y(De, Me, Qe, He, st, it, qe, rt, bt) {
          if (Me !== "" && !it && De[De.length - 1] !== "/") throw te(Qe, De, He, qe, st);
          if (!De.startsWith("./")) {
            if (qe && !De.startsWith("../") && !De.startsWith("/")) {
              let ut = !1;
              try {
                new (s()).URL(De), ut = !0;
              } catch {
              }
              if (!ut)
                return Ye(it ? N.call(ye, De, () => Me) : De + Me, He, bt);
            }
            throw te(Qe, De, He, qe, st);
          }
          if (ae.exec(De.slice(2)) !== null) {
            if (oe.exec(De.slice(2)) !== null) throw te(Qe, De, He, qe, st);
            if (!rt) {
              const ut = it ? Qe.replace("*", () => Me) : Qe + Me;
              be(it ? N.call(ye, De, () => Me) : De, ut, Qe, He, qe, st, !0);
            }
          }
          const dt = new (s()).URL(De, He), Je = dt.pathname, mt = new (s()).URL(".", He).pathname;
          if (!Je.startsWith(mt)) throw te(Qe, De, He, qe, st);
          if (Me === "") return dt;
          if (ae.exec(Me) !== null) {
            const ut = it ? Qe.replace("*", () => Me) : Qe + Me;
            oe.exec(Me) === null ? rt || be(it ? N.call(ye, De, () => Me) : De, ut, Qe, He, qe, st, !1) : function(Et, Tt, St, Vt, Kt) {
              const xt = `request is not a valid match in pattern "${Tt}" for the "${Vt ? "imports" : "exports"}" resolution of ${(0, s().fileURLToPath)(St)}`;
              throw new F(Et, xt, Kt && (0, s().fileURLToPath)(Kt));
            }(ut, Qe, He, qe, st);
          }
          return it ? new (s()).URL(N.call(ye, dt.href, () => Me)) : new (s()).URL(Me, dt);
        }
        function le(De) {
          const Me = Number(De);
          return `${Me}` === De && Me >= 0 && Me < 4294967295;
        }
        function Ee(De, Me, Qe, He, st, it, qe, rt, bt) {
          if (typeof Me == "string") return Y(Me, Qe, He, De, st, it, qe, rt, bt);
          if (Array.isArray(Me)) {
            const dt = Me;
            if (dt.length === 0) return null;
            let Je, mt = -1;
            for (; ++mt < dt.length; ) {
              const ut = dt[mt];
              let Et;
              try {
                Et = Ee(De, ut, Qe, He, st, it, qe, rt, bt);
              } catch (Tt) {
                if (Je = Tt, Tt.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                throw Tt;
              }
              if (Et !== void 0) {
                if (Et !== null) return Et;
                Je = null;
              }
            }
            if (Je == null) return null;
            throw Je;
          }
          if (typeof Me == "object" && Me !== null) {
            const dt = Object.getOwnPropertyNames(Me);
            let Je = -1;
            for (; ++Je < dt.length; )
              if (le(dt[Je])) throw new X((0, s().fileURLToPath)(De), st, '"exports" cannot contain numeric property keys.');
            for (Je = -1; ++Je < dt.length; ) {
              const mt = dt[Je];
              if (mt === "default" || bt && bt.has(mt)) {
                const ut = Ee(De, Me[mt], Qe, He, st, it, qe, rt, bt);
                if (ut === void 0) continue;
                return ut;
              }
            }
            return null;
          }
          if (Me === null) return null;
          throw te(He, Me, De, qe, st);
        }
        function Se(De, Me, Qe) {
          if (f().noDeprecation) return;
          const He = (0, s().fileURLToPath)(Me);
          ge.has(He + "|" + De) || (ge.add(He + "|" + De), f().emitWarning(`Use of deprecated trailing slash pattern mapping "${De}" in the "exports" field module resolution of the package at ${He}${Qe ? ` imported from ${(0, s().fileURLToPath)(Qe)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function Pe(De, Me, Qe, He, st) {
          let it = Qe.exports;
          if (function(Je, mt, ut) {
            if (typeof Je == "string" || Array.isArray(Je)) return !0;
            if (typeof Je != "object" || Je === null) return !1;
            const Et = Object.getOwnPropertyNames(Je);
            let Tt = !1, St = 0, Vt = -1;
            for (; ++Vt < Et.length; ) {
              const Kt = Et[Vt], xt = Kt === "" || Kt[0] !== ".";
              if (St++ == 0) Tt = xt;
              else if (Tt !== xt) throw new X((0, s().fileURLToPath)(mt), ut, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return Tt;
          }(it, De, He) && (it = { ".": it }), ee.call(it, Me) && !Me.includes("*") && !Me.endsWith("/")) {
            const Je = Ee(De, it[Me], "", Me, He, !1, !1, !1, st);
            if (Je == null) throw ue(Me, De, He);
            return Je;
          }
          let qe = "", rt = "";
          const bt = Object.getOwnPropertyNames(it);
          let dt = -1;
          for (; ++dt < bt.length; ) {
            const Je = bt[dt], mt = Je.indexOf("*");
            if (mt !== -1 && Me.startsWith(Je.slice(0, mt))) {
              Me.endsWith("/") && Se(Me, De, He);
              const ut = Je.slice(mt + 1);
              Me.length >= Je.length && Me.endsWith(ut) && Ve(qe, Je) === 1 && Je.lastIndexOf("*") === mt && (qe = Je, rt = Me.slice(mt, Me.length - ut.length));
            }
          }
          if (qe) {
            const Je = Ee(De, it[qe], rt, qe, He, !0, !1, Me.endsWith("/"), st);
            if (Je == null) throw ue(Me, De, He);
            return Je;
          }
          throw ue(Me, De, He);
        }
        function Ve(De, Me) {
          const Qe = De.indexOf("*"), He = Me.indexOf("*"), st = Qe === -1 ? De.length : Qe + 1, it = He === -1 ? Me.length : He + 1;
          return st > it ? -1 : it > st || Qe === -1 ? 1 : He === -1 || De.length > Me.length ? -1 : Me.length > De.length ? 1 : 0;
        }
        function Xe(De, Me, Qe) {
          if (De === "#" || De.startsWith("#/") || De.endsWith("/"))
            throw new F(De, "is not a valid internal imports specifier name", (0, s().fileURLToPath)(Me));
          let He;
          const st = R(Me);
          if (st.exists) {
            He = (0, s().pathToFileURL)(st.pjsonPath);
            const it = st.imports;
            if (it) if (ee.call(it, De) && !De.includes("*")) {
              const qe = Ee(He, it[De], "", De, Me, !1, !0, !1, Qe);
              if (qe != null) return qe;
            } else {
              let qe = "", rt = "";
              const bt = Object.getOwnPropertyNames(it);
              let dt = -1;
              for (; ++dt < bt.length; ) {
                const Je = bt[dt], mt = Je.indexOf("*");
                if (mt !== -1 && De.startsWith(Je.slice(0, -1))) {
                  const ut = Je.slice(mt + 1);
                  De.length >= Je.length && De.endsWith(ut) && Ve(qe, Je) === 1 && Je.lastIndexOf("*") === mt && (qe = Je, rt = De.slice(mt, De.length - ut.length));
                }
              }
              if (qe) {
                const Je = Ee(He, it[qe], rt, qe, Me, !0, !0, !1, Qe);
                if (Je != null) return Je;
              }
            }
          }
          throw function(it, qe, rt) {
            return new fe(it, qe && (0, s().fileURLToPath)(new (s()).URL(".", qe)), (0, s().fileURLToPath)(rt));
          }(De, He, Me);
        }
        function Ye(De, Me, Qe) {
          if (y().builtinModules.includes(De)) return new (s()).URL("node:" + De);
          const { packageName: He, packageSubpath: st, isScoped: it } = function(Je, mt) {
            let ut = Je.indexOf("/"), Et = !0, Tt = !1;
            Je[0] === "@" && (Tt = !0, ut === -1 || Je.length === 0 ? Et = !1 : ut = Je.indexOf("/", ut + 1));
            const St = ut === -1 ? Je : Je.slice(0, ut);
            if (me.exec(St) !== null && (Et = !1), !Et) throw new F(Je, "is not a valid package name", (0, s().fileURLToPath)(mt));
            return { packageName: St, packageSubpath: "." + (ut === -1 ? "" : Je.slice(ut)), isScoped: Tt };
          }(De, Me), qe = R(Me);
          if (qe.exists) {
            const Je = (0, s().pathToFileURL)(qe.pjsonPath);
            if (qe.name === He && qe.exports !== void 0 && qe.exports !== null) return Pe(Je, st, qe, Me, Qe);
          }
          let rt, bt = new (s()).URL("./node_modules/" + He + "/package.json", Me), dt = (0, s().fileURLToPath)(bt);
          do {
            const Je = Oe(dt.slice(0, -13));
            if (!Je || !Je.isDirectory()) {
              rt = dt, bt = new (s()).URL((it ? "../../../../node_modules/" : "../../../node_modules/") + He + "/package.json", bt), dt = (0, s().fileURLToPath)(bt);
              continue;
            }
            const mt = C(dt, { base: Me, specifier: De });
            return mt.exports !== void 0 && mt.exports !== null ? Pe(bt, st, mt, Me, Qe) : st === "." ? Fe(bt, mt, Me) : new (s()).URL(st, bt);
          } while (dt.length !== rt.length);
          throw new ie(He, (0, s().fileURLToPath)(Me), !1);
        }
        function We(De) {
          return De !== "" && (De[0] === "/" || function(Me) {
            return Me[0] === "." && (Me.length === 1 || Me[1] === "/" || Me[1] === "." && (Me.length === 2 || Me[2] === "/"));
          }(De));
        }
        function et(De, Me, Qe, He) {
          const st = Me.protocol, it = st === "data:" || st === "http:" || st === "https:";
          let qe;
          if (We(De)) try {
            qe = new (s()).URL(De, Me);
          } catch (rt) {
            const bt = new ce(De, Me);
            throw bt.cause = rt, bt;
          }
          else if (st === "file:" && De[0] === "#") qe = Xe(De, Me, Qe);
          else try {
            qe = new (s()).URL(De);
          } catch (rt) {
            if (it && !y().builtinModules.includes(De)) {
              const bt = new ce(De, Me);
              throw bt.cause = rt, bt;
            }
            qe = Ye(De, Me, Qe);
          }
          return i()(qe !== void 0, "expected to be defined"), qe.protocol !== "file:" ? qe : function(rt, bt, dt) {
            if (we.exec(rt.pathname) !== null) throw new F(rt.pathname, 'must not include encoded "/" or "\\" characters', (0, s().fileURLToPath)(bt));
            let Je;
            try {
              Je = (0, s().fileURLToPath)(rt);
            } catch (ut) {
              const Et = ut;
              throw Object.defineProperty(Et, "input", { value: String(rt) }), Object.defineProperty(Et, "module", { value: String(bt) }), Et;
            }
            const mt = Oe(Je.endsWith("/") ? Je.slice(-1) : Je);
            if (mt && mt.isDirectory()) {
              const ut = new Ae(Je, (0, s().fileURLToPath)(bt));
              throw ut.url = String(rt), ut;
            }
            if (!mt || !mt.isFile()) {
              const ut = new ie(Je || rt.pathname, bt && (0, s().fileURLToPath)(bt), !0);
              throw ut.url = String(rt), ut;
            }
            if (!dt) {
              const ut = (0, c().realpathSync)(Je), { search: Et, hash: Tt } = rt;
              (rt = (0, s().pathToFileURL)(ut + (Je.endsWith(o().sep) ? "/" : ""))).search = Et, rt.hash = Tt;
            }
            return rt;
          }(qe, Me, He);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/buffer.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, n.default = class {
          constructor(u, i) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = u, this._indentChar = i;
            for (let c = 0; c < 64; c++) this._fastIndentations.push(i.repeat(c));
            this._allocQueue();
          }
          _allocQueue() {
            const u = this._queue;
            for (let i = 0; i < 16; i++) u.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
          }
          _pushQueue(u, i, c, f, s) {
            const o = this._queueCursor;
            o === this._queue.length && this._allocQueue();
            const y = this._queue[o];
            y.char = u, y.repeat = i, y.line = c, y.column = f, y.filename = s, this._queueCursor++;
          }
          _popQueue() {
            if (this._queueCursor === 0) throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
          }
          get() {
            this._flush();
            const u = this._map, i = { code: (this._buf + this._str).trimRight(), decodedMap: u == null ? void 0 : u.getDecoded(), get __mergedMap() {
              return this.map;
            }, get map() {
              const c = u ? u.get() : null;
              return i.map = c, c;
            }, set map(c) {
              Object.defineProperty(i, "map", { value: c, writable: !0 });
            }, get rawMappings() {
              const c = u == null ? void 0 : u.getRawMappings();
              return i.rawMappings = c, c;
            }, set rawMappings(c) {
              Object.defineProperty(i, "rawMappings", { value: c, writable: !0 });
            } };
            return i;
          }
          append(u, i) {
            this._flush(), this._append(u, this._sourcePosition, i);
          }
          appendChar(u) {
            this._flush(), this._appendChar(u, 1, this._sourcePosition);
          }
          queue(u) {
            if (u === 10) for (; this._queueCursor !== 0; ) {
              const c = this._queue[this._queueCursor - 1].char;
              if (c !== 32 && c !== 9) break;
              this._queueCursor--;
            }
            const i = this._sourcePosition;
            this._pushQueue(u, 1, i.line, i.column, i.filename);
          }
          queueIndentation(u) {
            u !== 0 && this._pushQueue(-1, u, void 0, void 0, void 0);
          }
          _flush() {
            const u = this._queueCursor, i = this._queue;
            for (let c = 0; c < u; c++) {
              const f = i[c];
              this._appendChar(f.char, f.repeat, f);
            }
            this._queueCursor = 0;
          }
          _appendChar(u, i, c) {
            if (this._last = u, u === -1) {
              const f = this._fastIndentations[i];
              this._str += f !== void 0 ? f : i > 1 ? this._indentChar.repeat(i) : this._indentChar;
            } else this._str += i > 1 ? String.fromCharCode(u).repeat(i) : String.fromCharCode(u);
            u !== 10 ? (this._mark(c.line, c.column, c.identifierName, c.identifierNamePos, c.filename), this._position.column += i) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (c.identifierName = void 0, c.identifierNamePos = void 0);
          }
          _append(u, i, c) {
            const f = u.length, s = this._position;
            if (this._last = u.charCodeAt(f - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = u, this._appendCount = 0) : this._str += u, !c && !this._map) return void (s.column += f);
            const { column: o, identifierName: y, identifierNamePos: m, filename: g } = i;
            let b = i.line;
            y == null && m == null || !this._canMarkIdName || (i.identifierName = void 0, i.identifierNamePos = void 0);
            let v = u.indexOf(`
`), T = 0;
            for (v !== 0 && this._mark(b, o, y, m, g); v !== -1; ) s.line++, s.column = 0, T = v + 1, T < f && b !== void 0 && this._mark(++b, 0, null, null, g), v = u.indexOf(`
`, T);
            s.column += f - T;
          }
          _mark(u, i, c, f, s) {
            var o;
            (o = this._map) == null || o.mark(this._position, u, i, c, f, s);
          }
          removeTrailingNewline() {
            const u = this._queueCursor;
            u !== 0 && this._queue[u - 1].char === 10 && this._queueCursor--;
          }
          removeLastSemicolon() {
            const u = this._queueCursor;
            u !== 0 && this._queue[u - 1].char === 59 && this._queueCursor--;
          }
          getLastChar() {
            const u = this._queueCursor;
            return u !== 0 ? this._queue[u - 1].char : this._last;
          }
          getNewlineCount() {
            const u = this._queueCursor;
            let i = 0;
            if (u === 0) return this._last === 10 ? 1 : 0;
            for (let c = u - 1; c >= 0 && this._queue[c].char === 10; c--) i++;
            return i === u && this._last === 10 ? i + 1 : i;
          }
          endsWithCharAndNewline() {
            const u = this._queue, i = this._queueCursor;
            if (i !== 0)
              return u[i - 1].char !== 10 ? void 0 : i > 1 ? u[i - 2].char : this._last;
          }
          hasContent() {
            return this._queueCursor !== 0 || !!this._last;
          }
          exactSource(u, i) {
            if (!this._map) return void i();
            this.source("start", u);
            const c = u.identifierName, f = this._sourcePosition;
            c && (this._canMarkIdName = !1, f.identifierName = c), i(), c && (this._canMarkIdName = !0, f.identifierName = void 0, f.identifierNamePos = void 0), this.source("end", u);
          }
          source(u, i) {
            this._map && this._normalizePosition(u, i, 0);
          }
          sourceWithOffset(u, i, c) {
            this._map && this._normalizePosition(u, i, c);
          }
          withSource(u, i, c) {
            this._map && this.source(u, i), c();
          }
          _normalizePosition(u, i, c) {
            const f = i[u], s = this._sourcePosition;
            f && (s.line = f.line, s.column = Math.max(f.column + c, 0), s.filename = i.filename);
          }
          getCurrentColumn() {
            const u = this._queue, i = this._queueCursor;
            let c = -1, f = 0;
            for (let s = 0; s < i; s++) {
              const o = u[s];
              o.char === 10 && (c = f), f += o.repeat;
            }
            return c === -1 ? this._position.column + f : f - 1 - c;
          }
          getCurrentLine() {
            let u = 0;
            const i = this._queue;
            for (let c = 0; c < this._queueCursor; c++) i[c].char === 10 && u++;
            return this._position.line + u;
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/base.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BlockStatement = function(c) {
          var f;
          this.tokenChar(123);
          const s = (f = c.directives) == null ? void 0 : f.length;
          if (s) {
            var o;
            const y = c.body.length ? 2 : 1;
            this.printSequence(c.directives, c, { indent: !0, trailingCommentsLineOffset: y }), (o = c.directives[s - 1].trailingComments) != null && o.length || this.newline(y);
          }
          this.printSequence(c.body, c, { indent: !0 }), this.rightBrace(c);
        }, n.Directive = function(c) {
          this.print(c.value, c), this.semicolon();
        }, n.DirectiveLiteral = function(c) {
          const f = this.getPossibleRaw(c);
          if (!this.format.minified && f !== void 0) return void this.token(f);
          const { value: s } = c;
          if (i.test(s)) {
            if (u.test(s)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${s}'`);
          } else this.token(`"${s}"`);
        }, n.File = function(c) {
          c.program && this.print(c.program.interpreter, c), this.print(c.program, c);
        }, n.InterpreterDirective = function(c) {
          this.token(`#!${c.value}`), this.newline(1, !0);
        }, n.Placeholder = function(c) {
          this.token("%%"), this.print(c.name), this.token("%%"), c.expectedNode === "Statement" && this.semicolon();
        }, n.Program = function(c) {
          var f;
          this.noIndentInnerCommentsHere(), this.printInnerComments();
          const s = (f = c.directives) == null ? void 0 : f.length;
          if (s) {
            var o;
            const y = c.body.length ? 2 : 1;
            this.printSequence(c.directives, c, { trailingCommentsLineOffset: y }), (o = c.directives[s - 1].trailingComments) != null && o.length || this.newline(y);
          }
          this.printSequence(c.body, c);
        };
        const u = /(?:^|[^\\])(?:\\\\)*'/, i = /(?:^|[^\\])(?:\\\\)*"/;
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/classes.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ClassAccessorProperty = function(s) {
          var o;
          this.printJoin(s.decorators, s);
          const y = (o = s.key.loc) == null || (o = o.end) == null ? void 0 : o.line;
          y && this.catchUp(y), this.tsPrintClassMemberModifiers(s), this.word("accessor", !0), this.space(), s.computed ? (this.tokenChar(91), this.print(s.key, s), this.tokenChar(93)) : (this._variance(s), this.print(s.key, s)), s.optional && this.tokenChar(63), s.definite && this.tokenChar(33), this.print(s.typeAnnotation, s), s.value && (this.space(), this.tokenChar(61), this.space(), this.print(s.value, s)), this.semicolon();
        }, n.ClassBody = function(s) {
          this.tokenChar(123), s.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(s.body, s, { indent: !0 }), this.endsWith(10) || this.newline(), this.rightBrace(s));
        }, n.ClassExpression = n.ClassDeclaration = function(s, o) {
          (c(o) || f(o)) && this._shouldPrintDecoratorsBeforeExport(o) || this.printJoin(s.decorators, s), s.declare && (this.word("declare"), this.space()), s.abstract && (this.word("abstract"), this.space()), this.word("class"), s.id && (this.space(), this.print(s.id, s)), this.print(s.typeParameters, s), s.superClass && (this.space(), this.word("extends"), this.space(), this.print(s.superClass, s), this.print(s.superTypeParameters, s)), s.implements && (this.space(), this.word("implements"), this.space(), this.printList(s.implements, s)), this.space(), this.print(s.body, s);
        }, n.ClassMethod = function(s) {
          this._classMethodHead(s), this.space(), this.print(s.body, s);
        }, n.ClassPrivateMethod = function(s) {
          this._classMethodHead(s), this.space(), this.print(s.body, s);
        }, n.ClassPrivateProperty = function(s) {
          this.printJoin(s.decorators, s), s.static && (this.word("static"), this.space()), this.print(s.key, s), this.print(s.typeAnnotation, s), s.value && (this.space(), this.tokenChar(61), this.space(), this.print(s.value, s)), this.semicolon();
        }, n.ClassProperty = function(s) {
          var o;
          this.printJoin(s.decorators, s);
          const y = (o = s.key.loc) == null || (o = o.end) == null ? void 0 : o.line;
          y && this.catchUp(y), this.tsPrintClassMemberModifiers(s), s.computed ? (this.tokenChar(91), this.print(s.key, s), this.tokenChar(93)) : (this._variance(s), this.print(s.key, s)), s.optional && this.tokenChar(63), s.definite && this.tokenChar(33), this.print(s.typeAnnotation, s), s.value && (this.space(), this.tokenChar(61), this.space(), this.print(s.value, s)), this.semicolon();
        }, n.StaticBlock = function(s) {
          this.word("static"), this.space(), this.tokenChar(123), s.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(s.body, s, { indent: !0 }), this.rightBrace(s));
        }, n._classMethodHead = function(s) {
          var o;
          this.printJoin(s.decorators, s);
          const y = (o = s.key.loc) == null || (o = o.end) == null ? void 0 : o.line;
          y && this.catchUp(y), this.tsPrintClassMemberModifiers(s), this._methodHead(s);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isExportDefaultDeclaration: c, isExportNamedDeclaration: f } = i;
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/expressions.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.LogicalExpression = n.BinaryExpression = n.AssignmentExpression = function(g, b) {
          const v = this.inForStatementInitCounter && g.operator === "in" && !c.needsParens(g, b);
          v && this.tokenChar(40), this.print(g.left, g), this.space(), g.operator === "in" || g.operator === "instanceof" ? this.word(g.operator) : this.token(g.operator), this.space(), this.print(g.right, g), v && this.tokenChar(41);
        }, n.AssignmentPattern = function(g) {
          this.print(g.left, g), g.left.optional && this.tokenChar(63), this.print(g.left.typeAnnotation, g), this.space(), this.tokenChar(61), this.space(), this.print(g.right, g);
        }, n.AwaitExpression = function(g) {
          this.word("await"), g.argument && (this.space(), this.printTerminatorless(g.argument, g, !1));
        }, n.BindExpression = function(g) {
          this.print(g.object, g), this.token("::"), this.print(g.callee, g);
        }, n.CallExpression = function(g) {
          this.print(g.callee, g), this.print(g.typeArguments, g), this.print(g.typeParameters, g), this.tokenChar(40), this.printList(g.arguments, g), this.rightParens(g);
        }, n.ConditionalExpression = function(g) {
          this.print(g.test, g), this.space(), this.tokenChar(63), this.space(), this.print(g.consequent, g), this.space(), this.tokenChar(58), this.space(), this.print(g.alternate, g);
        }, n.Decorator = function(g) {
          this.tokenChar(64);
          const { expression: b } = g;
          (function(v) {
            return v.type === "ParenthesizedExpression" ? !1 : !m(v.type === "CallExpression" ? v.callee : v);
          })(b) ? (this.tokenChar(40), this.print(b, g), this.tokenChar(41)) : this.print(b, g), this.newline();
        }, n.DoExpression = function(g) {
          g.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(g.body, g);
        }, n.EmptyStatement = function() {
          this.semicolon(!0);
        }, n.ExpressionStatement = function(g) {
          this.print(g.expression, g), this.semicolon();
        }, n.Import = function() {
          this.word("import");
        }, n.MemberExpression = function(g) {
          if (this.print(g.object, g), !g.computed && o(g.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          let b = g.computed;
          s(g.property) && typeof g.property.value == "number" && (b = !0), b ? (this.tokenChar(91), this.print(g.property, g), this.tokenChar(93)) : (this.tokenChar(46), this.print(g.property, g));
        }, n.MetaProperty = function(g) {
          this.print(g.meta, g), this.tokenChar(46), this.print(g.property, g);
        }, n.ModuleExpression = function(g) {
          this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
          const { body: b } = g;
          (b.body.length || b.directives.length) && this.newline(), this.print(b, g), this.dedent(), this.rightBrace(g);
        }, n.NewExpression = function(g, b) {
          this.word("new"), this.space(), this.print(g.callee, g), !(this.format.minified && g.arguments.length === 0 && !g.optional && !f(b, { callee: g }) && !o(b) && !y(b)) && (this.print(g.typeArguments, g), this.print(g.typeParameters, g), g.optional && this.token("?."), this.tokenChar(40), this.printList(g.arguments, g), this.rightParens(g));
        }, n.OptionalCallExpression = function(g) {
          this.print(g.callee, g), this.print(g.typeParameters, g), g.optional && this.token("?."), this.print(g.typeArguments, g), this.tokenChar(40), this.printList(g.arguments, g), this.rightParens(g);
        }, n.OptionalMemberExpression = function(g) {
          let { computed: b } = g;
          const { optional: v, property: T } = g;
          if (this.print(g.object, g), !b && o(T)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          s(T) && typeof T.value == "number" && (b = !0), v && this.token("?."), b ? (this.tokenChar(91), this.print(T, g), this.tokenChar(93)) : (v || this.tokenChar(46), this.print(T, g));
        }, n.ParenthesizedExpression = function(g) {
          this.tokenChar(40), this.print(g.expression, g), this.rightParens(g);
        }, n.PrivateName = function(g) {
          this.tokenChar(35), this.print(g.id, g);
        }, n.SequenceExpression = function(g) {
          this.printList(g.expressions, g);
        }, n.Super = function() {
          this.word("super");
        }, n.ThisExpression = function() {
          this.word("this");
        }, n.UnaryExpression = function(g) {
          const { operator: b } = g;
          b === "void" || b === "delete" || b === "typeof" || b === "throw" ? (this.word(b), this.space()) : this.token(b), this.print(g.argument, g);
        }, n.UpdateExpression = function(g) {
          g.prefix ? (this.token(g.operator), this.print(g.argument, g)) : (this.printTerminatorless(g.argument, g, !0), this.token(g.operator));
        }, n.V8IntrinsicIdentifier = function(g) {
          this.tokenChar(37), this.word(g.name);
        }, n.YieldExpression = function(g) {
          this.word("yield", !0), g.delegate ? (this.tokenChar(42), g.argument && (this.space(), this.print(g.argument, g))) : g.argument && (this.space(), this.printTerminatorless(g.argument, g, !1));
        }, n._shouldPrintDecoratorsBeforeExport = function(g) {
          return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof g.start == "number" && g.start === g.declaration.start;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/index.js");
        const { isCallExpression: f, isLiteral: s, isMemberExpression: o, isNewExpression: y } = i;
        function m(g) {
          switch (g.type) {
            case "Identifier":
              return !0;
            case "MemberExpression":
              return !g.computed && g.property.type === "Identifier" && m(g.object);
            default:
              return !1;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/flow.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.AnyTypeAnnotation = function() {
          this.word("any");
        }, n.ArrayTypeAnnotation = function(E) {
          this.print(E.elementType, E, !0), this.tokenChar(91), this.tokenChar(93);
        }, n.BooleanLiteralTypeAnnotation = function(E) {
          this.word(E.value ? "true" : "false");
        }, n.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, n.DeclareClass = function(E, O) {
          s(O) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(E);
        }, n.DeclareExportAllDeclaration = function(E) {
          this.word("declare"), this.space(), c.ExportAllDeclaration.call(this, E);
        }, n.DeclareExportDeclaration = function(E) {
          this.word("declare"), this.space(), this.word("export"), this.space(), E.default && (this.word("default"), this.space()), b.call(this, E);
        }, n.DeclareFunction = function(E, O) {
          s(O) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(E.id, E), this.print(E.id.typeAnnotation.typeAnnotation, E), E.predicate && (this.space(), this.print(E.predicate, E)), this.semicolon();
        }, n.DeclareInterface = function(E) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(E);
        }, n.DeclareModule = function(E) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(E.id, E), this.space(), this.print(E.body, E);
        }, n.DeclareModuleExports = function(E) {
          this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(E.typeAnnotation, E);
        }, n.DeclareOpaqueType = function(E, O) {
          s(O) || (this.word("declare"), this.space()), this.OpaqueType(E);
        }, n.DeclareTypeAlias = function(E) {
          this.word("declare"), this.space(), this.TypeAlias(E);
        }, n.DeclareVariable = function(E, O) {
          s(O) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(E.id, E), this.print(E.id.typeAnnotation, E), this.semicolon();
        }, n.DeclaredPredicate = function(E) {
          this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(E.value, E), this.tokenChar(41);
        }, n.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, n.EnumBooleanBody = function(E) {
          const { explicitType: O } = E;
          y(this, "boolean", O), m(this, E);
        }, n.EnumBooleanMember = function(E) {
          g(this, E);
        }, n.EnumDeclaration = function(E) {
          const { id: O, body: D } = E;
          this.word("enum"), this.space(), this.print(O, E), this.print(D, E);
        }, n.EnumDefaultedMember = function(E) {
          const { id: O } = E;
          this.print(O, E), this.tokenChar(44);
        }, n.EnumNumberBody = function(E) {
          const { explicitType: O } = E;
          y(this, "number", O), m(this, E);
        }, n.EnumNumberMember = function(E) {
          g(this, E);
        }, n.EnumStringBody = function(E) {
          const { explicitType: O } = E;
          y(this, "string", O), m(this, E);
        }, n.EnumStringMember = function(E) {
          g(this, E);
        }, n.EnumSymbolBody = function(E) {
          y(this, "symbol", !0), m(this, E);
        }, n.ExistsTypeAnnotation = function() {
          this.tokenChar(42);
        }, n.FunctionTypeAnnotation = function(E, O) {
          this.print(E.typeParameters, E), this.tokenChar(40), E.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(E.this.typeAnnotation, E), (E.params.length || E.rest) && (this.tokenChar(44), this.space())), this.printList(E.params, E), E.rest && (E.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(E.rest, E)), this.tokenChar(41);
          const D = O == null ? void 0 : O.type;
          D != null && (D === "ObjectTypeCallProperty" || D === "ObjectTypeInternalSlot" || D === "DeclareFunction" || D === "ObjectTypeProperty" && O.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(E.returnType, E);
        }, n.FunctionTypeParam = function(E) {
          this.print(E.name, E), E.optional && this.tokenChar(63), E.name && (this.tokenChar(58), this.space()), this.print(E.typeAnnotation, E);
        }, n.IndexedAccessType = function(E) {
          this.print(E.objectType, E, !0), this.tokenChar(91), this.print(E.indexType, E), this.tokenChar(93);
        }, n.InferredPredicate = function() {
          this.tokenChar(37), this.word("checks");
        }, n.InterfaceDeclaration = function(E) {
          this.word("interface"), this.space(), this._interfaceish(E);
        }, n.GenericTypeAnnotation = n.ClassImplements = n.InterfaceExtends = function(E) {
          this.print(E.id, E), this.print(E.typeParameters, E, !0);
        }, n.InterfaceTypeAnnotation = function(E) {
          var O;
          this.word("interface"), (O = E.extends) != null && O.length && (this.space(), this.word("extends"), this.space(), this.printList(E.extends, E)), this.space(), this.print(E.body, E);
        }, n.IntersectionTypeAnnotation = function(E) {
          this.printJoin(E.types, E, { separator: v });
        }, n.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, n.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, n.NullableTypeAnnotation = function(E) {
          this.tokenChar(63), this.print(E.typeAnnotation, E);
        }, Object.defineProperty(n, "NumberLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return f.NumericLiteral;
        } }), n.NumberTypeAnnotation = function() {
          this.word("number");
        }, n.ObjectTypeAnnotation = function(E) {
          E.exact ? this.token("{|") : this.tokenChar(123);
          const O = [...E.properties, ...E.callProperties || [], ...E.indexers || [], ...E.internalSlots || []];
          O.length && (this.newline(), this.space(), this.printJoin(O, E, { addNewlines(D) {
            if (D && !O[0]) return 1;
          }, indent: !0, statement: !0, iterator: () => {
            (O.length !== 1 || E.inexact) && (this.tokenChar(44), this.space());
          } }), this.space()), E.inexact && (this.indent(), this.token("..."), O.length && this.newline(), this.dedent()), E.exact ? this.token("|}") : this.tokenChar(125);
        }, n.ObjectTypeCallProperty = function(E) {
          E.static && (this.word("static"), this.space()), this.print(E.value, E);
        }, n.ObjectTypeIndexer = function(E) {
          E.static && (this.word("static"), this.space()), this._variance(E), this.tokenChar(91), E.id && (this.print(E.id, E), this.tokenChar(58), this.space()), this.print(E.key, E), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(E.value, E);
        }, n.ObjectTypeInternalSlot = function(E) {
          E.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(E.id, E), this.tokenChar(93), this.tokenChar(93), E.optional && this.tokenChar(63), E.method || (this.tokenChar(58), this.space()), this.print(E.value, E);
        }, n.ObjectTypeProperty = function(E) {
          E.proto && (this.word("proto"), this.space()), E.static && (this.word("static"), this.space()), E.kind !== "get" && E.kind !== "set" || (this.word(E.kind), this.space()), this._variance(E), this.print(E.key, E), E.optional && this.tokenChar(63), E.method || (this.tokenChar(58), this.space()), this.print(E.value, E);
        }, n.ObjectTypeSpreadProperty = function(E) {
          this.token("..."), this.print(E.argument, E);
        }, n.OpaqueType = function(E) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(E.id, E), this.print(E.typeParameters, E), E.supertype && (this.tokenChar(58), this.space(), this.print(E.supertype, E)), E.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(E.impltype, E)), this.semicolon();
        }, n.OptionalIndexedAccessType = function(E) {
          this.print(E.objectType, E), E.optional && this.token("?."), this.tokenChar(91), this.print(E.indexType, E), this.tokenChar(93);
        }, n.QualifiedTypeIdentifier = function(E) {
          this.print(E.qualification, E), this.tokenChar(46), this.print(E.id, E);
        }, Object.defineProperty(n, "StringLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return f.StringLiteral;
        } }), n.StringTypeAnnotation = function() {
          this.word("string");
        }, n.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, n.ThisTypeAnnotation = function() {
          this.word("this");
        }, n.TupleTypeAnnotation = function(E) {
          this.tokenChar(91), this.printList(E.types, E), this.tokenChar(93);
        }, n.TypeAlias = function(E) {
          this.word("type"), this.space(), this.print(E.id, E), this.print(E.typeParameters, E), this.space(), this.tokenChar(61), this.space(), this.print(E.right, E), this.semicolon();
        }, n.TypeAnnotation = function(E) {
          this.tokenChar(58), this.space(), E.optional && this.tokenChar(63), this.print(E.typeAnnotation, E);
        }, n.TypeCastExpression = function(E) {
          this.tokenChar(40), this.print(E.expression, E), this.print(E.typeAnnotation, E), this.tokenChar(41);
        }, n.TypeParameter = function(E) {
          this._variance(E), this.word(E.name), E.bound && this.print(E.bound, E), E.default && (this.space(), this.tokenChar(61), this.space(), this.print(E.default, E));
        }, n.TypeParameterDeclaration = n.TypeParameterInstantiation = function(E) {
          this.tokenChar(60), this.printList(E.params, E, {}), this.tokenChar(62);
        }, n.TypeofTypeAnnotation = function(E) {
          this.word("typeof"), this.space(), this.print(E.argument, E);
        }, n.UnionTypeAnnotation = function(E) {
          this.printJoin(E.types, E, { separator: T });
        }, n.Variance = function(E) {
          E.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
        }, n.VoidTypeAnnotation = function() {
          this.word("void");
        }, n._interfaceish = function(E) {
          var O;
          if (this.print(E.id, E), this.print(E.typeParameters, E), (O = E.extends) != null && O.length && (this.space(), this.word("extends"), this.space(), this.printList(E.extends, E)), E.type === "DeclareClass") {
            var D, $;
            (D = E.mixins) != null && D.length && (this.space(), this.word("mixins"), this.space(), this.printList(E.mixins, E)), ($ = E.implements) != null && $.length && (this.space(), this.word("implements"), this.space(), this.printList(E.implements, E));
          }
          this.space(), this.print(E.body, E);
        }, n._variance = function(E) {
          var O;
          const D = (O = E.variance) == null ? void 0 : O.kind;
          D != null && (D === "plus" ? this.tokenChar(43) : D === "minus" && this.tokenChar(45));
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/modules.js"), f = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/types.js");
        const { isDeclareExportDeclaration: s, isStatement: o } = i;
        function y(E, O, D) {
          D && (E.space(), E.word("of"), E.space(), E.word(O)), E.space();
        }
        function m(E, O) {
          const { members: D } = O;
          E.token("{"), E.indent(), E.newline();
          for (const $ of D) E.print($, O), E.newline();
          O.hasUnknownMembers && (E.token("..."), E.newline()), E.dedent(), E.token("}");
        }
        function g(E, O) {
          const { id: D, init: $ } = O;
          E.print(D, O), E.space(), E.token("="), E.space(), E.print($, O), E.token(",");
        }
        function b(E) {
          if (E.declaration) {
            const O = E.declaration;
            this.print(O, E), o(O) || this.semicolon();
          } else this.tokenChar(123), E.specifiers.length && (this.space(), this.printList(E.specifiers, E), this.space()), this.tokenChar(125), E.source && (this.space(), this.word("from"), this.space(), this.print(E.source, E)), this.semicolon();
        }
        function v() {
          this.space(), this.tokenChar(38), this.space();
        }
        function T() {
          this.space(), this.tokenChar(124), this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 });
        var i = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/template-literals.js");
        Object.keys(i).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === i[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return i[E];
          } }));
        });
        var c = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/expressions.js");
        Object.keys(c).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === c[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return c[E];
          } }));
        });
        var f = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/statements.js");
        Object.keys(f).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === f[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return f[E];
          } }));
        });
        var s = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/classes.js");
        Object.keys(s).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === s[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return s[E];
          } }));
        });
        var o = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/methods.js");
        Object.keys(o).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === o[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return o[E];
          } }));
        });
        var y = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/modules.js");
        Object.keys(y).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === y[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return y[E];
          } }));
        });
        var m = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/types.js");
        Object.keys(m).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === m[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return m[E];
          } }));
        });
        var g = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/flow.js");
        Object.keys(g).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === g[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return g[E];
          } }));
        });
        var b = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/base.js");
        Object.keys(b).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === b[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return b[E];
          } }));
        });
        var v = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/jsx.js");
        Object.keys(v).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === v[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return v[E];
          } }));
        });
        var T = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/typescript.js");
        Object.keys(T).forEach(function(E) {
          E !== "default" && E !== "__esModule" && (E in n && n[E] === T[E] || Object.defineProperty(n, E, { enumerable: !0, get: function() {
            return T[E];
          } }));
        });
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/jsx.js": (h, n) => {
        function u() {
          this.space();
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.JSXAttribute = function(i) {
          this.print(i.name, i), i.value && (this.tokenChar(61), this.print(i.value, i));
        }, n.JSXClosingElement = function(i) {
          this.token("</"), this.print(i.name, i), this.tokenChar(62);
        }, n.JSXClosingFragment = function() {
          this.token("</"), this.tokenChar(62);
        }, n.JSXElement = function(i) {
          const c = i.openingElement;
          if (this.print(c, i), !c.selfClosing) {
            this.indent();
            for (const f of i.children) this.print(f, i);
            this.dedent(), this.print(i.closingElement, i);
          }
        }, n.JSXEmptyExpression = function() {
          this.printInnerComments();
        }, n.JSXExpressionContainer = function(i) {
          this.tokenChar(123), this.print(i.expression, i), this.tokenChar(125);
        }, n.JSXFragment = function(i) {
          this.print(i.openingFragment, i), this.indent();
          for (const c of i.children) this.print(c, i);
          this.dedent(), this.print(i.closingFragment, i);
        }, n.JSXIdentifier = function(i) {
          this.word(i.name);
        }, n.JSXMemberExpression = function(i) {
          this.print(i.object, i), this.tokenChar(46), this.print(i.property, i);
        }, n.JSXNamespacedName = function(i) {
          this.print(i.namespace, i), this.tokenChar(58), this.print(i.name, i);
        }, n.JSXOpeningElement = function(i) {
          this.tokenChar(60), this.print(i.name, i), this.print(i.typeParameters, i), i.attributes.length > 0 && (this.space(), this.printJoin(i.attributes, i, { separator: u })), i.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
        }, n.JSXOpeningFragment = function() {
          this.tokenChar(60), this.tokenChar(62);
        }, n.JSXSpreadAttribute = function(i) {
          this.tokenChar(123), this.token("..."), this.print(i.argument, i), this.tokenChar(125);
        }, n.JSXSpreadChild = function(i) {
          this.tokenChar(123), this.token("..."), this.print(i.expression, i), this.tokenChar(125);
        }, n.JSXText = function(i) {
          const c = this.getPossibleRaw(i);
          c !== void 0 ? this.token(c, !0) : this.token(i.value, !0);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/methods.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ArrowFunctionExpression = function(s, o) {
          s.async && (this.word("async", !0), this.space());
          let y;
          this.format.retainLines || s.params.length !== 1 || !c(y = s.params[0]) || function(m, g) {
            var b, v;
            return !!(m.typeParameters || m.returnType || m.predicate || g.typeAnnotation || g.optional || (b = g.leadingComments) != null && b.length || (v = g.trailingComments) != null && v.length);
          }(s, y) ? this._params(s, void 0, o) : this.print(y, s, !0), this._predicate(s, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(s.body, s);
        }, n.FunctionDeclaration = n.FunctionExpression = function(s, o) {
          this._functionHead(s, o), this.space(), this.print(s.body, s);
        }, n._functionHead = function(s, o) {
          s.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), s.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), s.id && this.print(s.id, s), this._params(s, s.id, o), s.type !== "TSDeclareFunction" && this._predicate(s);
        }, n._methodHead = function(s) {
          const o = s.kind, y = s.key;
          o !== "get" && o !== "set" || (this.word(o), this.space()), s.async && (this.word("async", !0), this.space()), o !== "method" && o !== "init" || s.generator && this.tokenChar(42), s.computed ? (this.tokenChar(91), this.print(y, s), this.tokenChar(93)) : this.print(y, s), s.optional && this.tokenChar(63), this._params(s, s.computed && s.key.type !== "StringLiteral" ? void 0 : s.key, void 0);
        }, n._param = function(s, o) {
          this.printJoin(s.decorators, s), this.print(s, o), s.optional && this.tokenChar(63), this.print(s.typeAnnotation, s);
        }, n._parameters = function(s, o) {
          const y = s.length;
          for (let m = 0; m < y; m++) this._param(s[m], o), m < s.length - 1 && (this.tokenChar(44), this.space());
        }, n._params = function(s, o, y) {
          this.print(s.typeParameters, s);
          const m = f.call(this, o, y);
          m && this.sourceIdentifierName(m.name, m.pos), this.tokenChar(40), this._parameters(s.params, s), this.tokenChar(41);
          const g = s.type === "ArrowFunctionExpression";
          this.print(s.returnType, s, g), this._noLineTerminator = g;
        }, n._predicate = function(s, o) {
          s.predicate && (s.returnType || this.tokenChar(58), this.space(), this.print(s.predicate, s, o));
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isIdentifier: c } = i;
        function f(s, o) {
          let y, m = s;
          if (!m && o) {
            const E = o.type;
            E === "VariableDeclarator" ? m = o.id : E === "AssignmentExpression" || E === "AssignmentPattern" ? m = o.left : E === "ObjectProperty" || E === "ClassProperty" ? o.computed && o.key.type !== "StringLiteral" || (m = o.key) : E !== "ClassPrivateProperty" && E !== "ClassAccessorProperty" || (m = o.key);
          }
          if (m) {
            var g, b;
            if (m.type === "Identifier") y = { pos: (g = m.loc) == null ? void 0 : g.start, name: ((b = m.loc) == null ? void 0 : b.identifierName) || m.name };
            else if (m.type === "PrivateName") {
              var v;
              y = { pos: (v = m.loc) == null ? void 0 : v.start, name: "#" + m.id.name };
            } else if (m.type === "StringLiteral") {
              var T;
              y = { pos: (T = m.loc) == null ? void 0 : T.start, name: m.value };
            }
            return y;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/modules.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ExportAllDeclaration = function(v) {
          var T, E;
          this.word("export"), this.space(), v.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (T = v.attributes) != null && T.length || (E = v.assertions) != null && E.length ? (this.print(v.source, v, !0), this.space(), this._printAttributes(v)) : this.print(v.source, v), this.semicolon();
        }, n.ExportDefaultDeclaration = function(v) {
          b(this, v), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
          const T = v.declaration;
          this.print(T, v), m(T) || this.semicolon();
        }, n.ExportDefaultSpecifier = function(v) {
          this.print(v.exported, v);
        }, n.ExportNamedDeclaration = function(v) {
          if (b(this, v), this.word("export"), this.space(), v.declaration) {
            const O = v.declaration;
            this.print(O, v), m(O) || this.semicolon();
          } else {
            v.exportKind === "type" && (this.word("type"), this.space());
            const O = v.specifiers.slice(0);
            let D = !1;
            for (; ; ) {
              const $ = O[0];
              if (!f($) && !s($)) break;
              D = !0, this.print(O.shift(), v), O.length && (this.tokenChar(44), this.space());
            }
            var T, E;
            (O.length || !O.length && !D) && (this.tokenChar(123), O.length && (this.space(), this.printList(O, v), this.space()), this.tokenChar(125)), v.source && (this.space(), this.word("from"), this.space(), (T = v.attributes) != null && T.length || (E = v.assertions) != null && E.length ? (this.print(v.source, v, !0), this.space(), this._printAttributes(v)) : this.print(v.source, v)), this.semicolon();
          }
        }, n.ExportNamespaceSpecifier = function(v) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(v.exported, v);
        }, n.ExportSpecifier = function(v) {
          v.exportKind === "type" && (this.word("type"), this.space()), this.print(v.local, v), v.exported && v.local.name !== v.exported.name && (this.space(), this.word("as"), this.space(), this.print(v.exported, v));
        }, n.ImportAttribute = function(v) {
          this.print(v.key), this.tokenChar(58), this.space(), this.print(v.value);
        }, n.ImportDeclaration = function(v) {
          var T, E;
          this.word("import"), this.space();
          const O = v.importKind === "type" || v.importKind === "typeof";
          O ? (this.noIndentInnerCommentsHere(), this.word(v.importKind), this.space()) : v.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : v.phase && (this.noIndentInnerCommentsHere(), this.word(v.phase), this.space());
          const D = v.specifiers.slice(0), $ = !!D.length;
          for (; $; ) {
            const I = D[0];
            if (!o(I) && !y(I)) break;
            this.print(D.shift(), v), D.length && (this.tokenChar(44), this.space());
          }
          D.length ? (this.tokenChar(123), this.space(), this.printList(D, v), this.space(), this.tokenChar(125)) : O && !$ && (this.tokenChar(123), this.tokenChar(125)), ($ || O) && (this.space(), this.word("from"), this.space()), (T = v.attributes) != null && T.length || (E = v.assertions) != null && E.length ? (this.print(v.source, v, !0), this.space(), this._printAttributes(v)) : this.print(v.source, v), this.semicolon();
        }, n.ImportDefaultSpecifier = function(v) {
          this.print(v.local, v);
        }, n.ImportExpression = function(v) {
          this.word("import"), v.phase && (this.tokenChar(46), this.word(v.phase)), this.tokenChar(40), this.print(v.source, v), v.options != null && (this.tokenChar(44), this.space(), this.print(v.options, v)), this.tokenChar(41);
        }, n.ImportNamespaceSpecifier = function(v) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(v.local, v);
        }, n.ImportSpecifier = function(v) {
          v.importKind !== "type" && v.importKind !== "typeof" || (this.word(v.importKind), this.space()), this.print(v.imported, v), v.local && v.local.name !== v.imported.name && (this.space(), this.word("as"), this.space(), this.print(v.local, v));
        }, n._printAttributes = function(v) {
          const { importAttributesKeyword: T } = this.format, { attributes: E, assertions: O } = v;
          !E || T || g || (g = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
          const D = T === "assert" || !T && O;
          if (this.word(D ? "assert" : "with"), this.space(), !D && T !== "with") return void this.printList(E || O, v);
          this.tokenChar(123), this.space(), this.printList(E || O, v), this.space(), this.tokenChar(125);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isClassDeclaration: c, isExportDefaultSpecifier: f, isExportNamespaceSpecifier: s, isImportDefaultSpecifier: o, isImportNamespaceSpecifier: y, isStatement: m } = i;
        let g = !1;
        function b(v, T) {
          c(T.declaration) && v._shouldPrintDecoratorsBeforeExport(T) && v.printJoin(T.declaration.decorators, T);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/statements.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.BreakStatement = function(b) {
          this.word("break"), g(this, b.label, b, !0);
        }, n.CatchClause = function(b) {
          this.word("catch"), this.space(), b.param && (this.tokenChar(40), this.print(b.param, b), this.print(b.param.typeAnnotation, b), this.tokenChar(41), this.space()), this.print(b.body, b);
        }, n.ContinueStatement = function(b) {
          this.word("continue"), g(this, b.label, b, !0);
        }, n.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, n.DoWhileStatement = function(b) {
          this.word("do"), this.space(), this.print(b.body, b), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(b.test, b), this.tokenChar(41), this.semicolon();
        }, n.ForOfStatement = n.ForInStatement = void 0, n.ForStatement = function(b) {
          this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(b.init, b), this.inForStatementInitCounter--, this.tokenChar(59), b.test && (this.space(), this.print(b.test, b)), this.tokenChar(59), b.update && (this.space(), this.print(b.update, b)), this.tokenChar(41), this.printBlock(b);
        }, n.IfStatement = function(b) {
          this.word("if"), this.space(), this.tokenChar(40), this.print(b.test, b), this.tokenChar(41), this.space();
          const v = b.alternate && s(y(b.consequent));
          v && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(b.consequent, b), v && (this.dedent(), this.newline(), this.tokenChar(125)), b.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(b.alternate, b));
        }, n.LabeledStatement = function(b) {
          this.print(b.label, b), this.tokenChar(58), this.space(), this.print(b.body, b);
        }, n.ReturnStatement = function(b) {
          this.word("return"), g(this, b.argument, b, !1);
        }, n.SwitchCase = function(b) {
          b.test ? (this.word("case"), this.space(), this.print(b.test, b), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), b.consequent.length && (this.newline(), this.printSequence(b.consequent, b, { indent: !0 }));
        }, n.SwitchStatement = function(b) {
          this.word("switch"), this.space(), this.tokenChar(40), this.print(b.discriminant, b), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(b.cases, b, { indent: !0, addNewlines(v, T) {
            if (!v && b.cases[b.cases.length - 1] === T) return -1;
          } }), this.rightBrace(b);
        }, n.ThrowStatement = function(b) {
          this.word("throw"), g(this, b.argument, b, !1);
        }, n.TryStatement = function(b) {
          this.word("try"), this.space(), this.print(b.block, b), this.space(), b.handlers ? this.print(b.handlers[0], b) : this.print(b.handler, b), b.finalizer && (this.space(), this.word("finally"), this.space(), this.print(b.finalizer, b));
        }, n.VariableDeclaration = function(b, v) {
          b.declare && (this.word("declare"), this.space());
          const { kind: T } = b;
          this.word(T, T === "using" || T === "await using"), this.space();
          let E = !1;
          if (!c(v)) for (const O of b.declarations) O.init && (E = !0);
          if (this.printList(b.declarations, b, { separator: E ? function() {
            this.tokenChar(44), this.newline();
          } : void 0, indent: b.declarations.length > 1 }), c(v)) {
            if (f(v)) {
              if (v.init === b) return;
            } else if (v.left === b) return;
          }
          this.semicolon();
        }, n.VariableDeclarator = function(b) {
          this.print(b.id, b), b.definite && this.tokenChar(33), this.print(b.id.typeAnnotation, b), b.init && (this.space(), this.tokenChar(61), this.space(), this.print(b.init, b));
        }, n.WhileStatement = function(b) {
          this.word("while"), this.space(), this.tokenChar(40), this.print(b.test, b), this.tokenChar(41), this.printBlock(b);
        }, n.WithStatement = function(b) {
          this.word("with"), this.space(), this.tokenChar(40), this.print(b.object, b), this.tokenChar(41), this.printBlock(b);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isFor: c, isForStatement: f, isIfStatement: s, isStatement: o } = i;
        function y(b) {
          const { body: v } = b;
          return o(v) === !1 ? b : y(v);
        }
        function m(b) {
          this.word("for"), this.space();
          const v = b.type === "ForOfStatement";
          v && b.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(b.left, b), this.space(), this.word(v ? "of" : "in"), this.space(), this.print(b.right, b), this.tokenChar(41), this.printBlock(b);
        }
        n.ForInStatement = m, n.ForOfStatement = m;
        function g(b, v, T, E) {
          v && (b.space(), b.printTerminatorless(v, T, E)), b.semicolon();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/template-literals.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.TaggedTemplateExpression = function(u) {
          this.print(u.tag, u), this.print(u.typeParameters, u), this.print(u.quasi, u);
        }, n.TemplateElement = function() {
          throw new Error("TemplateElement printing is handled in TemplateLiteral");
        }, n.TemplateLiteral = function(u) {
          const i = u.quasis;
          let c = "`";
          for (let f = 0; f < i.length; f++) c += i[f].value.raw, f + 1 < i.length && (this.token(c + "${", !0), this.print(u.expressions[f], u), c = "}");
          this.token(c + "`", !0);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/types.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ArgumentPlaceholder = function() {
          this.tokenChar(63);
        }, n.ArrayPattern = n.ArrayExpression = function(y) {
          const m = y.elements, g = m.length;
          this.tokenChar(91);
          for (let b = 0; b < m.length; b++) {
            const v = m[b];
            v ? (b > 0 && this.space(), this.print(v, y), b < g - 1 && this.tokenChar(44)) : this.tokenChar(44);
          }
          this.tokenChar(93);
        }, n.BigIntLiteral = function(y) {
          const m = this.getPossibleRaw(y);
          if (!this.format.minified && m !== void 0) return void this.word(m);
          this.word(y.value + "n");
        }, n.BooleanLiteral = function(y) {
          this.word(y.value ? "true" : "false");
        }, n.DecimalLiteral = function(y) {
          const m = this.getPossibleRaw(y);
          if (!this.format.minified && m !== void 0) return void this.word(m);
          this.word(y.value + "m");
        }, n.Identifier = function(y) {
          var m;
          this.sourceIdentifierName(((m = y.loc) == null ? void 0 : m.identifierName) || y.name), this.word(y.name);
        }, n.NullLiteral = function() {
          this.word("null");
        }, n.NumericLiteral = function(y) {
          const m = this.getPossibleRaw(y), g = this.format.jsescOption, b = y.value, v = b + "";
          g.numbers ? this.number(c(b, g), b) : m == null ? this.number(v, b) : this.format.minified ? this.number(m.length < v.length ? m : v, b) : this.number(m, b);
        }, n.ObjectPattern = n.ObjectExpression = function(y) {
          const m = y.properties;
          this.tokenChar(123), m.length && (this.space(), this.printList(m, y, { indent: !0, statement: !0 }), this.space()), this.sourceWithOffset("end", y.loc, -1), this.tokenChar(125);
        }, n.ObjectMethod = function(y) {
          this.printJoin(y.decorators, y), this._methodHead(y), this.space(), this.print(y.body, y);
        }, n.ObjectProperty = function(y) {
          if (this.printJoin(y.decorators, y), y.computed) this.tokenChar(91), this.print(y.key, y), this.tokenChar(93);
          else {
            if (f(y.value) && s(y.key) && y.key.name === y.value.left.name) return void this.print(y.value, y);
            if (this.print(y.key, y), y.shorthand && s(y.key) && s(y.value) && y.key.name === y.value.name) return;
          }
          this.tokenChar(58), this.space(), this.print(y.value, y);
        }, n.PipelineBareFunction = function(y) {
          this.print(y.callee, y);
        }, n.PipelinePrimaryTopicReference = function() {
          this.tokenChar(35);
        }, n.PipelineTopicExpression = function(y) {
          this.print(y.expression, y);
        }, n.RecordExpression = function(y) {
          const m = y.properties;
          let g, b;
          if (this.format.recordAndTupleSyntaxType === "bar") g = "{|", b = "|}";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            g = "#{", b = "}";
          }
          this.token(g), m.length && (this.space(), this.printList(m, y, { indent: !0, statement: !0 }), this.space()), this.token(b);
        }, n.RegExpLiteral = function(y) {
          this.word(`/${y.pattern}/${y.flags}`);
        }, n.SpreadElement = n.RestElement = function(y) {
          this.token("..."), this.print(y.argument, y);
        }, n.StringLiteral = function(y) {
          const m = this.getPossibleRaw(y);
          if (!this.format.minified && m !== void 0) return void this.token(m);
          const g = c(y.value, this.format.jsescOption);
          this.token(g);
        }, n.TopicReference = function() {
          const { topicToken: y } = this.format;
          if (!o.has(y)) {
            const m = JSON.stringify(y), g = Array.from(o, (b) => JSON.stringify(b));
            throw new Error(`The "topicToken" generator option must be one of ${g.join(", ")} (${m} received instead).`);
          }
          this.token(y);
        }, n.TupleExpression = function(y) {
          const m = y.elements, g = m.length;
          let b, v;
          if (this.format.recordAndTupleSyntaxType === "bar") b = "[|", v = "|]";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash") throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            b = "#[", v = "]";
          }
          this.token(b);
          for (let T = 0; T < m.length; T++) {
            const E = m[T];
            E && (T > 0 && this.space(), this.print(E, y), T < g - 1 && this.tokenChar(44));
          }
          this.token(v);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/jsesc@2.5.2/node_modules/jsesc/jsesc.js");
        const { isAssignmentPattern: f, isIdentifier: s } = i, o = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/typescript.js": (h, n) => {
        function u(f, s, o) {
          if (f.token("{"), s.length) {
            f.indent(), f.newline();
            for (const y of s) f.print(y, o), f.newline();
            f.dedent();
          }
          f.rightBrace(o);
        }
        function i(f, s, o) {
          f.printJoin(s.types, s, { separator() {
            this.space(), this.token(o), this.space();
          } });
        }
        function c(f, s) {
          s !== !0 && f.token(s);
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.TSAnyKeyword = function() {
          this.word("any");
        }, n.TSArrayType = function(f) {
          this.print(f.elementType, f, !0), this.token("[]");
        }, n.TSSatisfiesExpression = n.TSAsExpression = function(f) {
          var s;
          const { type: o, expression: y, typeAnnotation: m } = f, g = !((s = y.trailingComments) == null || !s.length);
          this.print(y, f, !0, void 0, g), this.space(), this.word(o === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(m, f);
        }, n.TSBigIntKeyword = function() {
          this.word("bigint");
        }, n.TSBooleanKeyword = function() {
          this.word("boolean");
        }, n.TSCallSignatureDeclaration = function(f) {
          this.tsPrintSignatureDeclarationBase(f), this.tokenChar(59);
        }, n.TSConditionalType = function(f) {
          this.print(f.checkType), this.space(), this.word("extends"), this.space(), this.print(f.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(f.trueType), this.space(), this.tokenChar(58), this.space(), this.print(f.falseType);
        }, n.TSConstructSignatureDeclaration = function(f) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(f), this.tokenChar(59);
        }, n.TSConstructorType = function(f) {
          f.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(f);
        }, n.TSDeclareFunction = function(f, s) {
          f.declare && (this.word("declare"), this.space()), this._functionHead(f, s), this.tokenChar(59);
        }, n.TSDeclareMethod = function(f) {
          this._classMethodHead(f), this.tokenChar(59);
        }, n.TSEnumDeclaration = function(f) {
          const { declare: s, const: o, id: y, members: m } = f;
          s && (this.word("declare"), this.space()), o && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(y, f), this.space(), u(this, m, f);
        }, n.TSEnumMember = function(f) {
          const { id: s, initializer: o } = f;
          this.print(s, f), o && (this.space(), this.tokenChar(61), this.space(), this.print(o, f)), this.tokenChar(44);
        }, n.TSExportAssignment = function(f) {
          this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(f.expression, f), this.tokenChar(59);
        }, n.TSExpressionWithTypeArguments = function(f) {
          this.print(f.expression, f), this.print(f.typeParameters, f);
        }, n.TSExternalModuleReference = function(f) {
          this.token("require("), this.print(f.expression, f), this.tokenChar(41);
        }, n.TSFunctionType = function(f) {
          this.tsPrintFunctionOrConstructorType(f);
        }, n.TSImportEqualsDeclaration = function(f) {
          const { isExport: s, id: o, moduleReference: y } = f;
          s && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(o, f), this.space(), this.tokenChar(61), this.space(), this.print(y, f), this.tokenChar(59);
        }, n.TSImportType = function(f) {
          const { argument: s, qualifier: o, typeParameters: y } = f;
          this.word("import"), this.tokenChar(40), this.print(s, f), this.tokenChar(41), o && (this.tokenChar(46), this.print(o, f)), y && this.print(y, f);
        }, n.TSIndexSignature = function(f) {
          const { readonly: s, static: o } = f;
          o && (this.word("static"), this.space()), s && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(f.parameters, f), this.tokenChar(93), this.print(f.typeAnnotation, f), this.tokenChar(59);
        }, n.TSIndexedAccessType = function(f) {
          this.print(f.objectType, f, !0), this.tokenChar(91), this.print(f.indexType, f), this.tokenChar(93);
        }, n.TSInferType = function(f) {
          this.token("infer"), this.space(), this.print(f.typeParameter);
        }, n.TSInstantiationExpression = function(f) {
          this.print(f.expression, f), this.print(f.typeParameters, f);
        }, n.TSInterfaceBody = function(f) {
          this.tsPrintTypeLiteralOrInterfaceBody(f.body, f);
        }, n.TSInterfaceDeclaration = function(f) {
          const { declare: s, id: o, typeParameters: y, extends: m, body: g } = f;
          s && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(o, f), this.print(y, f), m != null && m.length && (this.space(), this.word("extends"), this.space(), this.printList(m, f)), this.space(), this.print(g, f);
        }, n.TSIntersectionType = function(f) {
          i(this, f, "&");
        }, n.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, n.TSLiteralType = function(f) {
          this.print(f.literal, f);
        }, n.TSMappedType = function(f) {
          const { nameType: s, optional: o, readonly: y, typeParameter: m, typeAnnotation: g } = f;
          this.tokenChar(123), this.space(), y && (c(this, y), this.word("readonly"), this.space()), this.tokenChar(91), this.word(m.name), this.space(), this.word("in"), this.space(), this.print(m.constraint, m), s && (this.space(), this.word("as"), this.space(), this.print(s, f)), this.tokenChar(93), o && (c(this, o), this.tokenChar(63)), g && (this.tokenChar(58), this.space(), this.print(g, f)), this.space(), this.tokenChar(125);
        }, n.TSMethodSignature = function(f) {
          const { kind: s } = f;
          s !== "set" && s !== "get" || (this.word(s), this.space()), this.tsPrintPropertyOrMethodName(f), this.tsPrintSignatureDeclarationBase(f), this.tokenChar(59);
        }, n.TSModuleBlock = function(f) {
          u(this, f.body, f);
        }, n.TSModuleDeclaration = function(f) {
          const { declare: s, id: o } = f;
          if (s && (this.word("declare"), this.space()), f.global || (this.word(o.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(o, f), !f.body) return void this.tokenChar(59);
          let y = f.body;
          for (; y.type === "TSModuleDeclaration"; ) this.tokenChar(46), this.print(y.id, y), y = y.body;
          this.space(), this.print(y, f);
        }, n.TSNamedTupleMember = function(f) {
          this.print(f.label, f), f.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(f.elementType, f);
        }, n.TSNamespaceExportDeclaration = function(f) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(f.id, f);
        }, n.TSNeverKeyword = function() {
          this.word("never");
        }, n.TSNonNullExpression = function(f) {
          this.print(f.expression, f), this.tokenChar(33);
        }, n.TSNullKeyword = function() {
          this.word("null");
        }, n.TSNumberKeyword = function() {
          this.word("number");
        }, n.TSObjectKeyword = function() {
          this.word("object");
        }, n.TSOptionalType = function(f) {
          this.print(f.typeAnnotation, f), this.tokenChar(63);
        }, n.TSParameterProperty = function(f) {
          f.accessibility && (this.word(f.accessibility), this.space()), f.readonly && (this.word("readonly"), this.space()), this._param(f.parameter);
        }, n.TSParenthesizedType = function(f) {
          this.tokenChar(40), this.print(f.typeAnnotation, f), this.tokenChar(41);
        }, n.TSPropertySignature = function(f) {
          const { readonly: s } = f;
          s && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(f), this.print(f.typeAnnotation, f), this.tokenChar(59);
        }, n.TSQualifiedName = function(f) {
          this.print(f.left, f), this.tokenChar(46), this.print(f.right, f);
        }, n.TSRestType = function(f) {
          this.token("..."), this.print(f.typeAnnotation, f);
        }, n.TSStringKeyword = function() {
          this.word("string");
        }, n.TSSymbolKeyword = function() {
          this.word("symbol");
        }, n.TSThisType = function() {
          this.word("this");
        }, n.TSTupleType = function(f) {
          this.tokenChar(91), this.printList(f.elementTypes, f), this.tokenChar(93);
        }, n.TSTypeAliasDeclaration = function(f) {
          const { declare: s, id: o, typeParameters: y, typeAnnotation: m } = f;
          s && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(o, f), this.print(y, f), this.space(), this.tokenChar(61), this.space(), this.print(m, f), this.tokenChar(59);
        }, n.TSTypeAnnotation = function(f) {
          this.tokenChar(58), this.space(), f.optional && this.tokenChar(63), this.print(f.typeAnnotation, f);
        }, n.TSTypeAssertion = function(f) {
          const { typeAnnotation: s, expression: o } = f;
          this.tokenChar(60), this.print(s, f), this.tokenChar(62), this.space(), this.print(o, f);
        }, n.TSTypeLiteral = function(f) {
          this.tsPrintTypeLiteralOrInterfaceBody(f.members, f);
        }, n.TSTypeOperator = function(f) {
          this.word(f.operator), this.space(), this.print(f.typeAnnotation, f);
        }, n.TSTypeParameter = function(f) {
          f.in && (this.word("in"), this.space()), f.out && (this.word("out"), this.space()), this.word(f.name), f.constraint && (this.space(), this.word("extends"), this.space(), this.print(f.constraint, f)), f.default && (this.space(), this.tokenChar(61), this.space(), this.print(f.default, f));
        }, n.TSTypeParameterDeclaration = n.TSTypeParameterInstantiation = function(f, s) {
          this.tokenChar(60), this.printList(f.params, f, {}), s.type === "ArrowFunctionExpression" && f.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
        }, n.TSTypePredicate = function(f) {
          f.asserts && (this.word("asserts"), this.space()), this.print(f.parameterName), f.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(f.typeAnnotation.typeAnnotation));
        }, n.TSTypeQuery = function(f) {
          this.word("typeof"), this.space(), this.print(f.exprName), f.typeParameters && this.print(f.typeParameters, f);
        }, n.TSTypeReference = function(f) {
          this.print(f.typeName, f, !0), this.print(f.typeParameters, f, !0);
        }, n.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, n.TSUnionType = function(f) {
          i(this, f, "|");
        }, n.TSUnknownKeyword = function() {
          this.word("unknown");
        }, n.TSVoidKeyword = function() {
          this.word("void");
        }, n.tsPrintClassMemberModifiers = function(f) {
          const s = f.type === "ClassAccessorProperty" || f.type === "ClassProperty";
          s && f.declare && (this.word("declare"), this.space()), f.accessibility && (this.word(f.accessibility), this.space()), f.static && (this.word("static"), this.space()), f.override && (this.word("override"), this.space()), f.abstract && (this.word("abstract"), this.space()), s && f.readonly && (this.word("readonly"), this.space());
        }, n.tsPrintFunctionOrConstructorType = function(f) {
          const { typeParameters: s } = f, o = f.parameters;
          this.print(s, f), this.tokenChar(40), this._parameters(o, f), this.tokenChar(41), this.space(), this.token("=>"), this.space();
          const y = f.typeAnnotation;
          this.print(y.typeAnnotation, f);
        }, n.tsPrintPropertyOrMethodName = function(f) {
          f.computed && this.tokenChar(91), this.print(f.key, f), f.computed && this.tokenChar(93), f.optional && this.tokenChar(63);
        }, n.tsPrintSignatureDeclarationBase = function(f) {
          const { typeParameters: s } = f, o = f.parameters;
          this.print(s, f), this.tokenChar(40), this._parameters(o, f), this.tokenChar(41);
          const y = f.typeAnnotation;
          this.print(y, f);
        }, n.tsPrintTypeLiteralOrInterfaceBody = function(f, s) {
          u(this, f, s);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o = {}, y) {
          const m = f(y, o), g = o.sourceMaps ? new i.default(o, y) : null;
          return new c.default(m, g).generate(s);
        };
        var i = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/source-map.js"), c = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/printer.js");
        function f(s, o) {
          const y = { auxiliaryCommentBefore: o.auxiliaryCommentBefore, auxiliaryCommentAfter: o.auxiliaryCommentAfter, shouldPrintComment: o.shouldPrintComment, retainLines: o.retainLines, retainFunctionParens: o.retainFunctionParens, comments: o.comments == null || o.comments, compact: o.compact, minified: o.minified, concise: o.concise, indent: { adjustMultilineComment: !0, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: !0, minimal: !1 }, o.jsescOption), topicToken: o.topicToken, importAttributesKeyword: o.importAttributesKeyword };
          var m;
          y.decoratorsBeforeExport = o.decoratorsBeforeExport, y.jsescOption.json = o.jsonCompatibleStrings, y.recordAndTupleSyntaxType = (m = o.recordAndTupleSyntaxType) != null ? m : "hash", y.minified ? (y.compact = !0, y.shouldPrintComment = y.shouldPrintComment || (() => y.comments)) : y.shouldPrintComment = y.shouldPrintComment || ((T) => y.comments || T.includes("@license") || T.includes("@preserve")), y.compact === "auto" && (y.compact = typeof s == "string" && s.length > 5e5, y.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${o.filename} as it exceeds the max of 500KB.`)), y.compact && (y.indent.adjustMultilineComment = !1);
          const { auxiliaryCommentBefore: g, auxiliaryCommentAfter: b, shouldPrintComment: v } = y;
          return g && !v(g) && (y.auxiliaryCommentBefore = void 0), b && !v(b) && (y.auxiliaryCommentAfter = void 0), y;
        }
        n.CodeGenerator = class {
          constructor(s, o = {}, y) {
            this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = s, this._format = f(y, o), this._map = o.sourceMaps ? new i.default(o, y) : null;
          }
          generate() {
            return new c.default(this._format, this._map).generate(this._ast);
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.needsParens = function(D, $, I) {
          var k;
          return $ ? g($) && $.callee === D && E(D) ? !0 : (k = v.get(D.type)) == null ? void 0 : k(D, $, I) : !1;
        }, n.needsWhitespace = O, n.needsWhitespaceAfter = function(D, $) {
          return O(D, $, 2);
        }, n.needsWhitespaceBefore = function(D, $) {
          return O(D, $, 1);
        };
        var i = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/whitespace.js"), c = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/parentheses.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: s, isCallExpression: o, isExpressionStatement: y, isMemberExpression: m, isNewExpression: g } = f;
        function b(D) {
          const $ = /* @__PURE__ */ new Map();
          function I(k, L) {
            const M = $.get(k);
            $.set(k, M ? function(x, _, S) {
              var C;
              return (C = M(x, _, S)) != null ? C : L(x, _, S);
            } : L);
          }
          for (const k of Object.keys(D)) {
            const L = s[k];
            if (L) for (const M of L) I(M, D[k]);
            else I(k, D[k]);
          }
          return $;
        }
        const v = b(c), T = b(i.nodes);
        function E(D) {
          return !!o(D) || m(D) && E(D.object);
        }
        function O(D, $, I) {
          var k;
          if (!D) return !1;
          y(D) && (D = D.expression);
          const L = (k = T.get(D.type)) == null ? void 0 : k(D, $);
          return typeof L == "number" && !!(L & I);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/parentheses.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ArrowFunctionExpression = function(x, _) {
          return y(_) || L(x, _);
        }, n.AssignmentExpression = function(x, _) {
          return !!v(x.left) || L(x, _);
        }, n.Binary = function(x, _) {
          const S = _.type;
          if (x.operator === "**" && S === "BinaryExpression" && _.operator === "**") return _.left === x;
          if ($(x, _) || I(x, _) || S === "UnaryExpression" || S === "SpreadElement" || S === "AwaitExpression") return !0;
          if (S === "BinaryExpression" || S === "LogicalExpression") {
            const C = O.get(_.operator), R = O.get(x.operator);
            if (C === R && _.right === x && S !== "LogicalExpression" || C > R) return !0;
          }
        }, n.BinaryExpression = function(x, _) {
          if (x.operator === "in") {
            const S = _.type;
            return S === "VariableDeclarator" || S === "ForStatement" || S === "ForInStatement" || S === "ForOfStatement";
          }
          return !1;
        }, n.ClassExpression = function(x, _, S) {
          return M(S, 5);
        }, n.ConditionalExpression = L, n.DoExpression = function(x, _, S) {
          return !x.async && M(S, 1);
        }, n.FunctionExpression = function(x, _, S) {
          return M(S, 5);
        }, n.FunctionTypeAnnotation = function(x, _, S) {
          if (S.length < 3) return;
          const C = _.type;
          return C === "UnionTypeAnnotation" || C === "IntersectionTypeAnnotation" || C === "ArrayTypeAnnotation" || C === "TypeAnnotation" && f(S[S.length - 3]);
        }, n.Identifier = function(x, _, S) {
          var C;
          const R = _.type;
          if ((C = x.extra) != null && C.parenthesized && R === "AssignmentExpression" && _.left === x) {
            const H = _.right.type;
            if ((H === "FunctionExpression" || H === "ClassExpression") && _.right.id == null) return !0;
          }
          return x.name === "let" ? M(S, b(_, { object: x, computed: !0 }) || T(_, { object: x, computed: !0, optional: !1 }) ? 57 : 32) : x.name === "async" && m(_) && x === _.left;
        }, n.LogicalExpression = function(x, _) {
          const S = _.type;
          if (D(S)) return !0;
          if (S !== "LogicalExpression") return !1;
          switch (x.operator) {
            case "||":
              return _.operator === "??" || _.operator === "&&";
            case "&&":
              return _.operator === "??";
            case "??":
              return _.operator !== "??";
          }
        }, n.NullableTypeAnnotation = function(x, _) {
          return c(_);
        }, n.ObjectExpression = function(x, _, S) {
          return M(S, 3);
        }, n.OptionalIndexedAccessType = function(x, _) {
          return g(_) && _.objectType === x;
        }, n.OptionalCallExpression = n.OptionalMemberExpression = function(x, _) {
          return o(_) && _.callee === x || b(_) && _.object === x;
        }, n.SequenceExpression = function(x, _) {
          const S = _.type;
          return !(S === "ForStatement" || S === "ThrowStatement" || S === "ReturnStatement" || S === "IfStatement" && _.test === x || S === "WhileStatement" && _.test === x || S === "ForInStatement" && _.right === x || S === "SwitchStatement" && _.discriminant === x || S === "ExpressionStatement" && _.expression === x);
        }, n.TSTypeAssertion = n.TSSatisfiesExpression = n.TSAsExpression = function() {
          return !0;
        }, n.TSInferType = function(x, _) {
          const S = _.type;
          return S === "TSArrayType" || S === "TSOptionalType";
        }, n.TSInstantiationExpression = function(x, _) {
          const S = _.type;
          return (S === "CallExpression" || S === "OptionalCallExpression" || S === "NewExpression" || S === "TSInstantiationExpression") && !!_.typeParameters;
        }, n.TSIntersectionType = n.TSUnionType = function(x, _) {
          const S = _.type;
          return S === "TSArrayType" || S === "TSOptionalType" || S === "TSIntersectionType" || S === "TSUnionType" || S === "TSRestType";
        }, n.UnaryLike = k, n.IntersectionTypeAnnotation = n.UnionTypeAnnotation = function(x, _) {
          const S = _.type;
          return S === "ArrayTypeAnnotation" || S === "NullableTypeAnnotation" || S === "IntersectionTypeAnnotation" || S === "UnionTypeAnnotation";
        }, n.UpdateExpression = function(x, _) {
          return I(x, _) || $(x, _);
        }, n.AwaitExpression = n.YieldExpression = function(x, _) {
          const S = _.type;
          return S === "BinaryExpression" || S === "LogicalExpression" || S === "UnaryExpression" || S === "SpreadElement" || I(x, _) || S === "AwaitExpression" && E(x) || S === "ConditionalExpression" && x === _.test || $(x, _);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isArrayTypeAnnotation: c, isArrowFunctionExpression: f, isBinaryExpression: s, isCallExpression: o, isExportDeclaration: y, isForOfStatement: m, isIndexedAccessType: g, isMemberExpression: b, isObjectPattern: v, isOptionalMemberExpression: T, isYieldExpression: E } = i, O = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
        function D(x) {
          return x === "TSAsExpression" || x === "TSSatisfiesExpression" || x === "TSTypeAssertion";
        }
        const $ = (x, _) => {
          const S = _.type;
          return (S === "ClassDeclaration" || S === "ClassExpression") && _.superClass === x;
        }, I = (x, _) => {
          const S = _.type;
          return (S === "MemberExpression" || S === "OptionalMemberExpression") && _.object === x || (S === "CallExpression" || S === "OptionalCallExpression" || S === "NewExpression") && _.callee === x || S === "TaggedTemplateExpression" && _.tag === x || S === "TSNonNullExpression";
        };
        function k(x, _) {
          return I(x, _) || s(_) && _.operator === "**" && _.left === x || $(x, _);
        }
        function L(x, _) {
          const S = _.type;
          return !!(S === "UnaryExpression" || S === "SpreadElement" || S === "BinaryExpression" || S === "LogicalExpression" || S === "ConditionalExpression" && _.test === x || S === "AwaitExpression" || D(S)) || k(x, _);
        }
        function M(x, _) {
          const S = 1 & _, C = 2 & _, R = 4 & _, H = 8 & _, z = 16 & _, U = 32 & _;
          let P = x.length - 1;
          if (P <= 0) return;
          let W = x[P];
          P--;
          let B = x[P];
          for (; P >= 0; ) {
            const Q = B.type;
            if (S && Q === "ExpressionStatement" && B.expression === W || R && Q === "ExportDefaultDeclaration" && W === B.declaration || C && Q === "ArrowFunctionExpression" && B.body === W || H && Q === "ForStatement" && B.init === W || z && Q === "ForInStatement" && B.left === W || U && Q === "ForOfStatement" && B.left === W) return !0;
            if (!(P > 0 && (I(W, B) && Q !== "NewExpression" || Q === "SequenceExpression" && B.expressions[0] === W || Q === "UpdateExpression" && !B.prefix || Q === "ConditionalExpression" && B.test === W || (Q === "BinaryExpression" || Q === "LogicalExpression") && B.left === W || Q === "AssignmentExpression" && B.left === W))) return !1;
            W = B, P--, B = x[P];
          }
          return !1;
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/whitespace.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.nodes = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: c, isArrayExpression: f, isAssignmentExpression: s, isBinary: o, isBlockStatement: y, isCallExpression: m, isFunction: g, isIdentifier: b, isLiteral: v, isMemberExpression: T, isObjectExpression: E, isOptionalCallExpression: O, isOptionalMemberExpression: D, isStringLiteral: $ } = i;
        function I(_, S) {
          return _ && (T(_) || D(_) ? (I(_.object, S), _.computed && I(_.property, S)) : o(_) || s(_) ? (I(_.left, S), I(_.right, S)) : m(_) || O(_) ? (S.hasCall = !0, I(_.callee, S)) : g(_) ? S.hasFunction = !0 : b(_) && (S.hasHelper = S.hasHelper || _.callee && L(_.callee))), S;
        }
        function k(_) {
          return I(_, { hasCall: !1, hasFunction: !1, hasHelper: !1 });
        }
        function L(_) {
          return !!_ && (T(_) ? L(_.object) || L(_.property) : b(_) ? _.name === "require" || _.name.charCodeAt(0) === 95 : m(_) ? L(_.callee) : !(!o(_) && !s(_)) && (b(_.left) && L(_.left) || L(_.right)));
        }
        function M(_) {
          return v(_) || E(_) || f(_) || b(_) || T(_);
        }
        const x = n.nodes = { AssignmentExpression(_) {
          const S = k(_.right);
          if (S.hasCall && S.hasHelper || S.hasFunction) return S.hasFunction ? 3 : 2;
        }, SwitchCase: (_, S) => (_.consequent.length || S.cases[0] === _ ? 1 : 0) | (_.consequent.length || S.cases[S.cases.length - 1] !== _ ? 0 : 2), LogicalExpression(_) {
          if (g(_.left) || g(_.right)) return 2;
        }, Literal(_) {
          if ($(_) && _.value === "use strict") return 2;
        }, CallExpression(_) {
          if (g(_.callee) || L(_)) return 3;
        }, OptionalCallExpression(_) {
          if (g(_.callee)) return 3;
        }, VariableDeclaration(_) {
          for (let S = 0; S < _.declarations.length; S++) {
            const C = _.declarations[S];
            let R = L(C.id) && !M(C.init);
            if (!R && C.init) {
              const H = k(C.init);
              R = L(C.init) && H.hasCall || H.hasFunction;
            }
            if (R) return 3;
          }
        }, IfStatement(_) {
          if (y(_.consequent)) return 3;
        } };
        x.ObjectProperty = x.ObjectTypeProperty = x.ObjectMethod = function(_, S) {
          if (S.properties[0] === _) return 1;
        }, x.ObjectTypeCallProperty = function(_, S) {
          var C;
          if (S.callProperties[0] === _ && ((C = S.properties) == null || !C.length)) return 1;
        }, x.ObjectTypeIndexer = function(_, S) {
          var C, R;
          if (!(S.indexers[0] !== _ || (C = S.properties) != null && C.length || (R = S.callProperties) != null && R.length)) return 1;
        }, x.ObjectTypeInternalSlot = function(_, S) {
          var C, R, H;
          if (!(S.internalSlots[0] !== _ || (C = S.properties) != null && C.length || (R = S.callProperties) != null && R.length || (H = S.indexers) != null && H.length)) return 1;
        }, [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([_, S]) {
          [_].concat(c[_] || []).forEach(function(C) {
            const R = S ? 3 : 0;
            x[C] = () => R;
          });
        });
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/printer.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/buffer.js"), c = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/node/index.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), s = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/generators/index.js");
        const { isFunction: o, isStatement: y, isClassBody: m, isTSInterfaceBody: g, isTSEnumDeclaration: b } = f, v = /e/i, T = /\.0+$/, E = /[\n\r\u2028\u2029]/, O = /[\n\r\u2028\u2029]|\*\//, { needsParens: D } = c;
        class $ {
          constructor(L, M) {
            this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = L, this._indentRepeat = L.indent.style.length, this._inputMap = M == null ? void 0 : M._inputMap, this._buf = new i.default(M, L.indent.style[0]);
          }
          generate(L) {
            return this.print(L), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            this.format.compact || this.format.concise || this._indent++;
          }
          dedent() {
            this.format.compact || this.format.concise || this._indent--;
          }
          semicolon(L = !1) {
            this._maybeAddAuxComment(), L ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
          }
          rightBrace(L) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", L.loc, -1), this.tokenChar(125);
          }
          rightParens(L) {
            this.sourceWithOffset("end", L.loc, -1), this.tokenChar(41);
          }
          space(L = !1) {
            if (!this.format.compact) {
              if (L) this._space();
              else if (this._buf.hasContent()) {
                const M = this.getLastChar();
                M !== 32 && M !== 10 && this._space();
              }
            }
          }
          word(L, M = !1) {
            this._maybePrintInnerComments(), (this._endsWithWord || L.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(L, !1), this._endsWithWord = !0, this._noLineTerminator = M;
          }
          number(L, M) {
            this.word(L), this._endsWithInteger = Number.isInteger(M) && !function(x) {
              if (x.length > 2 && x.charCodeAt(0) === 48) {
                const _ = x.charCodeAt(1);
                return _ === 98 || _ === 111 || _ === 120;
              }
              return !1;
            }(L) && !v.test(L) && !T.test(L) && L.charCodeAt(L.length - 1) !== 46;
          }
          token(L, M = !1) {
            this._maybePrintInnerComments();
            const x = this.getLastChar(), _ = L.charCodeAt(0);
            (x === 33 && (L === "--" || _ === 61) || _ === 43 && x === 43 || _ === 45 && x === 45 || _ === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(L, M), this._noLineTerminator = !1;
          }
          tokenChar(L) {
            this._maybePrintInnerComments();
            const M = this.getLastChar();
            (L === 43 && M === 43 || L === 45 && M === 45 || L === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(L), this._noLineTerminator = !1;
          }
          newline(L = 1, M) {
            if (!(L <= 0)) {
              if (!M) {
                if (this.format.retainLines || this.format.compact) return;
                if (this.format.concise) return void this.space();
              }
              L > 2 && (L = 2), L -= this._buf.getNewlineCount();
              for (let x = 0; x < L; x++) this._newline();
            }
          }
          endsWith(L) {
            return this.getLastChar() === L;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(L, M) {
            L ? (this._catchUp("start", L), this._buf.exactSource(L, M)) : M();
          }
          source(L, M) {
            M && (this._catchUp(L, M), this._buf.source(L, M));
          }
          sourceWithOffset(L, M, x) {
            M && (this._catchUp(L, M), this._buf.sourceWithOffset(L, M, x));
          }
          withSource(L, M, x) {
            M ? (this._catchUp(L, M), this._buf.withSource(L, M, x)) : x();
          }
          sourceIdentifierName(L, M) {
            if (!this._buf._canMarkIdName) return;
            const x = this._buf._sourcePosition;
            x.identifierNamePos = M, x.identifierName = L;
          }
          _space() {
            this._queue(32);
          }
          _newline() {
            this._queue(10);
          }
          _append(L, M) {
            this._maybeAddParen(L), this._maybeIndent(L.charCodeAt(0)), this._buf.append(L, M), this._endsWithWord = !1, this._endsWithInteger = !1;
          }
          _appendChar(L) {
            this._maybeAddParenChar(L), this._maybeIndent(L), this._buf.appendChar(L), this._endsWithWord = !1, this._endsWithInteger = !1;
          }
          _queue(L) {
            this._maybeAddParenChar(L), this._maybeIndent(L), this._buf.queue(L), this._endsWithWord = !1, this._endsWithInteger = !1;
          }
          _maybeIndent(L) {
            this._indent && L !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
          }
          _shouldIndent(L) {
            if (this._indent && L !== 10 && this.endsWith(10)) return !0;
          }
          _maybeAddParenChar(L) {
            const M = this._parenPushNewlineState;
            M && L !== 32 && (L === 10 ? (this.tokenChar(40), this.indent(), M.printed = !0) : this._parenPushNewlineState = null);
          }
          _maybeAddParen(L) {
            const M = this._parenPushNewlineState;
            if (!M) return;
            const x = L.length;
            let _;
            for (_ = 0; _ < x && L.charCodeAt(_) === 32; _++) ;
            if (_ === x) return;
            const S = L.charCodeAt(_);
            if (S !== 10) {
              if (S !== 47 || _ + 1 === x) return void (this._parenPushNewlineState = null);
              const C = L.charCodeAt(_ + 1);
              if (C === 42) return;
              if (C !== 47) return void (this._parenPushNewlineState = null);
            }
            this.tokenChar(40), this.indent(), M.printed = !0;
          }
          catchUp(L) {
            if (!this.format.retainLines) return;
            const M = L - this._buf.getCurrentLine();
            for (let x = 0; x < M; x++) this._newline();
          }
          _catchUp(L, M) {
            var x;
            if (!this.format.retainLines) return;
            const _ = M == null || (x = M[L]) == null ? void 0 : x.line;
            if (_ != null) {
              const S = _ - this._buf.getCurrentLine();
              for (let C = 0; C < S; C++) this._newline();
            }
          }
          _getIndent() {
            return this._indentRepeat * this._indent;
          }
          printTerminatorless(L, M, x) {
            if (x) this._noLineTerminator = !0, this.print(L, M);
            else {
              const _ = { printed: !1 };
              this._parenPushNewlineState = _, this.print(L, M), _.printed && (this.dedent(), this.newline(), this.tokenChar(41));
            }
          }
          print(L, M, x, _, S) {
            var C, R;
            if (!L) return;
            this._endsWithInnerRaw = !1;
            const H = L.type, z = this.format, U = z.concise;
            L._compact && (z.concise = !0);
            const P = this[H];
            if (P === void 0) throw new ReferenceError(`unknown node of type ${JSON.stringify(H)} with constructor ${JSON.stringify(L.constructor.name)}`);
            this._printStack.push(L);
            const W = this._insideAux;
            this._insideAux = L.loc == null, this._maybeAddAuxComment(this._insideAux && !W);
            const B = (C = L.extra) == null ? void 0 : C.parenthesized;
            let Q = S || B && z.retainFunctionParens && H === "FunctionExpression" || D(L, M, this._printStack);
            if (!Q && B && (R = L.leadingComments) != null && R.length && L.leadingComments[0].type === "CommentBlock")
              switch (M == null ? void 0 : M.type) {
                case "ExpressionStatement":
                case "VariableDeclarator":
                case "AssignmentExpression":
                case "ReturnStatement":
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                case "NewExpression":
                  if (M.callee !== L) break;
                default:
                  Q = !0;
              }
            Q && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(L, M);
            const J = H === "Program" || H === "File" ? null : L.loc;
            this.exactSource(J, P.bind(this, L, M)), Q ? (this._printTrailingComments(L, M), this.tokenChar(41), this._noLineTerminator = x) : x && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(L, M)) : this._printTrailingComments(L, M, _), this._printStack.pop(), z.concise = U, this._insideAux = W, this._endsWithInnerRaw = !1;
          }
          _maybeAddAuxComment(L) {
            L && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = !0;
            const L = this.format.auxiliaryCommentBefore;
            L && this._printComment({ type: "CommentBlock", value: L }, 0);
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = !1;
            const L = this.format.auxiliaryCommentAfter;
            L && this._printComment({ type: "CommentBlock", value: L }, 0);
          }
          getPossibleRaw(L) {
            const M = L.extra;
            if ((M == null ? void 0 : M.raw) != null && M.rawValue != null && L.value === M.rawValue) return M.raw;
          }
          printJoin(L, M, x = {}) {
            if (L == null || !L.length) return;
            let { indent: _ } = x;
            if (_ == null && this.format.retainLines) {
              var S;
              const P = (S = L[0].loc) == null ? void 0 : S.start.line;
              P != null && P !== this._buf.getCurrentLine() && (_ = !0);
            }
            _ && this.indent();
            const C = { addNewlines: x.addNewlines, nextNodeStartLine: 0 }, R = x.separator ? x.separator.bind(this) : null, H = L.length;
            for (let P = 0; P < H; P++) {
              const W = L[P];
              var z;
              if (W && (x.statement && this._printNewline(P === 0, C), this.print(W, M, void 0, x.trailingCommentsLineOffset || 0), x.iterator == null || x.iterator(W, P), P < H - 1 && (R == null || R()), x.statement))
                if ((z = W.trailingComments) != null && z.length || (this._lastCommentLine = 0), P + 1 === H) this.newline(1);
                else {
                  var U;
                  const B = L[P + 1];
                  C.nextNodeStartLine = ((U = B.loc) == null ? void 0 : U.start.line) || 0, this._printNewline(!0, C);
                }
            }
            _ && this.dedent();
          }
          printAndIndentOnComments(L, M) {
            const x = L.leadingComments && L.leadingComments.length > 0;
            x && this.indent(), this.print(L, M), x && this.dedent();
          }
          printBlock(L) {
            const M = L.body;
            M.type !== "EmptyStatement" && this.space(), this.print(M, L);
          }
          _printTrailingComments(L, M, x) {
            const { innerComments: _, trailingComments: S } = L;
            _ != null && _.length && this._printComments(2, _, L, M, x), S != null && S.length && this._printComments(2, S, L, M, x);
          }
          _printLeadingComments(L, M) {
            const x = L.leadingComments;
            x != null && x.length && this._printComments(0, x, L, M);
          }
          _maybePrintInnerComments() {
            this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
          }
          printInnerComments() {
            const L = this._printStack[this._printStack.length - 1], M = L.innerComments;
            if (M == null || !M.length) return;
            const x = this.endsWith(32), _ = this._indentInnerComments, S = this._printedComments.size;
            _ && this.indent(), this._printComments(1, M, L), x && S !== this._printedComments.size && this.space(), _ && this.dedent();
          }
          noIndentInnerCommentsHere() {
            this._indentInnerComments = !1;
          }
          printSequence(L, M, x = {}) {
            x.statement = !0, x.indent != null || (x.indent = !1), this.printJoin(L, M, x);
          }
          printList(L, M, x = {}) {
            x.separator == null && (x.separator = I), this.printJoin(L, M, x);
          }
          _printNewline(L, M) {
            const x = this.format;
            if (x.retainLines || x.compact) return;
            if (x.concise) return void this.space();
            if (!L) return;
            const _ = M.nextNodeStartLine, S = this._lastCommentLine;
            if (_ > 0 && S > 0) {
              const C = _ - S;
              if (C >= 0) return void this.newline(C || 1);
            }
            this._buf.hasContent() && this.newline(1);
          }
          _shouldPrintComment(L) {
            return L.ignore || this._printedComments.has(L) ? 0 : this._noLineTerminator && O.test(L.value) ? 2 : (this._printedComments.add(L), this.format.shouldPrintComment(L.value) ? 1 : 0);
          }
          _printComment(L, M) {
            const x = this._noLineTerminator, _ = L.type === "CommentBlock", S = _ && M !== 1 && !this._noLineTerminator;
            S && this._buf.hasContent() && M !== 2 && this.newline(1);
            const C = this.getLastChar();
            let R;
            if (C !== 91 && C !== 123 && this.space(), _) {
              const { _parenPushNewlineState: z } = this;
              if ((z == null ? void 0 : z.printed) === !1 && E.test(L.value) && (this.tokenChar(40), this.indent(), z.printed = !0), R = `/*${L.value}*/`, this.format.indent.adjustMultilineComment) {
                var H;
                const U = (H = L.loc) == null ? void 0 : H.start.column;
                if (U) {
                  const P = new RegExp("\\n\\s{1," + U + "}", "g");
                  R = R.replace(P, `
`);
                }
                if (this.format.concise) R = R.replace(/\n(?!$)/g, `
`);
                else {
                  let P = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                  (this._shouldIndent(47) || this.format.retainLines) && (P += this._getIndent()), R = R.replace(/\n(?!$)/g, `
${" ".repeat(P)}`);
                }
              }
            } else R = x ? `/*${L.value}*/` : `//${L.value}`;
            this.endsWith(47) && this._space(), this.source("start", L.loc), this._append(R, _), _ || x || this.newline(1, !0), S && M !== 3 && this.newline(1);
          }
          _printComments(L, M, x, _, S = 0) {
            const C = x.loc, R = M.length;
            let H = !!C;
            const z = H ? C.start.line : 0, U = H ? C.end.line : 0;
            let P = 0, W = 0;
            const B = this._noLineTerminator ? function() {
            } : this.newline.bind(this);
            for (let Q = 0; Q < R; Q++) {
              const J = M[Q], re = this._shouldPrintComment(J);
              if (re === 2) {
                H = !1;
                break;
              }
              if (H && J.loc && re === 1) {
                const G = J.loc.start.line, N = J.loc.end.line;
                if (L === 0) {
                  let V = 0;
                  Q === 0 ? !this._buf.hasContent() || J.type !== "CommentLine" && G === N || (V = W = 1) : V = G - P, P = N, B(V), this._printComment(J, 1), Q + 1 === R && (B(Math.max(z - P, W)), P = z);
                } else if (L === 1) {
                  const V = G - (Q === 0 ? z : P);
                  P = N, B(V), this._printComment(J, 1), Q + 1 === R && (B(Math.min(1, U - P)), P = U);
                } else {
                  const V = G - (Q === 0 ? U - S : P);
                  P = N, B(V), this._printComment(J, 1);
                }
              } else {
                if (H = !1, re !== 1) continue;
                if (R === 1) {
                  const G = J.loc ? J.loc.start.line === J.loc.end.line : !E.test(J.value), N = G && !y(x) && !m(_) && !g(_) && !b(_);
                  L === 0 ? this._printComment(J, N && x.type !== "ObjectExpression" || G && o(_, { body: x }) ? 1 : 0) : N && L === 2 ? this._printComment(J, 1) : this._printComment(J, 0);
                } else L !== 1 || x.type === "ObjectExpression" && x.properties.length > 1 || x.type === "ClassBody" || x.type === "TSInterfaceBody" ? this._printComment(J, 0) : this._printComment(J, Q === 0 ? 2 : Q === R - 1 ? 3 : 0);
              }
            }
            L === 2 && H && P && (this._lastCommentLine = P);
          }
        }
        Object.assign($.prototype, s), $.prototype.Noop = function() {
        }, n.default = $;
        function I() {
          this.tokenChar(44), this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/source-map.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.5/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"), c = u("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js");
        n.default = class {
          constructor(f, s) {
            var o;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            const y = this._map = new i.GenMapping({ sourceRoot: f.sourceRoot });
            if (this._sourceFileName = (o = f.sourceFileName) == null ? void 0 : o.replace(/\\/g, "/"), this._rawMappings = void 0, f.inputSourceMap) {
              this._inputMap = new c.TraceMap(f.inputSourceMap);
              const g = this._inputMap.resolvedSources;
              if (g.length) for (let b = 0; b < g.length; b++) {
                var m;
                (0, i.setSourceContent)(y, g[b], (m = this._inputMap.sourcesContent) == null ? void 0 : m[b]);
              }
            }
            if (typeof s != "string" || f.inputSourceMap) {
              if (typeof s == "object") for (const g of Object.keys(s)) (0, i.setSourceContent)(y, g.replace(/\\/g, "/"), s[g]);
            } else (0, i.setSourceContent)(y, this._sourceFileName, s);
          }
          get() {
            return (0, i.toEncodedMap)(this._map);
          }
          getDecoded() {
            return (0, i.toDecodedMap)(this._map);
          }
          getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, i.allMappings)(this._map));
          }
          mark(f, s, o, y, m, g) {
            var b;
            let v;
            if (this._rawMappings = void 0, s != null) if (this._inputMap) {
              if (v = (0, c.originalPositionFor)(this._inputMap, { line: s, column: o }), !v.name && m) {
                const T = (0, c.originalPositionFor)(this._inputMap, m);
                T.name && (y = T.name);
              }
            } else v = { source: (g == null ? void 0 : g.replace(/\\/g, "/")) || this._sourceFileName, line: s, column: o };
            (0, i.maybeAddMapping)(this._map, { name: y, generated: f, source: (b = v) == null ? void 0 : b.source, original: v });
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.24.7/node_modules/@babel/helper-annotate-as-pure/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(o) {
          const y = o.node || o;
          s(y) || c(y, "leading", f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { addComment: c } = i, f = "#__PURE__", s = ({ leadingComments: o }) => !!o && o.some((y) => /[@#]__PURE__/.test(y.value));
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.buildDecoratedClass = function(g, b, v, T) {
          const { node: E, scope: O } = b, D = O.generateUidIdentifier("initialize"), $ = E.id && b.isDeclaration(), I = b.isInStrictMode(), { superClass: k } = E;
          E.type = "ClassDeclaration", E.id || (E.id = i.types.cloneNode(g));
          let L;
          k && (L = O.generateUidIdentifierBasedOnNode(E.superClass, "super"), E.superClass = L);
          const M = y(E), x = i.types.arrayExpression(v.filter((R) => !R.node.abstract && R.node.type !== "TSIndexSignature").map((R) => function(H, z, U, P) {
            const W = P.isClassMethod();
            if (P.isPrivate()) throw P.buildCodeFrameError(`Private ${W ? "methods" : "fields"} in decorated classes are not supported yet.`);
            if (P.node.type === "ClassAccessorProperty") throw P.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            if (P.node.type === "StaticBlock") throw P.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            const { node: B, scope: Q } = P;
            P.isTSDeclareMethod() || new c.default({ methodPath: P, objectRef: z, superRef: U, file: H, refToPreserve: z }).replace();
            const J = [o("kind", i.types.stringLiteral(i.types.isClassMethod(B) ? B.kind : "field")), o("decorators", y(B)), o("static", B.static && i.types.booleanLiteral(!0)), o("key", m(B))].filter(Boolean);
            if (i.types.isClassMethod(B)) {
              const N = B.computed ? null : B.key, V = i.types.toExpression(B);
              J.push(o("value", (0, f.default)({ node: V, id: N, scope: Q }) || V));
            } else i.types.isClassProperty(B) && B.value ? J.push((re = "value", G = i.template.statements.ast`return ${B.value}`, i.types.objectMethod("method", i.types.identifier(re), [], i.types.blockStatement(G)))) : J.push(o("value", Q.buildUndefinedNode()));
            var re, G;
            return P.remove(), i.types.objectExpression(J);
          }(T, E.id, L, R))), _ = i.template.expression.ast`
    ${function(R) {
            return R.addHelper("decorate");
          }(T)}(
      ${M || i.types.nullLiteral()},
      function (${D}, ${k ? i.types.cloneNode(L) : null}) {
        ${E}
        return { F: ${i.types.cloneNode(E.id)}, d: ${x} };
      },
      ${k}
    )
  `;
          I || _.arguments[1].body.directives.push(i.types.directive(i.types.directiveLiteral("use strict")));
          let S = _, C = "arguments.1.body.body.0";
          return $ && (S = i.template.statement.ast`let ${g} = ${_}`, C = "declarations.0.init." + C), { instanceNodes: [i.template.statement.ast`
        ${i.types.cloneNode(D)}(this)
      `], wrapClass: (R) => (R.replaceWith(S), R.get(C)) };
        }, n.hasDecorators = function(g) {
          return s(g) || g.body.body.some(s);
        }, n.hasOwnDecorators = s;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-replace-supers@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-replace-supers/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-function-name@7.24.7/node_modules/@babel/helper-function-name/lib/index.js");
        function s(g) {
          var b;
          return !((b = g.decorators) == null || !b.length);
        }
        function o(g, b) {
          return b ? i.types.objectProperty(i.types.identifier(g), b) : null;
        }
        function y(g) {
          let b;
          return g.decorators && g.decorators.length > 0 && (b = i.types.arrayExpression(g.decorators.map((v) => v.expression))), g.decorators = void 0, b;
        }
        function m(g) {
          return g.computed ? g.key : i.types.isIdentifier(g.key) ? i.types.stringLiteral(g.key.name) : i.types.stringLiteral(String(g.key.value));
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function({ assertVersion: ee, assumption: ae }, { loose: oe }, me, ye) {
          var we, ge;
          ee(me === "2023-11" || me === "2023-05" || me === "2023-01" ? "^7.21.0" : me === "2021-12" ? "^7.16.0" : "^7.19.0");
          const se = /* @__PURE__ */ new WeakSet(), be = (we = ae("constantSuper")) != null ? we : oe, Ie = (ge = ae("ignoreFunctionLength")) != null ? ge : oe, Oe = /* @__PURE__ */ function(Fe, ue) {
            function te(Y, le, Ee) {
              switch (le.type) {
                case "StringLiteral":
                  return i.types.stringLiteral(le.value);
                case "NumericLiteral":
                case "BigIntLiteral": {
                  const Se = le.value + "";
                  return Y.get("key").replaceWith(i.types.stringLiteral(Se)), i.types.stringLiteral(Se);
                }
                default: {
                  const Se = Y.scope.maybeGenerateMemoised(le);
                  return Y.get("key").replaceWith(i.types.assignmentExpression("=", Se, V(Ee, le))), i.types.cloneNode(Se);
                }
              }
            }
            return { VariableDeclarator(Y, le) {
              const Ee = Y.node.id;
              if (Ee.type === "Identifier") {
                const Se = (0, s.skipTransparentExprWrappers)(Y.get("init"));
                if (Fe(Se)) {
                  const Pe = Ee.name;
                  ue(Se, le, Pe);
                }
              }
            }, AssignmentExpression(Y, le) {
              const Ee = Y.node.left;
              if (Ee.type === "Identifier") {
                const Se = (0, s.skipTransparentExprWrappers)(Y.get("right"));
                if (Fe(Se)) switch (Y.node.operator) {
                  case "=":
                  case "&&=":
                  case "||=":
                  case "??=":
                    ue(Se, le, Ee.name);
                }
              }
            }, AssignmentPattern(Y, le) {
              const Ee = Y.node.left;
              if (Ee.type === "Identifier") {
                const Se = (0, s.skipTransparentExprWrappers)(Y.get("right"));
                if (Fe(Se)) {
                  const Pe = Ee.name;
                  ue(Se, le, Pe);
                }
              }
            }, ObjectExpression(Y, le) {
              for (const Ee of Y.get("properties")) {
                if (!Ee.isObjectProperty()) continue;
                const { node: Se } = Ee, Pe = Se.key, Ve = (0, s.skipTransparentExprWrappers)(Ee.get("value"));
                if (Fe(Ve)) {
                  if (Se.computed) {
                    const Xe = te(Ee, Pe, le);
                    ue(Ve, le, Xe);
                  } else if (!ie(Pe)) if (Pe.type === "Identifier") ue(Ve, le, Pe.name);
                  else {
                    const Xe = i.types.stringLiteral(Pe.value + "");
                    ue(Ve, le, Xe);
                  }
                }
              }
            }, ClassPrivateProperty(Y, le) {
              const { node: Ee } = Y, Se = (0, s.skipTransparentExprWrappers)(Y.get("value"));
              if (Fe(Se)) {
                const Pe = i.types.stringLiteral("#" + Ee.key.id.name);
                ue(Se, le, Pe);
              }
            }, ClassAccessorProperty(Y, le) {
              const { node: Ee } = Y, Se = Ee.key, Pe = (0, s.skipTransparentExprWrappers)(Y.get("value"));
              if (Fe(Pe)) if (Ee.computed) {
                const Ve = te(Y, Se, le);
                ue(Pe, le, Ve);
              } else if (Se.type === "Identifier") ue(Pe, le, Se.name);
              else if (Se.type === "PrivateName") {
                const Ve = i.types.stringLiteral("#" + Se.id.name);
                ue(Pe, le, Ve);
              } else {
                const Ve = i.types.stringLiteral(Se.value + "");
                ue(Pe, le, Ve);
              }
            }, ClassProperty(Y, le) {
              const { node: Ee } = Y, Se = Ee.key, Pe = (0, s.skipTransparentExprWrappers)(Y.get("value"));
              if (Fe(Pe)) if (Ee.computed) {
                const Ve = te(Y, Se, le);
                ue(Pe, le, Ve);
              } else if (Se.type === "Identifier") ue(Pe, le, Se.name);
              else {
                const Ve = i.types.stringLiteral(Se.value + "");
                ue(Pe, le, Ve);
              }
            } };
          }(Ae, Be);
          function Be(Fe, ue, te) {
            var Y;
            if (se.has(Fe)) return;
            const { node: le } = Fe;
            te != null || (te = (Y = le.id) == null ? void 0 : Y.name);
            const Ee = function(Se, Pe, Ve, Xe, Ye, We, et) {
              var De, Me;
              const Qe = Se.get("body.body"), He = Se.node.decorators;
              let st = !1, it = !1, qe = !1;
              const rt = /* @__PURE__ */ function(tt) {
                let pt;
                return () => (pt || (pt = function(Ot) {
                  const Pt = [], Wt = /* @__PURE__ */ new Set();
                  return Ot.traverse({ PrivateName(Xt) {
                    Wt.add(Xt.node.id.name);
                  } }), () => {
                    let Xt;
                    do
                      m(Pt), Xt = String.fromCharCode(...Pt);
                    while (Wt.has(Xt));
                    return i.types.privateName(i.types.identifier(Xt));
                  };
                }(tt)), pt());
              }(Se), bt = [], dt = Se.scope.parent, Je = (tt, pt, Ot) => {
                const Pt = ce(dt, pt);
                return Ot.push(i.types.assignmentExpression("=", Pt, tt)), i.types.cloneNode(Pt);
              };
              let mt, ut;
              const Et = (De = Se.node.id) == null ? void 0 : De.name, Tt = typeof Ye == "object" ? Ye : void 0, St = (tt) => {
                try {
                  return i.types.traverseFast(tt, (pt) => {
                    if (i.types.isThisExpression(pt) || i.types.isSuper(pt) || i.types.isYieldExpression(pt) || i.types.isAwaitExpression(pt) || i.types.isIdentifier(pt, { name: "arguments" }) || Et && i.types.isIdentifier(pt, { name: Et }) || i.types.isMetaProperty(pt) && pt.meta.name !== "import") throw null;
                  }), !1;
                } catch {
                  return !0;
                }
              }, Vt = [];
              for (const tt of Qe) {
                if (!J(tt)) continue;
                const pt = tt.node;
                if (!pt.static && i.types.isPrivateName(pt.key) && Vt.push(pt.key.id.name), fe(pt)) {
                  switch (pt.type) {
                    case "ClassProperty":
                      We.ClassProperty(tt, Pe);
                      break;
                    case "ClassPrivateProperty":
                      We.ClassPrivateProperty(tt, Pe);
                      break;
                    case "ClassAccessorProperty":
                      if (We.ClassAccessorProperty(tt, Pe), et === "2023-11") break;
                    default:
                      pt.static ? ut != null || (ut = ce(dt, "initStatic")) : mt != null || (mt = ce(dt, "initProto"));
                  }
                  st = !0, qe || (qe = pt.decorators.some(St));
                } else if (pt.type === "ClassAccessorProperty") {
                  We.ClassAccessorProperty(tt, Pe);
                  const { key: Ot, value: Pt, static: Wt, computed: Xt } = pt, Ft = rt(), ht = g(Ft, Pt, Wt), rr = tt.get("key"), [sr] = tt.replaceWith(ht);
                  let wr, At;
                  Xt && !rr.isConstantExpression() ? (wr = (0, y.memoiseComputedKey)(V(Pe, Ot), dt, dt.generateUid("computedKey")), At = i.types.cloneNode(wr.left)) : (wr = i.types.cloneNode(Ot), At = i.types.cloneNode(Ot)), b(Se, Ye), v(Se.node.id, sr, wr, At, Ft, Xt, Wt, et);
                }
                "computed" in tt.node && tt.node.computed && (it || (it = !dt.isStatic(tt.node.key)));
              }
              if (!He && !st) return Se.node.id || typeof Ye != "string" || (Se.node.id = i.types.identifier(Ye)), void (Tt && Se.node.body.body.unshift(M([N(Pe, Tt)])));
              const Kt = [];
              let xt;
              const Jt = /* @__PURE__ */ new Set();
              let Mt, Bt, It = null;
              function jr(tt) {
                let pt = !1, Ot = !1;
                const Pt = [];
                for (const Wt of tt) {
                  const { expression: Xt } = Wt;
                  let Ft;
                  (et === "2023-11" || et === "2023-05") && i.types.isMemberExpression(Xt) && (i.types.isSuper(Xt.object) ? Ft = i.types.thisExpression() : dt.isStatic(Xt.object) ? Ft = i.types.cloneNode(Xt.object) : (It != null || (It = ce(dt, "obj")), Ft = i.types.assignmentExpression("=", i.types.cloneNode(It), Xt.object), Xt.object = i.types.cloneNode(It))), Pt.push(Ft), pt || (pt = !dt.isStatic(Xt)), Ot || (Ot = St(Wt));
                }
                return { hasSideEffects: pt, usesFnContext: Ot, decoratorsThis: Pt };
              }
              const Cn = it || qe || et !== "2023-11";
              let an, Fr, En = !1, dn = 0, on = [], vr = [];
              if (He) {
                Mt = ce(dt, "initClass"), En = Se.isClassDeclaration(), { id: Bt, path: Se } = function(Ft, ht) {
                  const rr = Ft.node.id, sr = Ft.scope;
                  if (Ft.type === "ClassDeclaration") {
                    const wr = rr.name, At = sr.generateUidIdentifierBasedOnNode(rr), Er = i.types.identifier(wr);
                    return sr.rename(wr, At.name), Ft.get("id").replaceWith(Er), { id: i.types.cloneNode(At), path: Ft };
                  }
                  {
                    let wr;
                    rr ? (ht = rr.name, wr = ce(sr.parent, ht), sr.rename(ht, wr.name)) : wr = ce(sr.parent, typeof ht == "string" ? ht : "decorated_class");
                    const At = i.types.classExpression(typeof ht == "string" ? i.types.identifier(ht) : null, Ft.node.superClass, Ft.node.body), [Er] = Ft.replaceWith(i.types.sequenceExpression([At, wr]));
                    return { id: i.types.cloneNode(wr), path: Er.get("expressions.0") };
                  }
                }(Se, Ye), Se.node.decorators = null;
                const tt = He.some(X), { hasSideEffects: pt, usesFnContext: Ot, decoratorsThis: Pt } = jr(He), { haveThis: Wt, decs: Xt } = W(He, Pt, et);
                if (dn = Wt ? 1 : 0, on = Xt, (Ot || pt && Cn || tt) && (an = Je(i.types.arrayExpression(on), "classDecs", bt)), !st) for (const Ft of Se.get("body.body")) {
                  const { node: ht } = Ft;
                  if ("computed" in ht && ht.computed) if (Ft.isClassProperty({ static: !0 })) {
                    if (!Ft.get("key").isConstantExpression()) {
                      const rr = ht.key, sr = (0, y.memoiseComputedKey)(rr, dt, dt.generateUid("computedKey"));
                      sr != null && (ht.key = i.types.cloneNode(sr.left), vr.push(sr));
                    }
                  } else vr.length > 0 && (D(vr, Ft), vr = []);
                }
              } else b(Se, Ye), Bt = i.types.cloneNode(Se.node.id);
              let Vn = !1, Cr = [], br = [];
              if (st) {
                if (mt) {
                  const tt = i.types.callExpression(i.types.cloneNode(mt), [i.types.thisExpression()]);
                  Cr.push(tt);
                }
                for (const tt of Qe) {
                  if (!J(tt)) {
                    br.length > 0 && tt.isStaticBlock() && (I(br, tt), br = []);
                    continue;
                  }
                  const { node: pt } = tt, Ot = pt.decorators, Pt = !(Ot == null || !Ot.length), Wt = "computed" in pt && pt.computed;
                  let Xt, Ft, ht = "computedKey";
                  if (pt.key.type === "PrivateName" ? ht = pt.key.id.name : Wt || pt.key.type !== "Identifier" || (ht = pt.key.name), Pt) {
                    const { hasSideEffects: On, usesFnContext: Sn, decoratorsThis: fr } = jr(Ot), { decs: en, haveThis: bi } = W(Ot, fr, et);
                    Ft = bi, Xt = en.length === 1 ? en[0] : i.types.arrayExpression(en), (Sn || On && Cn) && (Xt = Je(Xt, ht + "Decs", vr));
                  }
                  if (Wt && !tt.get("key").isConstantExpression()) {
                    const On = pt.key, Sn = (0, y.memoiseComputedKey)(Pt ? V(Pe, On) : On, dt, dt.generateUid("computedKey"));
                    Sn != null && (He && tt.isClassProperty({ static: !0 }) ? (pt.key = i.types.cloneNode(Sn.left), vr.push(Sn)) : pt.key = Sn);
                  }
                  const { key: rr, static: sr } = pt, wr = rr.type === "PrivateName", At = P(tt);
                  let Er;
                  if (wr && !sr && (Pt && (Vn = !0), !i.types.isClassPrivateProperty(pt) && Fr || (Fr = rr)), tt.isClassMethod({ kind: "constructor" }) && (xt = tt), Pt) {
                    let On, Sn;
                    if (Sn = Wt ? O(tt.get("key")) : rr.type === "PrivateName" ? i.types.stringLiteral(rr.id.name) : rr.type === "Identifier" ? i.types.stringLiteral(rr.name) : i.types.cloneNode(rr), At === _) {
                      const { value: fr } = tt.node, en = et === "2023-11" && sr ? [] : [i.types.thisExpression()];
                      fr && en.push(i.types.cloneNode(fr));
                      const bi = rt(), fa = ce(dt, `init_${ht}`), So = g(bi, i.types.callExpression(i.types.cloneNode(fa), en), sr), [Lt] = tt.replaceWith(So);
                      if (wr) {
                        On = T(bi, et);
                        const ii = ce(dt, `get_${ht}`), Ci = ce(dt, `set_${ht}`);
                        B(et, Lt, rr, ii, Ci, sr), Er = [fa, ii, Ci];
                      } else b(Se, Ye), v(Se.node.id, Lt, i.types.cloneNode(rr), i.types.isAssignmentExpression(rr) ? i.types.cloneNode(rr.left) : i.types.cloneNode(rr), bi, Wt, sr, et), Er = [fa];
                    } else if (At === x) {
                      const fr = ce(dt, `init_${ht}`), en = tt.get("value"), bi = et === "2023-11" && sr ? [] : [i.types.thisExpression()];
                      en.node && bi.push(en.node), en.replaceWith(i.types.callExpression(i.types.cloneNode(fr), bi)), Er = [fr], wr && (On = T(rr, et));
                    } else if (wr) {
                      const fr = ce(dt, `call_${ht}`);
                      if (Er = [fr], new c.default({ constantSuper: Ve, methodPath: tt, objectRef: Bt, superRef: Se.node.superClass, file: Pe.file, refToPreserve: Bt }).replace(), On = [G(tt.node)], At === C || At === R) Q(tt, i.types.cloneNode(rr), i.types.cloneNode(fr), sr);
                      else {
                        const en = tt.node;
                        Se.node.body.body.unshift(i.types.classPrivateProperty(rr, i.types.cloneNode(fr), [], en.static)), Jt.add(rr.id.name), tt.remove();
                      }
                    }
                    Kt.push({ kind: At, decoratorsArray: Xt, decoratorsHaveThis: Ft, name: Sn, isStatic: sr, privateMethods: On, locals: Er }), tt.node && (tt.node.decorators = null);
                  }
                  if (Wt && vr.length > 0 && (He && tt.isClassProperty({ static: !0 }) || (D(vr, At === _ ? tt.getNextSibling() : tt), vr = [])), Cr.length > 0 && !sr && (At === x || At === _) && ($(Cr, tt), Cr = []), br.length > 0 && sr && (At === x || At === _) && ($(br, tt), br = []), Pt && et === "2023-11" && (At === x || At === _)) {
                    const On = ce(dt, `init_extra_${ht}`);
                    Er.push(On);
                    const Sn = i.types.callExpression(i.types.cloneNode(On), sr ? [] : [i.types.thisExpression()]);
                    sr ? br.push(Sn) : Cr.push(Sn);
                  }
                }
              }
              if (vr.length > 0) {
                const tt = Se.get("body.body");
                let pt;
                for (let Ot = tt.length - 1; Ot >= 0; Ot--) {
                  const Pt = tt[Ot], Wt = Pt.node;
                  if (Wt.computed) {
                    if (He && i.types.isClassProperty(Wt, { static: !0 })) continue;
                    pt = Pt;
                    break;
                  }
                }
                pt != null && (function(Ot, Pt) {
                  const Wt = Pt.get("key"), Xt = E(Wt);
                  if (Xt.isConstantExpression()) D(Ot, Pt);
                  else {
                    const Ft = Wt.scope.parent, ht = (0, y.memoiseComputedKey)(Xt.node, Ft, Ft.generateUid("computedKey"));
                    if (ht) {
                      const rr = [...Ot, i.types.cloneNode(ht.left)], sr = Xt.parentPath;
                      sr.isSequenceExpression() ? sr.pushContainer("expressions", rr) : Xt.replaceWith(re([i.types.cloneNode(ht), ...rr]));
                    } else D(Ot, Pt);
                  }
                }(vr, pt), vr = []);
              }
              if (Cr.length > 0) {
                const tt = !!Se.node.superClass;
                xt ? tt ? function(pt, Ot, Pt) {
                  Ot.traverse({ CallExpression: { exit(Wt) {
                    if (!Wt.get("callee").isSuper()) return;
                    const Xt = [Wt.node, ...pt.map((Ft) => i.types.cloneNode(Ft))];
                    Wt.isCompletionRecord() && Xt.push(i.types.thisExpression()), Wt.replaceWith(function(Ft, ht) {
                      if (ht) {
                        if (Ft.length >= 2 && k(Ft[1], ht)) {
                          const rr = i.types.callExpression(i.types.cloneNode(ht), [Ft[0]]);
                          Ft.splice(0, 2, rr);
                        }
                        Ft.length >= 2 && i.types.isThisExpression(Ft[Ft.length - 1]) && k(Ft[Ft.length - 2], ht) && Ft.splice(Ft.length - 1, 1);
                      }
                      return re(Ft);
                    }(Xt, Pt)), Wt.skip();
                  } }, ClassMethod(Wt) {
                    Wt.node.kind === "constructor" && Wt.skip();
                  } });
                }(Cr, xt, mt) : function(pt, Ot) {
                  Ot.node.body.body.unshift(i.types.expressionStatement(re(pt)));
                }(Cr, xt) : Se.node.body.body.unshift(L(Cr, tt)), Cr = [];
              }
              br.length > 0 && (Se.node.body.body.push(M(br)), br = []);
              const _n = (Dr = Kt, [...Dr.filter((tt) => tt.isStatic && tt.kind >= _ && tt.kind <= R), ...Dr.filter((tt) => !tt.isStatic && tt.kind >= _ && tt.kind <= R), ...Dr.filter((tt) => tt.isStatic && tt.kind === x), ...Dr.filter((tt) => !tt.isStatic && tt.kind === x)]), In = function(tt, pt) {
                return i.types.arrayExpression(tt.map((Ot) => {
                  let Pt = Ot.kind;
                  return Ot.isStatic && (Pt += pt === "2023-11" || pt === "2023-05" ? z : H), Ot.decoratorsHaveThis && (Pt += U), i.types.arrayExpression([Ot.decoratorsArray, i.types.numericLiteral(Pt), Ot.name, ...Ot.privateMethods || []]);
                }));
              }(et === "2023-11" ? Kt : _n, et), pn = function(tt) {
                const pt = [];
                for (const Ot of tt) {
                  const { locals: Pt } = Ot;
                  Array.isArray(Pt) ? pt.push(...Pt) : Pt !== void 0 && pt.push(Pt);
                }
                return pt;
              }(_n);
              var Dr;
              mt && pn.push(mt), ut && pn.push(ut);
              const Wn = [];
              let yi = !1;
              const ri = Mt && i.types.callExpression(i.types.cloneNode(Mt), []);
              let Nt = Se;
              const Pi = Se.node, ps = [];
              if (He) {
                Wn.push(Bt, Mt);
                const tt = [];
                if (Se.get("body.body").forEach((pt) => {
                  if (pt.isStaticBlock()) {
                    if (K(pt, Vt)) {
                      const Pt = Je((Ot = pt.node, i.types.functionExpression(null, [], i.types.blockStatement(Ot.body))), "staticBlock", ps);
                      br.push(i.types.callExpression(i.types.memberExpression(Pt, i.types.identifier("call")), [i.types.thisExpression()]));
                    } else br.push(function(Pt) {
                      return i.types.callExpression(i.types.arrowFunctionExpression([], i.types.blockStatement(Pt.body)), []);
                    }(pt.node));
                    pt.remove();
                  } else {
                    var Ot;
                    if ((pt.isClassProperty() || pt.isClassPrivateProperty()) && pt.node.static) {
                      const Pt = pt.get("value");
                      if (K(Pt, Vt)) {
                        const Wt = Je(function(Xt) {
                          return i.types.functionExpression(null, [], i.types.blockStatement([i.types.returnStatement(Xt)]));
                        }(Pt.node), "fieldValue", ps);
                        Pt.replaceWith(i.types.callExpression(i.types.memberExpression(Wt, i.types.identifier("call")), [i.types.thisExpression()]));
                      }
                      br.length > 0 && ($(br, pt), br = []), pt.node.static = !1, tt.push(pt.node), pt.remove();
                    } else if (pt.isClassPrivateMethod({ static: !0 })) {
                      if (K(pt, Vt)) {
                        new c.default({ constantSuper: Ve, methodPath: pt, objectRef: Bt, superRef: Se.node.superClass, file: Pe.file, refToPreserve: Bt }).replace();
                        const Pt = Je(G(pt.node), pt.get("key.id").node.name, ps);
                        Xe ? (pt.node.params = [i.types.restElement(i.types.identifier("arg"))], pt.node.body = i.types.blockStatement([i.types.returnStatement(i.types.callExpression(i.types.memberExpression(Pt, i.types.identifier("apply")), [i.types.thisExpression(), i.types.identifier("arg")]))])) : (pt.node.params = pt.node.params.map((Wt, Xt) => i.types.isRestElement(Wt) ? i.types.restElement(i.types.identifier("arg")) : i.types.identifier("_" + Xt)), pt.node.body = i.types.blockStatement([i.types.returnStatement(i.types.callExpression(i.types.memberExpression(Pt, i.types.identifier("apply")), [i.types.thisExpression(), i.types.identifier("arguments")]))]));
                      }
                      pt.node.static = !1, tt.push(pt.node), pt.remove();
                    }
                  }
                }), tt.length > 0 || br.length > 0) {
                  const pt = i.template.expression.ast`
        class extends ${Pe.addHelper("identity")} {}
      `;
                  pt.body.body = [i.types.classProperty(i.types.toExpression(Pi), void 0, void 0, void 0, !0, !0), ...tt];
                  const Ot = [], Pt = i.types.newExpression(pt, []);
                  br.length > 0 && Ot.push(...br), ri && (yi = !0, Ot.push(ri)), Ot.length > 0 ? (Ot.unshift(i.types.callExpression(i.types.super(), [i.types.cloneNode(Bt)])), pt.body.body.push(L(Ot, !1))) : Pt.arguments.push(i.types.cloneNode(Bt));
                  const [Wt] = Se.replaceWith(Pt);
                  Nt = Wt.get("callee").get("body").get("body.0.key");
                }
              }
              !yi && ri && Se.node.body.body.push(i.types.staticBlock([i.types.expressionStatement(ri)]));
              let { superClass: Gs } = Pi;
              if (Gs && (et === "2023-11" || et === "2023-05")) {
                const tt = Se.scope.maybeGenerateMemoised(Gs);
                tt && (Pi.superClass = i.types.assignmentExpression("=", tt, Gs), Gs = tt);
              }
              const ca = i.types.staticBlock([]);
              Pi.body.body.unshift(ca);
              const ni = ca.body;
              if (vr.length > 0) {
                const tt = Nt.get("body.body");
                let pt;
                for (const Ot of tt) if ((Ot.isClassProperty() || Ot.isClassMethod()) && Ot.node.kind !== "constructor") {
                  pt = Ot;
                  break;
                }
                pt != null ? (function(Ot) {
                  const { node: Pt } = Ot;
                  Pt.computed = !0, i.types.isIdentifier(Pt.key) && (Pt.key = i.types.stringLiteral(Pt.key.name));
                }(pt), D(vr, pt)) : (Pi.body.body.unshift(i.types.classProperty(i.types.sequenceExpression([...vr, i.types.stringLiteral("_")]), void 0, void 0, void 0, !0, !0)), ni.push(i.types.expressionStatement(i.types.unaryExpression("delete", i.types.memberExpression(i.types.thisExpression(), i.types.identifier("_")))))), vr = [];
              }
              if (ni.push(i.types.expressionStatement(function(tt, pt, Ot, Pt, Wt, Xt, Ft, ht, rr, sr) {
                let wr, At;
                const Er = [Ft ? N(rr, Ft) : i.types.thisExpression(), Pt, Ot];
                return sr !== "2023-11" && Er.splice(1, 2, Ot, Pt), sr === "2021-12" || sr === "2022-03" && !rr.availableHelper("applyDecs2203R") ? (wr = i.types.arrayPattern([...tt, ...pt]), At = i.types.callExpression(rr.addHelper(sr === "2021-12" ? "applyDecs" : "applyDecs2203"), Er), i.types.assignmentExpression("=", wr, At)) : (sr === "2022-03" ? At = i.types.callExpression(rr.addHelper("applyDecs2203R"), Er) : sr === "2023-01" ? (Xt && Er.push(F(Xt)), At = i.types.callExpression(rr.addHelper("applyDecs2301"), Er)) : sr === "2023-05" && ((Xt || ht || Wt.value !== 0) && Er.push(Wt), Xt ? Er.push(F(Xt)) : ht && Er.push(i.types.unaryExpression("void", i.types.numericLiteral(0))), ht && Er.push(ht), At = i.types.callExpression(rr.addHelper("applyDecs2305"), Er)), sr === "2023-11" && ((Xt || ht || Wt.value !== 0) && Er.push(Wt), Xt ? Er.push(F(Xt)) : ht && Er.push(i.types.unaryExpression("void", i.types.numericLiteral(0))), ht && Er.push(ht), At = i.types.callExpression(rr.addHelper("applyDecs2311"), Er)), tt.length > 0 ? pt.length > 0 ? wr = i.types.objectPattern([i.types.objectProperty(i.types.identifier("e"), i.types.arrayPattern(tt)), i.types.objectProperty(i.types.identifier("c"), i.types.arrayPattern(pt))]) : (wr = i.types.arrayPattern(tt), At = i.types.memberExpression(At, i.types.identifier("e"), !1, !1)) : (wr = i.types.arrayPattern(pt), At = i.types.memberExpression(At, i.types.identifier("c"), !1, !1)), i.types.assignmentExpression("=", wr, At));
              }(pn, Wn, In, (Me = an) != null ? Me : i.types.arrayExpression(on), i.types.numericLiteral(dn), Vn ? Fr : null, Tt, i.types.cloneNode(Gs), Pe, et))), ut && ni.push(i.types.expressionStatement(i.types.callExpression(i.types.cloneNode(ut), [i.types.thisExpression()]))), ps.length > 0 && ni.push(...ps.map((tt) => i.types.expressionStatement(tt))), Se.insertBefore(bt.map((tt) => i.types.expressionStatement(tt))), En)
                if (dt.getBinding(Bt.name).constantViolations.length) {
                  const tt = dt.generateUidIdentifier("t" + Bt.name), pt = Bt;
                  Se.replaceWithMultiple([i.types.variableDeclaration("let", [i.types.variableDeclarator(i.types.cloneNode(pt)), i.types.variableDeclarator(tt)]), i.types.blockStatement([i.types.variableDeclaration("let", [i.types.variableDeclarator(i.types.cloneNode(Bt))]), Se.node, i.types.expressionStatement(i.types.assignmentExpression("=", i.types.cloneNode(tt), i.types.cloneNode(Bt)))]), i.types.expressionStatement(i.types.assignmentExpression("=", i.types.cloneNode(pt), i.types.cloneNode(tt)))]);
                } else Se.insertBefore(i.types.variableDeclaration("let", [i.types.variableDeclarator(i.types.cloneNode(Bt))]));
              return Jt.size > 0 && function(tt, pt) {
                const Ot = (0, o.privateNameVisitorFactory)({ PrivateName(Wt, Xt) {
                  if (!Xt.privateNamesMap.has(Wt.node.id.name)) return;
                  const Ft = Wt.parentPath, ht = Ft.parentPath;
                  if (ht.node.type === "AssignmentExpression" && ht.node.left === Ft.node || ht.node.type === "UpdateExpression" || ht.node.type === "RestElement" || ht.node.type === "ArrayPattern" || ht.node.type === "ObjectProperty" && ht.node.value === Ft.node && ht.parentPath.type === "ObjectPattern" || ht.node.type === "ForOfStatement" && ht.node.left === Ft.node) throw Wt.buildCodeFrameError(`Decorated private methods are read-only, but "#${Wt.node.id.name}" is updated via this expression.`);
                } }), Pt = /* @__PURE__ */ new Map();
                for (const Wt of pt) Pt.set(Wt, null);
                tt.traverse(Ot, { privateNamesMap: Pt });
              }(Se, Jt), Se.scope.crawl(), Se;
            }(Fe, ue, be, Ie, te, Oe, me);
            Ee ? se.add(Ee) : se.add(Fe);
          }
          return { name: "proposal-decorators", inherits: ye, visitor: Object.assign({ ExportDefaultDeclaration(Fe, ue) {
            const { declaration: te } = Fe.node;
            if ((te == null ? void 0 : te.type) === "ClassDeclaration" && fe(te)) {
              const Y = !te.id, le = (0, f.default)(Fe);
              Y && Be(le, ue, i.types.stringLiteral("default"));
            }
          }, ExportNamedDeclaration(Fe) {
            const { declaration: ue } = Fe.node;
            (ue == null ? void 0 : ue.type) === "ClassDeclaration" && fe(ue) && (0, f.default)(Fe);
          }, Class(Fe, ue) {
            Be(Fe, ue, void 0);
          } }, Oe) };
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-replace-supers@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-replace-supers/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.24.7/node_modules/@babel/helper-split-export-declaration/lib/index.js"), s = u("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.24.7/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), o = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), y = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js");
        function m(ee, ae = ee.length - 1) {
          if (ae === -1) return void ee.unshift(65);
          const oe = ee[ae];
          oe === 90 ? ee[ae] = 97 : oe === 122 ? (ee[ae] = 65, m(ee, ae - 1)) : ee[ae] = oe + 1;
        }
        function g(ee, ae, oe) {
          return ee.type === "PrivateName" ? i.types.classPrivateProperty(ee, ae, void 0, oe) : i.types.classProperty(ee, ae, void 0, void 0, oe);
        }
        function b(ee, ae) {
          ee.node.id || (ee.node.id = typeof ae == "string" ? i.types.identifier(ae) : ee.scope.generateUidIdentifier("Class"));
        }
        function v(ee, ae, oe, me, ye, we, ge, se) {
          const be = se !== "2023-11" && se !== "2023-05" || !ge ? i.types.thisExpression() : ee, Ie = i.types.blockStatement([i.types.returnStatement(i.types.memberExpression(i.types.cloneNode(be), i.types.cloneNode(ye)))]), Oe = i.types.blockStatement([i.types.expressionStatement(i.types.assignmentExpression("=", i.types.memberExpression(i.types.cloneNode(be), i.types.cloneNode(ye)), i.types.identifier("v")))]);
          let Be, Fe;
          oe.type === "PrivateName" ? (Be = i.types.classPrivateMethod("get", oe, [], Ie, ge), Fe = i.types.classPrivateMethod("set", me, [i.types.identifier("v")], Oe, ge)) : (Be = i.types.classMethod("get", oe, [], Ie, we, ge), Fe = i.types.classMethod("set", me, [i.types.identifier("v")], Oe, we, ge)), ae.insertAfter(Fe), ae.insertAfter(Be);
        }
        function T(ee, ae) {
          return ae !== "2023-11" && ae !== "2023-05" && ae !== "2023-01" ? [i.template.expression.ast`
        function () {
          return this.${i.types.cloneNode(ee)};
        }
      `, i.template.expression.ast`
        function (value) {
          this.${i.types.cloneNode(ee)} = value;
        }
      `] : [i.template.expression.ast`
      o => o.${i.types.cloneNode(ee)}
    `, i.template.expression.ast`
      (o, v) => o.${i.types.cloneNode(ee)} = v
    `];
        }
        function E(ee) {
          if ((ee = (0, s.skipTransparentExprWrappers)(ee)).isSequenceExpression()) {
            const ae = ee.get("expressions");
            return E(ae[ae.length - 1]);
          }
          return ee;
        }
        function O(ee) {
          const ae = E(ee);
          if (ae.isConstantExpression() || ae.isIdentifier() && ee.scope.hasUid(ae.node.name)) return i.types.cloneNode(ee.node);
          if (ae.isAssignmentExpression() && ae.get("left").isIdentifier()) return i.types.cloneNode(ae.node.left);
          throw new Error(`Internal Error: the computed key ${ee.toString()} has not yet been memoised.`);
        }
        function D(ee, ae) {
          const oe = ae.get("key");
          oe.isSequenceExpression() ? ee.push(...oe.node.expressions) : ee.push(oe.node), oe.replaceWith(re(ee));
        }
        function $(ee, ae) {
          const oe = ae.get("value");
          oe.node ? ee.push(oe.node) : ee.length > 0 && (ee[ee.length - 1] = i.types.unaryExpression("void", ee[ee.length - 1])), oe.replaceWith(re(ee));
        }
        function I(ee, ae) {
          ae.unshiftContainer("body", i.types.expressionStatement(re(ee)));
        }
        function k(ee, ae) {
          return i.types.isCallExpression(ee) && i.types.isIdentifier(ee.callee, { name: ae.name });
        }
        function L(ee, ae) {
          const oe = [i.types.expressionStatement(re(ee))];
          return ae && oe.unshift(i.types.expressionStatement(i.types.callExpression(i.types.super(), [i.types.spreadElement(i.types.identifier("args"))]))), i.types.classMethod("constructor", i.types.identifier("constructor"), ae ? [i.types.restElement(i.types.identifier("args"))] : [], i.types.blockStatement(oe));
        }
        function M(ee) {
          return i.types.staticBlock([i.types.expressionStatement(re(ee))]);
        }
        const x = 0, _ = 1, S = 2, C = 3, R = 4, H = 5, z = 8, U = 16;
        function P(ee) {
          switch (ee.node.type) {
            case "ClassProperty":
            case "ClassPrivateProperty":
              return x;
            case "ClassAccessorProperty":
              return _;
            case "ClassMethod":
            case "ClassPrivateMethod":
              return ee.node.kind === "get" ? C : ee.node.kind === "set" ? R : S;
          }
        }
        function W(ee, ae, oe) {
          const me = ee.length, ye = ae.some(Boolean), we = [];
          for (let ge = 0; ge < me; ge++) oe !== "2023-11" && oe !== "2023-05" || !ye || we.push(ae[ge] || i.types.unaryExpression("void", i.types.numericLiteral(0))), we.push(ee[ge].expression);
          return { haveThis: ye, decs: we };
        }
        function B(ee, ae, oe, me, ye, we) {
          ae.insertAfter(i.types.classPrivateMethod("get", i.types.cloneNode(oe), [], i.types.blockStatement([i.types.returnStatement(i.types.callExpression(i.types.cloneNode(me), ee === "2023-11" && we ? [] : [i.types.thisExpression()]))]), we)), ae.insertAfter(i.types.classPrivateMethod("set", i.types.cloneNode(oe), [i.types.identifier("v")], i.types.blockStatement([i.types.expressionStatement(i.types.callExpression(i.types.cloneNode(ye), ee === "2023-11" && we ? [i.types.identifier("v")] : [i.types.thisExpression(), i.types.identifier("v")]))]), we));
        }
        function Q(ee, ae, oe, me) {
          let ye, we;
          ee.node.kind === "set" ? (ye = [i.types.identifier("v")], we = [i.types.expressionStatement(i.types.callExpression(oe, [i.types.thisExpression(), i.types.identifier("v")]))]) : (ye = [], we = [i.types.returnStatement(i.types.callExpression(oe, [i.types.thisExpression()]))]), ee.replaceWith(i.types.classPrivateMethod(ee.node.kind, i.types.cloneNode(ae), ye, i.types.blockStatement(we), me));
        }
        function J(ee) {
          const { type: ae } = ee;
          return ae !== "TSDeclareMethod" && ae !== "TSIndexSignature" && ae !== "StaticBlock";
        }
        function re(ee) {
          return ee.length === 0 ? i.types.unaryExpression("void", i.types.numericLiteral(0)) : ee.length === 1 ? ee[0] : i.types.sequenceExpression(ee);
        }
        function G(ee) {
          const { params: ae, body: oe, generator: me, async: ye } = ee;
          return i.types.functionExpression(void 0, ae, oe, me, ye);
        }
        function N(ee, ae) {
          return i.types.callExpression(ee.addHelper("setFunctionName"), [i.types.thisExpression(), ae]);
        }
        function V(ee, ae) {
          return i.types.callExpression(ee.addHelper("toPropertyKey"), [ae]);
        }
        function F(ee) {
          return i.types.arrowFunctionExpression([i.types.identifier("_")], i.types.binaryExpression("in", i.types.cloneNode(ee), i.types.identifier("_")));
        }
        function X(ee) {
          try {
            return i.types.traverseFast(ee, (ae) => {
              if (i.types.isPrivateName(ae)) throw null;
            }), !1;
          } catch {
            return !0;
          }
        }
        function K(ee, ae) {
          let oe = !1;
          if (ae.length > 0) {
            const me = (0, o.privateNameVisitorFactory)({ PrivateName(we, ge) {
              ge.privateNamesMap.has(we.node.id.name) && (oe = !0, we.stop());
            } }), ye = /* @__PURE__ */ new Map();
            for (const we of ae) ye.set(we, null);
            ee.traverse(me, { privateNamesMap: ye });
          }
          return oe;
        }
        function ie(ee) {
          return ee.type === "Identifier" ? ee.name === "__proto__" : ee.value === "__proto__";
        }
        function fe(ee) {
          return ee.decorators && ee.decorators.length > 0;
        }
        function _e(ee) {
          switch (ee.type) {
            case "ClassAccessorProperty":
              return !0;
            case "ClassMethod":
            case "ClassProperty":
            case "ClassPrivateMethod":
            case "ClassPrivateProperty":
              return fe(ee);
            default:
              return !1;
          }
        }
        function Ae(ee) {
          return ee.isClassExpression({ id: null }) && (fe(ae = ee.node) || ae.body.body.some(_e));
          var ae;
        }
        function ce(ee, ae) {
          const oe = ee.generateUidIdentifier(ae);
          return ee.push({ id: oe, kind: "let" }), i.types.cloneNode(oe);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/features.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.FEATURES = void 0, n.enableFeature = function(E, O, D) {
          b(E, O) && !m(E, O) || (E.set(s, E.get(s) | O), D === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (T(E, O, !0), E.set(y, E.get(y) | O)) : D === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (T(E, O, !1), E.set(y, E.get(y) | O)) : T(E, O, D));
          let $;
          for (const [k, L] of f) {
            if (!b(E, k) || m(E, k)) continue;
            const M = v(E, k);
            if ($ === !M) throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + g(E));
            $ = M;
            var I = L;
          }
          if ($ !== void 0) for (const [k, L] of f) b(E, k) && v(E, k) !== $ && (T(E, k, $), console.warn(`Though the "loose" option was set to "${!$}" in your @babel/preset-env config, it will not be used for ${L} since the "loose" mode option was set to "${$}" for ${I}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${L}", { "loose": ${$} }]
to the "plugins" section of your Babel config.

` + g(E)));
        }, n.isLoose = v, n.shouldTransform = function(E, O) {
          let D = null, $ = null, I = null, k = null, L = null;
          (0, i.hasOwnDecorators)(E.node) && (D = E.get("decorators.0"));
          for (const M of E.get("body.body")) !D && (0, i.hasOwnDecorators)(M.node) && (D = M.get("decorators.0")), !$ && M.isClassProperty() && ($ = M), !I && M.isClassPrivateProperty() && (I = M), !k && M.isClassPrivateMethod != null && M.isClassPrivateMethod() && (k = M), !L && M.isStaticBlock != null && M.isStaticBlock() && (L = M);
          if (D && I) throw I.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
          if (D && k) throw k.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
          if (D && !b(O, c.decorators)) throw E.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
          if (k && !b(O, c.privateMethods)) throw k.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
          if (($ || I) && !b(O, c.fields) && !b(O, c.privateMethods)) throw E.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
          if (L && !b(O, c.staticBlocks)) throw E.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
          return !!(D || k || L || ($ || I) && b(O, c.fields));
        };
        var i = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js");
        const c = n.FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 }), f = /* @__PURE__ */ new Map([[c.fields, "@babel/plugin-transform-class-properties"], [c.privateMethods, "@babel/plugin-transform-private-methods"], [c.privateIn, "@babel/plugin-transform-private-property-in-object"]]), s = "@babel/plugin-class-features/featuresKey", o = "@babel/plugin-class-features/looseKey";
        var y = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing", m = function(E, O) {
          return !!(E.get(y) & O);
        };
        function g(E) {
          let { filename: O } = E.opts;
          return O && O !== "unknown" || (O = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${O} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
        }
        function b(E, O) {
          return !!(E.get(s) & O);
        }
        function v(E, O) {
          return !!(E.get(o) & O);
        }
        function T(E, O, D) {
          D ? E.set(o, E.get(o) | O) : E.set(o, E.get(o) & ~O), E.set(y, E.get(y) & ~O);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.buildCheckInRHS = O, n.buildFieldsInitNodes = function(F, X, K, ie, fe, _e, Ae, ce, ee, ae) {
          var oe;
          let me, ye = 0;
          const we = [], ge = [];
          let se = !1;
          const be = [];
          let Ie = null;
          const Oe = i.types.isIdentifier(X) ? () => X : () => (me != null || (me = K[0].scope.generateUidIdentifierBasedOnNode(X)), me), Be = (oe = F) != null ? oe : K[0].scope.generateUidIdentifier((ae == null ? void 0 : ae.name) || "Class");
          F != null || (F = i.types.cloneNode(ae));
          for (const Fe of K) {
            Fe.isClassProperty() && g.assertFieldTransformed(Fe);
            const ue = !(i.types.isStaticBlock != null && i.types.isStaticBlock(Fe.node)) && Fe.node.static, te = !ue, Y = Fe.isPrivate(), le = !Y, Ee = Fe.isProperty(), Se = !Ee, Pe = Fe.isStaticBlock == null ? void 0 : Fe.isStaticBlock();
            switch (ue && (ye |= 1), (ue || Se && Y || Pe) && (new c.default({ methodPath: Fe, constantSuper: ee, file: fe, refToPreserve: ae, getSuperRef: Oe, getObjectRef: () => (ye |= 2, ue || Pe ? Be : i.types.memberExpression(Be, i.types.identifier("prototype"))) }).replace(), re(Fe, Be, ae) && (ye |= 2)), se = !1, !0) {
              case Pe: {
                const Ve = Fe.node.body;
                Ve.length === 1 && i.types.isExpressionStatement(Ve[0]) ? we.push(N(Ve[0], Fe)) : we.push(i.types.inheritsComments(i.template.statement.ast`(() => { ${Ve} })()`, Fe.node));
                break;
              }
              case (ue && Y && Ee && Ae):
                we.push(_(i.types.cloneNode(F), Fe, ie));
                break;
              case (ue && Y && Ee && !Ae):
                b(fe) ? we.push(C(Fe, ie, ce)) : we.push(R(Fe, ie));
                break;
              case (ue && le && Ee && _e):
                if (!G(Fe.node)) {
                  we.push(U(i.types.cloneNode(F), Fe));
                  break;
                }
              case (ue && le && Ee && !_e):
                we.push(P(i.types.cloneNode(F), Fe, fe));
                break;
              case (te && Y && Ee && Ae):
                ge.push(_(i.types.thisExpression(), Fe, ie));
                break;
              case (te && Y && Ee && !Ae):
                ge.push(S(i.types.thisExpression(), Fe, ie, fe));
                break;
              case (te && Y && Se && Ae):
                ge.unshift(H(i.types.thisExpression(), Fe, ie)), be.push(B(fe, Fe, ie, Ae));
                break;
              case (te && Y && Se && !Ae):
                ge.unshift(z(i.types.thisExpression(), Fe, ie, fe)), be.push(B(fe, Fe, ie, Ae));
                break;
              case (ue && Y && Se && !Ae):
                b(fe) || we.unshift(R(Fe, ie)), be.push(B(fe, Fe, ie, Ae));
                break;
              case (ue && Y && Se && Ae):
                we.unshift(W(i.types.cloneNode(F), Fe, fe, ie)), be.push(B(fe, Fe, ie, Ae));
                break;
              case (te && le && Ee && _e):
                ge.push(U(i.types.thisExpression(), Fe));
                break;
              case (te && le && Ee && !_e):
                se = !0, ge.push(P(i.types.thisExpression(), Fe, fe));
                break;
              default:
                throw new Error("Unreachable.");
            }
          }
          return 2 & ye && ae != null && (Ie = i.types.expressionStatement(i.types.assignmentExpression("=", i.types.cloneNode(Be), i.types.cloneNode(ae)))), { staticNodes: we.filter(Boolean), instanceNodes: ge.filter(Boolean), lastInstanceNodeReturnsThis: se, pureStaticNodes: be.filter(Boolean), classBindingNode: Ie, wrapClass(Fe) {
            for (const ue of K) ue.node.leadingComments = null, ue.remove();
            return me && (Fe.scope.push({ id: i.types.cloneNode(me) }), Fe.set("superClass", i.types.assignmentExpression("=", me, Fe.node.superClass))), ye !== 0 && (Fe.isClassExpression() ? (Fe.scope.push({ id: F }), Fe.replaceWith(i.types.assignmentExpression("=", i.types.cloneNode(F), Fe.node))) : (ae == null && (Fe.node.id = F), Ie != null && Fe.scope.push({ id: Be }))), Fe;
          } };
        }, n.buildPrivateNamesMap = function(F, X, K, ie) {
          const fe = /* @__PURE__ */ new Map();
          let _e;
          for (const Ae of K) if (Ae.isPrivate()) {
            const { name: ce } = Ae.node.key.id;
            let ee = fe.get(ce);
            if (!ee) {
              const ae = !Ae.isProperty(), oe = Ae.node.static;
              let me, ye = !1;
              !X && b(ie) && ae && !oe ? (ye = !!_e, _e != null || (_e = Ae.scope.generateUidIdentifier(`${F}_brand`)), me = _e) : me = Ae.scope.generateUidIdentifier(ce), ee = { id: me, static: oe, method: ae, initAdded: ye }, fe.set(ce, ee);
            }
            if (Ae.isClassPrivateMethod()) if (Ae.node.kind === "get") {
              const { body: ae } = Ae.node.body;
              let oe;
              ae.length === 1 && i.types.isReturnStatement(oe = ae[0]) && i.types.isCallExpression(oe = oe.argument) && oe.arguments.length === 1 && i.types.isThisExpression(oe.arguments[0]) && i.types.isIdentifier(oe = oe.callee) ? (ee.getId = i.types.cloneNode(oe), ee.getterDeclared = !0) : ee.getId = Ae.scope.generateUidIdentifier(`get_${ce}`);
            } else if (Ae.node.kind === "set") {
              const { params: ae } = Ae.node, { body: oe } = Ae.node.body;
              let me;
              oe.length === 1 && i.types.isExpressionStatement(me = oe[0]) && i.types.isCallExpression(me = me.expression) && me.arguments.length === 2 && i.types.isThisExpression(me.arguments[0]) && i.types.isIdentifier(me.arguments[1], { name: ae[0].name }) && i.types.isIdentifier(me = me.callee) ? (ee.setId = i.types.cloneNode(me), ee.setterDeclared = !0) : ee.setId = Ae.scope.generateUidIdentifier(`set_${ce}`);
            } else Ae.node.kind === "method" && (ee.methodId = Ae.scope.generateUidIdentifier(ce));
            fe.set(ce, ee);
          }
          return fe;
        }, n.buildPrivateNamesNodes = function(F, X, K, ie) {
          const fe = [], _e = /* @__PURE__ */ new Set();
          for (const [Ae, ce] of F) {
            const { static: ee, method: ae, getId: oe, setId: me } = ce, ye = oe || me, we = i.types.cloneNode(ce.id);
            let ge;
            if (X) ge = i.types.callExpression(ie.addHelper("classPrivateFieldLooseKey"), [i.types.stringLiteral(Ae)]);
            else if (K) ge = i.types.callExpression(i.types.identifier("Symbol"), [i.types.stringLiteral(Ae)]);
            else if (!ee) {
              if (_e.has(we.name)) continue;
              _e.add(we.name), ge = i.types.newExpression(i.types.identifier(!ae || ye && !b(ie) ? "WeakMap" : "WeakSet"), []);
            }
            ge && (K || (0, y.default)(ge), fe.push(i.template.statement.ast`var ${we} = ${ge}`));
          }
          return fe;
        }, n.privateNameVisitorFactory = v, n.transformPrivateNamesUsage = function(F, X, K, { privateFieldsAsProperties: ie, noUninitializedPrivateFieldAccess: fe, noDocumentAll: _e, innerBinding: Ae }, ce) {
          if (!K.size) return;
          const ee = X.get("body"), ae = ie ? x : M;
          (0, s.default)(ee, T, Object.assign({ privateNamesMap: K, classRef: F, file: ce }, ae, { noDocumentAll: _e, noUninitializedPrivateFieldAccess: fe, innerBinding: Ae })), ee.traverse(D, { privateNamesMap: K, classRef: F, file: ce, privateFieldsAsProperties: ie, innerBinding: Ae });
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-replace-supers@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-replace-supers/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js"), s = u("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.24.7/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), o = u("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.24.7/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), y = u("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.24.7/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), m = u("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.24.7/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), g = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js"), b = (F) => F.availableHelper("classPrivateFieldGet2");
        function v(F) {
          const X = i.traverse.visitors.merge([Object.assign({}, F), f.default]), K = Object.assign({}, F, { Class(ie) {
            const { privateNamesMap: fe } = this, _e = ie.get("body.body"), Ae = new Map(fe), ce = [];
            for (const ee of _e) {
              if (!ee.isPrivate()) continue;
              const { name: ae } = ee.node.key.id;
              Ae.delete(ae), ce.push(ae);
            }
            ce.length && (ie.get("body").traverse(X, Object.assign({}, this, { redeclared: ce })), ie.traverse(K, Object.assign({}, this, { privateNamesMap: Ae })), ie.skipKey("body"));
          } });
          return K;
        }
        const T = v({ PrivateName(F, { noDocumentAll: X }) {
          const { privateNamesMap: K, redeclared: ie } = this, { node: fe, parentPath: _e } = F;
          if (!_e.isMemberExpression({ property: fe }) && !_e.isOptionalMemberExpression({ property: fe })) return;
          const { name: Ae } = fe.id;
          K.has(Ae) && (ie != null && ie.includes(Ae) || this.handle(_e, X));
        } });
        function E(F, X, K) {
          for (; (ie = X) != null && ie.hasBinding(F) && !X.bindingIdentifierEquals(F, K); ) {
            var ie;
            X.rename(F), X = X.parent;
          }
        }
        function O(F, X, K) {
          return K || X.availableHelper == null || !X.availableHelper("checkInRHS") ? F : i.types.callExpression(X.addHelper("checkInRHS"), [F]);
        }
        const D = v({ BinaryExpression(F, { file: X }) {
          const { operator: K, left: ie, right: fe } = F.node;
          if (K !== "in" || !i.types.isPrivateName(ie)) return;
          const { privateFieldsAsProperties: _e, privateNamesMap: Ae, redeclared: ce } = this, { name: ee } = ie.id;
          if (!Ae.has(ee) || ce != null && ce.includes(ee)) return;
          if (E(this.classRef.name, F.scope, this.innerBinding), _e) {
            const { id: me } = Ae.get(ee);
            return void F.replaceWith(i.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${O(fe, X)}, ${i.types.cloneNode(me)})
      `);
          }
          const { id: ae, static: oe } = Ae.get(ee);
          oe ? F.replaceWith(i.template.expression.ast`${O(fe, X)} === ${i.types.cloneNode(this.classRef)}`) : F.replaceWith(i.template.expression.ast`${i.types.cloneNode(ae)}.has(${O(fe, X)})`);
        } });
        function $(F, X) {
          return i.types.callExpression(F.addHelper("readOnlyError"), [i.types.stringLiteral(`#${X}`)]);
        }
        function I(F, X) {
          return F.availableHelper("writeOnlyError") ? i.types.callExpression(F.addHelper("writeOnlyError"), [i.types.stringLiteral(`#${X}`)]) : (console.warn("@babel/helpers is outdated, update it to silence this warning."), i.types.buildUndefinedNode());
        }
        function k(F, X) {
          return X ? F : i.types.memberExpression(F, i.types.identifier("_"));
        }
        function L(F) {
          return function(X) {
            return i.types.inherits(F.apply(this, arguments), X.node);
          };
        }
        const M = { memoise(F, X) {
          const { scope: K } = F, { object: ie } = F.node, fe = K.maybeGenerateMemoised(ie);
          fe && this.memoiser.set(ie, fe, X);
        }, receiver(F) {
          const { object: X } = F.node;
          return this.memoiser.has(X) ? i.types.cloneNode(this.memoiser.get(X)) : i.types.cloneNode(X);
        }, get: L(function(F) {
          const { classRef: X, privateNamesMap: K, file: ie, innerBinding: fe, noUninitializedPrivateFieldAccess: _e } = this, Ae = F.node.property, { name: ce } = Ae.id, { id: ee, static: ae, method: oe, methodId: me, getId: ye, setId: we } = K.get(ce), ge = ye || we, se = (be) => i.types.inherits(i.types.cloneNode(be), Ae);
          if (ae) {
            if (E(X.name, F.scope, fe), !b(ie)) {
              const Oe = oe && !ge ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
              return i.types.callExpression(ie.addHelper(Oe), [this.receiver(F), i.types.cloneNode(X), se(ee)]);
            }
            const be = this.receiver(F), Ie = i.types.isIdentifier(be) && be.name === X.name;
            if (!oe) return k(Ie ? se(ee) : i.types.callExpression(ie.addHelper("assertClassBrand"), [i.types.cloneNode(X), be, se(ee)]), _e);
            if (ye) return Ie ? i.types.callExpression(se(ye), [be]) : i.types.callExpression(ie.addHelper("classPrivateGetter"), [i.types.cloneNode(X), be, se(ye)]);
            if (we) {
              const Oe = i.types.buildUndefinedNode();
              return Ie ? Oe : i.types.sequenceExpression([i.types.callExpression(ie.addHelper("assertClassBrand"), [i.types.cloneNode(X), be]), Oe]);
            }
            return Ie ? se(ee) : i.types.callExpression(ie.addHelper("assertClassBrand"), [i.types.cloneNode(X), be, se(ee)]);
          }
          return oe ? ge ? ye ? b(ie) ? i.types.callExpression(ie.addHelper("classPrivateGetter"), [i.types.cloneNode(ee), this.receiver(F), se(ye)]) : i.types.callExpression(ie.addHelper("classPrivateFieldGet"), [this.receiver(F), se(ee)]) : i.types.sequenceExpression([this.receiver(F), I(ie, ce)]) : b(ie) ? i.types.callExpression(ie.addHelper("assertClassBrand"), [i.types.cloneNode(ee), this.receiver(F), se(me)]) : i.types.callExpression(ie.addHelper("classPrivateMethodGet"), [this.receiver(F), i.types.cloneNode(ee), se(me)]) : b(ie) ? i.types.callExpression(ie.addHelper("classPrivateFieldGet2"), [se(ee), this.receiver(F)]) : i.types.callExpression(ie.addHelper("classPrivateFieldGet"), [this.receiver(F), se(ee)]);
        }), boundGet(F) {
          return this.memoise(F, 1), i.types.callExpression(i.types.memberExpression(this.get(F), i.types.identifier("bind")), [this.receiver(F)]);
        }, set: L(function(F, X) {
          const { classRef: K, privateNamesMap: ie, file: fe, noUninitializedPrivateFieldAccess: _e } = this, Ae = F.node.property, { name: ce } = Ae.id, { id: ee, static: ae, method: oe, setId: me, getId: ye } = ie.get(ce), we = ye || me, ge = (se) => i.types.inherits(i.types.cloneNode(se), Ae);
          if (ae) {
            if (!b(fe)) {
              const Ie = oe && !we ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
              return i.types.callExpression(fe.addHelper(Ie), [this.receiver(F), i.types.cloneNode(K), ge(ee), X]);
            }
            const se = this.receiver(F), be = i.types.isIdentifier(se) && se.name === K.name;
            if (oe && !me) {
              const Ie = $(fe, ce);
              return be ? i.types.sequenceExpression([X, Ie]) : i.types.sequenceExpression([X, i.types.callExpression(fe.addHelper("assertClassBrand"), [i.types.cloneNode(K), se]), $(fe, ce)]);
            }
            return me ? be ? i.types.callExpression(i.types.cloneNode(me), [se, X]) : i.types.callExpression(fe.addHelper("classPrivateSetter"), [i.types.cloneNode(K), ge(me), se, X]) : i.types.assignmentExpression("=", k(ge(ee), _e), be ? X : i.types.callExpression(fe.addHelper("assertClassBrand"), [i.types.cloneNode(K), se, X]));
          }
          return oe ? me ? b(fe) ? i.types.callExpression(fe.addHelper("classPrivateSetter"), [i.types.cloneNode(ee), ge(me), this.receiver(F), X]) : i.types.callExpression(fe.addHelper("classPrivateFieldSet"), [this.receiver(F), ge(ee), X]) : i.types.sequenceExpression([this.receiver(F), X, $(fe, ce)]) : b(fe) ? i.types.callExpression(fe.addHelper("classPrivateFieldSet2"), [ge(ee), this.receiver(F), X]) : i.types.callExpression(fe.addHelper("classPrivateFieldSet"), [this.receiver(F), ge(ee), X]);
        }), destructureSet(F) {
          const { classRef: X, privateNamesMap: K, file: ie, noUninitializedPrivateFieldAccess: fe } = this, _e = F.node.property, { name: Ae } = _e.id, { id: ce, static: ee, method: ae, setId: oe } = K.get(Ae), me = (se) => i.types.inherits(i.types.cloneNode(se), _e);
          if (!b(ie)) {
            if (ee) {
              try {
                var ye = ie.addHelper("classStaticPrivateFieldDestructureSet");
              } catch {
                throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
              }
              return i.types.memberExpression(i.types.callExpression(ye, [this.receiver(F), i.types.cloneNode(X), me(ce)]), i.types.identifier("value"));
            }
            return i.types.memberExpression(i.types.callExpression(ie.addHelper("classPrivateFieldDestructureSet"), [this.receiver(F), me(ce)]), i.types.identifier("value"));
          }
          if (ae && !oe) return i.types.memberExpression(i.types.sequenceExpression([F.node.object, $(ie, Ae)]), i.types.identifier("_"));
          if (ee && !ae) {
            const se = this.get(F);
            if (!fe || !i.types.isCallExpression(se)) return se;
            const be = se.arguments.pop();
            return se.arguments.push(i.template.expression.ast`(_) => ${be} = _`), i.types.memberExpression(i.types.callExpression(ie.addHelper("toSetter"), [se]), i.types.identifier("_"));
          }
          const we = this.set(F, i.types.identifier("_"));
          if (!i.types.isCallExpression(we) || !i.types.isIdentifier(we.arguments[we.arguments.length - 1], { name: "_" })) throw F.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");
          let ge;
          return ge = i.types.isMemberExpression(we.callee, { computed: !1 }) && i.types.isIdentifier(we.callee.property) && we.callee.property.name === "call" ? [we.callee.object, i.types.arrayExpression(we.arguments.slice(1, -1)), we.arguments[0]] : [we.callee, i.types.arrayExpression(we.arguments.slice(0, -1))], i.types.memberExpression(i.types.callExpression(ie.addHelper("toSetter"), ge), i.types.identifier("_"));
        }, call(F, X) {
          return this.memoise(F, 1), (0, o.default)(this.get(F), this.receiver(F), X, !1);
        }, optionalCall(F, X) {
          return this.memoise(F, 1), (0, o.default)(this.get(F), this.receiver(F), X, !0);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } }, x = { get(F) {
          const { privateNamesMap: X, file: K } = this, { object: ie } = F.node, { name: fe } = F.node.property.id;
          return i.template.expression`BASE(REF, PROP)[PROP]`({ BASE: K.addHelper("classPrivateFieldLooseBase"), REF: i.types.cloneNode(ie), PROP: i.types.cloneNode(X.get(fe).id) });
        }, set() {
          throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(F) {
          return i.types.callExpression(i.types.memberExpression(this.get(F), i.types.identifier("bind")), [i.types.cloneNode(F.node.object)]);
        }, simpleSet(F) {
          return this.get(F);
        }, destructureSet(F) {
          return this.get(F);
        }, call(F, X) {
          return i.types.callExpression(this.get(F), X);
        }, optionalCall(F, X) {
          return i.types.optionalCallExpression(this.get(F), X, !0);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } };
        function _(F, X, K) {
          const { id: ie } = K.get(X.node.key.id.name), fe = X.node.value || X.scope.buildUndefinedNode();
          return N(i.template.statement.ast`
      Object.defineProperty(${F}, ${i.types.cloneNode(ie)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${fe}
      });
    `, X);
        }
        function S(F, X, K, ie) {
          const { id: fe } = K.get(X.node.key.id.name), _e = X.node.value || X.scope.buildUndefinedNode();
          if (!ie.availableHelper("classPrivateFieldInitSpec")) return N(i.template.statement.ast`${i.types.cloneNode(fe)}.set(${F}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${_e},
        })`, X);
          const Ae = ie.addHelper("classPrivateFieldInitSpec");
          return V(N(i.types.expressionStatement(i.types.callExpression(Ae, [i.types.thisExpression(), V(i.types.cloneNode(fe), X.node.key), b(ie) ? _e : i.template.expression.ast`{ writable: true, value: ${_e} }`])), X), X.node);
        }
        function C(F, X, K) {
          const ie = X.get(F.node.key.id.name), fe = K ? F.node.value : i.template.expression.ast`{
        _: ${F.node.value || i.types.buildUndefinedNode()}
      }`;
          return N(i.types.variableDeclaration("var", [i.types.variableDeclarator(i.types.cloneNode(ie.id), fe)]), F);
        }
        var R = function(F, X) {
          const K = X.get(F.node.key.id.name), { id: ie, getId: fe, setId: _e, initAdded: Ae } = K, ce = fe || _e;
          if (!F.isProperty() && (Ae || !ce)) return;
          if (ce) return X.set(F.node.key.id.name, Object.assign({}, K, { initAdded: !0 })), N(i.template.statement.ast`
          var ${i.types.cloneNode(ie)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${fe ? fe.name : F.scope.buildUndefinedNode()},
            set: ${_e ? _e.name : F.scope.buildUndefinedNode()}
          }
        `, F);
          const ee = F.node.value || F.scope.buildUndefinedNode();
          return N(i.template.statement.ast`
        var ${i.types.cloneNode(ie)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${ee}
        };
      `, F);
        };
        function H(F, X, K) {
          const ie = K.get(X.node.key.id.name), { methodId: fe, id: _e, getId: Ae, setId: ce, initAdded: ee } = ie;
          if (!ee)
            return fe ? N(i.template.statement.ast`
        Object.defineProperty(${F}, ${_e}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${fe.name}
        });
      `, X) : Ae || ce ? (K.set(X.node.key.id.name, Object.assign({}, ie, { initAdded: !0 })), N(i.template.statement.ast`
        Object.defineProperty(${F}, ${_e}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${Ae ? Ae.name : X.scope.buildUndefinedNode()},
          set: ${ce ? ce.name : X.scope.buildUndefinedNode()}
        });
      `, X)) : void 0;
        }
        function z(F, X, K, ie) {
          const fe = K.get(X.node.key.id.name);
          if (!fe.initAdded)
            return !b(ie) && (fe.getId || fe.setId) ? function(_e, Ae, ce, ee) {
              const ae = ce.get(Ae.node.key.id.name), { id: oe, getId: me, setId: ye } = ae;
              if (ce.set(Ae.node.key.id.name, Object.assign({}, ae, { initAdded: !0 })), !ee.availableHelper("classPrivateFieldInitSpec")) return N(i.template.statement.ast`
          ${oe}.set(${_e}, {
            get: ${me ? me.name : Ae.scope.buildUndefinedNode()},
            set: ${ye ? ye.name : Ae.scope.buildUndefinedNode()}
          });
        `, Ae);
              const we = ee.addHelper("classPrivateFieldInitSpec");
              return V(N(i.template.statement.ast`${we}(
      ${i.types.thisExpression()},
      ${i.types.cloneNode(oe)},
      {
        get: ${me ? me.name : Ae.scope.buildUndefinedNode()},
        set: ${ye ? ye.name : Ae.scope.buildUndefinedNode()}
      },
    )`, Ae), Ae.node);
            }(F, X, K, ie) : function(_e, Ae, ce, ee) {
              const ae = ce.get(Ae.node.key.id.name), { id: oe } = ae;
              if (!ee.availableHelper("classPrivateMethodInitSpec")) return N(i.template.statement.ast`${oe}.add(${_e})`, Ae);
              const me = ee.addHelper("classPrivateMethodInitSpec");
              return N(i.template.statement.ast`${me}(
      ${i.types.thisExpression()},
      ${i.types.cloneNode(oe)}
    )`, Ae);
            }(F, X, K, ie);
        }
        function U(F, X) {
          const { key: K, computed: ie } = X.node, fe = X.node.value || X.scope.buildUndefinedNode();
          return N(i.types.expressionStatement(i.types.assignmentExpression("=", i.types.memberExpression(F, K, ie || i.types.isLiteral(K)), fe)), X);
        }
        function P(F, X, K) {
          const { key: ie, computed: fe } = X.node, _e = X.node.value || X.scope.buildUndefinedNode();
          return N(i.types.expressionStatement(i.types.callExpression(K.addHelper("defineProperty"), [F, fe || i.types.isLiteral(ie) ? ie : i.types.stringLiteral(ie.name), _e])), X);
        }
        function W(F, X, K, ie) {
          const fe = ie.get(X.node.key.id.name), { id: _e, methodId: Ae, getId: ce, setId: ee, initAdded: ae } = fe;
          if (!ae)
            return ce || ee ? (ie.set(X.node.key.id.name, Object.assign({}, fe, { initAdded: !0 })), N(i.template.statement.ast`
        Object.defineProperty(${F}, ${_e}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${ce ? ce.name : X.scope.buildUndefinedNode()},
          set: ${ee ? ee.name : X.scope.buildUndefinedNode()}
        })
      `, X)) : N(i.template.statement.ast`
      Object.defineProperty(${F}, ${_e}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${Ae.name}
      });
    `, X);
        }
        function B(F, X, K, ie = !1) {
          const fe = K.get(X.node.key.id.name), { id: _e, methodId: Ae, getId: ce, setId: ee, getterDeclared: ae, setterDeclared: oe, static: me } = fe, { params: ye, body: we, generator: ge, async: se } = X.node, be = ce && ye.length === 0, Ie = ee && ye.length > 0;
          if (be && ae || Ie && oe) return K.set(X.node.key.id.name, Object.assign({}, fe, { initAdded: !0 })), null;
          if (b(F) && (be || Ie) && !ie) {
            const Be = X.get("body").scope, Fe = Be.generateUidIdentifier("this"), ue = { thisRef: Fe, argumentsPath: [] };
            if (X.traverse(Q, ue), ue.argumentsPath.length) {
              const te = Be.generateUidIdentifier("arguments");
              Be.push({ id: te, init: i.template.expression.ast`[].slice.call(arguments, 1)` });
              for (const Y of ue.argumentsPath) Y.replaceWith(i.types.cloneNode(te));
            }
            ye.unshift(i.types.cloneNode(Fe));
          }
          let Oe = Ae;
          return be ? (K.set(X.node.key.id.name, Object.assign({}, fe, { getterDeclared: !0, initAdded: !0 })), Oe = ce) : Ie ? (K.set(X.node.key.id.name, Object.assign({}, fe, { setterDeclared: !0, initAdded: !0 })), Oe = ee) : me && !ie && (Oe = _e), N(i.types.functionDeclaration(i.types.cloneNode(Oe), ye, we, ge, se), X);
        }
        const Q = i.traverse.visitors.merge([{ Identifier(F, X) {
          X.argumentsPath && F.node.name === "arguments" && X.argumentsPath.push(F);
        }, UnaryExpression(F) {
          const { node: X } = F;
          if (X.operator === "delete") {
            const K = (0, m.skipTransparentExprWrapperNodes)(X.argument);
            i.types.isThisExpression(K) && F.replaceWith(i.types.booleanLiteral(!0));
          }
        }, ThisExpression(F, X) {
          X.needsClassRef = !0, F.replaceWith(i.types.cloneNode(X.thisRef));
        }, MetaProperty(F) {
          const { node: X, scope: K } = F;
          X.meta.name === "new" && X.property.name === "target" && F.replaceWith(K.buildUndefinedNode());
        } }, f.default]), J = { ReferencedIdentifier(F, X) {
          F.scope.bindingIdentifierEquals(F.node.name, X.innerBinding) && (X.needsClassRef = !0, F.node.name = X.thisRef.name);
        } };
        function re(F, X, K) {
          var ie;
          const fe = { thisRef: X, needsClassRef: !1, innerBinding: K };
          return F.isMethod() || F.traverse(Q, fe), K != null && (ie = fe.thisRef) != null && ie.name && fe.thisRef.name !== K.name && F.traverse(J, fe), fe.needsClassRef;
        }
        function G({ key: F, computed: X }) {
          return F.type === "Identifier" ? !X && (F.name === "name" || F.name === "length") : F.type === "StringLiteral" && (F.value === "name" || F.value === "length");
        }
        function N(F, X) {
          return i.types.inheritLeadingComments(F, X.node), i.types.inheritInnerComments(F, X.node), F;
        }
        function V(F, X) {
          return F.start = X.start, F.end = X.end, F.loc = X.loc, F;
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "FEATURES", { enumerable: !0, get: function() {
          return b.FEATURES;
        } }), Object.defineProperty(n, "buildCheckInRHS", { enumerable: !0, get: function() {
          return y.buildCheckInRHS;
        } }), n.createClassFeaturePlugin = function({ name: E, feature: O, loose: D, manipulateOptions: $, api: I, inherits: k, decoratorVersion: L }) {
          var M;
          if (O & b.FEATURES.decorators && (L === "2023-11" || L === "2023-05" || L === "2023-01" || L === "2022-03" || L === "2021-12")) return (0, s.default)(I, { loose: D }, L, k);
          I != null || (I = { assumption: () => {
          } });
          const x = I.assumption("setPublicClassFields"), _ = I.assumption("privateFieldsAsSymbols"), S = I.assumption("privateFieldsAsProperties"), C = (M = I.assumption("noUninitializedPrivateFieldAccess")) != null && M, R = I.assumption("constantSuper"), H = I.assumption("noDocumentAll");
          if (S && _) throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
          const z = S || _;
          if (D === !0) {
            const U = [];
            x !== void 0 && U.push('"setPublicClassFields"'), S !== void 0 && U.push('"privateFieldsAsProperties"'), _ !== void 0 && U.push('"privateFieldsAsSymbols"'), U.length !== 0 && console.warn(`[${E}]: You are using the "loose: true" option and you are explicitly setting a value for the ${U.join(" and ")} assumption${U.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
          }
          return { name: E, manipulateOptions: $, inherits: k, pre(U) {
            (0, b.enableFeature)(U, O, D), typeof U.get(T) != "number" && U.get(T) && !o.lt(U.get(T), "7.24.7") || U.set(T, "7.24.7");
          }, visitor: { Class(U, { file: P }) {
            var W;
            if (P.get(T) !== "7.24.7" || !(0, b.shouldTransform)(U, P)) return;
            const B = U.isClassDeclaration();
            B && (0, v.assertFieldTransformed)(U);
            const Q = (0, b.isLoose)(P, O);
            let J;
            const re = (0, m.hasDecorators)(U.node), G = [], N = [], V = [], F = /* @__PURE__ */ new Set(), X = U.get("body");
            for (const se of X.get("body")) {
              if ((se.isClassProperty() || se.isClassMethod()) && se.node.computed && V.push(se), se.isPrivate()) {
                const { name: be } = se.node.key.id, Ie = `get ${be}`, Oe = `set ${be}`;
                if (se.isClassPrivateMethod()) {
                  if (se.node.kind === "get") {
                    if (F.has(Ie) || F.has(be) && !F.has(Oe)) throw se.buildCodeFrameError("Duplicate private field");
                    F.add(Ie).add(be);
                  } else if (se.node.kind === "set") {
                    if (F.has(Oe) || F.has(be) && !F.has(Ie)) throw se.buildCodeFrameError("Duplicate private field");
                    F.add(Oe).add(be);
                  }
                } else {
                  if (F.has(be) && !F.has(Ie) && !F.has(Oe) || F.has(be) && (F.has(Ie) || F.has(Oe))) throw se.buildCodeFrameError("Duplicate private field");
                  F.add(be);
                }
              }
              se.isClassMethod({ kind: "constructor" }) ? J = se : (N.push(se), (se.isProperty() || se.isPrivate() || se.isStaticBlock != null && se.isStaticBlock()) && G.push(se));
            }
            if (!G.length && !re) return;
            const K = U.node.id;
            let ie;
            K && B || ((0, c.default)(U), ie = U.scope.generateUidIdentifier((K == null ? void 0 : K.name) || "Class"));
            const fe = (W = ie) != null ? W : i.types.cloneNode(K), _e = (0, y.buildPrivateNamesMap)(fe.name, z ?? Q, G, P), Ae = (0, y.buildPrivateNamesNodes)(_e, S ?? Q, _ != null && _, P);
            let ce, ee, ae, oe, me, ye, we;
            (0, y.transformPrivateNamesUsage)(fe, U, _e, { privateFieldsAsProperties: z ?? Q, noUninitializedPrivateFieldAccess: C, noDocumentAll: H, innerBinding: K }, P), re ? (ee = me = ce = [], { instanceNodes: ae, wrapClass: we } = (0, m.buildDecoratedClass)(fe, U, N, P)) : (ce = (0, g.extractComputedKeys)(U, V, P), { staticNodes: ee, pureStaticNodes: me, instanceNodes: ae, lastInstanceNodeReturnsThis: oe, classBindingNode: ye, wrapClass: we } = (0, y.buildFieldsInitNodes)(ie, U.node.superClass, G, _e, P, x ?? Q, z ?? Q, C, R ?? Q, K)), ae.length > 0 && (0, g.injectInitialization)(U, J, ae, (se, be) => {
              if (!re) for (const Ie of G) i.types.isStaticBlock != null && i.types.isStaticBlock(Ie.node) || Ie.node.static || Ie.traverse(se, be);
            }, oe);
            const ge = we(U);
            ge.insertBefore([...Ae, ...ce]), ee.length > 0 && ge.insertAfter(ee), me.length > 0 && ge.find((se) => se.isStatement() || se.isDeclaration()).insertAfter(me), ye != null && B && ge.insertAfter(ye);
          }, ExportDefaultDeclaration(U, { file: P }) {
            {
              if (P.get(T) !== "7.24.7") return;
              const W = U.get("declaration");
              W.isClassDeclaration() && (0, m.hasDecorators)(W.node) && (W.node.id ? (0, f.default)(U) : W.node.type = "ClassExpression");
            }
          } } };
        }, Object.defineProperty(n, "enableFeature", { enumerable: !0, get: function() {
          return b.enableFeature;
        } }), Object.defineProperty(n, "injectInitialization", { enumerable: !0, get: function() {
          return g.injectInitialization;
        } });
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-function-name@7.24.7/node_modules/@babel/helper-function-name/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.24.7/node_modules/@babel/helper-split-export-declaration/lib/index.js"), s = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"), o = u("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"), y = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), m = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js"), g = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"), b = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/features.js"), v = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        const T = "@babel/plugin-class-features/version";
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.extractComputedKeys = function(g, b, v) {
          const { scope: T } = g, E = [], O = { classBinding: g.node.id && T.getBinding(g.node.id.name), file: v };
          for (const D of b) {
            const $ = D.get("key");
            $.isReferencedIdentifier() ? o($, O) : $.traverse(y, O);
            const I = D.node;
            if (!$.isConstantExpression()) {
              const k = m($.node, T, T.generateUidBasedOnNode($.node));
              k && (E.push(i.types.expressionStatement(k)), I.key = i.types.cloneNode(k.left));
            }
          }
          return E;
        }, n.injectInitialization = function(g, b, v, T, E) {
          if (!v.length) return;
          const O = !!g.node.superClass;
          if (!b) {
            const D = i.types.classMethod("constructor", i.types.identifier("constructor"), [], i.types.blockStatement([]));
            O && (D.params = [i.types.restElement(i.types.identifier("args"))], D.body.body.push(i.template.statement.ast`super(...args)`)), [b] = g.get("body").unshiftContainer("body", D);
          }
          if (T && T(s, { scope: b.scope }), O) {
            const D = [];
            b.traverse(f, D);
            let $ = !0;
            for (const I of D) if ($ ? $ = !1 : v = v.map((k) => i.types.cloneNode(k)), I.parentPath.isExpressionStatement()) I.insertAfter(v);
            else {
              const k = [I.node, ...v.map((L) => i.types.toExpression(L))];
              E || k.push(i.types.thisExpression()), I.replaceWith(i.types.sequenceExpression(k));
            }
          } else b.get("body").unshiftContainer("body", v);
        }, n.memoiseComputedKey = m;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js");
        const f = i.traverse.visitors.merge([{ Super(g) {
          const { node: b, parentPath: v } = g;
          v.isCallExpression({ callee: b }) && this.push(v);
        } }, c.default]), s = { "TSTypeAnnotation|TypeAnnotation"(g) {
          g.skip();
        }, ReferencedIdentifier(g, { scope: b }) {
          b.hasOwnBinding(g.node.name) && (b.rename(g.node.name), g.skip());
        } };
        function o(g, b) {
          if (b.classBinding && b.classBinding === g.scope.getBinding(g.node.name)) {
            const v = b.file.addHelper("classNameTDZError"), T = i.types.callExpression(v, [i.types.stringLiteral(g.node.name)]);
            g.replaceWith(i.types.sequenceExpression([T, g.node])), g.skip();
          }
        }
        const y = { ReferencedIdentifier: o };
        function m(g, b, v) {
          if (!(i.types.isIdentifier(g) && b.hasUid(g.name))) {
            if (i.types.isAssignmentExpression(g, { operator: "=" }) && i.types.isIdentifier(g.left) && b.hasUid(g.left.name)) return i.types.cloneNode(g);
            {
              const T = i.types.identifier(v);
              return b.push({ id: T, kind: "let" }), i.types.assignmentExpression("=", i.types.cloneNode(T), g);
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.assertFieldTransformed = function(u) {
          if (u.node.declare) throw u.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
        };
      }, "./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js": (h, n) => {
        function u(c) {
          const { context: f, node: s } = c;
          if (s.computed && f.maybeQueue(c.get("key")), s.decorators) for (const o of c.get("decorators")) f.maybeQueue(o);
        }
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, n.requeueComputedKeyAndDecorators = u, n.skipAllButComputedKey = function(c) {
          c.skip(), c.node.computed && c.context.maybeQueue(c.get("key"));
        };
        const i = { FunctionParent(c) {
          c.isArrowFunctionExpression() || (c.skip(), c.isMethod() && u(c));
        }, Property(c) {
          c.isObjectProperty() || (c.skip(), u(c));
        } };
        n.default = i;
      }, "./node_modules/.pnpm/@babel+helper-function-name@7.24.7/node_modules/@babel/helper-function-name/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function({ node: S, parent: C, scope: R, id: H }, z = !1, U = !1) {
          if (S.id) return;
          if (!O(C) && !E(C, { kind: "method" }) || C.computed && !v(C.key)) {
            if (k(C)) {
              if (H = C.id, b(H) && !z) {
                const B = R.parent.getBinding(H.name);
                if (B && B.constant && R.getBinding(H.name) === B) return S.id = s(H), void (S.id[f] = !0);
              }
            } else if (y(C, { operator: "=" })) H = C.left;
            else if (!H) return;
          } else H = C.key;
          let P;
          if (H && v(H) ? P = function(B) {
            return T(B) ? "null" : D(B) ? `_${B.pattern}_${B.flags}` : I(B) ? B.quasis.map((Q) => Q.value.raw).join("") : B.value !== void 0 ? B.value + "" : "";
          }(H) : H && b(H) && (P = H.name), P === void 0 || !U && g(S) && /[\uD800-\uDFFF]/.test(P)) return;
          P = L(P);
          const W = o(P);
          return W[f] = !0, function(B, Q, J, re) {
            if (B.selfReference) {
              if (!re.hasBinding(J.name) || re.hasGlobal(J.name)) {
                if (!g(Q)) return;
                let G = M;
                Q.generator && (G = x);
                const N = G({ FUNCTION: Q, FUNCTION_ID: J, FUNCTION_KEY: re.generateUidIdentifier(J.name) }).expression, V = N.callee.body.body[0].params;
                for (let F = 0, X = function(K) {
                  const ie = K.params.findIndex((fe) => m(fe) || $(fe));
                  return ie === -1 ? K.params.length : ie;
                }(Q); F < X; F++) V.push(re.generateUidIdentifier("x"));
                return N;
              }
              re.rename(J.name);
            }
            Q.id = J, re.getProgramParent().references[J.name] = !0;
          }(function(B, Q, J) {
            const re = { selfAssignment: !1, selfReference: !1, outerDeclar: J.getBindingIdentifier(Q), name: Q }, G = J.getOwnBinding(Q);
            return G ? G.kind === "param" && (re.selfReference = !0) : (re.outerDeclar || J.hasGlobal(Q)) && J.traverse(B, _, re), re;
          }(S, P, R), S, W, R) || S;
        };
        var i = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { NOT_LOCAL_BINDING: f, cloneNode: s, identifier: o, isAssignmentExpression: y, isAssignmentPattern: m, isFunction: g, isIdentifier: b, isLiteral: v, isNullLiteral: T, isObjectMethod: E, isObjectProperty: O, isRegExpLiteral: D, isRestElement: $, isTemplateLiteral: I, isVariableDeclarator: k, toBindingIdentifierName: L } = c, M = i.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), x = i.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), _ = { "ReferencedIdentifier|BindingIdentifier"(S, C) {
          S.node.name === C.name && S.scope.getBindingIdentifier(C.name) === C.outerDeclar && (C.selfReference = !0, S.stop());
        } };
      }, "./node_modules/.pnpm/@babel+helper-hoist-variables@7.24.7/node_modules/@babel/helper-hoist-variables/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(y, m, g = "var") {
          y.traverse(o, { kind: g, emit: m });
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { assignmentExpression: c, expressionStatement: f, identifier: s } = i, o = { Scope(y, m) {
          m.kind === "let" && y.skip();
        }, FunctionParent(y) {
          y.skip();
        }, VariableDeclaration(y, m) {
          if (m.kind && y.node.kind !== m.kind) return;
          const g = [], b = y.get("declarations");
          let v;
          for (const T of b) {
            v = T.node.id, T.node.init && g.push(f(c("=", T.node.id, T.node.init)));
            for (const E of Object.keys(T.getBindingIdentifiers())) m.emit(s(E), E, T.node.init !== null);
          }
          y.parentPath.isFor({ left: y.node }) ? y.replaceWith(v) : y.replaceWithMultiple(g);
        } };
      }, "./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.24.7/node_modules/@babel/helper-member-expression-to-functions/lib/index.js": (h, n, u) => {
        function i(P) {
          if (P && P.__esModule) return P;
          var W = /* @__PURE__ */ Object.create(null);
          return P && Object.keys(P).forEach(function(B) {
            if (B !== "default") {
              var Q = Object.getOwnPropertyDescriptor(P, B);
              Object.defineProperty(W, B, Q.get ? Q : { enumerable: !0, get: function() {
                return P[B];
              } });
            }
          }), W.default = P, Object.freeze(W);
        }
        Object.defineProperty(n, "__esModule", { value: !0 });
        var c = i(u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"));
        function f(P) {
          const W = P, { node: B, parentPath: Q } = W;
          if (Q.isLogicalExpression()) {
            const { operator: J, right: re } = Q.node;
            if (J === "&&" || J === "||" || J === "??" && B === re) return f(Q);
          }
          if (Q.isSequenceExpression()) {
            const { expressions: J } = Q.node;
            return J[J.length - 1] !== B || f(Q);
          }
          return Q.isConditional({ test: B }) || Q.isUnaryExpression({ operator: "!" }) || Q.isLoop({ test: B });
        }
        const { LOGICAL_OPERATORS: s, arrowFunctionExpression: o, assignmentExpression: y, binaryExpression: m, booleanLiteral: g, callExpression: b, cloneNode: v, conditionalExpression: T, identifier: E, isMemberExpression: O, isOptionalCallExpression: D, isOptionalMemberExpression: $, isUpdateExpression: I, logicalExpression: k, memberExpression: L, nullLiteral: M, optionalCallExpression: x, optionalMemberExpression: _, sequenceExpression: S, updateExpression: C } = c;
        class R {
          constructor() {
            this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
          }
          has(W) {
            return this._map.has(W);
          }
          get(W) {
            if (!this.has(W)) return;
            const B = this._map.get(W), { value: Q } = B;
            return B.count--, B.count === 0 ? y("=", Q, W) : Q;
          }
          set(W, B, Q) {
            return this._map.set(W, { count: Q, value: B });
          }
        }
        function H(P, W) {
          const { node: B } = P;
          if ($(B)) return L(W, B.property, B.computed);
          if (P.isOptionalCallExpression()) {
            const Q = P.get("callee");
            if (P.node.optional && Q.isOptionalMemberExpression()) {
              const J = Q.node.object, re = P.scope.maybeGenerateMemoised(J);
              return Q.get("object").replaceWith(y("=", re, J)), b(L(W, E("call")), [re, ...P.node.arguments]);
            }
            return b(W, P.node.arguments);
          }
          return P.node;
        }
        const z = { memoise() {
        }, handle(P, W) {
          const { node: B, parent: Q, parentPath: J, scope: re } = P;
          if (P.isOptionalMemberExpression()) {
            if (function(ge) {
              for (; ge && !ge.isProgram(); ) {
                const { parentPath: se, container: be, listKey: Ie } = ge, Oe = se.node;
                if (Ie) {
                  if (be !== Oe[Ie]) return !0;
                } else if (be !== Oe) return !0;
                ge = se;
              }
              return !1;
            }(P)) return;
            const G = P.find(({ node: ge, parent: se }) => $(se) ? se.optional || se.object !== ge : !D(se) || ge !== P.node && se.optional || se.callee !== ge);
            if (re.path.isPattern()) return void G.replaceWith(b(o([], G.node), []));
            const N = f(G), V = G.parentPath;
            if (V.isUpdateExpression({ argument: B })) throw P.buildCodeFrameError("can't handle update expression");
            const F = V.isAssignmentExpression({ left: G.node }), X = V.isUnaryExpression({ operator: "delete" });
            if (X && G.isOptionalMemberExpression() && G.get("property").isPrivateName()) throw P.buildCodeFrameError("can't delete a private class element");
            let K = P;
            for (; ; ) if (K.isOptionalMemberExpression()) {
              if (K.node.optional) break;
              K = K.get("object");
            } else {
              if (!K.isOptionalCallExpression()) throw new Error(`Internal error: unexpected ${K.node.type}`);
              if (K.node.optional) break;
              K = K.get("callee");
            }
            const ie = K.isOptionalMemberExpression() ? K.node.object : K.node.callee, fe = re.maybeGenerateMemoised(ie), _e = fe ?? ie, Ae = J.isOptionalCallExpression({ callee: B }), ce = (ge) => Ae, ee = J.isCallExpression({ callee: B });
            K.replaceWith(H(K, _e)), ce() ? Q.optional ? J.replaceWith(this.optionalCall(P, Q.arguments)) : J.replaceWith(this.call(P, Q.arguments)) : ee ? P.replaceWith(this.boundGet(P)) : this.delete && J.isUnaryExpression({ operator: "delete" }) ? J.replaceWith(this.delete(P)) : J.isAssignmentExpression() ? U(this, P, J) : P.replaceWith(this.get(P));
            let ae, oe = P.node;
            for (let ge = P; ge !== G; ) {
              const se = ge.parentPath;
              if (se === G && ce() && Q.optional) {
                oe = se.node;
                break;
              }
              oe = H(se, oe), ge = se;
            }
            const me = G.parentPath;
            if (O(oe) && me.isOptionalCallExpression({ callee: G.node, optional: !0 })) {
              const { object: ge } = oe;
              ae = P.scope.maybeGenerateMemoised(ge), ae && (oe.object = y("=", ae, ge));
            }
            let ye = G;
            (X || F) && (ye = me, oe = me.node);
            const we = fe ? y("=", v(_e), v(ie)) : v(_e);
            if (N) {
              let ge;
              ge = W ? m("!=", we, M()) : k("&&", m("!==", we, M()), m("!==", v(_e), re.buildUndefinedNode())), ye.replaceWith(k("&&", ge, oe));
            } else {
              let ge;
              ge = W ? m("==", we, M()) : k("||", m("===", we, M()), m("===", v(_e), re.buildUndefinedNode())), ye.replaceWith(T(ge, X ? g(!0) : re.buildUndefinedNode(), oe));
            }
            if (ae) {
              const ge = me.node;
              me.replaceWith(x(_(ge.callee, E("call"), !1, !0), [v(ae), ...ge.arguments], !1));
            }
          } else {
            if (I(Q, { argument: B })) {
              if (this.simpleSet) return void P.replaceWith(this.simpleSet(P));
              const { operator: G, prefix: N } = Q;
              this.memoise(P, 2);
              const V = re.generateUidIdentifierBasedOnNode(B);
              re.push({ id: V });
              const F = [y("=", v(V), this.get(P))];
              if (N) {
                F.push(C(G, v(V), N));
                const X = S(F);
                return void J.replaceWith(this.set(P, X));
              }
              {
                const X = re.generateUidIdentifierBasedOnNode(B);
                re.push({ id: X }), F.push(y("=", v(X), C(G, v(V), N)), v(V));
                const K = S(F);
                return void J.replaceWith(S([this.set(P, K), v(X)]));
              }
            }
            if (J.isAssignmentExpression({ left: B })) U(this, P, J);
            else {
              if (!J.isCallExpression({ callee: B })) return J.isOptionalCallExpression({ callee: B }) ? re.path.isPattern() ? void J.replaceWith(b(o([], J.node), [])) : void J.replaceWith(this.optionalCall(P, J.node.arguments)) : void (this.delete && J.isUnaryExpression({ operator: "delete" }) ? J.replaceWith(this.delete(P)) : J.isForXStatement({ left: B }) || J.isObjectProperty({ value: B }) && J.parentPath.isObjectPattern() || J.isAssignmentPattern({ left: B }) && J.parentPath.isObjectProperty({ value: Q }) && J.parentPath.parentPath.isObjectPattern() || J.isArrayPattern() || J.isAssignmentPattern({ left: B }) && J.parentPath.isArrayPattern() || J.isRestElement() ? P.replaceWith(this.destructureSet(P)) : J.isTaggedTemplateExpression() ? P.replaceWith(this.boundGet(P)) : P.replaceWith(this.get(P)));
              J.replaceWith(this.call(P, J.node.arguments));
            }
          }
        } };
        function U(P, W, B) {
          if (P.simpleSet) return void W.replaceWith(P.simpleSet(W));
          const { operator: Q, right: J } = B.node;
          if (Q === "=") B.replaceWith(P.set(W, J));
          else {
            const re = Q.slice(0, -1);
            s.includes(re) ? (P.memoise(W, 1), B.replaceWith(k(re, P.get(W), P.set(W, J)))) : (P.memoise(W, 2), B.replaceWith(P.set(W, m(re, P.get(W), J))));
          }
        }
        n.default = function(P, W, B) {
          P.traverse(W, Object.assign({}, z, B, { memoiser: new R() }));
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/import-builder.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("assert"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { callExpression: f, cloneNode: s, expressionStatement: o, identifier: y, importDeclaration: m, importDefaultSpecifier: g, importNamespaceSpecifier: b, importSpecifier: v, memberExpression: T, stringLiteral: E, variableDeclaration: O, variableDeclarator: D } = c;
        n.default = class {
          constructor($, I, k) {
            this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = I, this._hub = k, this._importedSource = $;
          }
          done() {
            return { statements: this._statements, resultName: this._resultName };
          }
          import() {
            return this._statements.push(m([], E(this._importedSource))), this;
          }
          require() {
            return this._statements.push(o(f(y("require"), [E(this._importedSource)]))), this;
          }
          namespace($ = "namespace") {
            const I = this._scope.generateUidIdentifier($), k = this._statements[this._statements.length - 1];
            return i(k.type === "ImportDeclaration"), i(k.specifiers.length === 0), k.specifiers = [b(I)], this._resultName = s(I), this;
          }
          default($) {
            const I = this._scope.generateUidIdentifier($), k = this._statements[this._statements.length - 1];
            return i(k.type === "ImportDeclaration"), i(k.specifiers.length === 0), k.specifiers = [g(I)], this._resultName = s(I), this;
          }
          named($, I) {
            if (I === "default") return this.default($);
            const k = this._scope.generateUidIdentifier($), L = this._statements[this._statements.length - 1];
            return i(L.type === "ImportDeclaration"), i(L.specifiers.length === 0), L.specifiers = [v(k, y(I))], this._resultName = s(k), this;
          }
          var($) {
            const I = this._scope.generateUidIdentifier($);
            let k = this._statements[this._statements.length - 1];
            return k.type !== "ExpressionStatement" && (i(this._resultName), k = o(this._resultName), this._statements.push(k)), this._statements[this._statements.length - 1] = O("var", [D(I, k.expression)]), this._resultName = s(I), this;
          }
          defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
          }
          wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
          }
          _interop($) {
            const I = this._statements[this._statements.length - 1];
            return I.type === "ExpressionStatement" ? I.expression = f($, [I.expression]) : I.type === "VariableDeclaration" ? (i(I.declarations.length === 1), I.declarations[0].init = f($, [I.declarations[0].init])) : i.fail("Unexpected type."), this;
          }
          prop($) {
            const I = this._statements[this._statements.length - 1];
            return I.type === "ExpressionStatement" ? I.expression = T(I.expression, y($)) : I.type === "VariableDeclaration" ? (i(I.declarations.length === 1), I.declarations[0].init = T(I.declarations[0].init, y($))) : i.fail("Unexpected type:" + I.type), this;
          }
          read($) {
            this._resultName = T(this._resultName, y($));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/import-injector.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("assert"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/import-builder.js"), s = u("./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/is-module.js");
        const { identifier: o, importSpecifier: y, numericLiteral: m, sequenceExpression: g, isImportDeclaration: b } = c;
        function v(D) {
          return D.importKind !== "type" && D.importKind !== "typeof";
        }
        function T(D) {
          return D.specifiers.length === 1 && D.specifiers[0].type === "ImportNamespaceSpecifier" || D.specifiers.length === 2 && D.specifiers[1].type === "ImportNamespaceSpecifier";
        }
        function E(D) {
          return D.specifiers.length > 0 && D.specifiers[0].type === "ImportDefaultSpecifier";
        }
        function O(D, $) {
          return D.specifiers.length ? !$.specifiers.length || !T(D) && !T($) && (E($) && (E(D) ? $.specifiers[0] = y($.specifiers[0].local, o("default")) : D.specifiers.unshift($.specifiers.shift())), D.specifiers.push(...$.specifiers), !0) : (D.specifiers = $.specifiers, !0);
        }
        n.default = class {
          constructor(D, $, I) {
            this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: !1, ensureNoContext: !1, importPosition: "before" };
            const k = D.find((L) => L.isProgram());
            this._programPath = k, this._programScope = k.scope, this._hub = k.hub, this._defaultOpts = this._applyDefaults($, I, !0);
          }
          addDefault(D, $) {
            return this.addNamed("default", D, $);
          }
          addNamed(D, $, I) {
            return i(typeof D == "string"), this._generateImport(this._applyDefaults($, I), D);
          }
          addNamespace(D, $) {
            return this._generateImport(this._applyDefaults(D, $), null);
          }
          addSideEffect(D, $) {
            return this._generateImport(this._applyDefaults(D, $), void 0);
          }
          _applyDefaults(D, $, I = !1) {
            let k;
            return typeof D == "string" ? k = Object.assign({}, this._defaultOpts, { importedSource: D }, $) : (i(!$, "Unexpected secondary arguments."), k = Object.assign({}, this._defaultOpts, D)), !I && $ && ($.nameHint !== void 0 && (k.nameHint = $.nameHint), $.blockHoist !== void 0 && (k.blockHoist = $.blockHoist)), k;
          }
          _generateImport(D, $) {
            const I = $ === "default", k = !!$ && !I, L = $ === null, { importedSource: M, importedType: x, importedInterop: _, importingInterop: S, ensureLiveReference: C, ensureNoContext: R, nameHint: H, importPosition: z, blockHoist: U } = D;
            let P = H || $;
            const W = (0, s.default)(this._programPath), B = W && S === "node", Q = W && S === "babel";
            if (z === "after" && !W) throw new Error('"importPosition": "after" is only supported in modules');
            const J = new f.default(M, this._programScope, this._hub);
            if (x === "es6") {
              if (!B && !Q) throw new Error("Cannot import an ES6 module from CommonJS");
              J.import(), L ? J.namespace(H || M) : (I || k) && J.named(P, $);
            } else {
              if (x !== "commonjs") throw new Error(`Unexpected interopType "${x}"`);
              if (_ === "babel") if (B) {
                P = P !== "default" ? P : M;
                const N = `${M}$es6Default`;
                J.import(), L ? J.default(N).var(P || M).wildcardInterop() : I ? C ? J.default(N).var(P || M).defaultInterop().read("default") : J.default(N).var(P).defaultInterop().prop($) : k && J.default(N).read($);
              } else Q ? (J.import(), L ? J.namespace(P || M) : (I || k) && J.named(P, $)) : (J.require(), L ? J.var(P || M).wildcardInterop() : (I || k) && C ? I ? (P = P !== "default" ? P : M, J.var(P).read($), J.defaultInterop()) : J.var(M).read($) : I ? J.var(P).defaultInterop().prop($) : k && J.var(P).prop($));
              else if (_ === "compiled") B ? (J.import(), L ? J.default(P || M) : (I || k) && J.default(M).read(P)) : Q ? (J.import(), L ? J.namespace(P || M) : (I || k) && J.named(P, $)) : (J.require(), L ? J.var(P || M) : (I || k) && (C ? J.var(M).read(P) : J.prop($).var(P)));
              else {
                if (_ !== "uncompiled") throw new Error(`Unknown importedInterop "${_}".`);
                if (I && C) throw new Error("No live reference for commonjs default");
                B ? (J.import(), L ? J.default(P || M) : I ? J.default(P) : k && J.default(M).read(P)) : Q ? (J.import(), L ? J.default(P || M) : I ? J.default(P) : k && J.named(P, $)) : (J.require(), L ? J.var(P || M) : I ? J.var(P) : k && (C ? J.var(M).read(P) : J.var(P).prop($)));
              }
            }
            const { statements: re, resultName: G } = J.done();
            return this._insertStatements(re, z, U), (I || k) && R && G.type !== "Identifier" ? g([m(0), G]) : G;
          }
          _insertStatements(D, $ = "before", I = 3) {
            if ($ === "after") {
              if (this._insertStatementsAfter(D)) return;
            } else if (this._insertStatementsBefore(D, I)) return;
            this._programPath.unshiftContainer("body", D);
          }
          _insertStatementsBefore(D, $) {
            if (D.length === 1 && b(D[0]) && v(D[0])) {
              const k = this._programPath.get("body").find((L) => L.isImportDeclaration() && v(L.node));
              if ((k == null ? void 0 : k.node.source.value) === D[0].source.value && O(k.node, D[0])) return !0;
            }
            D.forEach((k) => {
              k._blockHoist = $;
            });
            const I = this._programPath.get("body").find((k) => {
              const L = k.node._blockHoist;
              return Number.isFinite(L) && L < 4;
            });
            return !!I && (I.insertBefore(D), !0);
          }
          _insertStatementsAfter(D) {
            const $ = new Set(D), I = /* @__PURE__ */ new Map();
            for (const L of D) if (b(L) && v(L)) {
              const M = L.source.value;
              I.has(M) || I.set(M, []), I.get(M).push(L);
            }
            let k = null;
            for (const L of this._programPath.get("body")) if (L.isImportDeclaration() && v(L.node)) {
              k = L;
              const M = L.node.source.value, x = I.get(M);
              if (!x) continue;
              for (const _ of x) $.has(_) && O(L.node, _) && $.delete(_);
            }
            return $.size === 0 || (k && k.insertAfter(Array.from($)), !!k);
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "ImportInjector", { enumerable: !0, get: function() {
          return i.default;
        } }), n.addDefault = function(f, s, o) {
          return new i.default(f).addDefault(s, o);
        }, n.addNamed = function(f, s, o, y) {
          return new i.default(f).addNamed(s, o, y);
        }, n.addNamespace = function(f, s, o) {
          return new i.default(f).addNamespace(s, o);
        }, n.addSideEffect = function(f, s, o) {
          return new i.default(f).addSideEffect(s, o);
        }, Object.defineProperty(n, "isModule", { enumerable: !0, get: function() {
          return c.default;
        } });
        var i = u("./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/import-injector.js"), c = u("./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/is-module.js");
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/is-module.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(u) {
          return u.node.sourceType === "module";
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.buildDynamicImport = function(c, f, s, o) {
          const y = i.types.isCallExpression(c) ? c.arguments[0] : c.source;
          if (i.types.isStringLiteral(y) || i.types.isTemplateLiteral(y) && y.quasis.length === 0) return f ? i.template.expression.ast`
        Promise.resolve().then(() => ${o(y)})
      ` : o(y);
          const m = i.types.isTemplateLiteral(y) ? i.types.identifier("specifier") : i.types.templateLiteral([i.types.templateElement({ raw: "" }), i.types.templateElement({ raw: "" })], [i.types.identifier("specifier")]);
          return f ? i.template.expression.ast`
      (specifier =>
        new Promise(r => r(${m}))
          .then(s => ${o(i.types.identifier("s"))})
      )(${y})
    ` : s ? i.template.expression.ast`
      (specifier =>
        new Promise(r => r(${o(m)}))
      )(${y})
    ` : i.template.expression.ast`
      (specifier => ${o(m)})(${y})
    `;
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        n.getDynamicImportSource = function(c) {
          const [f] = c.arguments;
          return i.types.isStringLiteral(f) || i.types.isTemplateLiteral(f) ? f : i.template.expression.ast`\`\${${f}}\``;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/get-module-name.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = u;
        {
          const i = u;
          n.default = u = function(c, f) {
            var s, o, y, m;
            return i(c, { moduleId: (s = f.moduleId) != null ? s : c.moduleId, moduleIds: (o = f.moduleIds) != null ? o : c.moduleIds, getModuleId: (y = f.getModuleId) != null ? y : c.getModuleId, moduleRoot: (m = f.moduleRoot) != null ? m : c.moduleRoot });
          };
        }
        function u(i, c) {
          const { filename: f, filenameRelative: s = f, sourceRoot: o = c.moduleRoot } = i, { moduleId: y, moduleIds: m = !!y, getModuleId: g, moduleRoot: b = o } = c;
          if (!m) return null;
          if (y != null && !g) return y;
          let v = b != null ? b + "/" : "";
          if (s) {
            const T = o != null ? new RegExp("^" + o + "/?") : "";
            v += s.replace(T, "").replace(/\.(\w*?)$/, "");
          }
          return v = v.replace(/\\/g, "/"), g && g(v) || v;
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "buildDynamicImport", { enumerable: !0, get: function() {
          return g.buildDynamicImport;
        } }), n.buildNamespaceInitStatements = function(U, P, W = !1, B = m.wrapReference) {
          var Q;
          const J = [], re = I(P.name);
          for (const N of P.importsNamespace) N !== P.name && J.push(c.template.statement`var NAME = SOURCE;`({ NAME: N, SOURCE: E(re) }));
          const G = (Q = B(re, P.wrap)) != null ? Q : re;
          W && J.push(...R(U, P, !0, B));
          for (const N of P.reexportNamespace) J.push((c.types.isIdentifier(G) ? c.template.statement`EXPORTS.NAME = NAMESPACE;` : c.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({ EXPORTS: U.exportName, NAME: N, NAMESPACE: E(G) }));
          if (P.reexportAll) {
            const N = function(V, F, X) {
              return (X ? c.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : c.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: F, EXPORTS: V.exportName, VERIFY_NAME_LIST: V.exportNameListName ? c.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: V.exportNameListName }) : null });
            }(U, E(G), W);
            N.loc = P.reexportAll.loc, J.push(N);
          }
          return J;
        }, n.ensureStatementsHoisted = function(U) {
          U.forEach((P) => {
            P._blockHoist = 3;
          });
        }, Object.defineProperty(n, "getModuleName", { enumerable: !0, get: function() {
          return b.default;
        } }), Object.defineProperty(n, "hasExports", { enumerable: !0, get: function() {
          return y.hasExports;
        } }), Object.defineProperty(n, "isModule", { enumerable: !0, get: function() {
          return f.isModule;
        } }), Object.defineProperty(n, "isSideEffectImport", { enumerable: !0, get: function() {
          return y.isSideEffectImport;
        } }), n.rewriteModuleStatementsAndPrepareHeader = function(U, { exportName: P, strict: W, allowTopLevelThis: B, strictMode: Q, noInterop: J, importInterop: re = J ? "none" : "babel", lazy: G, getWrapperPayload: N = m.toGetWrapperPayload(G != null && G), wrapReference: V = m.wrapReference, esNamespaceOnly: F, filename: X, constantReexports: K = arguments[1].loose, enumerableModuleMeta: ie = arguments[1].loose, noIncompleteNsImportDetection: fe }) {
          (0, y.validateImportInteropOption)(re), i((0, f.isModule)(U), "Cannot process module statements in a script"), U.node.sourceType = "script";
          const _e = (0, y.default)(U, P, { importInterop: re, initializeReexports: K, getWrapperPayload: N, esNamespaceOnly: F, filename: X });
          B || (0, s.default)(U), (0, o.default)(U, _e, V), Q !== !1 && (U.node.directives.some((ae) => ae.value.value === "use strict") || U.unshiftContainer("directives", O(D("use strict"))));
          const Ae = [];
          (0, y.hasExports)(_e) && !W && Ae.push(function(ee, ae = !1) {
            return (ae ? c.template.statement`
        EXPORTS.__esModule = true;
      ` : c.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: ee.exportName });
          }(_e, ie));
          const ce = function(ee, ae) {
            const oe = /* @__PURE__ */ Object.create(null);
            for (const we of ae.local.values()) for (const ge of we.names) oe[ge] = !0;
            let me = !1;
            for (const we of ae.source.values()) {
              for (const ge of we.reexports.keys()) oe[ge] = !0;
              for (const ge of we.reexportNamespace) oe[ge] = !0;
              me = me || !!we.reexportAll;
            }
            if (!me || Object.keys(oe).length === 0) return null;
            const ye = ee.scope.generateUidIdentifier("exportNames");
            return delete oe.default, { name: ye.name, statement: _("var", [S(ye, x(oe))]) };
          }(U, _e);
          return ce && (_e.exportNameListName = ce.name, Ae.push(ce.statement)), Ae.push(...function(ee, ae, oe, me = !1, ye = !1) {
            const we = [];
            for (const [se, be] of ae.local) if (be.kind !== "import") {
              if (be.kind === "hoisted") we.push([be.names[0], z(ae, be.names, I(se))]);
              else if (!ye) for (const Ie of be.names) we.push([Ie, null]);
            }
            for (const se of ae.source.values()) {
              if (!me) {
                const be = R(ae, se, !1, oe), Ie = [...se.reexports.keys()];
                for (let Oe = 0; Oe < be.length; Oe++) we.push([Ie[Oe], be[Oe]]);
              }
              if (!ye) for (const be of se.reexportNamespace) we.push([be, null]);
            }
            we.sort(([se], [be]) => se < be ? -1 : be < se ? 1 : 0);
            const ge = [];
            if (ye) for (const [, se] of we) ge.push(se);
            else
              for (let be = 0; be < we.length; be += 100) {
                let Ie = [];
                for (let Oe = 0; Oe < 100 && be + Oe < we.length; Oe++) {
                  const [Be, Fe] = we[be + Oe];
                  Fe !== null ? (Ie.length > 0 && (ge.push(z(ae, Ie, ee.scope.buildUndefinedNode())), Ie = []), ge.push(Fe)) : Ie.push(Be);
                }
                Ie.length > 0 && ge.push(z(ae, Ie, ee.scope.buildUndefinedNode()));
              }
            return ge;
          }(U, _e, V, K, fe)), { meta: _e, headers: Ae };
        }, Object.defineProperty(n, "rewriteThis", { enumerable: !0, get: function() {
          return s.default;
        } }), n.wrapInterop = function(U, P, W) {
          if (W === "none") return null;
          if (W === "node-namespace") return T(U.hub.addHelper("interopRequireWildcard"), [P, v(!0)]);
          if (W === "node-default") return null;
          let B;
          if (W === "default") B = "interopRequireDefault";
          else {
            if (W !== "namespace") throw new Error(`Unknown interop: ${W}`);
            B = "interopRequireWildcard";
          }
          return T(U.hub.addHelper(B), [P]);
        };
        var i = u("assert"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-module-imports@7.24.7/node_modules/@babel/helper-module-imports/lib/index.js"), s = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"), o = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"), y = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"), m = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js"), g = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"), b = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/get-module-name.js");
        const { booleanLiteral: v, callExpression: T, cloneNode: E, directive: O, directiveLiteral: D, expressionStatement: $, identifier: I, isIdentifier: k, memberExpression: L, stringLiteral: M, valueToNode: x, variableDeclaration: _, variableDeclarator: S } = c.types;
        n.getDynamicImportSource = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js").getDynamicImportSource;
        const C = { constant: c.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: c.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: c.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` };
        function R(U, P, W, B) {
          var Q;
          let J = I(P.name);
          J = (Q = B(J, P.wrap)) != null ? Q : J;
          const { stringSpecifiers: re } = U;
          return Array.from(P.reexports, ([G, N]) => {
            let V = E(J);
            N === "default" && P.interop === "node-default" || (V = re.has(N) ? L(V, M(N), !0) : L(V, I(N)));
            const F = { EXPORTS: U.exportName, EXPORT_NAME: G, NAMESPACE_IMPORT: V };
            return W || k(V) ? re.has(G) ? C.constantComputed(F) : C.constant(F) : C.spec(F);
          });
        }
        const H = { computed: c.template.expression`EXPORTS["NAME"] = VALUE`, default: c.template.expression`EXPORTS.NAME = VALUE`, define: c.template.expression`Object.defineProperty(EXPORTS, "NAME", { enumerable:true, value: void 0, writable: true })["NAME"] = VALUE` };
        function z(U, P, W) {
          const { stringSpecifiers: B, exportName: Q } = U;
          return $(P.reduce((J, re) => {
            const G = { EXPORTS: Q, NAME: re, VALUE: J };
            return re === "__proto__" ? H.define(G) : B.has(re) ? H.computed(G) : H.default(G);
          }, W));
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.toGetWrapperPayload = function(f) {
          return (s, o) => {
            if (f === !1 || (0, c.isSideEffectImport)(o) || o.reexportAll) return null;
            if (f === !0) return /\./.test(s) ? null : "lazy";
            if (Array.isArray(f)) return f.indexOf(s) === -1 ? null : "lazy";
            if (typeof f == "function") return f(s) ? "lazy" : null;
            throw new Error(".lazy must be a boolean, string array, or function");
          };
        }, n.wrapReference = function(f, s) {
          return s === "lazy" ? i.types.callExpression(f, []) : null;
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js");
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(g, b, { importInterop: v, initializeReexports: T = !1, getWrapperPayload: E, esNamespaceOnly: O = !1, filename: D }) {
          b || (b = g.scope.generateUidIdentifier("exports").name);
          const $ = /* @__PURE__ */ new Set();
          (function(M) {
            M.get("body").forEach((x) => {
              x.isExportDefaultDeclaration() && (0, f.default)(x);
            });
          })(g);
          const { local: I, sources: k, hasExports: L } = function(M, { getWrapperPayload: x, initializeReexports: _ }, S) {
            const C = function(P, W, B) {
              const Q = /* @__PURE__ */ new Map();
              P.get("body").forEach((G) => {
                let N;
                if (G.isImportDeclaration()) N = "import";
                else {
                  if (G.isExportDefaultDeclaration() && (G = G.get("declaration")), G.isExportNamedDeclaration()) {
                    if (G.node.declaration) G = G.get("declaration");
                    else if (W && G.node.source && G.get("source").isStringLiteral()) return void G.get("specifiers").forEach((V) => {
                      m(V), Q.set(V.get("local").node.name, "block");
                    });
                  }
                  if (G.isFunctionDeclaration()) N = "hoisted";
                  else if (G.isClassDeclaration()) N = "block";
                  else if (G.isVariableDeclaration({ kind: "var" })) N = "var";
                  else {
                    if (!G.isVariableDeclaration()) return;
                    N = "block";
                  }
                }
                Object.keys(G.getOuterBindingIdentifiers()).forEach((V) => {
                  Q.set(V, N);
                });
              });
              const J = /* @__PURE__ */ new Map(), re = (G) => {
                const N = G.node.name;
                let V = J.get(N);
                if (!V) {
                  const F = Q.get(N);
                  if (F === void 0) throw G.buildCodeFrameError(`Exporting local "${N}", which is not declared.`);
                  V = { names: [], kind: F }, J.set(N, V);
                }
                return V;
              };
              return P.get("body").forEach((G) => {
                if (!G.isExportNamedDeclaration() || !W && G.node.source) {
                  if (G.isExportDefaultDeclaration()) {
                    const N = G.get("declaration");
                    if (!N.isFunctionDeclaration() && !N.isClassDeclaration()) throw N.buildCodeFrameError("Unexpected default expression export.");
                    re(N.get("id")).names.push("default");
                  }
                } else if (G.node.declaration) {
                  const N = G.get("declaration"), V = N.getOuterBindingIdentifierPaths();
                  Object.keys(V).forEach((F) => {
                    if (F === "__esModule") throw N.buildCodeFrameError('Illegal export "__esModule".');
                    re(V[F]).names.push(F);
                  });
                } else G.get("specifiers").forEach((N) => {
                  const V = N.get("local"), F = N.get("exported"), X = re(V), K = y(F, B);
                  if (K === "__esModule") throw F.buildCodeFrameError('Illegal export "__esModule".');
                  X.names.push(K);
                });
              }), J;
            }(M, _, S), R = /* @__PURE__ */ new Map(), H = /* @__PURE__ */ new Map(), z = (P, W) => {
              const B = P.value;
              let Q = H.get(B);
              return Q ? R.get(B).push(W) : (Q = { name: M.scope.generateUidIdentifier((0, i.basename)(B, (0, i.extname)(B))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, wrap: null, get lazy() {
                return this.wrap === "lazy";
              }, referenced: !1 }, H.set(B, Q), R.set(B, [W])), Q;
            };
            let U = !1;
            M.get("body").forEach((P) => {
              if (P.isImportDeclaration()) {
                const W = z(P.node.source, P.node);
                W.loc || (W.loc = P.node.loc), P.get("specifiers").forEach((B) => {
                  if (B.isImportDefaultSpecifier()) {
                    const Q = B.get("local").node.name;
                    W.imports.set(Q, "default");
                    const J = C.get(Q);
                    J && (C.delete(Q), J.names.forEach((re) => {
                      W.reexports.set(re, "default");
                    }), W.referenced = !0);
                  } else if (B.isImportNamespaceSpecifier()) {
                    const Q = B.get("local").node.name;
                    W.importsNamespace.add(Q);
                    const J = C.get(Q);
                    J && (C.delete(Q), J.names.forEach((re) => {
                      W.reexportNamespace.add(re);
                    }), W.referenced = !0);
                  } else if (B.isImportSpecifier()) {
                    const Q = y(B.get("imported"), S), J = B.get("local").node.name;
                    W.imports.set(J, Q);
                    const re = C.get(J);
                    re && (C.delete(J), re.names.forEach((G) => {
                      W.reexports.set(G, Q);
                    }), W.referenced = !0);
                  }
                });
              } else if (P.isExportAllDeclaration()) {
                U = !0;
                const W = z(P.node.source, P.node);
                W.loc || (W.loc = P.node.loc), W.reexportAll = { loc: P.node.loc }, W.referenced = !0;
              } else if (P.isExportNamedDeclaration() && P.node.source) {
                U = !0;
                const W = z(P.node.source, P.node);
                W.loc || (W.loc = P.node.loc), P.get("specifiers").forEach((B) => {
                  m(B);
                  const Q = y(B.get("local"), S), J = y(B.get("exported"), S);
                  if (W.reexports.set(J, Q), W.referenced = !0, J === "__esModule") throw B.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                });
              } else (P.isExportNamedDeclaration() || P.isExportDefaultDeclaration()) && (U = !0);
            });
            for (const P of H.values()) {
              let W = !1, B = !1;
              P.importsNamespace.size > 0 && (W = !0, B = !0), P.reexportAll && (B = !0);
              for (const Q of P.imports.values()) Q === "default" ? W = !0 : B = !0;
              for (const Q of P.reexports.values()) Q === "default" ? W = !0 : B = !0;
              W && B ? P.interop = "namespace" : W && (P.interop = "default");
            }
            if (x) for (const [P, W] of H) W.wrap = x(P, W, R.get(P));
            return { hasExports: U, local: C, sources: H };
          }(g, { initializeReexports: T, getWrapperPayload: E }, $);
          (function(M) {
            M.get("body").forEach((x) => {
              if (x.isImportDeclaration()) x.remove();
              else if (x.isExportNamedDeclaration()) x.node.declaration ? (x.node.declaration._blockHoist = x.node._blockHoist, x.replaceWith(x.node.declaration)) : x.remove();
              else if (x.isExportDefaultDeclaration()) {
                const _ = x.get("declaration");
                if (!_.isFunctionDeclaration() && !_.isClassDeclaration()) throw _.buildCodeFrameError("Unexpected default expression export.");
                _._blockHoist = x.node._blockHoist, x.replaceWith(_);
              } else x.isExportAllDeclaration() && x.remove();
            });
          })(g);
          for (const [M, x] of k) {
            const { importsNamespace: _, imports: S } = x;
            if (_.size > 0 && S.size === 0) {
              const [R] = _;
              x.name = R;
            }
            const C = o(v, M, D);
            C === "none" ? x.interop = "none" : C === "node" && x.interop === "namespace" ? x.interop = "node-namespace" : C === "node" && x.interop === "default" ? x.interop = "node-default" : O && x.interop === "namespace" && (x.interop = "default");
          }
          return { exportName: b, exportNameListName: null, hasExports: L, local: I, source: k, stringSpecifiers: $ };
        }, n.hasExports = function(g) {
          return g.hasExports;
        }, n.isSideEffectImport = function(g) {
          return g.imports.size === 0 && g.importsNamespace.size === 0 && g.reexports.size === 0 && g.reexportNamespace.size === 0 && !g.reexportAll;
        }, n.validateImportInteropOption = s;
        var i = u("path"), c = u("./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.24.7/node_modules/@babel/helper-split-export-declaration/lib/index.js");
        function s(g) {
          if (typeof g != "function" && g !== "none" && g !== "babel" && g !== "node") throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${g}).`);
          return g;
        }
        function o(g, b, v) {
          return typeof g == "function" ? s(g(b, v)) : g;
        }
        function y(g, b) {
          if (g.isIdentifier()) return g.node.name;
          if (g.isStringLiteral()) {
            const v = g.node.value;
            return (0, c.isIdentifierName)(v) || b.add(v), v;
          }
          throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${g.node.type}`);
        }
        function m(g) {
          if (!g.isExportSpecifier()) throw g.isExportNamespaceSpecifier() ? g.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : g.buildCodeFrameError("Unexpected export specifier type");
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(U, P, W) {
          const B = /* @__PURE__ */ new Map(), Q = /* @__PURE__ */ new Map(), J = (V) => {
            U.requeue(V);
          };
          for (const [V, F] of P.source) {
            for (const [X, K] of F.imports) B.set(X, [V, K, null]);
            for (const X of F.importsNamespace) B.set(X, [V, null, X]);
          }
          for (const [V, F] of P.local) {
            let X = Q.get(V);
            X || (X = [], Q.set(V, X)), X.push(...F.names);
          }
          const re = { metadata: P, requeueInParent: J, scope: U.scope, exported: Q };
          U.traverse(C, re);
          const G = /* @__PURE__ */ new Set([...Array.from(B.keys()), ...Array.from(Q.keys())]);
          (0, f.default)(U, G, !1);
          const N = { seen: /* @__PURE__ */ new WeakSet(), metadata: P, requeueInParent: J, scope: U.scope, imported: B, exported: Q, buildImportReference([V, F, X], K) {
            const ie = P.source.get(V);
            if (ie.referenced = !0, X) {
              var fe;
              return ie.wrap && (K = (fe = W(K, ie.wrap)) != null ? fe : K), K;
            }
            let _e = g(ie.name);
            var Ae;
            if (ie.wrap && (_e = (Ae = W(_e, ie.wrap)) != null ? Ae : _e), F === "default" && ie.interop === "node-default") return _e;
            const ce = P.stringSpecifiers.has(F);
            return k(_e, ce ? x(F) : g(F), ce);
          } };
          U.traverse(z, N);
        };
        var i = u("assert"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-simple-access@7.24.7/node_modules/@babel/helper-simple-access/lib/index.js");
        const { assignmentExpression: s, cloneNode: o, expressionStatement: y, getOuterBindingIdentifiers: m, identifier: g, isArrowFunctionExpression: b, isClassExpression: v, isFunctionExpression: T, isIdentifier: E, isMemberExpression: O, isVariableDeclaration: D, jsxIdentifier: $, jsxMemberExpression: I, memberExpression: k, numericLiteral: L, sequenceExpression: M, stringLiteral: x, variableDeclaration: _, variableDeclarator: S } = c.types, C = { Scope(U) {
          U.skip();
        }, ClassDeclaration(U) {
          const { requeueInParent: P, exported: W, metadata: B } = this, { id: Q } = U.node;
          if (!Q) throw new Error("Expected class to have a name");
          const J = Q.name, re = W.get(J) || [];
          if (re.length > 0) {
            const G = y(R(B, re, g(J), U.scope));
            G._blockHoist = U.node._blockHoist, P(U.insertAfter(G)[0]);
          }
        }, VariableDeclaration(U) {
          const { requeueInParent: P, exported: W, metadata: B } = this, Q = U.node.kind === "var";
          for (const J of U.get("declarations")) {
            const { id: re } = J.node;
            let { init: G } = J.node;
            if (!E(re) || !W.has(re.name) || b(G) || T(G) && !G.id || v(G) && !G.id) {
              for (const N of Object.keys(J.getOuterBindingIdentifiers())) if (W.has(N)) {
                const V = y(R(B, W.get(N), g(N), U.scope));
                V._blockHoist = U.node._blockHoist, P(U.insertAfter(V)[0]);
              }
            } else {
              if (!G) {
                if (Q) continue;
                G = U.scope.buildUndefinedNode();
              }
              J.node.init = R(B, W.get(re.name), G, U.scope), P(J.get("init"));
            }
          }
        } }, R = (U, P, W, B) => {
          const Q = U.exportName;
          for (let J = B; J != null; J = J.parent) J.hasOwnBinding(Q) && J.rename(Q);
          return (P || []).reduce((J, re) => {
            const { stringSpecifiers: G } = U, N = G.has(re);
            return s("=", k(g(Q), N ? x(re) : g(re), N), J);
          }, W);
        }, H = (U) => c.template.expression.ast`
    (function() {
      throw new Error('"' + '${U}' + '" is read-only.');
    })()
  `, z = { ReferencedIdentifier(U) {
          const { seen: P, buildImportReference: W, scope: B, imported: Q, requeueInParent: J } = this;
          if (P.has(U.node)) return;
          P.add(U.node);
          const re = U.node.name, G = Q.get(re);
          if (G) {
            if (function(F) {
              do
                switch (F.parent.type) {
                  case "TSTypeAnnotation":
                  case "TSTypeAliasDeclaration":
                  case "TSTypeReference":
                  case "TypeAnnotation":
                  case "TypeAlias":
                    return !0;
                  case "ExportSpecifier":
                    return F.parentPath.parent.exportKind === "type";
                  default:
                    if (F.parentPath.isStatement() || F.parentPath.isExpression()) return !1;
                }
              while (F = F.parentPath);
            }(U)) throw U.buildCodeFrameError(`Cannot transform the imported binding "${re}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const N = U.scope.getBinding(re);
            if (B.getBinding(re) !== N) return;
            const V = W(G, U.node);
            if (V.loc = U.node.loc, (U.parentPath.isCallExpression({ callee: U.node }) || U.parentPath.isOptionalCallExpression({ callee: U.node }) || U.parentPath.isTaggedTemplateExpression({ tag: U.node })) && O(V)) U.replaceWith(M([L(0), V]));
            else if (U.isJSXIdentifier() && O(V)) {
              const { object: F, property: X } = V;
              U.replaceWith(I($(F.name), $(X.name)));
            } else U.replaceWith(V);
            J(U), U.skip();
          }
        }, UpdateExpression(U) {
          const { scope: P, seen: W, imported: B, exported: Q, requeueInParent: J, buildImportReference: re } = this;
          if (W.has(U.node)) return;
          W.add(U.node);
          const G = U.get("argument");
          if (G.isMemberExpression()) return;
          const N = U.node;
          if (G.isIdentifier()) {
            const V = G.node.name;
            if (P.getBinding(V) !== U.scope.getBinding(V)) return;
            const F = Q.get(V), X = B.get(V);
            if ((F == null ? void 0 : F.length) > 0 || X) if (X) U.replaceWith(s(N.operator[0] + "=", re(X, G.node), H(V)));
            else if (N.prefix) U.replaceWith(R(this.metadata, F, o(N), U.scope));
            else {
              const K = P.generateDeclaredUidIdentifier(V);
              U.replaceWith(M([s("=", o(K), o(N)), R(this.metadata, F, g(V), U.scope), o(K)]));
            }
          }
          J(U), U.skip();
        }, AssignmentExpression: { exit(U) {
          const { scope: P, seen: W, imported: B, exported: Q, requeueInParent: J, buildImportReference: re } = this;
          if (W.has(U.node)) return;
          W.add(U.node);
          const G = U.get("left");
          if (!G.isMemberExpression()) if (G.isIdentifier()) {
            const N = G.node.name;
            if (P.getBinding(N) !== U.scope.getBinding(N)) return;
            const V = Q.get(N), F = B.get(N);
            if ((V == null ? void 0 : V.length) > 0 || F) {
              i(U.node.operator === "=", "Path was not simplified");
              const X = U.node;
              F && (X.left = re(F, G.node), X.right = M([X.right, H(N)])), U.replaceWith(R(this.metadata, V, X, U.scope)), J(U);
            }
          } else {
            const N = G.getOuterBindingIdentifiers(), V = Object.keys(N).filter((K) => P.getBinding(K) === U.scope.getBinding(K)), F = V.find((K) => B.has(K));
            F && (U.node.right = M([U.node.right, H(F)]));
            const X = [];
            if (V.forEach((K) => {
              const ie = Q.get(K) || [];
              ie.length > 0 && X.push(R(this.metadata, ie, g(K), U.scope));
            }), X.length > 0) {
              let K = M(X);
              U.parentPath.isExpressionStatement() && (K = y(K), K._blockHoist = U.parentPath.node._blockHoist), J(U.insertAfter(K)[0]);
            }
          }
        } }, "ForOfStatement|ForInStatement"(U) {
          const { scope: P, node: W } = U, { left: B } = W, { exported: Q, imported: J, scope: re } = this;
          if (!D(B)) {
            let G, N = !1;
            const V = U.get("body").scope;
            for (const K of Object.keys(m(B))) re.getBinding(K) === P.getBinding(K) && (Q.has(K) && (N = !0, V.hasOwnBinding(K) && V.rename(K)), J.has(K) && !G && (G = K));
            if (!N && !G) return;
            U.ensureBlock();
            const F = U.get("body"), X = P.generateUidIdentifierBasedOnNode(B);
            U.get("left").replaceWith(_("let", [S(o(X))])), P.registerDeclaration(U.get("left")), N && F.unshiftContainer("body", y(s("=", B, X))), G && F.unshiftContainer("body", y(H(G)));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(y) {
          (0, c.traverse)(y.node, Object.assign({}, o, { noScope: !0 }));
        };
        var i = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        const { numericLiteral: f, unaryExpression: s } = c.types, o = c.traverse.visitors.merge([i.default, { ThisExpression(y) {
          y.replaceWith(s("void", f(0), !0));
        } }]);
      }, "./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.24.7/node_modules/@babel/helper-optimise-call-expression/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(b, v, T, E) {
          return T.length === 1 && o(T[0]) && s(T[0].argument, { name: "arguments" }) ? E ? m(g(b, f("apply"), !1, !0), [v, T[0].argument], !1) : c(y(b, f("apply")), [v, T[0].argument]) : E ? m(g(b, f("call"), !1, !0), [v, ...T], !1) : c(y(b, f("call")), [v, ...T]);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { callExpression: c, identifier: f, isIdentifier: s, isSpreadElement: o, memberExpression: y, optionalCallExpression: m, optionalMemberExpression: g } = i;
      }, "./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.declare = i, n.declarePreset = void 0;
        const u = { assertVersion: (f) => (s) => {
          (function(o, y) {
            if (typeof o == "number") {
              if (!Number.isInteger(o)) throw new Error("Expected string or integer value.");
              o = `^${o}.0.0-0`;
            }
            if (typeof o != "string") throw new Error("Expected string or integer value.");
            const m = Error.stackTraceLimit;
            typeof m == "number" && m < 25 && (Error.stackTraceLimit = 25);
            let g;
            throw g = y.slice(0, 2) === "7." ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${y}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${o}", but was loaded with "${y}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof m == "number" && (Error.stackTraceLimit = m), Object.assign(g, { code: "BABEL_VERSION_UNSUPPORTED", version: y, range: o });
          })(s, f.version);
        } };
        function i(f) {
          return (s, o, y) => {
            var m;
            let g;
            for (const b of Object.keys(u))
              s[b] || (g != null || (g = c(s)), g[b] = u[b](g));
            return f((m = g) != null ? m : s, o || {}, y);
          };
        }
        Object.assign(u, { targets: () => () => ({}), assumption: () => () => {
        } }), n.declarePreset = i;
        function c(f) {
          let s = null;
          return typeof f.version == "string" && /^7\./.test(f.version) && (s = Object.getPrototypeOf(f), !s || hasOwnProperty.call(s, "version") && hasOwnProperty.call(s, "transform") && hasOwnProperty.call(s, "template") && hasOwnProperty.call(s, "types") || (s = null)), Object.assign({}, s, f);
        }
      }, "./node_modules/.pnpm/@babel+helper-replace-supers@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-replace-supers/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.24.7/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.24.7/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        const { assignmentExpression: o, booleanLiteral: y, callExpression: m, cloneNode: g, identifier: b, memberExpression: v, sequenceExpression: T, stringLiteral: E, thisExpression: O } = s.types;
        {
          const M = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js");
          n.environmentVisitor = M.default, n.skipAllButComputedKey = M.skipAllButComputedKey;
        }
        function D(M, x, _, S) {
          M = g(M);
          const C = x || S ? M : v(M, b("prototype"));
          return m(_.addHelper("getPrototypeOf"), [C]);
        }
        const $ = s.traverse.visitors.merge([i.default, { Super(M, x) {
          const { node: _, parentPath: S } = M;
          S.isMemberExpression({ object: _ }) && x.handle(S);
        } }]), I = s.traverse.visitors.merge([i.default, { Scopable(M, { refName: x }) {
          const _ = M.scope.getOwnBinding(x);
          _ && _.identifier.name === x && M.scope.rename(x);
        } }]), k = { memoise(M, x) {
          const { scope: _, node: S } = M, { computed: C, property: R } = S;
          if (!C) return;
          const H = _.maybeGenerateMemoised(R);
          H && this.memoiser.set(R, H, x);
        }, prop(M) {
          const { computed: x, property: _ } = M.node;
          return this.memoiser.has(_) ? g(this.memoiser.get(_)) : x ? g(_) : E(_.name);
        }, get(M) {
          return this._get(M, this._getThisRefs());
        }, _get(M, x) {
          const _ = D(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return m(this.file.addHelper("get"), [x.needAccessFirst ? T([x.this, _]) : _, this.prop(M), x.this]);
        }, _getThisRefs() {
          return { needAccessFirst: this.isDerivedConstructor, this: O() };
        }, set(M, x) {
          const _ = this._getThisRefs(), S = D(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return m(this.file.addHelper("set"), [_.needAccessFirst ? T([_.this, S]) : S, this.prop(M), x, _.this, y(M.isInStrictMode())]);
        }, destructureSet(M) {
          throw M.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(M, x) {
          const _ = this._getThisRefs();
          return (0, f.default)(this._get(M, _), g(_.this), x, !1);
        }, optionalCall(M, x) {
          const _ = this._getThisRefs();
          return (0, f.default)(this._get(M, _), g(_.this), x, !0);
        }, delete(M) {
          return M.node.computed ? T([m(this.file.addHelper("toPropertyKey"), [g(M.node.property)]), s.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : s.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, L = Object.assign({}, k, { prop(M) {
          const { property: x } = M.node;
          return this.memoiser.has(x) ? g(this.memoiser.get(x)) : g(x);
        }, get(M) {
          const { isStatic: x, getSuperRef: _ } = this, { computed: S } = M.node, C = this.prop(M);
          let R;
          var H, z;
          return x ? R = (H = _()) != null ? H : v(b("Function"), b("prototype")) : R = v((z = _()) != null ? z : b("Object"), b("prototype")), v(R, C, S);
        }, set(M, x) {
          const { computed: _ } = M.node, S = this.prop(M);
          return o("=", v(O(), S, _), x);
        }, destructureSet(M) {
          const { computed: x } = M.node, _ = this.prop(M);
          return v(O(), _, x);
        }, call(M, x) {
          return (0, f.default)(this.get(M), O(), x, !1);
        }, optionalCall(M, x) {
          return (0, f.default)(this.get(M), O(), x, !0);
        } });
        n.default = class {
          constructor(M) {
            var x;
            const _ = M.methodPath;
            this.methodPath = _, this.isDerivedConstructor = _.isClassMethod({ kind: "constructor" }) && !!M.superRef, this.isStatic = _.isObjectMethod() || _.node.static || (_.isStaticBlock == null ? void 0 : _.isStaticBlock()), this.isPrivateMethod = _.isPrivate() && _.isMethod(), this.file = M.file, this.constantSuper = (x = M.constantSuper) != null ? x : M.isLoose, this.opts = M;
          }
          getObjectRef() {
            return g(this.opts.objectRef || this.opts.getObjectRef());
          }
          getSuperRef() {
            return this.opts.superRef ? g(this.opts.superRef) : this.opts.getSuperRef ? g(this.opts.getSuperRef()) : void 0;
          }
          replace() {
            const { methodPath: M } = this;
            this.opts.refToPreserve && M.traverse(I, { refName: this.opts.refToPreserve.name });
            const x = this.constantSuper ? L : k;
            $.shouldSkip = (_) => {
              if (_.parentPath === M && (_.parentKey === "decorators" || _.parentKey === "key")) return !0;
            }, (0, c.default)(M, $, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: x.get }, x));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-simple-access@7.24.7/node_modules/@babel/helper-simple-access/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(E, O) {
          var D;
          E.traverse(T, { scope: E.scope, bindingNames: O, seen: /* @__PURE__ */ new WeakSet(), includeUpdateExpression: (D = arguments[2]) == null || D });
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { LOGICAL_OPERATORS: c, assignmentExpression: f, binaryExpression: s, cloneNode: o, identifier: y, logicalExpression: m, numericLiteral: g, sequenceExpression: b, unaryExpression: v } = i, T = { AssignmentExpression: { exit(E) {
          const { scope: O, seen: D, bindingNames: $ } = this;
          if (E.node.operator === "=" || D.has(E.node)) return;
          D.add(E.node);
          const I = E.get("left");
          if (!I.isIdentifier()) return;
          const k = I.node.name;
          if (!$.has(k) || O.getBinding(k) !== E.scope.getBinding(k)) return;
          const L = E.node.operator.slice(0, -1);
          c.includes(L) ? E.replaceWith(m(L, E.node.left, f("=", o(E.node.left), E.node.right))) : (E.node.right = s(L, o(E.node.left), E.node.right), E.node.operator = "=");
        } } };
        T.UpdateExpression = { exit(E) {
          if (!this.includeUpdateExpression) return;
          const { scope: O, bindingNames: D } = this, $ = E.get("argument");
          if (!$.isIdentifier()) return;
          const I = $.node.name;
          if (D.has(I) && O.getBinding(I) === E.scope.getBinding(I)) if (E.parentPath.isExpressionStatement() && !E.isCompletionRecord()) {
            const k = E.node.operator === "++" ? "+=" : "-=";
            E.replaceWith(f(k, $.node, g(1)));
          } else if (E.node.prefix) E.replaceWith(f("=", y(I), s(E.node.operator[0], v("+", $.node), g(1))));
          else {
            const k = E.scope.generateUidIdentifierBasedOnNode($.node, "old"), L = k.name;
            E.scope.push({ id: k });
            const M = s(E.node.operator[0], y(L), g(1));
            E.replaceWith(b([f("=", y(L), v("+", $.node)), f("=", o($.node), M), y(L)]));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.24.7/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isTransparentExprWrapper = g, n.skipTransparentExprWrapperNodes = function(b) {
          for (; g(b); ) b = b.expression;
          return b;
        }, n.skipTransparentExprWrappers = function(b) {
          for (; g(b.node); ) b = b.get("expression");
          return b;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isParenthesizedExpression: c, isTSAsExpression: f, isTSNonNullExpression: s, isTSSatisfiesExpression: o, isTSTypeAssertion: y, isTypeCastExpression: m } = i;
        function g(b) {
          return f(b) || o(b) || y(b) || s(b) || m(b) || c(b);
        }
      }, "./node_modules/.pnpm/@babel+helper-split-export-declaration@7.24.7/node_modules/@babel/helper-split-export-declaration/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(g) {
          if (!g.isExportDeclaration() || g.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
          if (g.isExportDefaultDeclaration()) {
            const O = g.get("declaration"), D = O.isFunctionDeclaration() || O.isClassDeclaration(), $ = O.isFunctionExpression() || O.isClassExpression(), I = O.isScope() ? O.scope.parent : O.scope;
            let k = O.node.id, L = !1;
            k ? $ && I.hasBinding(k.name) && (L = !0, k = I.generateUidIdentifier(k.name)) : (L = !0, k = I.generateUidIdentifier("default"), (D || $) && (O.node.id = c(k)));
            const M = D ? O.node : y("var", [m(c(k), O.node)]), x = f(null, [s(c(k), o("default"))]);
            return g.insertAfter(x), g.replaceWith(M), L && I.registerDeclaration(g), g;
          }
          if (g.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
          const b = g.get("declaration"), v = b.getOuterBindingIdentifiers(), T = Object.keys(v).map((O) => s(o(O), o(O))), E = f(null, T);
          return g.insertAfter(E), g.replaceWith(b.node), g;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { cloneNode: c, exportNamedDeclaration: f, exportSpecifier: s, identifier: o, variableDeclaration: y, variableDeclarator: m } = i;
      }, "./node_modules/.pnpm/@babel+helper-string-parser@7.24.7/node_modules/@babel/helper-string-parser/lib/index.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.readCodePoint = m, n.readInt = y, n.readStringContents = function(g, b, v, T, E, O) {
          const D = v, $ = T, I = E;
          let k = "", L = null, M = v;
          const { length: x } = b;
          for (; ; ) {
            if (v >= x) {
              O.unterminated(D, $, I), k += b.slice(M, v);
              break;
            }
            const _ = b.charCodeAt(v);
            if (f(g, _, b, v)) {
              k += b.slice(M, v);
              break;
            }
            if (_ === 92) {
              k += b.slice(M, v);
              const S = s(b, v, T, E, g === "template", O);
              S.ch !== null || L ? k += S.ch : L = { pos: v, lineStart: T, curLine: E }, { pos: v, lineStart: T, curLine: E } = S, M = v;
            } else _ === 8232 || _ === 8233 ? (++E, T = ++v) : _ === 10 || _ === 13 ? g === "template" ? (k += b.slice(M, v) + `
`, ++v, _ === 13 && b.charCodeAt(v) === 10 && ++v, ++E, M = T = v) : O.unterminated(D, $, I) : ++v;
          }
          return { pos: v, str: k, firstInvalidLoc: L, lineStart: T, curLine: E, containsInvalid: !!L };
        };
        var u = function(g) {
          return g >= 48 && g <= 57;
        };
        const i = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, c = { bin: (g) => g === 48 || g === 49, oct: (g) => g >= 48 && g <= 55, dec: (g) => g >= 48 && g <= 57, hex: (g) => g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102 };
        function f(g, b, v, T) {
          return g === "template" ? b === 96 || b === 36 && v.charCodeAt(T + 1) === 123 : b === (g === "double" ? 34 : 39);
        }
        function s(g, b, v, T, E, O) {
          const D = !E;
          b++;
          const $ = (k) => ({ pos: b, ch: k, lineStart: v, curLine: T }), I = g.charCodeAt(b++);
          switch (I) {
            case 110:
              return $(`
`);
            case 114:
              return $("\r");
            case 120: {
              let k;
              return { code: k, pos: b } = o(g, b, v, T, 2, !1, D, O), $(k === null ? null : String.fromCharCode(k));
            }
            case 117: {
              let k;
              return { code: k, pos: b } = m(g, b, v, T, D, O), $(k === null ? null : String.fromCodePoint(k));
            }
            case 116:
              return $("	");
            case 98:
              return $("\b");
            case 118:
              return $("\v");
            case 102:
              return $("\f");
            case 13:
              g.charCodeAt(b) === 10 && ++b;
            case 10:
              v = b, ++T;
            case 8232:
            case 8233:
              return $("");
            case 56:
            case 57:
              if (E) return $(null);
              O.strictNumericEscape(b - 1, v, T);
            default:
              if (I >= 48 && I <= 55) {
                const k = b - 1;
                let L = g.slice(k, b + 2).match(/^[0-7]+/)[0], M = parseInt(L, 8);
                M > 255 && (L = L.slice(0, -1), M = parseInt(L, 8)), b += L.length - 1;
                const x = g.charCodeAt(b);
                if (L !== "0" || x === 56 || x === 57) {
                  if (E) return $(null);
                  O.strictNumericEscape(k, v, T);
                }
                return $(String.fromCharCode(M));
              }
              return $(String.fromCharCode(I));
          }
        }
        function o(g, b, v, T, E, O, D, $) {
          const I = b;
          let k;
          return { n: k, pos: b } = y(g, b, v, T, 16, E, O, !1, $, !D), k === null && (D ? $.invalidEscapeSequence(I, v, T) : b = I - 1), { code: k, pos: b };
        }
        function y(g, b, v, T, E, O, D, $, I, k) {
          const L = b, M = E === 16 ? i.hex : i.decBinOct, x = E === 16 ? c.hex : E === 10 ? c.dec : E === 8 ? c.oct : c.bin;
          let _ = !1, S = 0;
          for (let C = 0, R = O ?? 1 / 0; C < R; ++C) {
            const H = g.charCodeAt(b);
            let z;
            if (H !== 95 || $ === "bail") {
              if (z = H >= 97 ? H - 97 + 10 : H >= 65 ? H - 65 + 10 : u(H) ? H - 48 : 1 / 0, z >= E) {
                if (z <= 9 && k) return { n: null, pos: b };
                if (z <= 9 && I.invalidDigit(b, v, T, E)) z = 0;
                else {
                  if (!D) break;
                  z = 0, _ = !0;
                }
              }
              ++b, S = S * E + z;
            } else {
              const U = g.charCodeAt(b - 1), P = g.charCodeAt(b + 1);
              if ($) {
                if (Number.isNaN(P) || !x(P) || M.has(U) || M.has(P)) {
                  if (k) return { n: null, pos: b };
                  I.unexpectedNumericSeparator(b, v, T);
                }
              } else {
                if (k) return { n: null, pos: b };
                I.numericSeparatorInEscapeSequence(b, v, T);
              }
              ++b;
            }
          }
          return b === L || O != null && b - L !== O || _ ? { n: null, pos: b } : { n: S, pos: b };
        }
        function m(g, b, v, T, E, O) {
          let D;
          if (g.charCodeAt(b) === 123) {
            if (++b, { code: D, pos: b } = o(g, b, v, T, g.indexOf("}", b) - b, !0, E, O), ++b, D !== null && D > 1114111) {
              if (!E) return { code: null, pos: b };
              O.invalidCodePoint(b, v, T);
            }
          } else ({ code: D, pos: b } = o(g, b, v, T, 4, !1, E, O));
          return { code: D, pos: b };
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/identifier.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isIdentifierChar = g, n.isIdentifierName = function(b) {
          let v = !0;
          for (let T = 0; T < b.length; T++) {
            let E = b.charCodeAt(T);
            if ((64512 & E) == 55296 && T + 1 < b.length) {
              const O = b.charCodeAt(++T);
              (64512 & O) == 56320 && (E = 65536 + ((1023 & E) << 10) + (1023 & O));
            }
            if (v) {
              if (v = !1, !m(E)) return !1;
            } else if (!g(E)) return !1;
          }
          return !v;
        }, n.isIdentifierStart = m;
        let u = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", i = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
        const c = new RegExp("[" + u + "]"), f = new RegExp("[" + u + i + "]");
        u = i = null;
        const s = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], o = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function y(b, v) {
          let T = 65536;
          for (let E = 0, O = v.length; E < O; E += 2) {
            if (T += v[E], T > b) return !1;
            if (T += v[E + 1], T >= b) return !0;
          }
          return !1;
        }
        function m(b) {
          return b < 65 ? b === 36 : b <= 90 || (b < 97 ? b === 95 : b <= 122 || (b <= 65535 ? b >= 170 && c.test(String.fromCharCode(b)) : y(b, s)));
        }
        function g(b) {
          return b < 48 ? b === 36 : b < 58 || !(b < 65) && (b <= 90 || (b < 97 ? b === 95 : b <= 122 || (b <= 65535 ? b >= 170 && f.test(String.fromCharCode(b)) : y(b, s) || y(b, o))));
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "isIdentifierChar", { enumerable: !0, get: function() {
          return i.isIdentifierChar;
        } }), Object.defineProperty(n, "isIdentifierName", { enumerable: !0, get: function() {
          return i.isIdentifierName;
        } }), Object.defineProperty(n, "isIdentifierStart", { enumerable: !0, get: function() {
          return i.isIdentifierStart;
        } }), Object.defineProperty(n, "isKeyword", { enumerable: !0, get: function() {
          return c.isKeyword;
        } }), Object.defineProperty(n, "isReservedWord", { enumerable: !0, get: function() {
          return c.isReservedWord;
        } }), Object.defineProperty(n, "isStrictBindOnlyReservedWord", { enumerable: !0, get: function() {
          return c.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(n, "isStrictBindReservedWord", { enumerable: !0, get: function() {
          return c.isStrictBindReservedWord;
        } }), Object.defineProperty(n, "isStrictReservedWord", { enumerable: !0, get: function() {
          return c.isStrictReservedWord;
        } });
        var i = u("./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/identifier.js"), c = u("./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/keyword.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/keyword.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isKeyword = function(g) {
          return c.has(g);
        }, n.isReservedWord = o, n.isStrictBindOnlyReservedWord = m, n.isStrictBindReservedWord = function(g, b) {
          return y(g, b) || m(g);
        }, n.isStrictReservedWord = y;
        const u = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], i = ["eval", "arguments"], c = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), f = new Set(u), s = new Set(i);
        function o(g, b) {
          return b && g === "await" || g === "enum";
        }
        function y(g, b) {
          return o(g, b) || f.has(g);
        }
        function m(g) {
          return s.has(g);
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/find-suggestion.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.findSuggestion = function(i, c) {
          const f = c.map((s) => function(o, y) {
            let m, g, b = [], v = [];
            const T = o.length, E = y.length;
            if (!T) return E;
            if (!E) return T;
            for (g = 0; g <= E; g++) b[g] = g;
            for (m = 1; m <= T; m++) {
              for (v = [m], g = 1; g <= E; g++) v[g] = o[m - 1] === y[g - 1] ? b[g - 1] : u(b[g - 1], b[g], v[g - 1]) + 1;
              b = v;
            }
            return v[E];
          }(s, i));
          return c[f.indexOf(u(...f))];
        };
        const { min: u } = Math;
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "OptionValidator", { enumerable: !0, get: function() {
          return i.OptionValidator;
        } }), Object.defineProperty(n, "findSuggestion", { enumerable: !0, get: function() {
          return c.findSuggestion;
        } });
        var i = u("./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/validator.js"), c = u("./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/validator.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.OptionValidator = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
        n.OptionValidator = class {
          constructor(c) {
            this.descriptor = c;
          }
          validateTopLevelOptions(c, f) {
            const s = Object.keys(f);
            for (const o of Object.keys(c)) if (!s.includes(o)) throw new Error(this.formatMessage(`'${o}' is not a valid top-level option.
- Did you mean '${(0, i.findSuggestion)(o, s)}'?`));
          }
          validateBooleanOption(c, f, s) {
            return f === void 0 ? s : (this.invariant(typeof f == "boolean", `'${c}' option must be a boolean.`), f);
          }
          validateStringOption(c, f, s) {
            return f === void 0 ? s : (this.invariant(typeof f == "string", `'${c}' option must be a string.`), f);
          }
          invariant(c, f) {
            if (!c) throw new Error(this.formatMessage(f));
          }
          formatMessage(c) {
            return `${this.descriptor}: ${c}`;
          }
        };
      }, "./node_modules/.pnpm/@babel+helpers@7.24.7/node_modules/@babel/helpers/lib/helpers-generated.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/index.js");
        function c(s, o, y) {
          return Object.freeze({ minVersion: s, ast: () => i.default.program.ast(o, { preserveComments: !0 }), metadata: y });
        }
        const f = n.default = { __proto__: null, OverloadYield: c("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", { globals: [], locals: { _OverloadYield: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_OverloadYield", dependencies: {} }), applyDecoratedDescriptor: c("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer&&(Object.defineProperty(i,e,a),a=null),a}', { globals: ["Object"], locals: { _applyDecoratedDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_applyDecoratedDescriptor", dependencies: {} }), applyDecs2311: c("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', { globals: ["Symbol", "Object", "TypeError", "Error"], locals: { applyDecs2311: ["body.0.id"] }, exportBindingAssignments: [], exportName: "applyDecs2311", dependencies: { checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"], toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"] } }), arrayLikeToArray: c("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", { globals: ["Array"], locals: { _arrayLikeToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayLikeToArray", dependencies: {} }), arrayWithHoles: c("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", { globals: ["Array"], locals: { _arrayWithHoles: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayWithHoles", dependencies: {} }), arrayWithoutHoles: c("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", { globals: ["Array"], locals: { _arrayWithoutHoles: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayWithoutHoles", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"] } }), assertClassBrand: c("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', { globals: ["TypeError"], locals: { _assertClassBrand: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_assertClassBrand", dependencies: {} }), assertThisInitialized: c("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}`, { globals: ["ReferenceError"], locals: { _assertThisInitialized: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_assertThisInitialized", dependencies: {} }), asyncGeneratorDelegate: c("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', { globals: ["Promise", "Symbol"], locals: { _asyncGeneratorDelegate: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_asyncGeneratorDelegate", dependencies: { OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"] } }), asyncIterator: c("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', { globals: ["Symbol", "TypeError", "Object", "Promise"], locals: { _asyncIterator: ["body.0.id"], AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"] }, exportBindingAssignments: [], exportName: "_asyncIterator", dependencies: {} }), asyncToGenerator: c("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}', { globals: ["Promise"], locals: { asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"], _asyncToGenerator: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_asyncToGenerator", dependencies: {} }), awaitAsyncGenerator: c("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", { globals: [], locals: { _awaitAsyncGenerator: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_awaitAsyncGenerator", dependencies: { OverloadYield: ["body.0.body.body.0.argument.callee"] } }), callSuper: c("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", { globals: ["Reflect"], locals: { _callSuper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_callSuper", dependencies: { getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"], isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"], possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"] } }), checkInRHS: c("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`, { globals: ["Object", "TypeError"], locals: { _checkInRHS: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_checkInRHS", dependencies: {} }), checkPrivateRedeclaration: c("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', { globals: ["TypeError"], locals: { _checkPrivateRedeclaration: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_checkPrivateRedeclaration", dependencies: {} }), classCallCheck: c("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', { globals: ["TypeError"], locals: { _classCallCheck: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCallCheck", dependencies: {} }), classNameTDZError: c("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in computed property keys.')}`, { globals: ["ReferenceError"], locals: { _classNameTDZError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classNameTDZError", dependencies: {} }), classPrivateFieldGet2: c("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", { globals: [], locals: { _classPrivateFieldGet2: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldGet2", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"] } }), classPrivateFieldInitSpec: c("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", { globals: [], locals: { _classPrivateFieldInitSpec: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldInitSpec", dependencies: { checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"] } }), classPrivateFieldLooseBase: c("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', { globals: ["TypeError"], locals: { _classPrivateFieldBase: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldBase", dependencies: {} }), classPrivateFieldLooseKey: c("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', { globals: [], locals: { id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"], _classPrivateFieldKey: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldKey", dependencies: {} }), classPrivateFieldSet2: c("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", { globals: [], locals: { _classPrivateFieldSet2: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldSet2", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"] } }), classPrivateGetter: c("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", { globals: [], locals: { _classPrivateGetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateGetter", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"] } }), classPrivateMethodInitSpec: c("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", { globals: [], locals: { _classPrivateMethodInitSpec: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodInitSpec", dependencies: { checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"] } }), classPrivateSetter: c("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", { globals: [], locals: { _classPrivateSetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateSetter", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"] } }), classStaticPrivateMethodGet: c("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", { globals: [], locals: { _classStaticPrivateMethodGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateMethodGet", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"] } }), construct: c("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", { globals: ["Reflect"], locals: { _construct: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_construct", dependencies: { isNativeReflectConstruct: ["body.0.body.body.0.test.callee"], setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"] } }), createClass: c("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', { globals: ["Object"], locals: { _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"], _createClass: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_createClass", dependencies: { toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"] } }), createForOfIteratorHelper: c("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', { globals: ["Symbol", "Array", "TypeError"], locals: { _createForOfIteratorHelper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createForOfIteratorHelper", dependencies: { unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"] } }), createForOfIteratorHelperLoose: c("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["Symbol", "Array", "TypeError"], locals: { _createForOfIteratorHelperLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createForOfIteratorHelperLoose", dependencies: { unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"] } }), createSuper: c("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", { globals: ["Reflect"], locals: { _createSuper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createSuper", dependencies: { getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"], isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"], possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"] } }), decorate: c("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected '"+r+"' to be a function");return t}`, { globals: ["Object", "TypeError", "Symbol", "ReferenceError"], locals: { _decorate: ["body.0.id"], _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"], _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"], _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"], _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"], _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"], _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"], _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"] }, exportBindingAssignments: [], exportName: "_decorate", dependencies: { toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"], toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"] } }), defaults: c("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", { globals: ["Object"], locals: { _defaults: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defaults", dependencies: {} }), defineAccessor: c("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", { globals: ["Object"], locals: { _defineAccessor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineAccessor", dependencies: {} }), defineProperty: c("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", { globals: ["Object"], locals: { _defineProperty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineProperty", dependencies: { toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"] } }), extends: c("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", { globals: ["Object"], locals: { _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_extends", dependencies: {} }), get: c("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', { globals: ["Reflect", "Object"], locals: { _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_get", dependencies: { superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"] } }), getPrototypeOf: c("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", { globals: ["Object"], locals: { _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_getPrototypeOf", dependencies: {} }), identity: c("7.17.0", "function _identity(t){return t}", { globals: [], locals: { _identity: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_identity", dependencies: {} }), importDeferProxy: c("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", { globals: ["Proxy", "Reflect"], locals: { _importDeferProxy: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_importDeferProxy", dependencies: {} }), inherits: c("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', { globals: ["TypeError", "Object"], locals: { _inherits: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_inherits", dependencies: { setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"] } }), inheritsLoose: c("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", { globals: ["Object"], locals: { _inheritsLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_inheritsLoose", dependencies: { setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"] } }), initializerDefineProperty: c("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", { globals: ["Object"], locals: { _initializerDefineProperty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_initializerDefineProperty", dependencies: {} }), initializerWarningHelper: c("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', { globals: ["Error"], locals: { _initializerWarningHelper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_initializerWarningHelper", dependencies: {} }), instanceof: c("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', { globals: ["Symbol"], locals: { _instanceof: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_instanceof", dependencies: {} }), interopRequireDefault: c("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", { globals: [], locals: { _interopRequireDefault: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_interopRequireDefault", dependencies: {} }), interopRequireWildcard: c("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}', { globals: ["WeakMap", "Object"], locals: { _getRequireWildcardCache: ["body.0.id", "body.1.body.body.2.declarations.0.init.callee", "body.0.body.body.2.argument.callee.left"], _interopRequireWildcard: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_interopRequireWildcard", dependencies: {} }), isNativeFunction: c("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', { globals: ["Function"], locals: { _isNativeFunction: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_isNativeFunction", dependencies: {} }), isNativeReflectConstruct: c("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", { globals: ["Boolean", "Reflect"], locals: { _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.callee"], exportName: "_isNativeReflectConstruct", dependencies: {} }), iterableToArray: c("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', { globals: ["Symbol", "Array"], locals: { _iterableToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_iterableToArray", dependencies: {} }), iterableToArrayLimit: c("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', { globals: ["Symbol", "Object"], locals: { _iterableToArrayLimit: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_iterableToArrayLimit", dependencies: {} }), jsx: c("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', { globals: ["Symbol", "Array"], locals: { REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"], _createRawReactElement: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_createRawReactElement", dependencies: {} }), maybeArrayLike: c("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', { globals: ["Array"], locals: { _maybeArrayLike: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_maybeArrayLike", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"] } }), newArrowCheck: c("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', { globals: ["TypeError"], locals: { _newArrowCheck: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_newArrowCheck", dependencies: {} }), nonIterableRest: c("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["TypeError"], locals: { _nonIterableRest: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nonIterableRest", dependencies: {} }), nonIterableSpread: c("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["TypeError"], locals: { _nonIterableSpread: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nonIterableSpread", dependencies: {} }), nullishReceiverError: c("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', { globals: ["TypeError"], locals: { _nullishReceiverError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nullishReceiverError", dependencies: {} }), objectDestructuringEmpty: c("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', { globals: ["TypeError"], locals: { _objectDestructuringEmpty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectDestructuringEmpty", dependencies: {} }), objectSpread2: c("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", { globals: ["Object"], locals: { ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"], _objectSpread2: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_objectSpread2", dependencies: { defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"] } }), objectWithoutProperties: c("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],t.indexOf(o)>=0||{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", { globals: ["Object"], locals: { _objectWithoutProperties: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectWithoutProperties", dependencies: { objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"] } }), objectWithoutPropertiesLoose: c("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.indexOf(n)>=0)continue;t[n]=r[n]}return t}", { globals: [], locals: { _objectWithoutPropertiesLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectWithoutPropertiesLoose", dependencies: {} }), possibleConstructorReturn: c("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', { globals: ["TypeError"], locals: { _possibleConstructorReturn: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_possibleConstructorReturn", dependencies: { assertThisInitialized: ["body.0.body.body.2.argument.callee"] } }), readOnlyError: c("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, { globals: ["TypeError"], locals: { _readOnlyError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_readOnlyError", dependencies: {} }), regeneratorRuntime: c("7.18.0", `function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`, { globals: ["Object", "Symbol", "Error", "TypeError", "isNaN", "Promise"], locals: { _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.expression.left"] }, exportBindingAssignments: ["body.0.body.body.0.expression"], exportName: "_regeneratorRuntime", dependencies: {} }), set: c("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', { globals: ["Reflect", "Object", "TypeError"], locals: { set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"], _set: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_set", dependencies: { superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"], defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"] } }), setFunctionName: c("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', { globals: ["Object"], locals: { setFunctionName: ["body.0.id"] }, exportBindingAssignments: [], exportName: "setFunctionName", dependencies: {} }), setPrototypeOf: c("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", { globals: ["Object"], locals: { _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_setPrototypeOf", dependencies: {} }), skipFirstGeneratorNext: c("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", { globals: [], locals: { _skipFirstGeneratorNext: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_skipFirstGeneratorNext", dependencies: {} }), slicedToArray: c("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", { globals: [], locals: { _slicedToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_slicedToArray", dependencies: { arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableRest: ["body.0.body.body.0.argument.right.callee"] } }), superPropBase: c("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", { globals: [], locals: { _superPropBase: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropBase", dependencies: { getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"] } }), taggedTemplateLiteral: c("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", { globals: ["Object"], locals: { _taggedTemplateLiteral: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_taggedTemplateLiteral", dependencies: {} }), taggedTemplateLiteralLoose: c("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", { globals: [], locals: { _taggedTemplateLiteralLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_taggedTemplateLiteralLoose", dependencies: {} }), tdz: c("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', { globals: ["ReferenceError"], locals: { _tdzError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_tdzError", dependencies: {} }), temporalRef: c("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", { globals: [], locals: { _temporalRef: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_temporalRef", dependencies: { temporalUndefined: ["body.0.body.body.0.argument.test.right"], tdz: ["body.0.body.body.0.argument.consequent.callee"] } }), temporalUndefined: c("7.0.0-beta.0", "function _temporalUndefined(){}", { globals: [], locals: { _temporalUndefined: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_temporalUndefined", dependencies: {} }), toArray: c("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", { globals: [], locals: { _toArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toArray", dependencies: { arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableRest: ["body.0.body.body.0.argument.right.callee"] } }), toConsumableArray: c("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", { globals: [], locals: { _toConsumableArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toConsumableArray", dependencies: { arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableSpread: ["body.0.body.body.0.argument.right.callee"] } }), toPrimitive: c("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', { globals: ["Symbol", "TypeError", "String", "Number"], locals: { toPrimitive: ["body.0.id"] }, exportBindingAssignments: [], exportName: "toPrimitive", dependencies: {} }), toPropertyKey: c("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', { globals: [], locals: { toPropertyKey: ["body.0.id"] }, exportBindingAssignments: [], exportName: "toPropertyKey", dependencies: { toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"] } }), toSetter: c("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', { globals: ["Object"], locals: { _toSetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toSetter", dependencies: {} }), typeof: c("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', { globals: ["Symbol"], locals: { _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_typeof", dependencies: {} }), unsupportedIterableToArray: c("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', { globals: ["Array"], locals: { _unsupportedIterableToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_unsupportedIterableToArray", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"] } }), usingCtx: c("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,n){var e=Error();return e.name="SuppressedError",e.error=r,e.suppressed=n,e},n={},e=[];function using(r,n){if(null!=n){if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==o&&(o=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof o)throw new TypeError("Property [Symbol.dispose] is not a function.");e.push({v:n,d:o,a:r})}else r&&e.push({d:n,a:r});return n}return{e:n,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o=this.e;function next(){for(;r=e.pop();)try{var r,t=r.d&&r.d.call(r.v);if(r.a)return Promise.resolve(t).then(next,err)}catch(r){return err(r)}if(o!==n)throw o}function err(e){return o=o!==n?new r(e,o):e,next()}return next()}}}', { globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"], locals: { _usingCtx: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_usingCtx", dependencies: {} }), wrapAsyncGenerator: c("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', { globals: ["Promise", "Symbol"], locals: { _wrapAsyncGenerator: ["body.0.id"], AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"] }, exportBindingAssignments: [], exportName: "_wrapAsyncGenerator", dependencies: { OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"] } }), wrapNativeSuper: c("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', { globals: ["Map", "TypeError", "Object"], locals: { _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"], exportName: "_wrapNativeSuper", dependencies: { getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"], setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"], isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"], construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"] } }), wrapRegExp: c("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', { globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"], locals: { _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"] }, exportBindingAssignments: ["body.0.body.body.0.expression"], exportName: "_wrapRegExp", dependencies: { setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"], inherits: ["body.0.body.body.4.argument.expressions.0.callee"] } }), writeOnlyError: c("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, { globals: ["TypeError"], locals: { _writeOnlyError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_writeOnlyError", dependencies: {} }) };
        Object.assign(f, { AwaitValue: c("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", { globals: [], locals: { _AwaitValue: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_AwaitValue", dependencies: {} }), applyDecs: c("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', { globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"], locals: { old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"], old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"], old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"], old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"], old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"], old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"], old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"], old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"], old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"], old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"], old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"], old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"], old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"], applyDecs: ["body.13.id"] }, exportBindingAssignments: [], exportName: "applyDecs", dependencies: { setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] } }), applyDecs2203: c("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"], applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"], applyDecs2203: ["body.2.id"] }, exportBindingAssignments: [], exportName: "applyDecs2203", dependencies: {} }), applyDecs2203R: c("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"], applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"] }, exportBindingAssignments: ["body.1.body.body.0.argument.callee"], exportName: "applyDecs2203R", dependencies: { setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] } }), applyDecs2301: c("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"], applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"] }, exportBindingAssignments: ["body.1.body.body.0.argument.callee"], exportName: "applyDecs2301", dependencies: { checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] } }), applyDecs2305: c("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', { globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"], locals: { applyDecs2305: ["body.0.id"] }, exportBindingAssignments: [], exportName: "applyDecs2305", dependencies: { checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"], toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"] } }), classApplyDescriptorDestructureSet: c("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', { globals: ["TypeError"], locals: { _classApplyDescriptorDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorDestructureSet", dependencies: {} }), classApplyDescriptorGet: c("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", { globals: [], locals: { _classApplyDescriptorGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorGet", dependencies: {} }), classApplyDescriptorSet: c("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', { globals: ["TypeError"], locals: { _classApplyDescriptorSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorSet", dependencies: {} }), classCheckPrivateStaticAccess: c("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", { globals: [], locals: { _classCheckPrivateStaticAccess: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCheckPrivateStaticAccess", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.callee"] } }), classCheckPrivateStaticFieldDescriptor: c("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', { globals: ["TypeError"], locals: { _classCheckPrivateStaticFieldDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCheckPrivateStaticFieldDescriptor", dependencies: {} }), classExtractFieldDescriptor: c("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", { globals: [], locals: { _classExtractFieldDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classExtractFieldDescriptor", dependencies: { classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"] } }), classPrivateFieldDestructureSet: c("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", { globals: [], locals: { _classPrivateFieldDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldDestructureSet", dependencies: { classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] } }), classPrivateFieldGet: c("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", { globals: [], locals: { _classPrivateFieldGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldGet", dependencies: { classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] } }), classPrivateFieldSet: c("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", { globals: [], locals: { _classPrivateFieldSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldSet", dependencies: { classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] } }), classPrivateMethodGet: c("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", { globals: [], locals: { _classPrivateMethodGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodGet", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"] } }), classPrivateMethodSet: c("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', { globals: ["TypeError"], locals: { _classPrivateMethodSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodSet", dependencies: {} }), classStaticPrivateFieldDestructureSet: c("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', { globals: [], locals: { _classStaticPrivateFieldDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldDestructureSet", dependencies: { classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] } }), classStaticPrivateFieldSpecGet: c("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', { globals: [], locals: { _classStaticPrivateFieldSpecGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldSpecGet", dependencies: { classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] } }), classStaticPrivateFieldSpecSet: c("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', { globals: [], locals: { _classStaticPrivateFieldSpecSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldSpecSet", dependencies: { classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] } }), classStaticPrivateMethodSet: c("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', { globals: ["TypeError"], locals: { _classStaticPrivateMethodSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateMethodSet", dependencies: {} }), defineEnumerableProperties: c("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', { globals: ["Object"], locals: { _defineEnumerableProperties: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineEnumerableProperties", dependencies: {} }), dispose: c("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', { globals: ["SuppressedError", "Error", "Object", "Promise"], locals: { dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"], _dispose: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_dispose", dependencies: {} }), objectSpread: c("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', { globals: ["Object"], locals: { _objectSpread: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectSpread", dependencies: { defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"] } }), using: c("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', { globals: ["Object", "TypeError", "Symbol"], locals: { _using: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_using", dependencies: {} }) });
      }, "./node_modules/.pnpm/@babel+helpers@7.24.7/node_modules/@babel/helpers/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, n.get = g, n.getDependencies = function(b) {
          return m(b).getDependencies();
        }, n.list = void 0, n.minVersion = function(b) {
          return m(b).minVersion;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helpers@7.24.7/node_modules/@babel/helpers/lib/helpers-generated.js");
        const { cloneNode: f, identifier: s } = i;
        function o(b, v, T) {
          try {
            const E = v.split(".");
            let O = E.shift();
            for (; E.length > 0; ) b = b[O], O = E.shift();
            if (!(arguments.length > 2)) return b[O];
            b[O] = T;
          } catch (E) {
            throw E.message += ` (when accessing ${v})`, E;
          }
        }
        const y = /* @__PURE__ */ Object.create(null);
        function m(b) {
          if (!y[b]) {
            const v = c.default[b];
            if (!v) throw Object.assign(new ReferenceError(`Unknown helper ${b}`), { code: "BABEL_HELPER_UNKNOWN", helper: b });
            y[b] = { minVersion: v.minVersion, build(T, E, O, D) {
              const $ = v.ast();
              return function(I, k, L, M, x, _) {
                const { locals: S, dependencies: C, exportBindingAssignments: R, exportName: H } = k, z = new Set(M || []);
                L && z.add(L);
                for (const [U, P] of (Object.entries || ((W) => Object.keys(W).map((B) => [B, W[B]])))(S)) {
                  let W = U;
                  if (L && U === H) W = L;
                  else for (; z.has(W); ) W = "_" + W;
                  if (W !== U) for (const B of P) o(I, B, s(W));
                }
                for (const [U, P] of (Object.entries || ((W) => Object.keys(W).map((B) => [B, W[B]])))(C)) {
                  const W = typeof x == "function" && x(U) || s(U);
                  for (const B of P) o(I, B, f(W));
                }
                _ == null || _(I, H, (U) => {
                  R.forEach((P) => o(I, P, U(o(I, P))));
                });
              }($, v.metadata, E, O, T, D), { nodes: $.body, globals: v.metadata.globals };
            }, getDependencies: () => Object.keys(v.metadata.dependencies) };
          }
          return y[b];
        }
        function g(b, v, T, E, O) {
          if (typeof T == "object") {
            const D = T;
            T = (D == null ? void 0 : D.type) === "Identifier" ? D.name : void 0;
          }
          return m(b).build(v, T, E, O);
        }
        n.ensure = (b) => {
          m(b);
        }, n.list = Object.keys(c.default).map((b) => b.replace(/^_/, "")), n.default = g;
      }, "./node_modules/.pnpm/@babel+parser@7.24.7/node_modules/@babel/parser/lib/index.js": (h, n) => {
        function u(Te, p) {
          if (Te == null) return {};
          var w, q, ne = {}, pe = Object.keys(Te);
          for (q = 0; q < pe.length; q++) w = pe[q], p.indexOf(w) >= 0 || (ne[w] = Te[w]);
          return ne;
        }
        Object.defineProperty(n, "__esModule", { value: !0 });
        class i {
          constructor(p, w, q) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = p, this.column = w, this.index = q;
          }
        }
        class c {
          constructor(p, w) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = p, this.end = w;
          }
        }
        function f(Te, p) {
          const { line: w, column: q, index: ne } = Te;
          return new i(w, q + p, ne + p);
        }
        const s = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        var o = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: s }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: s } };
        const y = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, m = (Te) => Te.type === "UpdateExpression" ? y.UpdateExpression[`${Te.prefix}`] : y[Te.type];
        var g = { AccessorIsGenerator: ({ kind: Te }) => `A ${Te}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: Te }) => `Missing initializer in ${Te} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: Te }) => `\`${Te}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: Te }) => `'import.${Te}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: Te, exportName: p }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${Te}' as '${p}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: Te }) => `'${Te === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: Te }) => `Unsyntactic ${Te === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: Te }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${Te}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: Te }) => `\`import()\` requires exactly ${Te === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: Te }) => `Expected number in radix ${Te}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: Te }) => `Escape sequence in keyword ${Te}.`, InvalidIdentifier: ({ identifierName: Te }) => `Invalid identifier ${Te}.`, InvalidLhs: ({ ancestor: Te }) => `Invalid left-hand side in ${m(Te)}.`, InvalidLhsBinding: ({ ancestor: Te }) => `Binding invalid left-hand side in ${m(Te)}.`, InvalidLhsOptionalChaining: ({ ancestor: Te }) => `Invalid optional chaining in the left-hand side of ${m(Te)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: Te }) => `Unexpected character '${Te}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: Te }) => `Private name #${Te} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: Te }) => `Label '${Te}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: Te }) => `This experimental syntax requires enabling the parser plugin: ${Te.map((p) => JSON.stringify(p)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: Te }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${Te.map((p) => JSON.stringify(p)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: Te }) => `Duplicate key "${Te}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: Te }) => `An export name cannot include a lone surrogate, found '\\u${Te.toString(16)}'.`, ModuleExportUndefined: ({ localName: Te }) => `Export '${Te}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: Te }) => `Private names are only allowed in property accesses (\`obj.#${Te}\`) or in \`in\` expressions (\`#${Te} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: Te }) => `Duplicate private name #${Te}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: Te }) => `Unexpected keyword '${Te}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: Te }) => `Unexpected reserved word '${Te}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: Te, unexpected: p }) => `Unexpected token${p ? ` '${p}'.` : ""}${Te ? `, expected "${Te}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: Te, onlyValidPropertyName: p }) => `The only valid meta property for ${Te} is ${Te}.${p}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: Te }) => `Identifier '${Te}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
        const b = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
        var v = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: Te }) => `Invalid topic token ${Te}. In order to use ${Te} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${Te}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: Te }) => `Hack-style pipe body cannot be an unparenthesized ${m({ type: Te })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
        const T = ["toMessage"], E = ["message"];
        function O(Te, p, w) {
          Object.defineProperty(Te, p, { enumerable: !1, configurable: !0, value: w });
        }
        function D(Te) {
          let { toMessage: p } = Te, w = u(Te, T);
          return function q(ne, pe) {
            const xe = new SyntaxError();
            return Object.assign(xe, w, { loc: ne, pos: ne.index }), "missingPlugin" in pe && Object.assign(xe, { missingPlugin: pe.missingPlugin }), O(xe, "clone", function(Ce = {}) {
              var Re;
              const { line: Ue, column: Ke, index: yt } = (Re = Ce.loc) != null ? Re : ne;
              return q(new i(Ue, Ke, yt), Object.assign({}, pe, Ce.details));
            }), O(xe, "details", pe), Object.defineProperty(xe, "message", { configurable: !0, get() {
              const Ce = `${p(pe)} (${ne.line}:${ne.column})`;
              return this.message = Ce, Ce;
            }, set(Ce) {
              Object.defineProperty(this, "message", { value: Ce, writable: !0 });
            } }), xe;
          };
        }
        function $(Te, p) {
          if (Array.isArray(Te)) return (q) => $(q, Te[0]);
          const w = {};
          for (const q of Object.keys(Te)) {
            const ne = Te[q], pe = typeof ne == "string" ? { message: () => ne } : typeof ne == "function" ? { message: ne } : ne, { message: xe } = pe, Ce = u(pe, E), Re = typeof xe == "string" ? () => xe : xe;
            w[q] = D(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: q, toMessage: Re }, p ? { syntaxPlugin: p } : {}, Ce));
          }
          return w;
        }
        const I = Object.assign({}, $(o), $(g), $({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: Te }) => `Assigning to '${Te}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: Te }) => `Binding '${Te}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), $`pipelineOperator`(v)), { defineProperty: k } = Object, L = (Te, p) => k(Te, p, { enumerable: !1, value: Te[p] });
        function M(Te) {
          return Te.loc.start && L(Te.loc.start, "index"), Te.loc.end && L(Te.loc.end, "index"), Te;
        }
        class x {
          constructor(p, w) {
            this.token = void 0, this.preserveSpace = void 0, this.token = p, this.preserveSpace = !!w;
          }
        }
        const _ = { brace: new x("{"), j_oTag: new x("<tag"), j_cTag: new x("</tag"), j_expr: new x("<tag>...</tag>", !0) };
        _.template = new x("`", !0);
        class S {
          constructor(p, w = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = p, this.keyword = w.keyword, this.beforeExpr = !!w.beforeExpr, this.startsExpr = !!w.startsExpr, this.rightAssociative = !!w.rightAssociative, this.isLoop = !!w.isLoop, this.isAssign = !!w.isAssign, this.prefix = !!w.prefix, this.postfix = !!w.postfix, this.binop = w.binop != null ? w.binop : null, this.updateContext = null;
          }
        }
        const C = /* @__PURE__ */ new Map();
        function R(Te, p = {}) {
          p.keyword = Te;
          const w = re(Te, p);
          return C.set(Te, w), w;
        }
        function H(Te, p) {
          return re(Te, { beforeExpr: !0, binop: p });
        }
        let z = -1;
        const U = [], P = [], W = [], B = [], Q = [], J = [];
        function re(Te, p = {}) {
          var w, q, ne, pe;
          return ++z, P.push(Te), W.push((w = p.binop) != null ? w : -1), B.push((q = p.beforeExpr) != null && q), Q.push((ne = p.startsExpr) != null && ne), J.push((pe = p.prefix) != null && pe), U.push(new S(Te, p)), z;
        }
        function G(Te, p = {}) {
          var w, q, ne, pe;
          return ++z, C.set(Te, z), P.push(Te), W.push((w = p.binop) != null ? w : -1), B.push((q = p.beforeExpr) != null && q), Q.push((ne = p.startsExpr) != null && ne), J.push((pe = p.prefix) != null && pe), U.push(new S("name", p)), z;
        }
        const N = { bracketL: re("[", { beforeExpr: !0, startsExpr: !0 }), bracketHashL: re("#[", { beforeExpr: !0, startsExpr: !0 }), bracketBarL: re("[|", { beforeExpr: !0, startsExpr: !0 }), bracketR: re("]"), bracketBarR: re("|]"), braceL: re("{", { beforeExpr: !0, startsExpr: !0 }), braceBarL: re("{|", { beforeExpr: !0, startsExpr: !0 }), braceHashL: re("#{", { beforeExpr: !0, startsExpr: !0 }), braceR: re("}"), braceBarR: re("|}"), parenL: re("(", { beforeExpr: !0, startsExpr: !0 }), parenR: re(")"), comma: re(",", { beforeExpr: !0 }), semi: re(";", { beforeExpr: !0 }), colon: re(":", { beforeExpr: !0 }), doubleColon: re("::", { beforeExpr: !0 }), dot: re("."), question: re("?", { beforeExpr: !0 }), questionDot: re("?."), arrow: re("=>", { beforeExpr: !0 }), template: re("template"), ellipsis: re("...", { beforeExpr: !0 }), backQuote: re("`", { startsExpr: !0 }), dollarBraceL: re("${", { beforeExpr: !0, startsExpr: !0 }), templateTail: re("...`", { startsExpr: !0 }), templateNonTail: re("...${", { beforeExpr: !0, startsExpr: !0 }), at: re("@"), hash: re("#", { startsExpr: !0 }), interpreterDirective: re("#!..."), eq: re("=", { beforeExpr: !0, isAssign: !0 }), assign: re("_=", { beforeExpr: !0, isAssign: !0 }), slashAssign: re("_=", { beforeExpr: !0, isAssign: !0 }), xorAssign: re("_=", { beforeExpr: !0, isAssign: !0 }), moduloAssign: re("_=", { beforeExpr: !0, isAssign: !0 }), incDec: re("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }), bang: re("!", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), tilde: re("~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), doubleCaret: re("^^", { startsExpr: !0 }), doubleAt: re("@@", { startsExpr: !0 }), pipeline: H("|>", 0), nullishCoalescing: H("??", 1), logicalOR: H("||", 1), logicalAND: H("&&", 2), bitwiseOR: H("|", 3), bitwiseXOR: H("^", 4), bitwiseAND: H("&", 5), equality: H("==/!=/===/!==", 6), lt: H("</>/<=/>=", 7), gt: H("</>/<=/>=", 7), relational: H("</>/<=/>=", 7), bitShift: H("<</>>/>>>", 8), bitShiftL: H("<</>>/>>>", 8), bitShiftR: H("<</>>/>>>", 8), plusMin: re("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }), modulo: re("%", { binop: 10, startsExpr: !0 }), star: re("*", { binop: 10 }), slash: H("/", 10), exponent: re("**", { beforeExpr: !0, binop: 11, rightAssociative: !0 }), _in: R("in", { beforeExpr: !0, binop: 7 }), _instanceof: R("instanceof", { beforeExpr: !0, binop: 7 }), _break: R("break"), _case: R("case", { beforeExpr: !0 }), _catch: R("catch"), _continue: R("continue"), _debugger: R("debugger"), _default: R("default", { beforeExpr: !0 }), _else: R("else", { beforeExpr: !0 }), _finally: R("finally"), _function: R("function", { startsExpr: !0 }), _if: R("if"), _return: R("return", { beforeExpr: !0 }), _switch: R("switch"), _throw: R("throw", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _try: R("try"), _var: R("var"), _const: R("const"), _with: R("with"), _new: R("new", { beforeExpr: !0, startsExpr: !0 }), _this: R("this", { startsExpr: !0 }), _super: R("super", { startsExpr: !0 }), _class: R("class", { startsExpr: !0 }), _extends: R("extends", { beforeExpr: !0 }), _export: R("export"), _import: R("import", { startsExpr: !0 }), _null: R("null", { startsExpr: !0 }), _true: R("true", { startsExpr: !0 }), _false: R("false", { startsExpr: !0 }), _typeof: R("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _void: R("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _delete: R("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }), _do: R("do", { isLoop: !0, beforeExpr: !0 }), _for: R("for", { isLoop: !0 }), _while: R("while", { isLoop: !0 }), _as: G("as", { startsExpr: !0 }), _assert: G("assert", { startsExpr: !0 }), _async: G("async", { startsExpr: !0 }), _await: G("await", { startsExpr: !0 }), _defer: G("defer", { startsExpr: !0 }), _from: G("from", { startsExpr: !0 }), _get: G("get", { startsExpr: !0 }), _let: G("let", { startsExpr: !0 }), _meta: G("meta", { startsExpr: !0 }), _of: G("of", { startsExpr: !0 }), _sent: G("sent", { startsExpr: !0 }), _set: G("set", { startsExpr: !0 }), _source: G("source", { startsExpr: !0 }), _static: G("static", { startsExpr: !0 }), _using: G("using", { startsExpr: !0 }), _yield: G("yield", { startsExpr: !0 }), _asserts: G("asserts", { startsExpr: !0 }), _checks: G("checks", { startsExpr: !0 }), _exports: G("exports", { startsExpr: !0 }), _global: G("global", { startsExpr: !0 }), _implements: G("implements", { startsExpr: !0 }), _intrinsic: G("intrinsic", { startsExpr: !0 }), _infer: G("infer", { startsExpr: !0 }), _is: G("is", { startsExpr: !0 }), _mixins: G("mixins", { startsExpr: !0 }), _proto: G("proto", { startsExpr: !0 }), _require: G("require", { startsExpr: !0 }), _satisfies: G("satisfies", { startsExpr: !0 }), _keyof: G("keyof", { startsExpr: !0 }), _readonly: G("readonly", { startsExpr: !0 }), _unique: G("unique", { startsExpr: !0 }), _abstract: G("abstract", { startsExpr: !0 }), _declare: G("declare", { startsExpr: !0 }), _enum: G("enum", { startsExpr: !0 }), _module: G("module", { startsExpr: !0 }), _namespace: G("namespace", { startsExpr: !0 }), _interface: G("interface", { startsExpr: !0 }), _type: G("type", { startsExpr: !0 }), _opaque: G("opaque", { startsExpr: !0 }), name: re("name", { startsExpr: !0 }), string: re("string", { startsExpr: !0 }), num: re("num", { startsExpr: !0 }), bigint: re("bigint", { startsExpr: !0 }), decimal: re("decimal", { startsExpr: !0 }), regexp: re("regexp", { startsExpr: !0 }), privateName: re("#name", { startsExpr: !0 }), eof: re("eof"), jsxName: re("jsxName"), jsxText: re("jsxText", { beforeExpr: !0 }), jsxTagStart: re("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: re("jsxTagEnd"), placeholder: re("%%", { startsExpr: !0 }) };
        function V(Te) {
          return Te >= 93 && Te <= 132;
        }
        function F(Te) {
          return Te >= 58 && Te <= 132;
        }
        function X(Te) {
          return Te >= 58 && Te <= 136;
        }
        function K(Te) {
          return Q[Te];
        }
        function ie(Te) {
          return Te >= 129 && Te <= 131;
        }
        function fe(Te) {
          return Te >= 58 && Te <= 92;
        }
        function _e(Te) {
          return P[Te];
        }
        function Ae(Te) {
          return W[Te];
        }
        function ce(Te) {
          return Te >= 24 && Te <= 25;
        }
        function ee(Te) {
          return U[Te];
        }
        U[8].updateContext = (Te) => {
          Te.pop();
        }, U[5].updateContext = U[7].updateContext = U[23].updateContext = (Te) => {
          Te.push(_.brace);
        }, U[22].updateContext = (Te) => {
          Te[Te.length - 1] === _.template ? Te.pop() : Te.push(_.template);
        }, U[142].updateContext = (Te) => {
          Te.push(_.j_expr, _.j_oTag);
        };
        let ae = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", oe = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
        const me = new RegExp("[" + ae + "]"), ye = new RegExp("[" + ae + oe + "]");
        ae = oe = null;
        const we = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], ge = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function se(Te, p) {
          let w = 65536;
          for (let q = 0, ne = p.length; q < ne; q += 2) {
            if (w += p[q], w > Te) return !1;
            if (w += p[q + 1], w >= Te) return !0;
          }
          return !1;
        }
        function be(Te) {
          return Te < 65 ? Te === 36 : Te <= 90 || (Te < 97 ? Te === 95 : Te <= 122 || (Te <= 65535 ? Te >= 170 && me.test(String.fromCharCode(Te)) : se(Te, we)));
        }
        function Ie(Te) {
          return Te < 48 ? Te === 36 : Te < 58 || !(Te < 65) && (Te <= 90 || (Te < 97 ? Te === 95 : Te <= 122 || (Te <= 65535 ? Te >= 170 && ye.test(String.fromCharCode(Te)) : se(Te, we) || se(Te, ge))));
        }
        const Oe = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Be = ["eval", "arguments"], Fe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), ue = new Set(Oe), te = new Set(Be);
        function Y(Te, p) {
          return p && Te === "await" || Te === "enum";
        }
        function le(Te, p) {
          return Y(Te, p) || ue.has(Te);
        }
        function Ee(Te) {
          return te.has(Te);
        }
        function Se(Te, p) {
          return le(Te, p) || Ee(Te);
        }
        const Pe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class Ve {
          constructor(p) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = p;
          }
        }
        class Xe {
          constructor(p, w) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = p, this.inModule = w;
          }
          get inTopLevel() {
            return (1 & this.currentScope().flags) > 0;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const p = this.currentThisScopeFlags();
            return (64 & p) > 0 && !(2 & p);
          }
          get inStaticBlock() {
            for (let p = this.scopeStack.length - 1; ; p--) {
              const { flags: w } = this.scopeStack[p];
              if (128 & w) return !0;
              if (451 & w) return !1;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(p) {
            return new Ve(p);
          }
          enter(p) {
            this.scopeStack.push(this.createScope(p));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(p) {
            return !!(130 & p.flags || !this.parser.inModule && 1 & p.flags);
          }
          declareName(p, w, q) {
            let ne = this.currentScope();
            if (8 & w || 16 & w) {
              this.checkRedeclarationInScope(ne, p, w, q);
              let pe = ne.names.get(p) || 0;
              16 & w ? pe |= 4 : (ne.firstLexicalName || (ne.firstLexicalName = p), pe |= 2), ne.names.set(p, pe), 8 & w && this.maybeExportDefined(ne, p);
            } else if (4 & w) for (let pe = this.scopeStack.length - 1; pe >= 0 && (ne = this.scopeStack[pe], this.checkRedeclarationInScope(ne, p, w, q), ne.names.set(p, 1 | (ne.names.get(p) || 0)), this.maybeExportDefined(ne, p), !(387 & ne.flags)); --pe) ;
            this.parser.inModule && 1 & ne.flags && this.undefinedExports.delete(p);
          }
          maybeExportDefined(p, w) {
            this.parser.inModule && 1 & p.flags && this.undefinedExports.delete(w);
          }
          checkRedeclarationInScope(p, w, q, ne) {
            this.isRedeclaredInScope(p, w, q) && this.parser.raise(I.VarRedeclaration, ne, { identifierName: w });
          }
          isRedeclaredInScope(p, w, q) {
            if (!(1 & q)) return !1;
            if (8 & q) return p.names.has(w);
            const ne = p.names.get(w);
            return 16 & q ? (2 & ne) > 0 || !this.treatFunctionsAsVarInScope(p) && (1 & ne) > 0 : (2 & ne) > 0 && !(8 & p.flags && p.firstLexicalName === w) || !this.treatFunctionsAsVarInScope(p) && (4 & ne) > 0;
          }
          checkLocalExport(p) {
            const { name: w } = p;
            this.scopeStack[0].names.has(w) || this.undefinedExports.set(w, p.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let p = this.scopeStack.length - 1; ; p--) {
              const { flags: w } = this.scopeStack[p];
              if (387 & w) return w;
            }
          }
          currentThisScopeFlags() {
            for (let p = this.scopeStack.length - 1; ; p--) {
              const { flags: w } = this.scopeStack[p];
              if (451 & w && !(4 & w)) return w;
            }
          }
        }
        class Ye extends Ve {
          constructor(...p) {
            super(...p), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class We extends Xe {
          createScope(p) {
            return new Ye(p);
          }
          declareName(p, w, q) {
            const ne = this.currentScope();
            if (2048 & w) return this.checkRedeclarationInScope(ne, p, w, q), this.maybeExportDefined(ne, p), void ne.declareFunctions.add(p);
            super.declareName(p, w, q);
          }
          isRedeclaredInScope(p, w, q) {
            if (super.isRedeclaredInScope(p, w, q)) return !0;
            if (2048 & q && !p.declareFunctions.has(w)) {
              const ne = p.names.get(w);
              return (4 & ne) > 0 || (2 & ne) > 0;
            }
            return !1;
          }
          checkLocalExport(p) {
            this.scopeStack[0].declareFunctions.has(p.name) || super.checkLocalExport(p);
          }
        }
        class et {
          constructor() {
            this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
          }
          hasPlugin(p) {
            if (typeof p == "string") return this.plugins.has(p);
            {
              const [w, q] = p;
              if (!this.hasPlugin(w)) return !1;
              const ne = this.plugins.get(w);
              for (const pe of Object.keys(q)) if ((ne == null ? void 0 : ne[pe]) !== q[pe]) return !1;
              return !0;
            }
          }
          getPluginOption(p, w) {
            var q;
            return (q = this.plugins.get(p)) == null ? void 0 : q[w];
          }
        }
        function De(Te, p) {
          Te.trailingComments === void 0 ? Te.trailingComments = p : Te.trailingComments.unshift(...p);
        }
        function Me(Te, p) {
          Te.innerComments === void 0 ? Te.innerComments = p : Te.innerComments.unshift(...p);
        }
        function Qe(Te, p, w) {
          let q = null, ne = p.length;
          for (; q === null && ne > 0; ) q = p[--ne];
          q === null || q.start > w.start ? Me(Te, w.comments) : De(q, w.comments);
        }
        class He extends et {
          addComment(p) {
            this.filename && (p.loc.filename = this.filename);
            const { commentsLen: w } = this.state;
            this.comments.length !== w && (this.comments.length = w), this.comments.push(p), this.state.commentsLen++;
          }
          processComment(p) {
            const { commentStack: w } = this.state, q = w.length;
            if (q === 0) return;
            let ne = q - 1;
            const pe = w[ne];
            pe.start === p.end && (pe.leadingNode = p, ne--);
            const { start: xe } = p;
            for (; ne >= 0; ne--) {
              const Ce = w[ne], Re = Ce.end;
              if (!(Re > xe)) {
                Re === xe && (Ce.trailingNode = p);
                break;
              }
              Ce.containingNode = p, this.finalizeComment(Ce), w.splice(ne, 1);
            }
          }
          finalizeComment(p) {
            const { comments: w } = p;
            if (p.leadingNode !== null || p.trailingNode !== null) p.leadingNode !== null && De(p.leadingNode, w), p.trailingNode !== null && function(q, ne) {
              q.leadingComments === void 0 ? q.leadingComments = ne : q.leadingComments.unshift(...ne);
            }(p.trailingNode, w);
            else {
              const { containingNode: q, start: ne } = p;
              if (this.input.charCodeAt(ne - 1) === 44) switch (q.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  Qe(q, q.properties, p);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  Qe(q, q.arguments, p);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  Qe(q, q.params, p);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  Qe(q, q.elements, p);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  Qe(q, q.specifiers, p);
                  break;
                default:
                  Me(q, w);
              }
              else Me(q, w);
            }
          }
          finalizeRemainingComments() {
            const { commentStack: p } = this.state;
            for (let w = p.length - 1; w >= 0; w--) this.finalizeComment(p[w]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(p) {
            const { commentStack: w } = this.state, { length: q } = w;
            if (q === 0) return;
            const ne = w[q - 1];
            ne.leadingNode === p && (ne.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(p) {
            const { commentStack: w } = this.state, { length: q } = w;
            q !== 0 && (w[q - 1].trailingNode === p ? w[q - 1].trailingNode = null : q >= 2 && w[q - 2].trailingNode === p && (w[q - 2].trailingNode = null));
          }
          takeSurroundingComments(p, w, q) {
            const { commentStack: ne } = this.state, pe = ne.length;
            if (pe === 0) return;
            let xe = pe - 1;
            for (; xe >= 0; xe--) {
              const Ce = ne[xe], Re = Ce.end;
              if (Ce.start === q) Ce.leadingNode = p;
              else if (Re === w) Ce.trailingNode = p;
              else if (Re < w) break;
            }
          }
        }
        const st = /\r\n?|[\n\u2028\u2029]/, it = new RegExp(st.source, "g");
        function qe(Te) {
          switch (Te) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return !0;
            default:
              return !1;
          }
        }
        const rt = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, bt = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, dt = new RegExp("(?=(" + bt.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function Je(Te) {
          switch (Te) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return !0;
            default:
              return !1;
          }
        }
        class mt {
          constructor() {
            this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [_.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (1 & this.flags) > 0;
          }
          set strict(p) {
            p ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: p, sourceType: w, startLine: q, startColumn: ne }) {
            this.strict = p !== !1 && (p === !0 || w === "module"), this.curLine = q, this.lineStart = -ne, this.startLoc = this.endLoc = new i(q, ne, 0);
          }
          get maybeInArrowParameters() {
            return (2 & this.flags) > 0;
          }
          set maybeInArrowParameters(p) {
            p ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (4 & this.flags) > 0;
          }
          set inType(p) {
            p ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (8 & this.flags) > 0;
          }
          set noAnonFunctionType(p) {
            p ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (16 & this.flags) > 0;
          }
          set hasFlowComment(p) {
            p ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (32 & this.flags) > 0;
          }
          set isAmbientContext(p) {
            p ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (64 & this.flags) > 0;
          }
          set inAbstractClass(p) {
            p ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (128 & this.flags) > 0;
          }
          set inDisallowConditionalTypesContext(p) {
            p ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (256 & this.flags) > 0;
          }
          set soloAwait(p) {
            p ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (512 & this.flags) > 0;
          }
          set inFSharpPipelineDirectBody(p) {
            p ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (1024 & this.flags) > 0;
          }
          set canStartJSXElement(p) {
            p ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (2048 & this.flags) > 0;
          }
          set containsEsc(p) {
            p ? this.flags |= 2048 : this.flags &= -2049;
          }
          curPosition() {
            return new i(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone() {
            const p = new mt();
            return p.flags = this.flags, p.curLine = this.curLine, p.lineStart = this.lineStart, p.startLoc = this.startLoc, p.endLoc = this.endLoc, p.errors = this.errors.slice(), p.potentialArrowAt = this.potentialArrowAt, p.noArrowAt = this.noArrowAt.slice(), p.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), p.topicContext = this.topicContext, p.labels = this.labels.slice(), p.commentsLen = this.commentsLen, p.commentStack = this.commentStack.slice(), p.pos = this.pos, p.type = this.type, p.value = this.value, p.start = this.start, p.end = this.end, p.lastTokEndLoc = this.lastTokEndLoc, p.lastTokStartLoc = this.lastTokStartLoc, p.context = this.context.slice(), p.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, p.strictErrors = this.strictErrors, p.tokensLength = this.tokensLength, p;
          }
        }
        var ut = function(Te) {
          return Te >= 48 && Te <= 57;
        };
        const Et = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Tt = { bin: (Te) => Te === 48 || Te === 49, oct: (Te) => Te >= 48 && Te <= 55, dec: (Te) => Te >= 48 && Te <= 57, hex: (Te) => Te >= 48 && Te <= 57 || Te >= 65 && Te <= 70 || Te >= 97 && Te <= 102 };
        function St(Te, p, w, q, ne, pe) {
          const xe = w, Ce = q, Re = ne;
          let Ue = "", Ke = null, yt = w;
          const { length: $t } = p;
          for (; ; ) {
            if (w >= $t) {
              pe.unterminated(xe, Ce, Re), Ue += p.slice(yt, w);
              break;
            }
            const wt = p.charCodeAt(w);
            if (Vt(Te, wt, p, w)) {
              Ue += p.slice(yt, w);
              break;
            }
            if (wt === 92) {
              Ue += p.slice(yt, w);
              const Ht = Kt(p, w, q, ne, Te === "template", pe);
              Ht.ch !== null || Ke ? Ue += Ht.ch : Ke = { pos: w, lineStart: q, curLine: ne }, { pos: w, lineStart: q, curLine: ne } = Ht, yt = w;
            } else wt === 8232 || wt === 8233 ? (++ne, q = ++w) : wt === 10 || wt === 13 ? Te === "template" ? (Ue += p.slice(yt, w) + `
`, ++w, wt === 13 && p.charCodeAt(w) === 10 && ++w, ++ne, yt = q = w) : pe.unterminated(xe, Ce, Re) : ++w;
          }
          return { pos: w, str: Ue, firstInvalidLoc: Ke, lineStart: q, curLine: ne, containsInvalid: !!Ke };
        }
        function Vt(Te, p, w, q) {
          return Te === "template" ? p === 96 || p === 36 && w.charCodeAt(q + 1) === 123 : p === (Te === "double" ? 34 : 39);
        }
        function Kt(Te, p, w, q, ne, pe) {
          const xe = !ne;
          p++;
          const Ce = (Ue) => ({ pos: p, ch: Ue, lineStart: w, curLine: q }), Re = Te.charCodeAt(p++);
          switch (Re) {
            case 110:
              return Ce(`
`);
            case 114:
              return Ce("\r");
            case 120: {
              let Ue;
              return { code: Ue, pos: p } = xt(Te, p, w, q, 2, !1, xe, pe), Ce(Ue === null ? null : String.fromCharCode(Ue));
            }
            case 117: {
              let Ue;
              return { code: Ue, pos: p } = Mt(Te, p, w, q, xe, pe), Ce(Ue === null ? null : String.fromCodePoint(Ue));
            }
            case 116:
              return Ce("	");
            case 98:
              return Ce("\b");
            case 118:
              return Ce("\v");
            case 102:
              return Ce("\f");
            case 13:
              Te.charCodeAt(p) === 10 && ++p;
            case 10:
              w = p, ++q;
            case 8232:
            case 8233:
              return Ce("");
            case 56:
            case 57:
              if (ne) return Ce(null);
              pe.strictNumericEscape(p - 1, w, q);
            default:
              if (Re >= 48 && Re <= 55) {
                const Ue = p - 1;
                let Ke = Te.slice(Ue, p + 2).match(/^[0-7]+/)[0], yt = parseInt(Ke, 8);
                yt > 255 && (Ke = Ke.slice(0, -1), yt = parseInt(Ke, 8)), p += Ke.length - 1;
                const $t = Te.charCodeAt(p);
                if (Ke !== "0" || $t === 56 || $t === 57) {
                  if (ne) return Ce(null);
                  pe.strictNumericEscape(Ue, w, q);
                }
                return Ce(String.fromCharCode(yt));
              }
              return Ce(String.fromCharCode(Re));
          }
        }
        function xt(Te, p, w, q, ne, pe, xe, Ce) {
          const Re = p;
          let Ue;
          return { n: Ue, pos: p } = Jt(Te, p, w, q, 16, ne, pe, !1, Ce, !xe), Ue === null && (xe ? Ce.invalidEscapeSequence(Re, w, q) : p = Re - 1), { code: Ue, pos: p };
        }
        function Jt(Te, p, w, q, ne, pe, xe, Ce, Re, Ue) {
          const Ke = p, yt = ne === 16 ? Et.hex : Et.decBinOct, $t = ne === 16 ? Tt.hex : ne === 10 ? Tt.dec : ne === 8 ? Tt.oct : Tt.bin;
          let wt = !1, Ht = 0;
          for (let Gr = 0, Vr = pe ?? 1 / 0; Gr < Vr; ++Gr) {
            const ur = Te.charCodeAt(p);
            let hn;
            if (ur !== 95 || Ce === "bail") {
              if (hn = ur >= 97 ? ur - 97 + 10 : ur >= 65 ? ur - 65 + 10 : ut(ur) ? ur - 48 : 1 / 0, hn >= ne) {
                if (hn <= 9 && Ue) return { n: null, pos: p };
                if (hn <= 9 && Re.invalidDigit(p, w, q, ne)) hn = 0;
                else {
                  if (!xe) break;
                  hn = 0, wt = !0;
                }
              }
              ++p, Ht = Ht * ne + hn;
            } else {
              const To = Te.charCodeAt(p - 1), Ao = Te.charCodeAt(p + 1);
              if (Ce) {
                if (Number.isNaN(Ao) || !$t(Ao) || yt.has(To) || yt.has(Ao)) {
                  if (Ue) return { n: null, pos: p };
                  Re.unexpectedNumericSeparator(p, w, q);
                }
              } else {
                if (Ue) return { n: null, pos: p };
                Re.numericSeparatorInEscapeSequence(p, w, q);
              }
              ++p;
            }
          }
          return p === Ke || pe != null && p - Ke !== pe || wt ? { n: null, pos: p } : { n: Ht, pos: p };
        }
        function Mt(Te, p, w, q, ne, pe) {
          let xe;
          if (Te.charCodeAt(p) === 123) {
            if (++p, { code: xe, pos: p } = xt(Te, p, w, q, Te.indexOf("}", p) - p, !0, ne, pe), ++p, xe !== null && xe > 1114111) {
              if (!ne) return { code: null, pos: p };
              pe.invalidCodePoint(p, w, q);
            }
          } else ({ code: xe, pos: p } = xt(Te, p, w, q, 4, !1, ne, pe));
          return { code: xe, pos: p };
        }
        function Bt(Te, p, w) {
          return new i(w, Te - p, Te);
        }
        const It = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
        class jr {
          constructor(p) {
            this.type = p.type, this.value = p.value, this.start = p.start, this.end = p.end, this.loc = new c(p.startLoc, p.endLoc);
          }
        }
        class Cn extends He {
          constructor(p, w) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (q, ne, pe, xe) => !!this.options.errorRecovery && (this.raise(I.InvalidDigit, Bt(q, ne, pe), { radix: xe }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(I.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(I.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(I.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(I.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (q, ne, pe) => {
              this.recordStrictModeErrors(I.StrictNumericEscape, Bt(q, ne, pe));
            }, unterminated: (q, ne, pe) => {
              throw this.raise(I.UnterminatedString, Bt(q - 1, ne, pe));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(I.StrictNumericEscape), unterminated: (q, ne, pe) => {
              throw this.raise(I.UnterminatedTemplate, Bt(q, ne, pe));
            } }), this.state = new mt(), this.state.init(p), this.input = w, this.length = w.length, this.comments = [], this.isLookahead = !1;
          }
          pushToken(p) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(p), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new jr(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(p) {
            return !!this.match(p) && (this.next(), !0);
          }
          match(p) {
            return this.state.type === p;
          }
          createLookaheadState(p) {
            return { pos: p.pos, value: null, type: p.type, start: p.start, end: p.end, context: [this.curContext()], inType: p.inType, startLoc: p.startLoc, lastTokEndLoc: p.lastTokEndLoc, curLine: p.curLine, lineStart: p.lineStart, curPosition: p.curPosition };
          }
          lookahead() {
            const p = this.state;
            this.state = this.createLookaheadState(p), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
            const w = this.state;
            return this.state = p, w;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(p) {
            return rt.lastIndex = p, rt.test(this.input) ? rt.lastIndex : p;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(p) {
            return bt.lastIndex = p, bt.test(this.input) ? bt.lastIndex : p;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(p) {
            let w = this.input.charCodeAt(p);
            if ((64512 & w) == 55296 && ++p < this.input.length) {
              const q = this.input.charCodeAt(p);
              (64512 & q) == 56320 && (w = 65536 + ((1023 & w) << 10) + (1023 & q));
            }
            return w;
          }
          setStrict(p) {
            this.state.strict = p, p && (this.state.strictErrors.forEach(([w, q]) => this.raise(w, q)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(139) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(p) {
            let w;
            this.isLookahead || (w = this.state.curPosition());
            const q = this.state.pos, ne = this.input.indexOf(p, q + 2);
            if (ne === -1) throw this.raise(I.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = ne + p.length, it.lastIndex = q + 2; it.test(this.input) && it.lastIndex <= ne; ) ++this.state.curLine, this.state.lineStart = it.lastIndex;
            if (this.isLookahead) return;
            const pe = { type: "CommentBlock", value: this.input.slice(q + 2, ne), start: q, end: ne + p.length, loc: new c(w, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(pe), pe;
          }
          skipLineComment(p) {
            const w = this.state.pos;
            let q;
            this.isLookahead || (q = this.state.curPosition());
            let ne = this.input.charCodeAt(this.state.pos += p);
            if (this.state.pos < this.length) for (; !qe(ne) && ++this.state.pos < this.length; ) ne = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            const pe = this.state.pos, xe = { type: "CommentLine", value: this.input.slice(w + p, pe), start: w, end: pe, loc: new c(q, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(xe), xe;
          }
          skipSpace() {
            const p = this.state.pos, w = [];
            e: for (; this.state.pos < this.length; ) {
              const q = this.input.charCodeAt(this.state.pos);
              switch (q) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const ne = this.skipBlockComment("*/");
                      ne !== void 0 && (this.addComment(ne), this.options.attachComment && w.push(ne));
                      break;
                    }
                    case 47: {
                      const ne = this.skipLineComment(2);
                      ne !== void 0 && (this.addComment(ne), this.options.attachComment && w.push(ne));
                      break;
                    }
                    default:
                      break e;
                  }
                  break;
                default:
                  if (Je(q)) ++this.state.pos;
                  else if (q === 45 && !this.inModule && this.options.annexB) {
                    const ne = this.state.pos;
                    if (this.input.charCodeAt(ne + 1) !== 45 || this.input.charCodeAt(ne + 2) !== 62 || !(p === 0 || this.state.lineStart > p)) break e;
                    {
                      const pe = this.skipLineComment(3);
                      pe !== void 0 && (this.addComment(pe), this.options.attachComment && w.push(pe));
                    }
                  } else {
                    if (q !== 60 || this.inModule || !this.options.annexB) break e;
                    {
                      const ne = this.state.pos;
                      if (this.input.charCodeAt(ne + 1) !== 33 || this.input.charCodeAt(ne + 2) !== 45 || this.input.charCodeAt(ne + 3) !== 45) break e;
                      {
                        const pe = this.skipLineComment(4);
                        pe !== void 0 && (this.addComment(pe), this.options.attachComment && w.push(pe));
                      }
                    }
                  }
              }
            }
            if (w.length > 0) {
              const q = { start: p, end: this.state.pos, comments: w, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(q);
            }
          }
          finishToken(p, w) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const q = this.state.type;
            this.state.type = p, this.state.value = w, this.isLookahead || this.updateContext(q);
          }
          replaceToken(p) {
            this.state.type = p, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) return;
            const p = this.state.pos + 1, w = this.codePointAtPos(p);
            if (w >= 48 && w <= 57) throw this.raise(I.UnexpectedDigitAfterHash, this.state.curPosition());
            if (w === 123 || w === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(w === 123 ? I.RecordExpressionHashIncorrectStartSyntaxType : I.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, w === 123 ? this.finishToken(7) : this.finishToken(1);
            } else be(w) ? (++this.state.pos, this.finishToken(138, this.readWord1(w))) : w === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const p = this.input.charCodeAt(this.state.pos + 1);
            p >= 48 && p <= 57 ? this.readNumber(!0) : p === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2) return !1;
            let p = this.input.charCodeAt(this.state.pos + 1);
            if (p !== 33) return !1;
            const w = this.state.pos;
            for (this.state.pos += 1; !qe(p) && ++this.state.pos < this.length; ) p = this.input.charCodeAt(this.state.pos);
            const q = this.input.slice(w + 2, this.state.pos);
            return this.finishToken(28, q), !0;
          }
          readToken_mult_modulo(p) {
            let w = p === 42 ? 55 : 54, q = 1, ne = this.input.charCodeAt(this.state.pos + 1);
            p === 42 && ne === 42 && (q++, ne = this.input.charCodeAt(this.state.pos + 2), w = 57), ne !== 61 || this.state.inType || (q++, w = p === 37 ? 33 : 30), this.finishOp(w, q);
          }
          readToken_pipe_amp(p) {
            const w = this.input.charCodeAt(this.state.pos + 1);
            if (w !== p) {
              if (p === 124) {
                if (w === 62) return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && w === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(I.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && w === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(I.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              w !== 61 ? this.finishOp(p === 124 ? 43 : 45, 1) : this.finishOp(30, 2);
            } else this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(p === 124 ? 41 : 42, 2);
          }
          readToken_caret() {
            const p = this.input.charCodeAt(this.state.pos + 1);
            p !== 61 || this.state.inType ? p === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(p) {
            const w = this.input.charCodeAt(this.state.pos + 1);
            w !== p ? w === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos: p } = this.state, w = this.input.charCodeAt(p + 1);
            if (w === 60) return this.input.charCodeAt(p + 2) === 61 ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
            w !== 61 ? this.finishOp(47, 1) : this.finishOp(49, 2);
          }
          readToken_gt() {
            const { pos: p } = this.state, w = this.input.charCodeAt(p + 1);
            if (w === 62) {
              const q = this.input.charCodeAt(p + 2) === 62 ? 3 : 2;
              return this.input.charCodeAt(p + q) === 61 ? void this.finishOp(30, q + 1) : void this.finishOp(52, q);
            }
            w !== 61 ? this.finishOp(48, 1) : this.finishOp(49, 2);
          }
          readToken_eq_excl(p) {
            const w = this.input.charCodeAt(this.state.pos + 1);
            if (w !== 61) return p === 61 && w === 62 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(p === 61 ? 29 : 35, 1);
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          }
          readToken_question() {
            const p = this.input.charCodeAt(this.state.pos + 1), w = this.input.charCodeAt(this.state.pos + 2);
            p === 63 ? w === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : p !== 46 || w >= 48 && w <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(p) {
            switch (p) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(I.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(I.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const w = this.input.charCodeAt(this.state.pos + 1);
                if (w === 120 || w === 88) return void this.readRadixNumber(16);
                if (w === 111 || w === 79) return void this.readRadixNumber(8);
                if (w === 98 || w === 66) return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(!1);
              case 34:
              case 39:
                return void this.readString(p);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(p);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(p);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(p);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(p);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (be(p)) return void this.readWord(p);
            }
            throw this.raise(I.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(p) });
          }
          finishOp(p, w) {
            const q = this.input.slice(this.state.pos, this.state.pos + w);
            this.state.pos += w, this.finishToken(p, q);
          }
          readRegexp() {
            const p = this.state.startLoc, w = this.state.start + 1;
            let q, ne, { pos: pe } = this.state;
            for (; ; ++pe) {
              if (pe >= this.length) throw this.raise(I.UnterminatedRegExp, f(p, 1));
              const Ue = this.input.charCodeAt(pe);
              if (qe(Ue)) throw this.raise(I.UnterminatedRegExp, f(p, 1));
              if (q) q = !1;
              else {
                if (Ue === 91) ne = !0;
                else if (Ue === 93 && ne) ne = !1;
                else if (Ue === 47 && !ne) break;
                q = Ue === 92;
              }
            }
            const xe = this.input.slice(w, pe);
            ++pe;
            let Ce = "";
            const Re = () => f(p, pe + 2 - w);
            for (; pe < this.length; ) {
              const Ue = this.codePointAtPos(pe), Ke = String.fromCharCode(Ue);
              if (It.has(Ue)) Ue === 118 ? Ce.includes("u") && this.raise(I.IncompatibleRegExpUVFlags, Re()) : Ue === 117 && Ce.includes("v") && this.raise(I.IncompatibleRegExpUVFlags, Re()), Ce.includes(Ke) && this.raise(I.DuplicateRegExpFlags, Re());
              else {
                if (!Ie(Ue) && Ue !== 92) break;
                this.raise(I.MalformedRegExpFlags, Re());
              }
              ++pe, Ce += Ke;
            }
            this.state.pos = pe, this.finishToken(137, { pattern: xe, flags: Ce });
          }
          readInt(p, w, q = !1, ne = !0) {
            const { n: pe, pos: xe } = Jt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, p, w, q, ne, this.errorHandlers_readInt, !1);
            return this.state.pos = xe, pe;
          }
          readRadixNumber(p) {
            const w = this.state.curPosition();
            let q = !1;
            this.state.pos += 2;
            const ne = this.readInt(p);
            ne == null && this.raise(I.InvalidDigit, f(w, 2), { radix: p });
            const pe = this.input.charCodeAt(this.state.pos);
            if (pe === 110) ++this.state.pos, q = !0;
            else if (pe === 109) throw this.raise(I.InvalidDecimal, w);
            if (be(this.codePointAtPos(this.state.pos))) throw this.raise(I.NumberIdentifier, this.state.curPosition());
            if (q) {
              const xe = this.input.slice(w.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(135, xe);
            } else this.finishToken(134, ne);
          }
          readNumber(p) {
            const w = this.state.pos, q = this.state.curPosition();
            let ne = !1, pe = !1, xe = !1, Ce = !1, Re = !1;
            p || this.readInt(10) !== null || this.raise(I.InvalidNumber, this.state.curPosition());
            const Ue = this.state.pos - w >= 2 && this.input.charCodeAt(w) === 48;
            if (Ue) {
              const wt = this.input.slice(w, this.state.pos);
              if (this.recordStrictModeErrors(I.StrictOctalLiteral, q), !this.state.strict) {
                const Ht = wt.indexOf("_");
                Ht > 0 && this.raise(I.ZeroDigitNumericSeparator, f(q, Ht));
              }
              Re = Ue && !/[89]/.test(wt);
            }
            let Ke = this.input.charCodeAt(this.state.pos);
            if (Ke !== 46 || Re || (++this.state.pos, this.readInt(10), ne = !0, Ke = this.input.charCodeAt(this.state.pos)), Ke !== 69 && Ke !== 101 || Re || (Ke = this.input.charCodeAt(++this.state.pos), Ke !== 43 && Ke !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(I.InvalidOrMissingExponent, q), ne = !0, Ce = !0, Ke = this.input.charCodeAt(this.state.pos)), Ke === 110 && ((ne || Ue) && this.raise(I.InvalidBigIntLiteral, q), ++this.state.pos, pe = !0), Ke === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (Ce || Ue) && this.raise(I.InvalidDecimal, q), ++this.state.pos, xe = !0), be(this.codePointAtPos(this.state.pos))) throw this.raise(I.NumberIdentifier, this.state.curPosition());
            const yt = this.input.slice(w, this.state.pos).replace(/[_mn]/g, "");
            if (pe) return void this.finishToken(135, yt);
            if (xe) return void this.finishToken(136, yt);
            const $t = Re ? parseInt(yt, 8) : parseFloat(yt);
            this.finishToken(134, $t);
          }
          readCodePoint(p) {
            const { code: w, pos: q } = Mt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, p, this.errorHandlers_readCodePoint);
            return this.state.pos = q, w;
          }
          readString(p) {
            const { str: w, pos: q, curLine: ne, lineStart: pe } = St(p === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = q + 1, this.state.lineStart = pe, this.state.curLine = ne, this.finishToken(133, w);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            const p = this.input[this.state.pos], { str: w, firstInvalidLoc: q, pos: ne, curLine: pe, lineStart: xe } = St("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = ne + 1, this.state.lineStart = xe, this.state.curLine = pe, q && (this.state.firstInvalidTemplateEscapePos = new i(q.curLine, q.pos - q.lineStart, q.pos)), this.input.codePointAt(ne) === 96 ? this.finishToken(24, q ? null : p + w + "`") : (this.state.pos++, this.finishToken(25, q ? null : p + w + "${"));
          }
          recordStrictModeErrors(p, w) {
            const q = w.index;
            this.state.strict && !this.state.strictErrors.has(q) ? this.raise(p, w) : this.state.strictErrors.set(q, [p, w]);
          }
          readWord1(p) {
            this.state.containsEsc = !1;
            let w = "";
            const q = this.state.pos;
            let ne = this.state.pos;
            for (p !== void 0 && (this.state.pos += p <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const pe = this.codePointAtPos(this.state.pos);
              if (Ie(pe)) this.state.pos += pe <= 65535 ? 1 : 2;
              else {
                if (pe !== 92) break;
                {
                  this.state.containsEsc = !0, w += this.input.slice(ne, this.state.pos);
                  const xe = this.state.curPosition(), Ce = this.state.pos === q ? be : Ie;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(I.MissingUnicodeEscape, this.state.curPosition()), ne = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const Re = this.readCodePoint(!0);
                  Re !== null && (Ce(Re) || this.raise(I.EscapedCharNotAnIdentifier, xe), w += String.fromCodePoint(Re)), ne = this.state.pos;
                }
              }
            }
            return w + this.input.slice(ne, this.state.pos);
          }
          readWord(p) {
            const w = this.readWord1(p), q = C.get(w);
            q !== void 0 ? this.finishToken(q, _e(q)) : this.finishToken(132, w);
          }
          checkKeywordEscapes() {
            const { type: p } = this.state;
            fe(p) && this.state.containsEsc && this.raise(I.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: _e(p) });
          }
          raise(p, w, q = {}) {
            const ne = p(w instanceof i ? w : w.loc.start, q);
            if (!this.options.errorRecovery) throw ne;
            return this.isLookahead || this.state.errors.push(ne), ne;
          }
          raiseOverwrite(p, w, q = {}) {
            const ne = w instanceof i ? w : w.loc.start, pe = ne.index, xe = this.state.errors;
            for (let Ce = xe.length - 1; Ce >= 0; Ce--) {
              const Re = xe[Ce];
              if (Re.loc.index === pe) return xe[Ce] = p(ne, q);
              if (Re.loc.index < pe) break;
            }
            return this.raise(p, w, q);
          }
          updateContext(p) {
          }
          unexpected(p, w) {
            throw this.raise(I.UnexpectedToken, p ?? this.state.startLoc, { expected: w ? _e(w) : null });
          }
          expectPlugin(p, w) {
            if (this.hasPlugin(p)) return !0;
            throw this.raise(I.MissingPlugin, w ?? this.state.startLoc, { missingPlugin: [p] });
          }
          expectOnePlugin(p) {
            if (!p.some((w) => this.hasPlugin(w))) throw this.raise(I.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: p });
          }
          errorBuilder(p) {
            return (w, q, ne) => {
              this.raise(p, Bt(w, q, ne));
            };
          }
        }
        class an {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class Fr {
          constructor(p) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = p;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new an());
          }
          exit() {
            const p = this.stack.pop(), w = this.current();
            for (const [q, ne] of Array.from(p.undefinedPrivateNames)) w ? w.undefinedPrivateNames.has(q) || w.undefinedPrivateNames.set(q, ne) : this.parser.raise(I.InvalidPrivateFieldResolution, ne, { identifierName: q });
          }
          declarePrivateName(p, w, q) {
            const { privateNames: ne, loneAccessors: pe, undefinedPrivateNames: xe } = this.current();
            let Ce = ne.has(p);
            if (3 & w) {
              const Re = Ce && pe.get(p);
              Re ? (Ce = (3 & Re) === (3 & w) || (4 & Re) !== (4 & w), Ce || pe.delete(p)) : Ce || pe.set(p, w);
            }
            Ce && this.parser.raise(I.PrivateNameRedeclaration, q, { identifierName: p }), ne.add(p), xe.delete(p);
          }
          usePrivateName(p, w) {
            let q;
            for (q of this.stack) if (q.privateNames.has(p)) return;
            q ? q.undefinedPrivateNames.set(p, w) : this.parser.raise(I.InvalidPrivateFieldResolution, w, { identifierName: p });
          }
        }
        class En {
          constructor(p = 0) {
            this.type = p;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }
        class dn extends En {
          constructor(p) {
            super(p), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(p, w) {
            const q = w.index;
            this.declarationErrors.set(q, [p, w]);
          }
          clearDeclarationError(p) {
            this.declarationErrors.delete(p);
          }
          iterateErrors(p) {
            this.declarationErrors.forEach(p);
          }
        }
        class on {
          constructor(p) {
            this.parser = void 0, this.stack = [new En()], this.parser = p;
          }
          enter(p) {
            this.stack.push(p);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(p, w) {
            const q = w.loc.start, { stack: ne } = this;
            let pe = ne.length - 1, xe = ne[pe];
            for (; !xe.isCertainlyParameterDeclaration(); ) {
              if (!xe.canBeArrowParameterDeclaration()) return;
              xe.recordDeclarationError(p, q), xe = ne[--pe];
            }
            this.parser.raise(p, q);
          }
          recordArrowParameterBindingError(p, w) {
            const { stack: q } = this, ne = q[q.length - 1], pe = w.loc.start;
            if (ne.isCertainlyParameterDeclaration()) this.parser.raise(p, pe);
            else {
              if (!ne.canBeArrowParameterDeclaration()) return;
              ne.recordDeclarationError(p, pe);
            }
          }
          recordAsyncArrowParametersError(p) {
            const { stack: w } = this;
            let q = w.length - 1, ne = w[q];
            for (; ne.canBeArrowParameterDeclaration(); ) ne.type === 2 && ne.recordDeclarationError(I.AwaitBindingIdentifier, p), ne = w[--q];
          }
          validateAsPattern() {
            const { stack: p } = this, w = p[p.length - 1];
            w.canBeArrowParameterDeclaration() && w.iterateErrors(([q, ne]) => {
              this.parser.raise(q, ne);
              let pe = p.length - 2, xe = p[pe];
              for (; xe.canBeArrowParameterDeclaration(); ) xe.clearDeclarationError(ne.index), xe = p[--pe];
            });
          }
        }
        function vr() {
          return new En();
        }
        class Vn {
          constructor() {
            this.stacks = [];
          }
          enter(p) {
            this.stacks.push(p);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function Cr(Te, p) {
          return (Te ? 2 : 0) | (p ? 1 : 0);
        }
        class br extends Cn {
          addExtra(p, w, q, ne = !0) {
            if (!p) return;
            const pe = p.extra = p.extra || {};
            ne ? pe[w] = q : Object.defineProperty(pe, w, { enumerable: ne, value: q });
          }
          isContextual(p) {
            return this.state.type === p && !this.state.containsEsc;
          }
          isUnparsedContextual(p, w) {
            const q = p + w.length;
            if (this.input.slice(p, q) === w) {
              const ne = this.input.charCodeAt(q);
              return !(Ie(ne) || (64512 & ne) == 55296);
            }
            return !1;
          }
          isLookaheadContextual(p) {
            const w = this.nextTokenStart();
            return this.isUnparsedContextual(w, p);
          }
          eatContextual(p) {
            return !!this.isContextual(p) && (this.next(), !0);
          }
          expectContextual(p, w) {
            if (!this.eatContextual(p)) {
              if (w != null) throw this.raise(w, this.state.startLoc);
              this.unexpected(null, p);
            }
          }
          canInsertSemicolon() {
            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return st.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return dt.lastIndex = this.state.end, dt.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(p = !0) {
            (p ? this.isLineTerminator() : this.eat(13)) || this.raise(I.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(p, w) {
            this.eat(p) || this.unexpected(w, p);
          }
          tryParse(p, w = this.state.clone()) {
            const q = { node: null };
            try {
              const ne = p((pe = null) => {
                throw q.node = pe, q;
              });
              if (this.state.errors.length > w.errors.length) {
                const pe = this.state;
                return this.state = w, this.state.tokensLength = pe.tokensLength, { node: ne, error: pe.errors[w.errors.length], thrown: !1, aborted: !1, failState: pe };
              }
              return { node: ne, error: null, thrown: !1, aborted: !1, failState: null };
            } catch (ne) {
              const pe = this.state;
              if (this.state = w, ne instanceof SyntaxError) return { node: null, error: ne, thrown: !0, aborted: !1, failState: pe };
              if (ne === q) return { node: q.node, error: null, thrown: !1, aborted: !0, failState: pe };
              throw ne;
            }
          }
          checkExpressionErrors(p, w) {
            if (!p) return !1;
            const { shorthandAssignLoc: q, doubleProtoLoc: ne, privateKeyLoc: pe, optionalParametersLoc: xe } = p;
            if (!w) return !!(q || ne || xe || pe);
            q != null && this.raise(I.InvalidCoverInitializedName, q), ne != null && this.raise(I.DuplicateProto, ne), pe != null && this.raise(I.UnexpectedPrivateField, pe), xe != null && this.unexpected(xe);
          }
          isLiteralPropertyName() {
            return X(this.state.type);
          }
          isPrivateName(p) {
            return p.type === "PrivateName";
          }
          getPrivateNameSV(p) {
            return p.id.name;
          }
          hasPropertyAsPrivateName(p) {
            return (p.type === "MemberExpression" || p.type === "OptionalMemberExpression") && this.isPrivateName(p.property);
          }
          isObjectProperty(p) {
            return p.type === "ObjectProperty";
          }
          isObjectMethod(p) {
            return p.type === "ObjectMethod";
          }
          initializeScopes(p = this.options.sourceType === "module") {
            const w = this.state.labels;
            this.state.labels = [];
            const q = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const ne = this.inModule;
            this.inModule = p;
            const pe = this.scope, xe = this.getScopeHandler();
            this.scope = new xe(this, p);
            const Ce = this.prodParam;
            this.prodParam = new Vn();
            const Re = this.classScope;
            this.classScope = new Fr(this);
            const Ue = this.expressionScope;
            return this.expressionScope = new on(this), () => {
              this.state.labels = w, this.exportedIdentifiers = q, this.inModule = ne, this.scope = pe, this.prodParam = Ce, this.classScope = Re, this.expressionScope = Ue;
            };
          }
          enterInitialScopes() {
            let p = 0;
            this.inModule && (p |= 2), this.scope.enter(1), this.prodParam.enter(p);
          }
          checkDestructuringPrivate(p) {
            const { privateKeyLoc: w } = p;
            w !== null && this.expectPlugin("destructuringPrivate", w);
          }
        }
        class _n {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }
        class In {
          constructor(p, w, q) {
            this.type = "", this.start = w, this.end = 0, this.loc = new c(q), p != null && p.options.ranges && (this.range = [w, 0]), p != null && p.filename && (this.loc.filename = p.filename);
          }
        }
        const pn = In.prototype;
        function Dr(Te) {
          const { type: p, start: w, end: q, loc: ne, range: pe, extra: xe, name: Ce } = Te, Re = Object.create(pn);
          return Re.type = p, Re.start = w, Re.end = q, Re.loc = ne, Re.range = pe, Re.extra = xe, Re.name = Ce, p === "Placeholder" && (Re.expectedNode = Te.expectedNode), Re;
        }
        function Wn(Te) {
          const { type: p, start: w, end: q, loc: ne, range: pe, extra: xe } = Te;
          if (p === "Placeholder") return function(Re) {
            return Dr(Re);
          }(Te);
          const Ce = Object.create(pn);
          return Ce.type = p, Ce.start = w, Ce.end = q, Ce.loc = ne, Ce.range = pe, Te.raw !== void 0 ? Ce.raw = Te.raw : Ce.extra = xe, Ce.value = Te.value, Ce;
        }
        pn.__clone = function() {
          const Te = new In(void 0, this.start, this.loc.start), p = Object.keys(this);
          for (let w = 0, q = p.length; w < q; w++) {
            const ne = p[w];
            ne !== "leadingComments" && ne !== "trailingComments" && ne !== "innerComments" && (Te[ne] = this[ne]);
          }
          return Te;
        };
        class yi extends br {
          startNode() {
            const p = this.state.startLoc;
            return new In(this, p.index, p);
          }
          startNodeAt(p) {
            return new In(this, p.index, p);
          }
          startNodeAtNode(p) {
            return this.startNodeAt(p.loc.start);
          }
          finishNode(p, w) {
            return this.finishNodeAt(p, w, this.state.lastTokEndLoc);
          }
          finishNodeAt(p, w, q) {
            return p.type = w, p.end = q.index, p.loc.end = q, this.options.ranges && (p.range[1] = q.index), this.options.attachComment && this.processComment(p), p;
          }
          resetStartLocation(p, w) {
            p.start = w.index, p.loc.start = w, this.options.ranges && (p.range[0] = w.index);
          }
          resetEndLocation(p, w = this.state.lastTokEndLoc) {
            p.end = w.index, p.loc.end = w, this.options.ranges && (p.range[1] = w.index);
          }
          resetStartLocationFromNode(p, w) {
            this.resetStartLocation(p, w.loc.start);
          }
        }
        const ri = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Nt = $`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: Te }) => `Cannot overwrite reserved type ${Te}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: Te, enumName: p }) => `Boolean enum members need to be initialized. Use either \`${Te} = true,\` or \`${Te} = false,\` in enum \`${p}\`.`, EnumDuplicateMemberName: ({ memberName: Te, enumName: p }) => `Enum member names need to be unique, but the name \`${Te}\` has already been used before in enum \`${p}\`.`, EnumInconsistentMemberValues: ({ enumName: Te }) => `Enum \`${Te}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: Te, enumName: p }) => `Enum type \`${Te}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${p}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: Te }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${Te}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: Te, memberName: p, explicitType: w }) => `Enum \`${Te}\` has type \`${w}\`, so the initializer of \`${p}\` needs to be a ${w} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: Te, memberName: p }) => `Symbol enum members cannot be initialized. Use \`${p},\` in enum \`${Te}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: Te, memberName: p }) => `The enum member initializer for \`${p}\` needs to be a literal (either a boolean, number, or string) in enum \`${Te}\`.`, EnumInvalidMemberName: ({ enumName: Te, memberName: p, suggestion: w }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${p}\`, consider using \`${w}\`, in enum \`${Te}\`.`, EnumNumberMemberNotInitialized: ({ enumName: Te, memberName: p }) => `Number enum members need to be initialized, e.g. \`${p} = 1\` in enum \`${Te}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: Te }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${Te}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: Te }) => `Unexpected reserved type ${Te}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: Te, suggestion: p }) => `\`declare export ${Te}\` is not supported. Use \`${p}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function Pi(Te) {
          return Te.importKind === "type" || Te.importKind === "typeof";
        }
        const ps = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, Gs = /\*?\s*@((?:no)?flow)\b/, ca = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", times: "×", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", divide: "÷", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", frasl: "⁄", euro: "€", image: "ℑ", weierp: "℘", real: "ℜ", trade: "™", alefsym: "ℵ", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lArr: "⇐", uArr: "⇑", rArr: "⇒", dArr: "⇓", hArr: "⇔", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", lang: "〈", rang: "〉", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦" }, ni = $`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: Te }) => `Expected corresponding JSX closing tag for <${Te}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: Te, HTMLEntity: p }) => `Unexpected token \`${Te}\`. Did you mean \`${p}\` or \`{'${Te}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function tt(Te) {
          return !!Te && (Te.type === "JSXOpeningFragment" || Te.type === "JSXClosingFragment");
        }
        function pt(Te) {
          if (Te.type === "JSXIdentifier") return Te.name;
          if (Te.type === "JSXNamespacedName") return Te.namespace.name + ":" + Te.name.name;
          if (Te.type === "JSXMemberExpression") return pt(Te.object) + "." + pt(Te.property);
          throw new Error("Node had unexpected type: " + Te.type);
        }
        class Ot extends Ve {
          constructor(...p) {
            super(...p), this.tsNames = /* @__PURE__ */ new Map();
          }
        }
        class Pt extends Xe {
          constructor(...p) {
            super(...p), this.importsStack = [];
          }
          createScope(p) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new Ot(p);
          }
          enter(p) {
            p === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(p);
          }
          exit() {
            const p = super.exit();
            return p === 256 && this.importsStack.pop(), p;
          }
          hasImport(p, w) {
            const q = this.importsStack.length;
            if (this.importsStack[q - 1].has(p)) return !0;
            if (!w && q > 1) {
              for (let ne = 0; ne < q - 1; ne++) if (this.importsStack[ne].has(p)) return !0;
            }
            return !1;
          }
          declareName(p, w, q) {
            if (4096 & w) return this.hasImport(p, !0) && this.parser.raise(I.VarRedeclaration, q, { identifierName: p }), void this.importsStack[this.importsStack.length - 1].add(p);
            const ne = this.currentScope();
            let pe = ne.tsNames.get(p) || 0;
            if (1024 & w) return this.maybeExportDefined(ne, p), void ne.tsNames.set(p, 16 | pe);
            super.declareName(p, w, q), 2 & w && (1 & w || (this.checkRedeclarationInScope(ne, p, w, q), this.maybeExportDefined(ne, p)), pe |= 1), 256 & w && (pe |= 2), 512 & w && (pe |= 4), 128 & w && (pe |= 8), pe && ne.tsNames.set(p, pe);
          }
          isRedeclaredInScope(p, w, q) {
            const ne = p.tsNames.get(w);
            return (2 & ne) > 0 ? 256 & q ? !!(512 & q) != (4 & ne) > 0 : !0 : 128 & q && (8 & ne) > 0 ? !!(2 & p.names.get(w)) && !!(1 & q) : !!(2 & q && (1 & ne) > 0) || super.isRedeclaredInScope(p, w, q);
          }
          checkLocalExport(p) {
            const { name: w } = p;
            if (!this.hasImport(w)) {
              for (let q = this.scopeStack.length - 1; q >= 0; q--) {
                const ne = this.scopeStack[q].tsNames.get(w);
                if ((1 & ne) > 0 || (16 & ne) > 0) return;
              }
              super.checkLocalExport(p);
            }
          }
        }
        const Wt = (Te) => Te.type === "ParenthesizedExpression" ? Wt(Te.expression) : Te;
        class Xt extends yi {
          toAssignable(p, w = !1) {
            var q, ne;
            let pe;
            switch ((p.type === "ParenthesizedExpression" || (q = p.extra) != null && q.parenthesized) && (pe = Wt(p), w ? pe.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(I.InvalidParenthesizedAssignment, p) : pe.type === "MemberExpression" || this.isOptionalMemberExpression(pe) || this.raise(I.InvalidParenthesizedAssignment, p) : this.raise(I.InvalidParenthesizedAssignment, p)), p.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                p.type = "ObjectPattern";
                for (let Ce = 0, Re = p.properties.length, Ue = Re - 1; Ce < Re; Ce++) {
                  var xe;
                  const Ke = p.properties[Ce], yt = Ce === Ue;
                  this.toAssignableObjectExpressionProp(Ke, yt, w), yt && Ke.type === "RestElement" && (xe = p.extra) != null && xe.trailingCommaLoc && this.raise(I.RestTrailingComma, p.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                const { key: Ce, value: Re } = p;
                this.isPrivateName(Ce) && this.classScope.usePrivateName(this.getPrivateNameSV(Ce), Ce.loc.start), this.toAssignable(Re, w);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                p.type = "ArrayPattern", this.toAssignableList(p.elements, (ne = p.extra) == null ? void 0 : ne.trailingCommaLoc, w);
                break;
              case "AssignmentExpression":
                p.operator !== "=" && this.raise(I.MissingEqInAssignment, p.left.loc.end), p.type = "AssignmentPattern", delete p.operator, this.toAssignable(p.left, w);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(pe, w);
            }
          }
          toAssignableObjectExpressionProp(p, w, q) {
            if (p.type === "ObjectMethod") this.raise(p.kind === "get" || p.kind === "set" ? I.PatternHasAccessor : I.PatternHasMethod, p.key);
            else if (p.type === "SpreadElement") {
              p.type = "RestElement";
              const ne = p.argument;
              this.checkToRestConversion(ne, !1), this.toAssignable(ne, q), w || this.raise(I.RestTrailingComma, p);
            } else this.toAssignable(p, q);
          }
          toAssignableList(p, w, q) {
            const ne = p.length - 1;
            for (let pe = 0; pe <= ne; pe++) {
              const xe = p[pe];
              if (xe) {
                if (xe.type === "SpreadElement") {
                  xe.type = "RestElement";
                  const Ce = xe.argument;
                  this.checkToRestConversion(Ce, !0), this.toAssignable(Ce, q);
                } else this.toAssignable(xe, q);
                xe.type === "RestElement" && (pe < ne ? this.raise(I.RestTrailingComma, xe) : w && this.raise(I.RestTrailingComma, w));
              }
            }
          }
          isAssignable(p, w) {
            switch (p.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return !0;
              case "ObjectExpression": {
                const q = p.properties.length - 1;
                return p.properties.every((ne, pe) => ne.type !== "ObjectMethod" && (pe === q || ne.type !== "SpreadElement") && this.isAssignable(ne));
              }
              case "ObjectProperty":
                return this.isAssignable(p.value);
              case "SpreadElement":
                return this.isAssignable(p.argument);
              case "ArrayExpression":
                return p.elements.every((q) => q === null || this.isAssignable(q));
              case "AssignmentExpression":
                return p.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(p.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !w;
              default:
                return !1;
            }
          }
          toReferencedList(p, w) {
            return p;
          }
          toReferencedListDeep(p, w) {
            this.toReferencedList(p, w);
            for (const q of p) (q == null ? void 0 : q.type) === "ArrayExpression" && this.toReferencedListDeep(q.elements);
          }
          parseSpread(p) {
            const w = this.startNode();
            return this.next(), w.argument = this.parseMaybeAssignAllowIn(p, void 0), this.finishNode(w, "SpreadElement");
          }
          parseRestBinding() {
            const p = this.startNode();
            return this.next(), p.argument = this.parseBindingAtom(), this.finishNode(p, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const p = this.startNode();
                return this.next(), p.elements = this.parseBindingList(3, 93, 1), this.finishNode(p, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, !0);
            }
            return this.parseIdentifier();
          }
          parseBindingList(p, w, q) {
            const ne = 1 & q, pe = [];
            let xe = !0;
            for (; !this.eat(p); ) if (xe ? xe = !1 : this.expect(12), ne && this.match(12)) pe.push(null);
            else {
              if (this.eat(p)) break;
              if (this.match(21)) {
                if (pe.push(this.parseAssignableListItemTypes(this.parseRestBinding(), q)), !this.checkCommaAfterRest(w)) {
                  this.expect(p);
                  break;
                }
              } else {
                const Ce = [];
                for (this.match(26) && this.hasPlugin("decorators") && this.raise(I.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) Ce.push(this.parseDecorator());
                pe.push(this.parseAssignableListItem(q, Ce));
              }
            }
            return pe;
          }
          parseBindingRestProperty(p) {
            return this.next(), p.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(p, "RestElement");
          }
          parseBindingProperty() {
            const { type: p, startLoc: w } = this.state;
            if (p === 21) return this.parseBindingRestProperty(this.startNode());
            const q = this.startNode();
            return p === 138 ? (this.expectPlugin("destructuringPrivate", w), this.classScope.usePrivateName(this.state.value, w), q.key = this.parsePrivateName()) : this.parsePropertyName(q), q.method = !1, this.parseObjPropValue(q, w, !1, !1, !0, !1);
          }
          parseAssignableListItem(p, w) {
            const q = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(q, p);
            const ne = this.parseMaybeDefault(q.loc.start, q);
            return w.length && (q.decorators = w), ne;
          }
          parseAssignableListItemTypes(p, w) {
            return p;
          }
          parseMaybeDefault(p, w) {
            var q;
            if (p != null || (p = this.state.startLoc), w = (q = w) != null ? q : this.parseBindingAtom(), !this.eat(29)) return w;
            const ne = this.startNodeAt(p);
            return ne.left = w, ne.right = this.parseMaybeAssignAllowIn(), this.finishNode(ne, "AssignmentPattern");
          }
          isValidLVal(p, w, q) {
            return ne = { AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, pe = p, hasOwnProperty.call(ne, pe) && ne[pe];
            var ne, pe;
          }
          isOptionalMemberExpression(p) {
            return p.type === "OptionalMemberExpression";
          }
          checkLVal(p, { in: w, binding: q = 64, checkClashes: ne = !1, strictModeChanged: pe = !1, hasParenthesizedAncestor: xe = !1 }) {
            var Ce;
            const Re = p.type;
            if (this.isObjectMethod(p)) return;
            const Ue = this.isOptionalMemberExpression(p);
            if (Ue || Re === "MemberExpression") return Ue && (this.expectPlugin("optionalChainingAssign", p.loc.start), w.type !== "AssignmentExpression" && this.raise(I.InvalidLhsOptionalChaining, p, { ancestor: w })), void (q !== 64 && this.raise(I.InvalidPropertyBindingPattern, p));
            if (Re === "Identifier") {
              this.checkIdentifier(p, q, pe);
              const { name: Ht } = p;
              return void (ne && (ne.has(Ht) ? this.raise(I.ParamDupe, p) : ne.add(Ht)));
            }
            const Ke = this.isValidLVal(Re, !(xe || (Ce = p.extra) != null && Ce.parenthesized) && w.type === "AssignmentExpression", q);
            if (Ke === !0) return;
            if (Ke === !1) {
              const Ht = q === 64 ? I.InvalidLhs : I.InvalidLhsBinding;
              return void this.raise(Ht, p, { ancestor: w });
            }
            const [yt, $t] = Array.isArray(Ke) ? Ke : [Ke, Re === "ParenthesizedExpression"], wt = Re === "ArrayPattern" || Re === "ObjectPattern" ? { type: Re } : w;
            for (const Ht of [].concat(p[yt])) Ht && this.checkLVal(Ht, { in: wt, binding: q, checkClashes: ne, strictModeChanged: pe, hasParenthesizedAncestor: $t });
          }
          checkIdentifier(p, w, q = !1) {
            this.state.strict && (q ? Se(p.name, this.inModule) : Ee(p.name)) && (w === 64 ? this.raise(I.StrictEvalArguments, p, { referenceName: p.name }) : this.raise(I.StrictEvalArgumentsBinding, p, { bindingName: p.name })), 8192 & w && p.name === "let" && this.raise(I.LetInLexicalBinding, p), 64 & w || this.declareNameFromIdentifier(p, w);
          }
          declareNameFromIdentifier(p, w) {
            this.scope.declareName(p.name, w, p.loc.start);
          }
          checkToRestConversion(p, w) {
            switch (p.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(p.expression, w);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (w) break;
              default:
                this.raise(I.InvalidRestAssignmentPattern, p);
            }
          }
          checkCommaAfterRest(p) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === p ? I.RestTrailingComma : I.ElementAfterRest, this.state.startLoc), !0);
          }
        }
        function Ft(Te) {
          if (!Te) throw new Error("Assert fail");
        }
        const ht = $`typescript`({ AbstractMethodHasImplementation: ({ methodName: Te }) => `Method '${Te}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: Te }) => `Property '${Te}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: Te }) => `'declare' is not allowed in ${Te}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: Te }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: Te }) => `Duplicate modifier: '${Te}'.`, EmptyHeritageClauseType: ({ token: Te }) => `'${Te}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: Te }) => `'${Te[0]}' modifier cannot be used with '${Te[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: Te }) => `Index signatures cannot have an accessibility modifier ('${Te}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: Te }) => `'${Te}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: Te }) => `'${Te}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: Te }) => `'${Te}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: Te }) => `'${Te[0]}' modifier must precede '${Te[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: Te }) => `Private elements cannot have an accessibility modifier ('${Te}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: Te }) => `Single type parameter ${Te} should have a trailing comma. Example usage: <${Te},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: Te }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${Te}.` });
        function rr(Te) {
          return Te === "private" || Te === "public" || Te === "protected";
        }
        function sr(Te) {
          return Te === "in" || Te === "out";
        }
        function wr(Te) {
          if (Te.type !== "MemberExpression") return !1;
          const { computed: p, property: w } = Te;
          return (!p || w.type === "StringLiteral" || !(w.type !== "TemplateLiteral" || w.expressions.length > 0)) && On(Te.object);
        }
        function At(Te, p) {
          var w;
          const { type: q } = Te;
          if ((w = Te.extra) != null && w.parenthesized) return !1;
          if (p) {
            if (q === "Literal") {
              const { value: ne } = Te;
              if (typeof ne == "string" || typeof ne == "boolean") return !0;
            }
          } else if (q === "StringLiteral" || q === "BooleanLiteral") return !0;
          return !(!Er(Te, p) && !function(ne, pe) {
            if (ne.type === "UnaryExpression") {
              const { operator: xe, argument: Ce } = ne;
              if (xe === "-" && Er(Ce, pe)) return !0;
            }
            return !1;
          }(Te, p)) || q === "TemplateLiteral" && Te.expressions.length === 0 || !!wr(Te);
        }
        function Er(Te, p) {
          return p ? Te.type === "Literal" && (typeof Te.value == "number" || "bigint" in Te) : Te.type === "NumericLiteral" || Te.type === "BigIntLiteral";
        }
        function On(Te) {
          return Te.type === "Identifier" || Te.type === "MemberExpression" && !Te.computed && On(Te.object);
        }
        const Sn = $`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
        function fr(Te, p) {
          const [w, q] = typeof p == "string" ? [p, {}] : p, ne = Object.keys(q), pe = ne.length === 0;
          return Te.some((xe) => {
            if (typeof xe == "string") return pe && xe === w;
            {
              const [Ce, Re] = xe;
              if (Ce !== w) return !1;
              for (const Ue of ne) if (Re[Ue] !== q[Ue]) return !1;
              return !0;
            }
          });
        }
        function en(Te, p, w) {
          const q = Te.find((ne) => Array.isArray(ne) ? ne[0] === p : ne === p);
          return q && Array.isArray(q) && q.length > 1 ? q[1][w] : null;
        }
        const bi = ["minimal", "fsharp", "hack", "smart"], fa = ["^^", "@@", "^", "%", "#"], So = { estree: (Te) => class extends Te {
          parse() {
            const p = M(super.parse());
            return this.options.tokens && (p.tokens = p.tokens.map(M)), p;
          }
          parseRegExpLiteral({ pattern: p, flags: w }) {
            let q = null;
            try {
              q = new RegExp(p, w);
            } catch {
            }
            const ne = this.estreeParseLiteral(q);
            return ne.regex = { pattern: p, flags: w }, ne;
          }
          parseBigIntLiteral(p) {
            let w;
            try {
              w = BigInt(p);
            } catch {
              w = null;
            }
            const q = this.estreeParseLiteral(w);
            return q.bigint = String(q.value || p), q;
          }
          parseDecimalLiteral(p) {
            const w = this.estreeParseLiteral(null);
            return w.decimal = String(w.value || p), w;
          }
          estreeParseLiteral(p) {
            return this.parseLiteral(p, "Literal");
          }
          parseStringLiteral(p) {
            return this.estreeParseLiteral(p);
          }
          parseNumericLiteral(p) {
            return this.estreeParseLiteral(p);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(p) {
            return this.estreeParseLiteral(p);
          }
          directiveToStmt(p) {
            const w = p.value;
            delete p.value, w.type = "Literal", w.raw = w.extra.raw, w.value = w.extra.expressionValue;
            const q = p;
            return q.type = "ExpressionStatement", q.expression = w, q.directive = w.extra.rawValue, delete w.extra, q;
          }
          initFunction(p, w) {
            super.initFunction(p, w), p.expression = !1;
          }
          checkDeclaration(p) {
            p != null && this.isObjectProperty(p) ? this.checkDeclaration(p.value) : super.checkDeclaration(p);
          }
          getObjectOrClassMethodParams(p) {
            return p.value.params;
          }
          isValidDirective(p) {
            var w;
            return p.type === "ExpressionStatement" && p.expression.type === "Literal" && typeof p.expression.value == "string" && !((w = p.expression.extra) != null && w.parenthesized);
          }
          parseBlockBody(p, w, q, ne, pe) {
            super.parseBlockBody(p, w, q, ne, pe);
            const xe = p.directives.map((Ce) => this.directiveToStmt(Ce));
            p.body = xe.concat(p.body), delete p.directives;
          }
          pushClassMethod(p, w, q, ne, pe, xe) {
            this.parseMethod(w, q, ne, pe, xe, "ClassMethod", !0), w.typeParameters && (w.value.typeParameters = w.typeParameters, delete w.typeParameters), p.body.push(w);
          }
          parsePrivateName() {
            const p = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(p) : p;
          }
          convertPrivateNameToPrivateIdentifier(p) {
            const w = super.getPrivateNameSV(p);
            return delete p.id, p.name = w, p.type = "PrivateIdentifier", p;
          }
          isPrivateName(p) {
            return this.getPluginOption("estree", "classFeatures") ? p.type === "PrivateIdentifier" : super.isPrivateName(p);
          }
          getPrivateNameSV(p) {
            return this.getPluginOption("estree", "classFeatures") ? p.name : super.getPrivateNameSV(p);
          }
          parseLiteral(p, w) {
            const q = super.parseLiteral(p, w);
            return q.raw = q.extra.raw, delete q.extra, q;
          }
          parseFunctionBody(p, w, q = !1) {
            super.parseFunctionBody(p, w, q), p.expression = p.body.type !== "BlockStatement";
          }
          parseMethod(p, w, q, ne, pe, xe, Ce = !1) {
            let Re = this.startNode();
            return Re.kind = p.kind, Re = super.parseMethod(Re, w, q, ne, pe, xe, Ce), Re.type = "FunctionExpression", delete Re.kind, p.value = Re, xe === "ClassPrivateMethod" && (p.computed = !1), this.finishNode(p, "MethodDefinition");
          }
          nameIsConstructor(p) {
            return p.type === "Literal" ? p.value === "constructor" : super.nameIsConstructor(p);
          }
          parseClassProperty(...p) {
            const w = super.parseClassProperty(...p);
            return this.getPluginOption("estree", "classFeatures") && (w.type = "PropertyDefinition"), w;
          }
          parseClassPrivateProperty(...p) {
            const w = super.parseClassPrivateProperty(...p);
            return this.getPluginOption("estree", "classFeatures") && (w.type = "PropertyDefinition", w.computed = !1), w;
          }
          parseObjectMethod(p, w, q, ne, pe) {
            const xe = super.parseObjectMethod(p, w, q, ne, pe);
            return xe && (xe.type = "Property", xe.kind === "method" && (xe.kind = "init"), xe.shorthand = !1), xe;
          }
          parseObjectProperty(p, w, q, ne) {
            const pe = super.parseObjectProperty(p, w, q, ne);
            return pe && (pe.kind = "init", pe.type = "Property"), pe;
          }
          isValidLVal(p, w, q) {
            return p === "Property" ? "value" : super.isValidLVal(p, w, q);
          }
          isAssignable(p, w) {
            return p != null && this.isObjectProperty(p) ? this.isAssignable(p.value, w) : super.isAssignable(p, w);
          }
          toAssignable(p, w = !1) {
            if (p != null && this.isObjectProperty(p)) {
              const { key: q, value: ne } = p;
              this.isPrivateName(q) && this.classScope.usePrivateName(this.getPrivateNameSV(q), q.loc.start), this.toAssignable(ne, w);
            } else super.toAssignable(p, w);
          }
          toAssignableObjectExpressionProp(p, w, q) {
            p.type !== "Property" || p.kind !== "get" && p.kind !== "set" ? p.type === "Property" && p.method ? this.raise(I.PatternHasMethod, p.key) : super.toAssignableObjectExpressionProp(p, w, q) : this.raise(I.PatternHasAccessor, p.key);
          }
          finishCallExpression(p, w) {
            const q = super.finishCallExpression(p, w);
            if (q.callee.type === "Import") {
              var ne, pe;
              q.type = "ImportExpression", q.source = q.arguments[0], (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (q.options = (ne = q.arguments[1]) != null ? ne : null, q.attributes = (pe = q.arguments[1]) != null ? pe : null), delete q.arguments, delete q.callee;
            }
            return q;
          }
          toReferencedArguments(p) {
            p.type !== "ImportExpression" && super.toReferencedArguments(p);
          }
          parseExport(p, w) {
            const q = this.state.lastTokStartLoc, ne = super.parseExport(p, w);
            switch (ne.type) {
              case "ExportAllDeclaration":
                ne.exported = null;
                break;
              case "ExportNamedDeclaration":
                ne.specifiers.length === 1 && ne.specifiers[0].type === "ExportNamespaceSpecifier" && (ne.type = "ExportAllDeclaration", ne.exported = ne.specifiers[0].exported, delete ne.specifiers);
              case "ExportDefaultDeclaration": {
                var pe;
                const { declaration: xe } = ne;
                (xe == null ? void 0 : xe.type) === "ClassDeclaration" && ((pe = xe.decorators) == null ? void 0 : pe.length) > 0 && xe.start === ne.start && this.resetStartLocation(ne, q);
              }
            }
            return ne;
          }
          parseSubscript(p, w, q, ne) {
            const pe = super.parseSubscript(p, w, q, ne);
            if (ne.optionalChainMember) {
              if (pe.type !== "OptionalMemberExpression" && pe.type !== "OptionalCallExpression" || (pe.type = pe.type.substring(8)), ne.stop) {
                const xe = this.startNodeAtNode(pe);
                return xe.expression = pe, this.finishNode(xe, "ChainExpression");
              }
            } else pe.type !== "MemberExpression" && pe.type !== "CallExpression" || (pe.optional = !1);
            return pe;
          }
          isOptionalMemberExpression(p) {
            return p.type === "ChainExpression" ? p.expression.type === "MemberExpression" : super.isOptionalMemberExpression(p);
          }
          hasPropertyAsPrivateName(p) {
            return p.type === "ChainExpression" && (p = p.expression), super.hasPropertyAsPrivateName(p);
          }
          isObjectProperty(p) {
            return p.type === "Property" && p.kind === "init" && !p.method;
          }
          isObjectMethod(p) {
            return p.type === "Property" && (p.method || p.kind === "get" || p.kind === "set");
          }
          finishNodeAt(p, w, q) {
            return M(super.finishNodeAt(p, w, q));
          }
          resetStartLocation(p, w) {
            super.resetStartLocation(p, w), M(p);
          }
          resetEndLocation(p, w = this.state.lastTokEndLoc) {
            super.resetEndLocation(p, w), M(p);
          }
        }, jsx: (Te) => class extends Te {
          jsxReadToken() {
            let p = "", w = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(ni.UnterminatedJsxContent, this.state.startLoc);
              const q = this.input.charCodeAt(this.state.pos);
              switch (q) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? void (q === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(q)) : (p += this.input.slice(w, this.state.pos), void this.finishToken(141, p));
                case 38:
                  p += this.input.slice(w, this.state.pos), p += this.jsxReadEntity(), w = this.state.pos;
                  break;
                default:
                  qe(q) ? (p += this.input.slice(w, this.state.pos), p += this.jsxReadNewLine(!0), w = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(p) {
            const w = this.input.charCodeAt(this.state.pos);
            let q;
            return ++this.state.pos, w === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, q = p ? `
` : `\r
`) : q = String.fromCharCode(w), ++this.state.curLine, this.state.lineStart = this.state.pos, q;
          }
          jsxReadString(p) {
            let w = "", q = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(I.UnterminatedString, this.state.startLoc);
              const ne = this.input.charCodeAt(this.state.pos);
              if (ne === p) break;
              ne === 38 ? (w += this.input.slice(q, this.state.pos), w += this.jsxReadEntity(), q = this.state.pos) : qe(ne) ? (w += this.input.slice(q, this.state.pos), w += this.jsxReadNewLine(!1), q = this.state.pos) : ++this.state.pos;
            }
            w += this.input.slice(q, this.state.pos++), this.finishToken(133, w);
          }
          jsxReadEntity() {
            const p = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let w = 10;
              this.codePointAtPos(this.state.pos) === 120 && (w = 16, ++this.state.pos);
              const q = this.readInt(w, void 0, !1, "bail");
              if (q !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(q);
            } else {
              let w = 0, q = !1;
              for (; w++ < 10 && this.state.pos < this.length && !(q = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
              if (q) {
                const ne = this.input.slice(p, this.state.pos), pe = ca[ne];
                if (++this.state.pos, pe) return pe;
              }
            }
            return this.state.pos = p, "&";
          }
          jsxReadWord() {
            let p;
            const w = this.state.pos;
            do
              p = this.input.charCodeAt(++this.state.pos);
            while (Ie(p) || p === 45);
            this.finishToken(140, this.input.slice(w, this.state.pos));
          }
          jsxParseIdentifier() {
            const p = this.startNode();
            return this.match(140) ? p.name = this.state.value : fe(this.state.type) ? p.name = _e(this.state.type) : this.unexpected(), this.next(), this.finishNode(p, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const p = this.state.startLoc, w = this.jsxParseIdentifier();
            if (!this.eat(14)) return w;
            const q = this.startNodeAt(p);
            return q.namespace = w, q.name = this.jsxParseIdentifier(), this.finishNode(q, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const p = this.state.startLoc;
            let w = this.jsxParseNamespacedName();
            if (w.type === "JSXNamespacedName") return w;
            for (; this.eat(16); ) {
              const q = this.startNodeAt(p);
              q.object = w, q.property = this.jsxParseIdentifier(), w = this.finishNode(q, "JSXMemberExpression");
            }
            return w;
          }
          jsxParseAttributeValue() {
            let p;
            switch (this.state.type) {
              case 5:
                return p = this.startNode(), this.setContext(_.brace), this.next(), p = this.jsxParseExpressionContainer(p, _.j_oTag), p.expression.type === "JSXEmptyExpression" && this.raise(ni.AttributeIsEmpty, p), p;
              case 142:
              case 133:
                return this.parseExprAtom();
              default:
                throw this.raise(ni.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            const p = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(p, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(p) {
            return this.next(), p.expression = this.parseExpression(), this.setContext(_.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(p, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(p, w) {
            if (this.match(8)) p.expression = this.jsxParseEmptyExpression();
            else {
              const q = this.parseExpression();
              p.expression = q;
            }
            return this.setContext(w), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(p, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const p = this.startNode();
            return this.match(5) ? (this.setContext(_.brace), this.next(), this.expect(21), p.argument = this.parseMaybeAssignAllowIn(), this.setContext(_.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(p, "JSXSpreadAttribute")) : (p.name = this.jsxParseNamespacedName(), p.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(p, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(p) {
            const w = this.startNodeAt(p);
            return this.eat(143) ? this.finishNode(w, "JSXOpeningFragment") : (w.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(w));
          }
          jsxParseOpeningElementAfterName(p) {
            const w = [];
            for (; !this.match(56) && !this.match(143); ) w.push(this.jsxParseAttribute());
            return p.attributes = w, p.selfClosing = this.eat(56), this.expect(143), this.finishNode(p, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(p) {
            const w = this.startNodeAt(p);
            return this.eat(143) ? this.finishNode(w, "JSXClosingFragment") : (w.name = this.jsxParseElementName(), this.expect(143), this.finishNode(w, "JSXClosingElement"));
          }
          jsxParseElementAt(p) {
            const w = this.startNodeAt(p), q = [], ne = this.jsxParseOpeningElementAt(p);
            let pe = null;
            if (!ne.selfClosing) {
              e: for (; ; ) switch (this.state.type) {
                case 142:
                  if (p = this.state.startLoc, this.next(), this.eat(56)) {
                    pe = this.jsxParseClosingElementAt(p);
                    break e;
                  }
                  q.push(this.jsxParseElementAt(p));
                  break;
                case 141:
                  q.push(this.parseLiteral(this.state.value, "JSXText"));
                  break;
                case 5: {
                  const xe = this.startNode();
                  this.setContext(_.brace), this.next(), this.match(21) ? q.push(this.jsxParseSpreadChild(xe)) : q.push(this.jsxParseExpressionContainer(xe, _.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
              tt(ne) && !tt(pe) && pe !== null ? this.raise(ni.MissingClosingTagFragment, pe) : !tt(ne) && tt(pe) ? this.raise(ni.MissingClosingTagElement, pe, { openingTagName: pt(ne.name) }) : tt(ne) || tt(pe) || pt(pe.name) !== pt(ne.name) && this.raise(ni.MissingClosingTagElement, pe, { openingTagName: pt(ne.name) });
            }
            if (tt(ne) ? (w.openingFragment = ne, w.closingFragment = pe) : (w.openingElement = ne, w.closingElement = pe), w.children = q, this.match(47)) throw this.raise(ni.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return tt(ne) ? this.finishNode(w, "JSXFragment") : this.finishNode(w, "JSXElement");
          }
          jsxParseElement() {
            const p = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(p);
          }
          setContext(p) {
            const { context: w } = this.state;
            w[w.length - 1] = p;
          }
          parseExprAtom(p) {
            return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(p);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(p) {
            const w = this.curContext();
            if (w !== _.j_expr) {
              if (w === _.j_oTag || w === _.j_cTag) {
                if (be(p)) return void this.jsxReadWord();
                if (p === 62) return ++this.state.pos, void this.finishToken(143);
                if ((p === 34 || p === 39) && w === _.j_oTag) return void this.jsxReadString(p);
              }
              if (p === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) return ++this.state.pos, void this.finishToken(142);
              super.getTokenFromCode(p);
            } else this.jsxReadToken();
          }
          updateContext(p) {
            const { context: w, type: q } = this.state;
            if (q === 56 && p === 142) w.splice(-2, 2, _.j_cTag), this.state.canStartJSXElement = !1;
            else if (q === 142) w.push(_.j_oTag);
            else if (q === 143) {
              const ne = w[w.length - 1];
              ne === _.j_oTag && p === 56 || ne === _.j_cTag ? (w.pop(), this.state.canStartJSXElement = w[w.length - 1] === _.j_expr) : (this.setContext(_.j_expr), this.state.canStartJSXElement = !0);
            } else this.state.canStartJSXElement = B[q];
          }
        }, flow: (Te) => class extends Te {
          constructor(...p) {
            super(...p), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return We;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(p, w) {
            p !== 133 && p !== 13 && p !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(p, w);
          }
          addComment(p) {
            if (this.flowPragma === void 0) {
              const w = Gs.exec(p.value);
              if (w) if (w[1] === "flow") this.flowPragma = "flow";
              else {
                if (w[1] !== "noflow") throw new Error("Unexpected flow pragma");
                this.flowPragma = "noflow";
              }
            }
            super.addComment(p);
          }
          flowParseTypeInitialiser(p) {
            const w = this.state.inType;
            this.state.inType = !0, this.expect(p || 14);
            const q = this.flowParseType();
            return this.state.inType = w, q;
          }
          flowParsePredicate() {
            const p = this.startNode(), w = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > w.index + 1 && this.raise(Nt.UnexpectedSpaceBetweenModuloChecks, w), this.eat(10) ? (p.value = super.parseExpression(), this.expect(11), this.finishNode(p, "DeclaredPredicate")) : this.finishNode(p, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const p = this.state.inType;
            this.state.inType = !0, this.expect(14);
            let w = null, q = null;
            return this.match(54) ? (this.state.inType = p, q = this.flowParsePredicate()) : (w = this.flowParseType(), this.state.inType = p, this.match(54) && (q = this.flowParsePredicate())), [w, q];
          }
          flowParseDeclareClass(p) {
            return this.next(), this.flowParseInterfaceish(p, !0), this.finishNode(p, "DeclareClass");
          }
          flowParseDeclareFunction(p) {
            this.next();
            const w = p.id = this.parseIdentifier(), q = this.startNode(), ne = this.startNode();
            this.match(47) ? q.typeParameters = this.flowParseTypeParameterDeclaration() : q.typeParameters = null, this.expect(10);
            const pe = this.flowParseFunctionTypeParams();
            return q.params = pe.params, q.rest = pe.rest, q.this = pe._this, this.expect(11), [q.returnType, p.predicate] = this.flowParseTypeAndPredicateInitialiser(), ne.typeAnnotation = this.finishNode(q, "FunctionTypeAnnotation"), w.typeAnnotation = this.finishNode(ne, "TypeAnnotation"), this.resetEndLocation(w), this.semicolon(), this.scope.declareName(p.id.name, 2048, p.id.loc.start), this.finishNode(p, "DeclareFunction");
          }
          flowParseDeclare(p, w) {
            return this.match(80) ? this.flowParseDeclareClass(p) : this.match(68) ? this.flowParseDeclareFunction(p) : this.match(74) ? this.flowParseDeclareVariable(p) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(p) : (w && this.raise(Nt.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(p)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(p) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(p) : this.isContextual(129) ? this.flowParseDeclareInterface(p) : this.match(82) ? this.flowParseDeclareExportDeclaration(p, w) : void this.unexpected();
          }
          flowParseDeclareVariable(p) {
            return this.next(), p.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(p.id.name, 5, p.id.loc.start), this.semicolon(), this.finishNode(p, "DeclareVariable");
          }
          flowParseDeclareModule(p) {
            this.scope.enter(0), this.match(133) ? p.id = super.parseExprAtom() : p.id = this.parseIdentifier();
            const w = p.body = this.startNode(), q = w.body = [];
            for (this.expect(5); !this.match(8); ) {
              let xe = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(Nt.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(xe)) : (this.expectContextual(125, Nt.UnsupportedStatementInDeclareModule), xe = this.flowParseDeclare(xe, !0)), q.push(xe);
            }
            this.scope.exit(), this.expect(8), this.finishNode(w, "BlockStatement");
            let ne = null, pe = !1;
            return q.forEach((xe) => {
              (function(Ce) {
                return Ce.type === "DeclareExportAllDeclaration" || Ce.type === "DeclareExportDeclaration" && (!Ce.declaration || Ce.declaration.type !== "TypeAlias" && Ce.declaration.type !== "InterfaceDeclaration");
              })(xe) ? (ne === "CommonJS" && this.raise(Nt.AmbiguousDeclareModuleKind, xe), ne = "ES") : xe.type === "DeclareModuleExports" && (pe && this.raise(Nt.DuplicateDeclareModuleExports, xe), ne === "ES" && this.raise(Nt.AmbiguousDeclareModuleKind, xe), ne = "CommonJS", pe = !0);
            }), p.kind = ne || "CommonJS", this.finishNode(p, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(p, w) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? p.declaration = this.flowParseDeclare(this.startNode()) : (p.declaration = this.flowParseType(), this.semicolon()), p.default = !0, this.finishNode(p, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !w) {
              const q = this.state.value;
              throw this.raise(Nt.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: q, suggestion: ps[q] });
            }
            return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (p.declaration = this.flowParseDeclare(this.startNode()), p.default = !1, this.finishNode(p, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ((p = this.parseExport(p, null)).type === "ExportNamedDeclaration" && (p.type = "ExportDeclaration", p.default = !1, delete p.exportKind), p.type = "Declare" + p.type, p) : void this.unexpected();
          }
          flowParseDeclareModuleExports(p) {
            return this.next(), this.expectContextual(111), p.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(p, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(p) {
            this.next();
            const w = this.flowParseTypeAlias(p);
            return w.type = "DeclareTypeAlias", w;
          }
          flowParseDeclareOpaqueType(p) {
            this.next();
            const w = this.flowParseOpaqueType(p, !0);
            return w.type = "DeclareOpaqueType", w;
          }
          flowParseDeclareInterface(p) {
            return this.next(), this.flowParseInterfaceish(p, !1), this.finishNode(p, "DeclareInterface");
          }
          flowParseInterfaceish(p, w) {
            if (p.id = this.flowParseRestrictedIdentifier(!w, !0), this.scope.declareName(p.id.name, w ? 17 : 8201, p.id.loc.start), this.match(47) ? p.typeParameters = this.flowParseTypeParameterDeclaration() : p.typeParameters = null, p.extends = [], this.eat(81)) do
              p.extends.push(this.flowParseInterfaceExtends());
            while (!w && this.eat(12));
            if (w) {
              if (p.implements = [], p.mixins = [], this.eatContextual(117)) do
                p.mixins.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
              if (this.eatContextual(113)) do
                p.implements.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            }
            p.body = this.flowParseObjectType({ allowStatic: w, allowExact: !1, allowSpread: !1, allowProto: w, allowInexact: !1 });
          }
          flowParseInterfaceExtends() {
            const p = this.startNode();
            return p.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? p.typeParameters = this.flowParseTypeParameterInstantiation() : p.typeParameters = null, this.finishNode(p, "InterfaceExtends");
          }
          flowParseInterface(p) {
            return this.flowParseInterfaceish(p, !1), this.finishNode(p, "InterfaceDeclaration");
          }
          checkNotUnderscore(p) {
            p === "_" && this.raise(Nt.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(p, w, q) {
            ri.has(p) && this.raise(q ? Nt.AssignReservedType : Nt.UnexpectedReservedType, w, { reservedType: p });
          }
          flowParseRestrictedIdentifier(p, w) {
            return this.checkReservedType(this.state.value, this.state.startLoc, w), this.parseIdentifier(p);
          }
          flowParseTypeAlias(p) {
            return p.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(p.id.name, 8201, p.id.loc.start), this.match(47) ? p.typeParameters = this.flowParseTypeParameterDeclaration() : p.typeParameters = null, p.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(p, "TypeAlias");
          }
          flowParseOpaqueType(p, w) {
            return this.expectContextual(130), p.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(p.id.name, 8201, p.id.loc.start), this.match(47) ? p.typeParameters = this.flowParseTypeParameterDeclaration() : p.typeParameters = null, p.supertype = null, this.match(14) && (p.supertype = this.flowParseTypeInitialiser(14)), p.impltype = null, w || (p.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(p, "OpaqueType");
          }
          flowParseTypeParameter(p = !1) {
            const w = this.state.startLoc, q = this.startNode(), ne = this.flowParseVariance(), pe = this.flowParseTypeAnnotatableIdentifier();
            return q.name = pe.name, q.variance = ne, q.bound = pe.typeAnnotation, this.match(29) ? (this.eat(29), q.default = this.flowParseType()) : p && this.raise(Nt.MissingTypeParamDefault, w), this.finishNode(q, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const p = this.state.inType, w = this.startNode();
            w.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let q = !1;
            do {
              const ne = this.flowParseTypeParameter(q);
              w.params.push(ne), ne.default && (q = !0), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = p, this.finishNode(w, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const p = this.startNode(), w = this.state.inType;
            p.params = [], this.state.inType = !0, this.expect(47);
            const q = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48); ) p.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = q, this.expect(48), this.state.inType = w, this.finishNode(p, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const p = this.startNode(), w = this.state.inType;
            for (p.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) p.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = w, this.finishNode(p, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const p = this.startNode();
            if (this.expectContextual(129), p.extends = [], this.eat(81)) do
              p.extends.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
            return p.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(p, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(p, w, q) {
            return p.static = w, this.lookahead().type === 14 ? (p.id = this.flowParseObjectPropertyKey(), p.key = this.flowParseTypeInitialiser()) : (p.id = null, p.key = this.flowParseType()), this.expect(3), p.value = this.flowParseTypeInitialiser(), p.variance = q, this.finishNode(p, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(p, w) {
            return p.static = w, p.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (p.method = !0, p.optional = !1, p.value = this.flowParseObjectTypeMethodish(this.startNodeAt(p.loc.start))) : (p.method = !1, this.eat(17) && (p.optional = !0), p.value = this.flowParseTypeInitialiser()), this.finishNode(p, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(p) {
            for (p.params = [], p.rest = null, p.typeParameters = null, p.this = null, this.match(47) && (p.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (p.this = this.flowParseFunctionTypeParam(!0), p.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) p.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (p.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), p.returnType = this.flowParseTypeInitialiser(), this.finishNode(p, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(p, w) {
            const q = this.startNode();
            return p.static = w, p.value = this.flowParseObjectTypeMethodish(q), this.finishNode(p, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: p, allowExact: w, allowSpread: q, allowProto: ne, allowInexact: pe }) {
            const xe = this.state.inType;
            this.state.inType = !0;
            const Ce = this.startNode();
            let Re, Ue;
            Ce.callProperties = [], Ce.properties = [], Ce.indexers = [], Ce.internalSlots = [];
            let Ke = !1;
            for (w && this.match(6) ? (this.expect(6), Re = 9, Ue = !0) : (this.expect(5), Re = 8, Ue = !1), Ce.exact = Ue; !this.match(Re); ) {
              let $t = !1, wt = null, Ht = null;
              const Gr = this.startNode();
              if (ne && this.isContextual(118)) {
                const ur = this.lookahead();
                ur.type !== 14 && ur.type !== 17 && (this.next(), wt = this.state.startLoc, p = !1);
              }
              if (p && this.isContextual(106)) {
                const ur = this.lookahead();
                ur.type !== 14 && ur.type !== 17 && (this.next(), $t = !0);
              }
              const Vr = this.flowParseVariance();
              if (this.eat(0)) wt != null && this.unexpected(wt), this.eat(0) ? (Vr && this.unexpected(Vr.loc.start), Ce.internalSlots.push(this.flowParseObjectTypeInternalSlot(Gr, $t))) : Ce.indexers.push(this.flowParseObjectTypeIndexer(Gr, $t, Vr));
              else if (this.match(10) || this.match(47)) wt != null && this.unexpected(wt), Vr && this.unexpected(Vr.loc.start), Ce.callProperties.push(this.flowParseObjectTypeCallProperty(Gr, $t));
              else {
                let ur = "init";
                (this.isContextual(99) || this.isContextual(104)) && X(this.lookahead().type) && (ur = this.state.value, this.next());
                const hn = this.flowParseObjectTypeProperty(Gr, $t, wt, Vr, ur, q, pe ?? !Ue);
                hn === null ? (Ke = !0, Ht = this.state.lastTokStartLoc) : Ce.properties.push(hn);
              }
              this.flowObjectTypeSemicolon(), !Ht || this.match(8) || this.match(9) || this.raise(Nt.UnexpectedExplicitInexactInObject, Ht);
            }
            this.expect(Re), q && (Ce.inexact = Ke);
            const yt = this.finishNode(Ce, "ObjectTypeAnnotation");
            return this.state.inType = xe, yt;
          }
          flowParseObjectTypeProperty(p, w, q, ne, pe, xe, Ce) {
            if (this.eat(21))
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (xe ? Ce || this.raise(Nt.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(Nt.InexactInsideNonObject, this.state.lastTokStartLoc), ne && this.raise(Nt.InexactVariance, ne), null) : (xe || this.raise(Nt.UnexpectedSpreadType, this.state.lastTokStartLoc), q != null && this.unexpected(q), ne && this.raise(Nt.SpreadVariance, ne), p.argument = this.flowParseType(), this.finishNode(p, "ObjectTypeSpreadProperty"));
            {
              p.key = this.flowParseObjectPropertyKey(), p.static = w, p.proto = q != null, p.kind = pe;
              let Re = !1;
              return this.match(47) || this.match(10) ? (p.method = !0, q != null && this.unexpected(q), ne && this.unexpected(ne.loc.start), p.value = this.flowParseObjectTypeMethodish(this.startNodeAt(p.loc.start)), pe !== "get" && pe !== "set" || this.flowCheckGetterSetterParams(p), !xe && p.key.name === "constructor" && p.value.this && this.raise(Nt.ThisParamBannedInConstructor, p.value.this)) : (pe !== "init" && this.unexpected(), p.method = !1, this.eat(17) && (Re = !0), p.value = this.flowParseTypeInitialiser(), p.variance = ne), p.optional = Re, this.finishNode(p, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(p) {
            const w = p.kind === "get" ? 0 : 1, q = p.value.params.length + (p.value.rest ? 1 : 0);
            p.value.this && this.raise(p.kind === "get" ? Nt.GetterMayNotHaveThisParam : Nt.SetterMayNotHaveThisParam, p.value.this), q !== w && this.raise(p.kind === "get" ? I.BadGetterArity : I.BadSetterArity, p), p.kind === "set" && p.value.rest && this.raise(I.BadSetterRestParameter, p);
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(p, w) {
            p != null || (p = this.state.startLoc);
            let q = w || this.flowParseRestrictedIdentifier(!0);
            for (; this.eat(16); ) {
              const ne = this.startNodeAt(p);
              ne.qualification = q, ne.id = this.flowParseRestrictedIdentifier(!0), q = this.finishNode(ne, "QualifiedTypeIdentifier");
            }
            return q;
          }
          flowParseGenericType(p, w) {
            const q = this.startNodeAt(p);
            return q.typeParameters = null, q.id = this.flowParseQualifiedTypeIdentifier(p, w), this.match(47) && (q.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(q, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const p = this.startNode();
            return this.expect(87), p.argument = this.flowParsePrimaryType(), this.finishNode(p, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const p = this.startNode();
            for (p.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (p.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(p, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(p) {
            let w = null, q = !1, ne = null;
            const pe = this.startNode(), xe = this.lookahead(), Ce = this.state.type === 78;
            return xe.type === 14 || xe.type === 17 ? (Ce && !p && this.raise(Nt.ThisParamMustBeFirst, pe), w = this.parseIdentifier(Ce), this.eat(17) && (q = !0, Ce && this.raise(Nt.ThisParamMayNotBeOptional, pe)), ne = this.flowParseTypeInitialiser()) : ne = this.flowParseType(), pe.name = w, pe.optional = q, pe.typeAnnotation = ne, this.finishNode(pe, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(p) {
            const w = this.startNodeAt(p.loc.start);
            return w.name = null, w.optional = !1, w.typeAnnotation = p, this.finishNode(w, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(p = []) {
            let w = null, q = null;
            for (this.match(78) && (q = this.flowParseFunctionTypeParam(!0), q.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) p.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (w = this.flowParseFunctionTypeParam(!1)), { params: p, rest: w, _this: q };
          }
          flowIdentToTypeAnnotation(p, w, q) {
            switch (q.name) {
              case "any":
                return this.finishNode(w, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(w, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(w, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(w, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(w, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(w, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(w, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(q.name), this.flowParseGenericType(p, q);
            }
          }
          flowParsePrimaryType() {
            const p = this.state.startLoc, w = this.startNode();
            let q, ne, pe = !1;
            const xe = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
              case 6:
                return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
              case 0:
                return this.state.noAnonFunctionType = !1, ne = this.flowParseTupleType(), this.state.noAnonFunctionType = xe, ne;
              case 47: {
                const Ce = this.startNode();
                return Ce.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), q = this.flowParseFunctionTypeParams(), Ce.params = q.params, Ce.rest = q.rest, Ce.this = q._this, this.expect(11), this.expect(19), Ce.returnType = this.flowParseType(), this.finishNode(Ce, "FunctionTypeAnnotation");
              }
              case 10: {
                const Ce = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21)) if (V(this.state.type) || this.match(78)) {
                  const Re = this.lookahead().type;
                  pe = Re !== 17 && Re !== 14;
                } else pe = !0;
                if (pe) {
                  if (this.state.noAnonFunctionType = !1, ne = this.flowParseType(), this.state.noAnonFunctionType = xe, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), ne;
                  this.eat(12);
                }
                return q = ne ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(ne)]) : this.flowParseFunctionTypeParams(), Ce.params = q.params, Ce.rest = q.rest, Ce.this = q._this, this.expect(11), this.expect(19), Ce.returnType = this.flowParseType(), Ce.typeParameters = null, this.finishNode(Ce, "FunctionTypeAnnotation");
              }
              case 133:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return w.value = this.match(85), this.next(), this.finishNode(w, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(134)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", w);
                  if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", w);
                  throw this.raise(Nt.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                return void this.unexpected();
              case 134:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 135:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(w, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(w, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(w, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(w, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (fe(this.state.type)) {
                  const Ce = _e(this.state.type);
                  return this.next(), super.createIdentifier(w, Ce);
                }
                if (V(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(p, w, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const p = this.state.startLoc;
            let w = this.flowParsePrimaryType(), q = !1;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const ne = this.startNodeAt(p), pe = this.eat(18);
              q = q || pe, this.expect(0), !pe && this.match(3) ? (ne.elementType = w, this.next(), w = this.finishNode(ne, "ArrayTypeAnnotation")) : (ne.objectType = w, ne.indexType = this.flowParseType(), this.expect(3), q ? (ne.optional = pe, w = this.finishNode(ne, "OptionalIndexedAccessType")) : w = this.finishNode(ne, "IndexedAccessType"));
            }
            return w;
          }
          flowParsePrefixType() {
            const p = this.startNode();
            return this.eat(17) ? (p.typeAnnotation = this.flowParsePrefixType(), this.finishNode(p, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const p = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const w = this.startNodeAt(p.loc.start);
              return w.params = [this.reinterpretTypeAsFunctionTypeParam(p)], w.rest = null, w.this = null, w.returnType = this.flowParseType(), w.typeParameters = null, this.finishNode(w, "FunctionTypeAnnotation");
            }
            return p;
          }
          flowParseIntersectionType() {
            const p = this.startNode();
            this.eat(45);
            const w = this.flowParseAnonFunctionWithoutParens();
            for (p.types = [w]; this.eat(45); ) p.types.push(this.flowParseAnonFunctionWithoutParens());
            return p.types.length === 1 ? w : this.finishNode(p, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const p = this.startNode();
            this.eat(43);
            const w = this.flowParseIntersectionType();
            for (p.types = [w]; this.eat(43); ) p.types.push(this.flowParseIntersectionType());
            return p.types.length === 1 ? w : this.finishNode(p, "UnionTypeAnnotation");
          }
          flowParseType() {
            const p = this.state.inType;
            this.state.inType = !0;
            const w = this.flowParseUnionType();
            return this.state.inType = p, w;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
              const p = this.state.startLoc, w = this.parseIdentifier();
              return this.flowParseGenericType(p, w);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const p = this.startNode();
            return p.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(p, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(p) {
            const w = p ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (w.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(w)), w;
          }
          typeCastToParameter(p) {
            return p.expression.typeAnnotation = p.typeAnnotation, this.resetEndLocation(p.expression, p.typeAnnotation.loc.end), p.expression;
          }
          flowParseVariance() {
            let p = null;
            return this.match(53) ? (p = this.startNode(), this.state.value === "+" ? p.kind = "plus" : p.kind = "minus", this.next(), this.finishNode(p, "Variance")) : p;
          }
          parseFunctionBody(p, w, q = !1) {
            w ? this.forwardNoArrowParamsConversionAt(p, () => super.parseFunctionBody(p, !0, q)) : super.parseFunctionBody(p, !1, q);
          }
          parseFunctionBodyAndFinish(p, w, q = !1) {
            if (this.match(14)) {
              const ne = this.startNode();
              [ne.typeAnnotation, p.predicate] = this.flowParseTypeAndPredicateInitialiser(), p.returnType = ne.typeAnnotation ? this.finishNode(ne, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(p, w, q);
          }
          parseStatementLike(p) {
            if (this.state.strict && this.isContextual(129)) {
              if (F(this.lookahead().type)) {
                const q = this.startNode();
                return this.next(), this.flowParseInterface(q);
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              const q = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(q);
            }
            const w = super.parseStatementLike(p);
            return this.flowPragma !== void 0 || this.isValidDirective(w) || (this.flowPragma = null), w;
          }
          parseExpressionStatement(p, w, q) {
            if (w.type === "Identifier") {
              if (w.name === "declare") {
                if (this.match(80) || V(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(p);
              } else if (V(this.state.type)) {
                if (w.name === "interface") return this.flowParseInterface(p);
                if (w.name === "type") return this.flowParseTypeAlias(p);
                if (w.name === "opaque") return this.flowParseOpaqueType(p, !1);
              }
            }
            return super.parseExpressionStatement(p, w, q);
          }
          shouldParseExportDeclaration() {
            const { type: p } = this.state;
            return ie(p) || this.shouldParseEnums() && p === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: p } = this.state;
            return ie(p) || this.shouldParseEnums() && p === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              const p = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(p);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(p, w, q) {
            if (!this.match(17)) return p;
            if (this.state.maybeInArrowParameters) {
              const yt = this.lookaheadCharCode();
              if (yt === 44 || yt === 61 || yt === 58 || yt === 41) return this.setOptionalParametersError(q), p;
            }
            this.expect(17);
            const ne = this.state.clone(), pe = this.state.noArrowAt, xe = this.startNodeAt(w);
            let { consequent: Ce, failed: Re } = this.tryParseConditionalConsequent(), [Ue, Ke] = this.getArrowLikeExpressions(Ce);
            if (Re || Ke.length > 0) {
              const yt = [...pe];
              if (Ke.length > 0) {
                this.state = ne, this.state.noArrowAt = yt;
                for (let $t = 0; $t < Ke.length; $t++) yt.push(Ke[$t].start);
                ({ consequent: Ce, failed: Re } = this.tryParseConditionalConsequent()), [Ue, Ke] = this.getArrowLikeExpressions(Ce);
              }
              Re && Ue.length > 1 && this.raise(Nt.AmbiguousConditionalArrow, ne.startLoc), Re && Ue.length === 1 && (this.state = ne, yt.push(Ue[0].start), this.state.noArrowAt = yt, { consequent: Ce, failed: Re } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(Ce, !0), this.state.noArrowAt = pe, this.expect(14), xe.test = p, xe.consequent = Ce, xe.alternate = this.forwardNoArrowParamsConversionAt(xe, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(xe, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const p = this.parseMaybeAssignAllowIn(), w = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: p, failed: w };
          }
          getArrowLikeExpressions(p, w) {
            const q = [p], ne = [];
            for (; q.length !== 0; ) {
              const pe = q.pop();
              pe.type === "ArrowFunctionExpression" && pe.body.type !== "BlockStatement" ? (pe.typeParameters || !pe.returnType ? this.finishArrowValidation(pe) : ne.push(pe), q.push(pe.body)) : pe.type === "ConditionalExpression" && (q.push(pe.consequent), q.push(pe.alternate));
            }
            return w ? (ne.forEach((pe) => this.finishArrowValidation(pe)), [ne, []]) : function(pe, xe) {
              const Ce = [], Re = [];
              for (let Ue = 0; Ue < pe.length; Ue++) (xe(pe[Ue], Ue, pe) ? Ce : Re).push(pe[Ue]);
              return [Ce, Re];
            }(ne, (pe) => pe.params.every((xe) => this.isAssignable(xe, !0)));
          }
          finishArrowValidation(p) {
            var w;
            this.toAssignableList(p.params, (w = p.extra) == null ? void 0 : w.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(p, !1, !0), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(p, w) {
            let q;
            return this.state.noArrowParamsConversionAt.indexOf(p.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), q = w(), this.state.noArrowParamsConversionAt.pop()) : q = w(), q;
          }
          parseParenItem(p, w) {
            const q = super.parseParenItem(p, w);
            if (this.eat(17) && (q.optional = !0, this.resetEndLocation(p)), this.match(14)) {
              const ne = this.startNodeAt(w);
              return ne.expression = q, ne.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(ne, "TypeCastExpression");
            }
            return q;
          }
          assertModuleNodeAllowed(p) {
            p.type === "ImportDeclaration" && (p.importKind === "type" || p.importKind === "typeof") || p.type === "ExportNamedDeclaration" && p.exportKind === "type" || p.type === "ExportAllDeclaration" && p.exportKind === "type" || super.assertModuleNodeAllowed(p);
          }
          parseExportDeclaration(p) {
            if (this.isContextual(130)) {
              p.exportKind = "type";
              const w = this.startNode();
              return this.next(), this.match(5) ? (p.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(p), null) : this.flowParseTypeAlias(w);
            }
            if (this.isContextual(131)) {
              p.exportKind = "type";
              const w = this.startNode();
              return this.next(), this.flowParseOpaqueType(w, !1);
            }
            if (this.isContextual(129)) {
              p.exportKind = "type";
              const w = this.startNode();
              return this.next(), this.flowParseInterface(w);
            }
            if (this.shouldParseEnums() && this.isContextual(126)) {
              p.exportKind = "value";
              const w = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(w);
            }
            return super.parseExportDeclaration(p);
          }
          eatExportStar(p) {
            return !!super.eatExportStar(p) || !(!this.isContextual(130) || this.lookahead().type !== 55) && (p.exportKind = "type", this.next(), this.next(), !0);
          }
          maybeParseExportNamespaceSpecifier(p) {
            const { startLoc: w } = this.state, q = super.maybeParseExportNamespaceSpecifier(p);
            return q && p.exportKind === "type" && this.unexpected(w), q;
          }
          parseClassId(p, w, q) {
            super.parseClassId(p, w, q), this.match(47) && (p.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(p, w, q) {
            const { startLoc: ne } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(p, w)) return;
              w.declare = !0;
            }
            super.parseClassMember(p, w, q), w.declare && (w.type !== "ClassProperty" && w.type !== "ClassPrivateProperty" && w.type !== "PropertyDefinition" ? this.raise(Nt.DeclareClassElement, ne) : w.value && this.raise(Nt.DeclareClassFieldInitializer, w.value));
          }
          isIterator(p) {
            return p === "iterator" || p === "asyncIterator";
          }
          readIterator() {
            const p = super.readWord1(), w = "@@" + p;
            this.isIterator(p) && this.state.inType || this.raise(I.InvalidIdentifier, this.state.curPosition(), { identifierName: w }), this.finishToken(132, w);
          }
          getTokenFromCode(p) {
            const w = this.input.charCodeAt(this.state.pos + 1);
            p === 123 && w === 124 ? this.finishOp(6, 2) : !this.state.inType || p !== 62 && p !== 60 ? this.state.inType && p === 63 ? w === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(q, ne, pe) {
              return q === 64 && ne === 64 && be(pe);
            }(p, w, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(p) : this.finishOp(p === 62 ? 48 : 47, 1);
          }
          isAssignable(p, w) {
            return p.type === "TypeCastExpression" ? this.isAssignable(p.expression, w) : super.isAssignable(p, w);
          }
          toAssignable(p, w = !1) {
            w || p.type !== "AssignmentExpression" || p.left.type !== "TypeCastExpression" || (p.left = this.typeCastToParameter(p.left)), super.toAssignable(p, w);
          }
          toAssignableList(p, w, q) {
            for (let ne = 0; ne < p.length; ne++) {
              const pe = p[ne];
              (pe == null ? void 0 : pe.type) === "TypeCastExpression" && (p[ne] = this.typeCastToParameter(pe));
            }
            super.toAssignableList(p, w, q);
          }
          toReferencedList(p, w) {
            for (let ne = 0; ne < p.length; ne++) {
              var q;
              const pe = p[ne];
              !pe || pe.type !== "TypeCastExpression" || (q = pe.extra) != null && q.parenthesized || !(p.length > 1) && w || this.raise(Nt.TypeCastInPattern, pe.typeAnnotation);
            }
            return p;
          }
          parseArrayLike(p, w, q, ne) {
            const pe = super.parseArrayLike(p, w, q, ne);
            return w && !this.state.maybeInArrowParameters && this.toReferencedList(pe.elements), pe;
          }
          isValidLVal(p, w, q) {
            return p === "TypeCastExpression" || super.isValidLVal(p, w, q);
          }
          parseClassProperty(p) {
            return this.match(14) && (p.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(p);
          }
          parseClassPrivateProperty(p) {
            return this.match(14) && (p.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(p);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(p) {
            return !this.match(14) && super.isNonstaticConstructor(p);
          }
          pushClassMethod(p, w, q, ne, pe, xe) {
            if (w.variance && this.unexpected(w.variance.loc.start), delete w.variance, this.match(47) && (w.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(p, w, q, ne, pe, xe), w.params && pe) {
              const Ce = w.params;
              Ce.length > 0 && this.isThisParam(Ce[0]) && this.raise(Nt.ThisParamBannedInConstructor, w);
            } else if (w.type === "MethodDefinition" && pe && w.value.params) {
              const Ce = w.value.params;
              Ce.length > 0 && this.isThisParam(Ce[0]) && this.raise(Nt.ThisParamBannedInConstructor, w);
            }
          }
          pushClassPrivateMethod(p, w, q, ne) {
            w.variance && this.unexpected(w.variance.loc.start), delete w.variance, this.match(47) && (w.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(p, w, q, ne);
          }
          parseClassSuper(p) {
            if (super.parseClassSuper(p), p.superClass && this.match(47) && (p.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
              this.next();
              const w = p.implements = [];
              do {
                const q = this.startNode();
                q.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? q.typeParameters = this.flowParseTypeParameterInstantiation() : q.typeParameters = null, w.push(this.finishNode(q, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(p) {
            super.checkGetterSetterParams(p);
            const w = this.getObjectOrClassMethodParams(p);
            if (w.length > 0) {
              const q = w[0];
              this.isThisParam(q) && p.kind === "get" ? this.raise(Nt.GetterMayNotHaveThisParam, q) : this.isThisParam(q) && this.raise(Nt.SetterMayNotHaveThisParam, q);
            }
          }
          parsePropertyNamePrefixOperator(p) {
            p.variance = this.flowParseVariance();
          }
          parseObjPropValue(p, w, q, ne, pe, xe, Ce) {
            let Re;
            p.variance && this.unexpected(p.variance.loc.start), delete p.variance, this.match(47) && !xe && (Re = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            const Ue = super.parseObjPropValue(p, w, q, ne, pe, xe, Ce);
            return Re && ((Ue.value || Ue).typeParameters = Re), Ue;
          }
          parseAssignableListItemTypes(p) {
            return this.eat(17) && (p.type !== "Identifier" && this.raise(Nt.PatternIsOptional, p), this.isThisParam(p) && this.raise(Nt.ThisParamMayNotBeOptional, p), p.optional = !0), this.match(14) ? p.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(p) && this.raise(Nt.ThisParamAnnotationRequired, p), this.match(29) && this.isThisParam(p) && this.raise(Nt.ThisParamNoDefault, p), this.resetEndLocation(p), p;
          }
          parseMaybeDefault(p, w) {
            const q = super.parseMaybeDefault(p, w);
            return q.type === "AssignmentPattern" && q.typeAnnotation && q.right.start < q.typeAnnotation.start && this.raise(Nt.TypeBeforeInitializer, q.typeAnnotation), q;
          }
          checkImportReflection(p) {
            super.checkImportReflection(p), p.module && p.importKind !== "value" && this.raise(Nt.ImportReflectionHasImportType, p.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(p, w, q) {
            w.local = Pi(p) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), p.specifiers.push(this.finishImportSpecifier(w, q));
          }
          isPotentialImportPhase(p) {
            if (super.isPotentialImportPhase(p)) return !0;
            if (this.isContextual(130)) {
              if (!p) return !0;
              const w = this.lookaheadCharCode();
              return w === 123 || w === 42;
            }
            return !p && this.isContextual(87);
          }
          applyImportPhase(p, w, q, ne) {
            if (super.applyImportPhase(p, w, q, ne), w) {
              if (!q && this.match(65)) return;
              p.exportKind = q === "type" ? q : "value";
            } else q === "type" && this.match(55) && this.unexpected(), p.importKind = q === "type" || q === "typeof" ? q : "value";
          }
          parseImportSpecifier(p, w, q, ne, pe) {
            const xe = p.imported;
            let Ce = null;
            xe.type === "Identifier" && (xe.name === "type" ? Ce = "type" : xe.name === "typeof" && (Ce = "typeof"));
            let Re = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const Ke = this.parseIdentifier(!0);
              Ce === null || F(this.state.type) ? (p.imported = xe, p.importKind = null, p.local = this.parseIdentifier()) : (p.imported = Ke, p.importKind = Ce, p.local = Dr(Ke));
            } else {
              if (Ce !== null && F(this.state.type)) p.imported = this.parseIdentifier(!0), p.importKind = Ce;
              else {
                if (w) throw this.raise(I.ImportBindingIsString, p, { importName: xe.value });
                p.imported = xe, p.importKind = null;
              }
              this.eatContextual(93) ? p.local = this.parseIdentifier() : (Re = !0, p.local = Dr(p.imported));
            }
            const Ue = Pi(p);
            return q && Ue && this.raise(Nt.ImportTypeShorthandOnlyInPureImport, p), (q || Ue) && this.checkReservedType(p.local.name, p.local.loc.start, !0), !Re || q || Ue || this.checkReservedWord(p.local.name, p.loc.start, !0, !0), this.finishImportSpecifier(p, "ImportSpecifier");
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseFunctionParams(p, w) {
            const q = p.kind;
            q !== "get" && q !== "set" && this.match(47) && (p.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(p, w);
          }
          parseVarId(p, w) {
            super.parseVarId(p, w), this.match(14) && (p.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(p.id));
          }
          parseAsyncArrowFromCallExpression(p, w) {
            if (this.match(14)) {
              const q = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = !0, p.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = q;
            }
            return super.parseAsyncArrowFromCallExpression(p, w);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(p, w) {
            var q;
            let ne, pe = null;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (pe = this.state.clone(), ne = this.tryParse(() => super.parseMaybeAssign(p, w), pe), !ne.error) return ne.node;
              const { context: Re } = this.state, Ue = Re[Re.length - 1];
              Ue !== _.j_oTag && Ue !== _.j_expr || Re.pop();
            }
            if ((q = ne) != null && q.error || this.match(47)) {
              var xe, Ce;
              let Re;
              pe = pe || this.state.clone();
              const Ue = this.tryParse((yt) => {
                var $t;
                Re = this.flowParseTypeParameterDeclaration();
                const wt = this.forwardNoArrowParamsConversionAt(Re, () => {
                  const Gr = super.parseMaybeAssign(p, w);
                  return this.resetStartLocationFromNode(Gr, Re), Gr;
                });
                ($t = wt.extra) != null && $t.parenthesized && yt();
                const Ht = this.maybeUnwrapTypeCastExpression(wt);
                return Ht.type !== "ArrowFunctionExpression" && yt(), Ht.typeParameters = Re, this.resetStartLocationFromNode(Ht, Re), wt;
              }, pe);
              let Ke = null;
              if (Ue.node && this.maybeUnwrapTypeCastExpression(Ue.node).type === "ArrowFunctionExpression") {
                if (!Ue.error && !Ue.aborted) return Ue.node.async && this.raise(Nt.UnexpectedTypeParameterBeforeAsyncArrowFunction, Re), Ue.node;
                Ke = Ue.node;
              }
              if ((xe = ne) != null && xe.node) return this.state = ne.failState, ne.node;
              if (Ke) return this.state = Ue.failState, Ke;
              throw (Ce = ne) != null && Ce.thrown ? ne.error : Ue.thrown ? Ue.error : this.raise(Nt.UnexpectedTokenAfterTypeParameter, Re);
            }
            return super.parseMaybeAssign(p, w);
          }
          parseArrow(p) {
            if (this.match(14)) {
              const w = this.tryParse(() => {
                const q = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0;
                const ne = this.startNode();
                return [ne.typeAnnotation, p.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = q, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), ne;
              });
              if (w.thrown) return null;
              w.error && (this.state = w.failState), p.returnType = w.node.typeAnnotation ? this.finishNode(w.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(p);
          }
          shouldParseArrow(p) {
            return this.match(14) || super.shouldParseArrow(p);
          }
          setArrowFunctionParameters(p, w) {
            this.state.noArrowParamsConversionAt.indexOf(p.start) !== -1 ? p.params = w : super.setArrowFunctionParameters(p, w);
          }
          checkParams(p, w, q, ne = !0) {
            if (!q || this.state.noArrowParamsConversionAt.indexOf(p.start) === -1) {
              for (let pe = 0; pe < p.params.length; pe++) this.isThisParam(p.params[pe]) && pe > 0 && this.raise(Nt.ThisParamMustBeFirst, p.params[pe]);
              super.checkParams(p, w, q, ne);
            }
          }
          parseParenAndDistinguishExpression(p) {
            return super.parseParenAndDistinguishExpression(p && this.state.noArrowAt.indexOf(this.state.start) === -1);
          }
          parseSubscripts(p, w, q) {
            if (p.type === "Identifier" && p.name === "async" && this.state.noArrowAt.indexOf(w.index) !== -1) {
              this.next();
              const ne = this.startNodeAt(w);
              ne.callee = p, ne.arguments = super.parseCallExpressionArguments(11, !1), p = this.finishNode(ne, "CallExpression");
            } else if (p.type === "Identifier" && p.name === "async" && this.match(47)) {
              const ne = this.state.clone(), pe = this.tryParse((Ce) => this.parseAsyncArrowWithTypeParameters(w) || Ce(), ne);
              if (!pe.error && !pe.aborted) return pe.node;
              const xe = this.tryParse(() => super.parseSubscripts(p, w, q), ne);
              if (xe.node && !xe.error) return xe.node;
              if (pe.node) return this.state = pe.failState, pe.node;
              if (xe.node) return this.state = xe.failState, xe.node;
              throw pe.error || xe.error;
            }
            return super.parseSubscripts(p, w, q);
          }
          parseSubscript(p, w, q, ne) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (ne.optionalChainMember = !0, q) return ne.stop = !0, p;
              this.next();
              const pe = this.startNodeAt(w);
              return pe.callee = p, pe.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), pe.arguments = this.parseCallExpressionArguments(11, !1), pe.optional = !0, this.finishCallExpression(pe, !0);
            }
            if (!q && this.shouldParseTypes() && this.match(47)) {
              const pe = this.startNodeAt(w);
              pe.callee = p;
              const xe = this.tryParse(() => (pe.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), pe.arguments = super.parseCallExpressionArguments(11, !1), ne.optionalChainMember && (pe.optional = !1), this.finishCallExpression(pe, ne.optionalChainMember)));
              if (xe.node) return xe.error && (this.state = xe.failState), xe.node;
            }
            return super.parseSubscript(p, w, q, ne);
          }
          parseNewCallee(p) {
            super.parseNewCallee(p);
            let w = null;
            this.shouldParseTypes() && this.match(47) && (w = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), p.typeArguments = w;
          }
          parseAsyncArrowWithTypeParameters(p) {
            const w = this.startNodeAt(p);
            if (this.parseFunctionParams(w, !1), this.parseArrow(w)) return super.parseArrowExpression(w, void 0, !0);
          }
          readToken_mult_modulo(p) {
            const w = this.input.charCodeAt(this.state.pos + 1);
            if (p === 42 && w === 47 && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(p);
          }
          readToken_pipe_amp(p) {
            const w = this.input.charCodeAt(this.state.pos + 1);
            p !== 124 || w !== 125 ? super.readToken_pipe_amp(p) : this.finishOp(9, 2);
          }
          parseTopLevel(p, w) {
            const q = super.parseTopLevel(p, w);
            return this.state.hasFlowComment && this.raise(Nt.UnterminatedFlowComment, this.state.curPosition()), q;
          }
          skipBlockComment() {
            if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            {
              if (this.state.hasFlowComment) throw this.raise(Nt.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              const p = this.skipFlowComment();
              p && (this.state.pos += p, this.state.hasFlowComment = !0);
            }
          }
          skipFlowComment() {
            const { pos: p } = this.state;
            let w = 2;
            for (; [32, 9].includes(this.input.charCodeAt(p + w)); ) w++;
            const q = this.input.charCodeAt(w + p), ne = this.input.charCodeAt(w + p + 1);
            return q === 58 && ne === 58 ? w + 2 : this.input.slice(w + p, w + p + 12) === "flow-include" ? w + 12 : q === 58 && ne !== 58 && w;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(I.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(p, { enumName: w, memberName: q }) {
            this.raise(Nt.EnumBooleanMemberNotInitialized, p, { memberName: q, enumName: w });
          }
          flowEnumErrorInvalidMemberInitializer(p, w) {
            return this.raise(w.explicitType ? w.explicitType === "symbol" ? Nt.EnumInvalidMemberInitializerSymbolType : Nt.EnumInvalidMemberInitializerPrimaryType : Nt.EnumInvalidMemberInitializerUnknownType, p, w);
          }
          flowEnumErrorNumberMemberNotInitialized(p, w) {
            this.raise(Nt.EnumNumberMemberNotInitialized, p, w);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(p, w) {
            this.raise(Nt.EnumStringMemberInconsistentlyInitialized, p, w);
          }
          flowEnumMemberInit() {
            const p = this.state.startLoc, w = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 134: {
                const q = this.parseNumericLiteral(this.state.value);
                return w() ? { type: "number", loc: q.loc.start, value: q } : { type: "invalid", loc: p };
              }
              case 133: {
                const q = this.parseStringLiteral(this.state.value);
                return w() ? { type: "string", loc: q.loc.start, value: q } : { type: "invalid", loc: p };
              }
              case 85:
              case 86: {
                const q = this.parseBooleanLiteral(this.match(85));
                return w() ? { type: "boolean", loc: q.loc.start, value: q } : { type: "invalid", loc: p };
              }
              default:
                return { type: "invalid", loc: p };
            }
          }
          flowEnumMemberRaw() {
            const p = this.state.startLoc;
            return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: p } };
          }
          flowEnumCheckExplicitTypeMismatch(p, w, q) {
            const { explicitType: ne } = w;
            ne !== null && ne !== q && this.flowEnumErrorInvalidMemberInitializer(p, w);
          }
          flowEnumMembers({ enumName: p, explicitType: w }) {
            const q = /* @__PURE__ */ new Set(), ne = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let pe = !1;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                pe = !0;
                break;
              }
              const xe = this.startNode(), { id: Ce, init: Re } = this.flowEnumMemberRaw(), Ue = Ce.name;
              if (Ue === "") continue;
              /^[a-z]/.test(Ue) && this.raise(Nt.EnumInvalidMemberName, Ce, { memberName: Ue, suggestion: Ue[0].toUpperCase() + Ue.slice(1), enumName: p }), q.has(Ue) && this.raise(Nt.EnumDuplicateMemberName, Ce, { memberName: Ue, enumName: p }), q.add(Ue);
              const Ke = { enumName: p, explicitType: w, memberName: Ue };
              switch (xe.id = Ce, Re.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(Re.loc, Ke, "boolean"), xe.init = Re.value, ne.booleanMembers.push(this.finishNode(xe, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(Re.loc, Ke, "number"), xe.init = Re.value, ne.numberMembers.push(this.finishNode(xe, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(Re.loc, Ke, "string"), xe.init = Re.value, ne.stringMembers.push(this.finishNode(xe, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(Re.loc, Ke);
                case "none":
                  switch (w) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(Re.loc, Ke);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(Re.loc, Ke);
                      break;
                    default:
                      ne.defaultedMembers.push(this.finishNode(xe, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: ne, hasUnknownMembers: pe };
          }
          flowEnumStringMembers(p, w, { enumName: q }) {
            if (p.length === 0) return w;
            if (w.length === 0) return p;
            if (w.length > p.length) {
              for (const ne of p) this.flowEnumErrorStringMemberInconsistentlyInitialized(ne, { enumName: q });
              return w;
            }
            for (const ne of w) this.flowEnumErrorStringMemberInconsistentlyInitialized(ne, { enumName: q });
            return p;
          }
          flowEnumParseExplicitType({ enumName: p }) {
            if (!this.eatContextual(102)) return null;
            if (!V(this.state.type)) throw this.raise(Nt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: p });
            const { value: w } = this.state;
            return this.next(), w !== "boolean" && w !== "number" && w !== "string" && w !== "symbol" && this.raise(Nt.EnumInvalidExplicitType, this.state.startLoc, { enumName: p, invalidEnumType: w }), w;
          }
          flowEnumBody(p, w) {
            const q = w.name, ne = w.loc.start, pe = this.flowEnumParseExplicitType({ enumName: q });
            this.expect(5);
            const { members: xe, hasUnknownMembers: Ce } = this.flowEnumMembers({ enumName: q, explicitType: pe });
            switch (p.hasUnknownMembers = Ce, pe) {
              case "boolean":
                return p.explicitType = !0, p.members = xe.booleanMembers, this.expect(8), this.finishNode(p, "EnumBooleanBody");
              case "number":
                return p.explicitType = !0, p.members = xe.numberMembers, this.expect(8), this.finishNode(p, "EnumNumberBody");
              case "string":
                return p.explicitType = !0, p.members = this.flowEnumStringMembers(xe.stringMembers, xe.defaultedMembers, { enumName: q }), this.expect(8), this.finishNode(p, "EnumStringBody");
              case "symbol":
                return p.members = xe.defaultedMembers, this.expect(8), this.finishNode(p, "EnumSymbolBody");
              default: {
                const Re = () => (p.members = [], this.expect(8), this.finishNode(p, "EnumStringBody"));
                p.explicitType = !1;
                const Ue = xe.booleanMembers.length, Ke = xe.numberMembers.length, yt = xe.stringMembers.length, $t = xe.defaultedMembers.length;
                if (Ue || Ke || yt || $t) {
                  if (Ue || Ke) {
                    if (!Ke && !yt && Ue >= $t) {
                      for (const wt of xe.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(wt.loc.start, { enumName: q, memberName: wt.id.name });
                      return p.members = xe.booleanMembers, this.expect(8), this.finishNode(p, "EnumBooleanBody");
                    }
                    if (!Ue && !yt && Ke >= $t) {
                      for (const wt of xe.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(wt.loc.start, { enumName: q, memberName: wt.id.name });
                      return p.members = xe.numberMembers, this.expect(8), this.finishNode(p, "EnumNumberBody");
                    }
                    return this.raise(Nt.EnumInconsistentMemberValues, ne, { enumName: q }), Re();
                  }
                  return p.members = this.flowEnumStringMembers(xe.stringMembers, xe.defaultedMembers, { enumName: q }), this.expect(8), this.finishNode(p, "EnumStringBody");
                }
                return Re();
              }
            }
          }
          flowParseEnumDeclaration(p) {
            const w = this.parseIdentifier();
            return p.id = w, p.body = this.flowEnumBody(this.startNode(), w), this.finishNode(p, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const p = this.nextTokenStart();
            if (this.input.charCodeAt(p) === 60) {
              const w = this.input.charCodeAt(p + 1);
              return w !== 60 && w !== 61;
            }
            return !1;
          }
          maybeUnwrapTypeCastExpression(p) {
            return p.type === "TypeCastExpression" ? p.expression : p;
          }
        }, typescript: (Te) => class extends Te {
          constructor(...p) {
            super(...p), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ht.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: ht.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ht.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return Pt;
          }
          tsIsIdentifier() {
            return V(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(p, w) {
            if (!V(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
            const q = this.state.value;
            if (p.indexOf(q) !== -1) {
              if (w && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return q;
            }
          }
          tsParseModifiers({ allowedModifiers: p, disallowedModifiers: w, stopOnStartOfClassStaticBlock: q, errorTemplate: ne = ht.InvalidModifierOnTypeMember }, pe) {
            const xe = (Re, Ue, Ke, yt) => {
              Ue === Ke && pe[yt] && this.raise(ht.InvalidModifiersOrder, Re, { orderedModifiers: [Ke, yt] });
            }, Ce = (Re, Ue, Ke, yt) => {
              (pe[Ke] && Ue === yt || pe[yt] && Ue === Ke) && this.raise(ht.IncompatibleModifiers, Re, { modifiers: [Ke, yt] });
            };
            for (; ; ) {
              const { startLoc: Re } = this.state, Ue = this.tsParseModifier(p.concat(w ?? []), q);
              if (!Ue) break;
              rr(Ue) ? pe.accessibility ? this.raise(ht.DuplicateAccessibilityModifier, Re, { modifier: Ue }) : (xe(Re, Ue, Ue, "override"), xe(Re, Ue, Ue, "static"), xe(Re, Ue, Ue, "readonly"), pe.accessibility = Ue) : sr(Ue) ? (pe[Ue] && this.raise(ht.DuplicateModifier, Re, { modifier: Ue }), pe[Ue] = !0, xe(Re, Ue, "in", "out")) : (hasOwnProperty.call(pe, Ue) ? this.raise(ht.DuplicateModifier, Re, { modifier: Ue }) : (xe(Re, Ue, "static", "readonly"), xe(Re, Ue, "static", "override"), xe(Re, Ue, "override", "readonly"), xe(Re, Ue, "abstract", "override"), Ce(Re, Ue, "declare", "override"), Ce(Re, Ue, "static", "abstract")), pe[Ue] = !0), w != null && w.includes(Ue) && this.raise(ne, Re, { modifier: Ue });
            }
          }
          tsIsListTerminator(p) {
            switch (p) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(p, w) {
            const q = [];
            for (; !this.tsIsListTerminator(p); ) q.push(w());
            return q;
          }
          tsParseDelimitedList(p, w, q) {
            return function(ne) {
              if (ne == null) throw new Error(`Unexpected ${ne} value.`);
              return ne;
            }(this.tsParseDelimitedListWorker(p, w, !0, q));
          }
          tsParseDelimitedListWorker(p, w, q, ne) {
            const pe = [];
            let xe = -1;
            for (; !this.tsIsListTerminator(p); ) {
              xe = -1;
              const Ce = w();
              if (Ce == null) return;
              if (pe.push(Ce), !this.eat(12)) {
                if (this.tsIsListTerminator(p)) break;
                return void (q && this.expect(12));
              }
              xe = this.state.lastTokStartLoc.index;
            }
            return ne && (ne.value = xe), pe;
          }
          tsParseBracketedList(p, w, q, ne, pe) {
            ne || (q ? this.expect(0) : this.expect(47));
            const xe = this.tsParseDelimitedList(p, w, pe);
            return q ? this.expect(3) : this.expect(48), xe;
          }
          tsParseImportType() {
            const p = this.startNode();
            return this.expect(83), this.expect(10), this.match(133) || this.raise(ht.UnsupportedImportTypeArgument, this.state.startLoc), p.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (p.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (p.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (p.qualifier = this.tsParseEntityName()), this.match(47) && (p.typeParameters = this.tsParseTypeArguments()), this.finishNode(p, "TSImportType");
          }
          tsParseEntityName(p = !0) {
            let w = this.parseIdentifier(p);
            for (; this.eat(16); ) {
              const q = this.startNodeAtNode(w);
              q.left = w, q.right = this.parseIdentifier(p), w = this.finishNode(q, "TSQualifiedName");
            }
            return w;
          }
          tsParseTypeReference() {
            const p = this.startNode();
            return p.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (p.typeParameters = this.tsParseTypeArguments()), this.finishNode(p, "TSTypeReference");
          }
          tsParseThisTypePredicate(p) {
            this.next();
            const w = this.startNodeAtNode(p);
            return w.parameterName = p, w.typeAnnotation = this.tsParseTypeAnnotation(!1), w.asserts = !1, this.finishNode(w, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const p = this.startNode();
            return this.next(), this.finishNode(p, "TSThisType");
          }
          tsParseTypeQuery() {
            const p = this.startNode();
            return this.expect(87), this.match(83) ? p.exprName = this.tsParseImportType() : p.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (p.typeParameters = this.tsParseTypeArguments()), this.finishNode(p, "TSTypeQuery");
          }
          tsParseTypeParameter(p) {
            const w = this.startNode();
            return p(w), w.name = this.tsParseTypeParameterName(), w.constraint = this.tsEatThenParseType(81), w.default = this.tsEatThenParseType(29), this.finishNode(w, "TSTypeParameter");
          }
          tsTryParseTypeParameters(p) {
            if (this.match(47)) return this.tsParseTypeParameters(p);
          }
          tsParseTypeParameters(p) {
            const w = this.startNode();
            this.match(47) || this.match(142) ? this.next() : this.unexpected();
            const q = { value: -1 };
            return w.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, p), !1, !0, q), w.params.length === 0 && this.raise(ht.EmptyTypeParameters, w), q.value !== -1 && this.addExtra(w, "trailingComma", q.value), this.finishNode(w, "TSTypeParameterDeclaration");
          }
          tsFillSignature(p, w) {
            const q = p === 19;
            w.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), w.parameters = this.tsParseBindingListForSignature(), (q || this.match(p)) && (w.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(p));
          }
          tsParseBindingListForSignature() {
            const p = super.parseBindingList(11, 41, 2);
            for (const w of p) {
              const { type: q } = w;
              q !== "AssignmentPattern" && q !== "TSParameterProperty" || this.raise(ht.UnsupportedSignatureParameterKind, w, { type: q });
            }
            return p;
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(p, w) {
            return this.tsFillSignature(14, w), this.tsParseTypeMemberSemicolon(), this.finishNode(w, p);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!V(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(p) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
            this.expect(0);
            const w = this.parseIdentifier();
            w.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(w), this.expect(3), p.parameters = [w];
            const q = this.tsTryParseTypeAnnotation();
            return q && (p.typeAnnotation = q), this.tsParseTypeMemberSemicolon(), this.finishNode(p, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(p, w) {
            this.eat(17) && (p.optional = !0);
            const q = p;
            if (this.match(10) || this.match(47)) {
              w && this.raise(ht.ReadonlyForMethodSignature, p);
              const ne = q;
              ne.kind && this.match(47) && this.raise(ht.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, ne), this.tsParseTypeMemberSemicolon();
              const pe = "parameters", xe = "typeAnnotation";
              if (ne.kind === "get") ne[pe].length > 0 && (this.raise(I.BadGetterArity, this.state.curPosition()), this.isThisParam(ne[pe][0]) && this.raise(ht.AccesorCannotDeclareThisParameter, this.state.curPosition()));
              else if (ne.kind === "set") {
                if (ne[pe].length !== 1) this.raise(I.BadSetterArity, this.state.curPosition());
                else {
                  const Ce = ne[pe][0];
                  this.isThisParam(Ce) && this.raise(ht.AccesorCannotDeclareThisParameter, this.state.curPosition()), Ce.type === "Identifier" && Ce.optional && this.raise(ht.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), Ce.type === "RestElement" && this.raise(ht.SetAccesorCannotHaveRestParameter, this.state.curPosition());
                }
                ne[xe] && this.raise(ht.SetAccesorCannotHaveReturnType, ne[xe]);
              } else ne.kind = "method";
              return this.finishNode(ne, "TSMethodSignature");
            }
            {
              const ne = q;
              w && (ne.readonly = !0);
              const pe = this.tsTryParseTypeAnnotation();
              return pe && (ne.typeAnnotation = pe), this.tsParseTypeMemberSemicolon(), this.finishNode(ne, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const p = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", p);
            if (this.match(77)) {
              const q = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", p) : (p.key = this.createIdentifier(q, "new"), this.tsParsePropertyOrMethodSignature(p, !1));
            }
            return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, p), this.tsTryParseIndexSignature(p) || (super.parsePropertyName(p), p.computed || p.key.type !== "Identifier" || p.key.name !== "get" && p.key.name !== "set" || !this.tsTokenCanFollowModifier() || (p.kind = p.key.name, super.parsePropertyName(p)), this.tsParsePropertyOrMethodSignature(p, !!p.readonly));
          }
          tsParseTypeLiteral() {
            const p = this.startNode();
            return p.members = this.tsParseObjectTypeMembers(), this.finishNode(p, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const p = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), p;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedTypeParameter() {
            const p = this.startNode();
            return p.name = this.tsParseTypeParameterName(), p.constraint = this.tsExpectThenParseType(58), this.finishNode(p, "TSTypeParameter");
          }
          tsParseMappedType() {
            const p = this.startNode();
            return this.expect(5), this.match(53) ? (p.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (p.readonly = !0), this.expect(0), p.typeParameter = this.tsParseMappedTypeParameter(), p.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (p.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (p.optional = !0), p.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(p, "TSMappedType");
          }
          tsParseTupleType() {
            const p = this.startNode();
            p.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
            let w = !1;
            return p.elementTypes.forEach((q) => {
              const { type: ne } = q;
              !w || ne === "TSRestType" || ne === "TSOptionalType" || ne === "TSNamedTupleMember" && q.optional || this.raise(ht.OptionalTypeBeforeRequired, q), w || (w = ne === "TSNamedTupleMember" && q.optional || ne === "TSOptionalType");
            }), this.finishNode(p, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { startLoc: p } = this.state, w = this.eat(21);
            let q, ne, pe, xe;
            const Ce = F(this.state.type) ? this.lookaheadCharCode() : null;
            if (Ce === 58) q = !0, pe = !1, ne = this.parseIdentifier(!0), this.expect(14), xe = this.tsParseType();
            else if (Ce === 63) {
              pe = !0;
              const Re = this.state.startLoc, Ue = this.state.value, Ke = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (q = !0, ne = this.createIdentifier(this.startNodeAt(Re), Ue), this.expect(17), this.expect(14), xe = this.tsParseType()) : (q = !1, xe = Ke, this.expect(17));
            } else xe = this.tsParseType(), pe = this.eat(17), q = this.eat(14);
            if (q) {
              let Re;
              ne ? (Re = this.startNodeAtNode(ne), Re.optional = pe, Re.label = ne, Re.elementType = xe, this.eat(17) && (Re.optional = !0, this.raise(ht.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (Re = this.startNodeAtNode(xe), Re.optional = pe, this.raise(ht.InvalidTupleMemberLabel, xe), Re.label = xe, Re.elementType = this.tsParseType()), xe = this.finishNode(Re, "TSNamedTupleMember");
            } else if (pe) {
              const Re = this.startNodeAtNode(xe);
              Re.typeAnnotation = xe, xe = this.finishNode(Re, "TSOptionalType");
            }
            if (w) {
              const Re = this.startNodeAt(p);
              Re.typeAnnotation = xe, xe = this.finishNode(Re, "TSRestType");
            }
            return xe;
          }
          tsParseParenthesizedType() {
            const p = this.startNode();
            return this.expect(10), p.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(p, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(p, w) {
            const q = this.startNode();
            return p === "TSConstructorType" && (q.abstract = !!w, w && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, q)), this.finishNode(q, p);
          }
          tsParseLiteralTypeNode() {
            const p = this.startNode();
            switch (this.state.type) {
              case 134:
              case 135:
              case 133:
              case 85:
              case 86:
                p.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(p, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const p = this.startNode();
            return p.literal = super.parseTemplate(!1), this.finishNode(p, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const p = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(p) : p;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 133:
              case 134:
              case 135:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  const p = this.startNode(), w = this.lookahead();
                  return w.type !== 134 && w.type !== 135 && this.unexpected(), p.literal = this.parseMaybeUnary(), this.finishNode(p, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: p } = this.state;
                if (V(p) || p === 88 || p === 84) {
                  const w = p === 88 ? "TSVoidKeyword" : p === 84 ? "TSNullKeyword" : function(q) {
                    switch (q) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (w !== void 0 && this.lookaheadCharCode() !== 46) {
                    const q = this.startNode();
                    return this.next(), this.finishNode(q, w);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let p = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              const w = this.startNodeAtNode(p);
              w.elementType = p, this.expect(3), p = this.finishNode(w, "TSArrayType");
            } else {
              const w = this.startNodeAtNode(p);
              w.objectType = p, w.indexType = this.tsParseType(), this.expect(3), p = this.finishNode(w, "TSIndexedAccessType");
            }
            return p;
          }
          tsParseTypeOperator() {
            const p = this.startNode(), w = this.state.value;
            return this.next(), p.operator = w, p.typeAnnotation = this.tsParseTypeOperatorOrHigher(), w === "readonly" && this.tsCheckTypeAnnotationForReadOnly(p), this.finishNode(p, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(p) {
            switch (p.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(ht.UnexpectedReadonly, p);
            }
          }
          tsParseInferType() {
            const p = this.startNode();
            this.expectContextual(115);
            const w = this.startNode();
            return w.name = this.tsParseTypeParameterName(), w.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), p.typeParameter = this.finishNode(w, "TSTypeParameter"), this.finishNode(p, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const p = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return p;
            }
          }
          tsParseTypeOperatorOrHigher() {
            var p;
            return (p = this.state.type) >= 121 && p <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(p, w, q) {
            const ne = this.startNode(), pe = this.eat(q), xe = [];
            do
              xe.push(w());
            while (this.eat(q));
            return xe.length !== 1 || pe ? (ne.types = xe, this.finishNode(ne, p)) : xe[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (V(this.state.type) || this.match(78)) return this.next(), !0;
            if (this.match(5)) {
              const { errors: p } = this.state, w = p.length;
              try {
                return this.parseObjectLike(8, !0), p.length === w;
              } catch {
                return !1;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors: p } = this.state, w = p.length;
              try {
                return super.parseBindingList(3, 93, 1), p.length === w;
              } catch {
                return !1;
              }
            }
            return !1;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(p) {
            return this.tsInType(() => {
              const w = this.startNode();
              this.expect(p);
              const q = this.startNode(), ne = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (ne && this.match(78)) {
                let Ce = this.tsParseThisTypeOrThisTypePredicate();
                return Ce.type === "TSThisType" ? (q.parameterName = Ce, q.asserts = !0, q.typeAnnotation = null, Ce = this.finishNode(q, "TSTypePredicate")) : (this.resetStartLocationFromNode(Ce, q), Ce.asserts = !0), w.typeAnnotation = Ce, this.finishNode(w, "TSTypeAnnotation");
              }
              const pe = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!pe) return ne ? (q.parameterName = this.parseIdentifier(), q.asserts = ne, q.typeAnnotation = null, w.typeAnnotation = this.finishNode(q, "TSTypePredicate"), this.finishNode(w, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, w);
              const xe = this.tsParseTypeAnnotation(!1);
              return q.parameterName = pe, q.typeAnnotation = xe, q.asserts = ne, w.typeAnnotation = this.finishNode(q, "TSTypePredicate"), this.finishNode(w, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const p = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), p;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109) return !1;
            const p = this.state.containsEsc;
            return this.next(), !(!V(this.state.type) && !this.match(78)) && (p && this.raise(I.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
          }
          tsParseTypeAnnotation(p = !0, w = this.startNode()) {
            return this.tsInType(() => {
              p && this.expect(14), w.typeAnnotation = this.tsParseType();
            }), this.finishNode(w, "TSTypeAnnotation");
          }
          tsParseType() {
            Ft(this.state.inType);
            const p = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return p;
            const w = this.startNodeAtNode(p);
            return w.checkType = p, w.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), w.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), w.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(w, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ht.ReservedTypeAssertion, this.state.startLoc);
            const p = this.startNode();
            return p.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), p.expression = this.parseMaybeUnary(), this.finishNode(p, "TSTypeAssertion");
          }
          tsParseHeritageClause(p) {
            const w = this.state.startLoc, q = this.tsParseDelimitedList("HeritageClauseElement", () => {
              const ne = this.startNode();
              return ne.expression = this.tsParseEntityName(), this.match(47) && (ne.typeParameters = this.tsParseTypeArguments()), this.finishNode(ne, "TSExpressionWithTypeArguments");
            });
            return q.length || this.raise(ht.EmptyHeritageClauseType, w, { token: p }), q;
          }
          tsParseInterfaceDeclaration(p, w = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129), w.declare && (p.declare = !0), V(this.state.type) ? (p.id = this.parseIdentifier(), this.checkIdentifier(p.id, 130)) : (p.id = null, this.raise(ht.MissingInterfaceName, this.state.startLoc)), p.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (p.extends = this.tsParseHeritageClause("extends"));
            const q = this.startNode();
            return q.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), p.body = this.finishNode(q, "TSInterfaceBody"), this.finishNode(p, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(p) {
            return p.id = this.parseIdentifier(), this.checkIdentifier(p.id, 2), p.typeAnnotation = this.tsInType(() => {
              if (p.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                const w = this.startNode();
                return this.next(), this.finishNode(w, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(p, "TSTypeAliasDeclaration");
          }
          tsInNoContext(p) {
            const w = this.state.context;
            this.state.context = [w[0]];
            try {
              return p();
            } finally {
              this.state.context = w;
            }
          }
          tsInType(p) {
            const w = this.state.inType;
            this.state.inType = !0;
            try {
              return p();
            } finally {
              this.state.inType = w;
            }
          }
          tsInDisallowConditionalTypesContext(p) {
            const w = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = !0;
            try {
              return p();
            } finally {
              this.state.inDisallowConditionalTypesContext = w;
            }
          }
          tsInAllowConditionalTypesContext(p) {
            const w = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = !1;
            try {
              return p();
            } finally {
              this.state.inDisallowConditionalTypesContext = w;
            }
          }
          tsEatThenParseType(p) {
            if (this.match(p)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(p) {
            return this.tsInType(() => (this.expect(p), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const p = this.startNode();
            return p.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (p.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(p, "TSEnumMember");
          }
          tsParseEnumDeclaration(p, w = {}) {
            return w.const && (p.const = !0), w.declare && (p.declare = !0), this.expectContextual(126), p.id = this.parseIdentifier(), this.checkIdentifier(p.id, p.const ? 8971 : 8459), this.expect(5), p.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(p, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const p = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(p.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(p, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(p, w = !1) {
            if (p.id = this.parseIdentifier(), w || this.checkIdentifier(p.id, 1024), this.eat(16)) {
              const q = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(q, !0), p.body = q;
            } else this.scope.enter(256), this.prodParam.enter(0), p.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(p, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(p) {
            return this.isContextual(112) ? (p.global = !0, p.id = this.parseIdentifier()) : this.match(133) ? p.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), p.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(p, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(p, w, q) {
            p.isExport = q || !1, p.id = w || this.parseIdentifier(), this.checkIdentifier(p.id, 4096), this.expect(29);
            const ne = this.tsParseModuleReference();
            return p.importKind === "type" && ne.type !== "TSExternalModuleReference" && this.raise(ht.ImportAliasHasImportType, ne), p.moduleReference = ne, this.semicolon(), this.finishNode(p, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
          }
          tsParseExternalModuleReference() {
            const p = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), p.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(p, "TSExternalModuleReference");
          }
          tsLookAhead(p) {
            const w = this.state.clone(), q = p();
            return this.state = w, q;
          }
          tsTryParseAndCatch(p) {
            const w = this.tryParse((q) => p() || q());
            if (!w.aborted && w.node) return w.error && (this.state = w.failState), w.node;
          }
          tsTryParse(p) {
            const w = this.state.clone(), q = p();
            if (q !== void 0 && q !== !1) return q;
            this.state = w;
          }
          tsTryParseDeclare(p) {
            if (this.isLineTerminator()) return;
            let w, q = this.state.type;
            return this.isContextual(100) && (q = 74, w = "let"), this.tsInAmbientContext(() => {
              switch (q) {
                case 68:
                  return p.declare = !0, super.parseFunctionStatement(p, !1, !1);
                case 80:
                  return p.declare = !0, this.parseClass(p, !0, !1);
                case 126:
                  return this.tsParseEnumDeclaration(p, { declare: !0 });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(p);
                case 75:
                case 74:
                  return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(p, { const: !0, declare: !0 })) : (p.declare = !0, this.parseVarStatement(p, w || this.state.value, !0));
                case 129: {
                  const ne = this.tsParseInterfaceDeclaration(p, { declare: !0 });
                  if (ne) return ne;
                }
                default:
                  if (V(q)) return this.tsParseDeclaration(p, this.state.value, !0, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
          }
          tsParseExpressionStatement(p, w, q) {
            switch (w.name) {
              case "declare": {
                const ne = this.tsTryParseDeclare(p);
                return ne && (ne.declare = !0), ne;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  const ne = p;
                  return ne.global = !0, ne.id = w, ne.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(ne, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(p, w.name, !1, q);
            }
          }
          tsParseDeclaration(p, w, q, ne) {
            switch (w) {
              case "abstract":
                if (this.tsCheckLineTerminator(q) && (this.match(80) || V(this.state.type))) return this.tsParseAbstractDeclaration(p, ne);
                break;
              case "module":
                if (this.tsCheckLineTerminator(q)) {
                  if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(p);
                  if (V(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(p);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(q) && V(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(p);
                break;
              case "type":
                if (this.tsCheckLineTerminator(q) && V(this.state.type)) return this.tsParseTypeAliasDeclaration(p);
            }
          }
          tsCheckLineTerminator(p) {
            return p ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(p) {
            if (!this.match(47)) return;
            const w = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = !0;
            const q = this.tsTryParseAndCatch(() => {
              const ne = this.startNodeAt(p);
              return ne.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(ne), ne.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), ne;
            });
            return this.state.maybeInArrowParameters = w, q ? super.parseArrowExpression(q, null, !0) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const p = this.startNode();
            return p.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), p.params.length === 0 ? this.raise(ht.EmptyTypeArguments, p) : this.state.inType || this.curContext() !== _.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(p, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (p = this.state.type) >= 124 && p <= 130;
            var p;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(p, w) {
            const q = this.state.startLoc, ne = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, ne);
            const pe = ne.accessibility, xe = ne.override, Ce = ne.readonly;
            4 & p || !(pe || Ce || xe) || this.raise(ht.UnexpectedParameterModifier, q);
            const Re = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(Re, p);
            const Ue = this.parseMaybeDefault(Re.loc.start, Re);
            if (pe || Ce || xe) {
              const Ke = this.startNodeAt(q);
              return w.length && (Ke.decorators = w), pe && (Ke.accessibility = pe), Ce && (Ke.readonly = Ce), xe && (Ke.override = xe), Ue.type !== "Identifier" && Ue.type !== "AssignmentPattern" && this.raise(ht.UnsupportedParameterPropertyKind, Ke), Ke.parameter = Ue, this.finishNode(Ke, "TSParameterProperty");
            }
            return w.length && (Re.decorators = w), Ue;
          }
          isSimpleParameter(p) {
            return p.type === "TSParameterProperty" && super.isSimpleParameter(p.parameter) || super.isSimpleParameter(p);
          }
          tsDisallowOptionalPattern(p) {
            for (const w of p.params) w.type !== "Identifier" && w.optional && !this.state.isAmbientContext && this.raise(ht.PatternIsOptional, w);
          }
          setArrowFunctionParameters(p, w, q) {
            super.setArrowFunctionParameters(p, w, q), this.tsDisallowOptionalPattern(p);
          }
          parseFunctionBodyAndFinish(p, w, q = !1) {
            this.match(14) && (p.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const ne = w === "FunctionDeclaration" ? "TSDeclareFunction" : w === "ClassMethod" || w === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return ne && !this.match(5) && this.isLineTerminator() ? this.finishNode(p, ne) : ne === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ht.DeclareFunctionHasImplementation, p), p.declare) ? super.parseFunctionBodyAndFinish(p, ne, q) : (this.tsDisallowOptionalPattern(p), super.parseFunctionBodyAndFinish(p, w, q));
          }
          registerFunctionStatementId(p) {
            !p.body && p.id ? this.checkIdentifier(p.id, 1024) : super.registerFunctionStatementId(p);
          }
          tsCheckForInvalidTypeCasts(p) {
            p.forEach((w) => {
              (w == null ? void 0 : w.type) === "TSTypeCastExpression" && this.raise(ht.UnexpectedTypeAnnotation, w.typeAnnotation);
            });
          }
          toReferencedList(p, w) {
            return this.tsCheckForInvalidTypeCasts(p), p;
          }
          parseArrayLike(p, w, q, ne) {
            const pe = super.parseArrayLike(p, w, q, ne);
            return pe.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(pe.elements), pe;
          }
          parseSubscript(p, w, q, ne) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = !1, this.next();
              const xe = this.startNodeAt(w);
              return xe.expression = p, this.finishNode(xe, "TSNonNullExpression");
            }
            let pe = !1;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (q) return ne.stop = !0, p;
              ne.optionalChainMember = pe = !0, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let xe;
              const Ce = this.tsTryParseAndCatch(() => {
                if (!q && this.atPossibleAsyncArrow(p)) {
                  const yt = this.tsTryParseGenericAsyncArrowFunction(w);
                  if (yt) return yt;
                }
                const Re = this.tsParseTypeArgumentsInExpression();
                if (!Re) return;
                if (pe && !this.match(10)) return void (xe = this.state.curPosition());
                if (ce(this.state.type)) {
                  const yt = super.parseTaggedTemplateExpression(p, w, ne);
                  return yt.typeParameters = Re, yt;
                }
                if (!q && this.eat(10)) {
                  const yt = this.startNodeAt(w);
                  return yt.callee = p, yt.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(yt.arguments), yt.typeParameters = Re, ne.optionalChainMember && (yt.optional = pe), this.finishCallExpression(yt, ne.optionalChainMember);
                }
                const Ue = this.state.type;
                if (Ue === 48 || Ue === 52 || Ue !== 10 && K(Ue) && !this.hasPrecedingLineBreak()) return;
                const Ke = this.startNodeAt(w);
                return Ke.expression = p, Ke.typeParameters = Re, this.finishNode(Ke, "TSInstantiationExpression");
              });
              if (xe && this.unexpected(xe, 10), Ce) return Ce.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ht.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), Ce;
            }
            return super.parseSubscript(p, w, q, ne);
          }
          parseNewCallee(p) {
            var w;
            super.parseNewCallee(p);
            const { callee: q } = p;
            q.type !== "TSInstantiationExpression" || (w = q.extra) != null && w.parenthesized || (p.typeParameters = q.typeParameters, p.callee = q.expression);
          }
          parseExprOp(p, w, q) {
            let ne;
            if (Ae(58) > q && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (ne = this.isContextual(120)))) {
              const pe = this.startNodeAt(w);
              return pe.expression = p, pe.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (ne && this.raise(I.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(pe, ne ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(pe, w, q);
            }
            return super.parseExprOp(p, w, q);
          }
          checkReservedWord(p, w, q, ne) {
            this.state.isAmbientContext || super.checkReservedWord(p, w, q, ne);
          }
          checkImportReflection(p) {
            super.checkImportReflection(p), p.module && p.importKind !== "value" && this.raise(ht.ImportReflectionHasImportType, p.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(p) {
            if (super.isPotentialImportPhase(p)) return !0;
            if (this.isContextual(130)) {
              const w = this.lookaheadCharCode();
              return p ? w === 123 || w === 42 : w !== 61;
            }
            return !p && this.isContextual(87);
          }
          applyImportPhase(p, w, q, ne) {
            super.applyImportPhase(p, w, q, ne), w ? p.exportKind = q === "type" ? "type" : "value" : p.importKind = q === "type" || q === "typeof" ? q : "value";
          }
          parseImport(p) {
            if (this.match(133)) return p.importKind = "value", super.parseImport(p);
            let w;
            if (V(this.state.type) && this.lookaheadCharCode() === 61) return p.importKind = "value", this.tsParseImportEqualsDeclaration(p);
            if (this.isContextual(130)) {
              const q = this.parseMaybeImportPhase(p, !1);
              if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(p, q);
              w = super.parseImportSpecifiersAndAfter(p, q);
            } else w = super.parseImport(p);
            return w.importKind === "type" && w.specifiers.length > 1 && w.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ht.TypeImportCannotSpecifyDefaultAndNamed, w), w;
          }
          parseExport(p, w) {
            if (this.match(83)) {
              this.next();
              const q = p;
              let ne = null;
              return this.isContextual(130) && this.isPotentialImportPhase(!1) ? ne = this.parseMaybeImportPhase(q, !1) : q.importKind = "value", this.tsParseImportEqualsDeclaration(q, ne, !0);
            }
            if (this.eat(29)) {
              const q = p;
              return q.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(q, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const q = p;
              return this.expectContextual(128), q.id = this.parseIdentifier(), this.semicolon(), this.finishNode(q, "TSNamespaceExportDeclaration");
            }
            return super.parseExport(p, w);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const p = this.startNode();
              return this.next(), p.abstract = !0, this.parseClass(p, !0, !0);
            }
            if (this.match(129)) {
              const p = this.tsParseInterfaceDeclaration(this.startNode());
              if (p) return p;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(p, w, q = !1) {
            const { isAmbientContext: ne } = this.state, pe = super.parseVarStatement(p, w, q || ne);
            if (!ne) return pe;
            for (const { id: xe, init: Ce } of pe.declarations) Ce && (w !== "const" || xe.typeAnnotation ? this.raise(ht.InitializerNotAllowedInAmbientContext, Ce) : At(Ce, this.hasPlugin("estree")) || this.raise(ht.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, Ce));
            return pe;
          }
          parseStatementContent(p, w) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const q = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(q, { const: !0 });
            }
            if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              const q = this.tsParseInterfaceDeclaration(this.startNode());
              if (q) return q;
            }
            return super.parseStatementContent(p, w);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(p, w) {
            return w.some((q) => rr(q) ? p.accessibility === q : !!p[q]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(p, w, q) {
            const ne = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: ne, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: ht.InvalidModifierOnTypeParameterPositions }, w);
            const pe = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(w, ne) && this.raise(ht.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(p, w)) : this.parseClassMemberWithIsStatic(p, w, q, !!w.static);
            };
            w.declare ? this.tsInAmbientContext(pe) : pe();
          }
          parseClassMemberWithIsStatic(p, w, q, ne) {
            const pe = this.tsTryParseIndexSignature(w);
            if (pe) return p.body.push(pe), w.abstract && this.raise(ht.IndexSignatureHasAbstract, w), w.accessibility && this.raise(ht.IndexSignatureHasAccessibility, w, { modifier: w.accessibility }), w.declare && this.raise(ht.IndexSignatureHasDeclare, w), void (w.override && this.raise(ht.IndexSignatureHasOverride, w));
            !this.state.inAbstractClass && w.abstract && this.raise(ht.NonAbstractClassHasAbstractMethod, w), w.override && (q.hadSuperClass || this.raise(ht.OverrideNotInSubClass, w)), super.parseClassMemberWithIsStatic(p, w, q, ne);
          }
          parsePostMemberNameModifiers(p) {
            this.eat(17) && (p.optional = !0), p.readonly && this.match(10) && this.raise(ht.ClassMethodHasReadonly, p), p.declare && this.match(10) && this.raise(ht.ClassMethodHasDeclare, p);
          }
          parseExpressionStatement(p, w, q) {
            return (w.type === "Identifier" ? this.tsParseExpressionStatement(p, w, q) : void 0) || super.parseExpressionStatement(p, w, q);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(p, w, q) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(p, w, q);
            const ne = this.tryParse(() => super.parseConditional(p, w));
            return ne.node ? (ne.error && (this.state = ne.failState), ne.node) : (ne.error && super.setOptionalParametersError(q, ne.error), p);
          }
          parseParenItem(p, w) {
            const q = super.parseParenItem(p, w);
            if (this.eat(17) && (q.optional = !0, this.resetEndLocation(p)), this.match(14)) {
              const ne = this.startNodeAt(w);
              return ne.expression = p, ne.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(ne, "TSTypeCastExpression");
            }
            return p;
          }
          parseExportDeclaration(p) {
            if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(p));
            const w = this.state.startLoc, q = this.eatContextual(125);
            if (q && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(ht.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            const ne = V(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(p);
            return ne ? ((ne.type === "TSInterfaceDeclaration" || ne.type === "TSTypeAliasDeclaration" || q) && (p.exportKind = "type"), q && (this.resetStartLocation(ne, w), ne.declare = !0), ne) : null;
          }
          parseClassId(p, w, q, ne) {
            if ((!w || q) && this.isContextual(113)) return;
            super.parseClassId(p, w, q, p.declare ? 1024 : 8331);
            const pe = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            pe && (p.typeParameters = pe);
          }
          parseClassPropertyAnnotation(p) {
            p.optional || (this.eat(35) ? p.definite = !0 : this.eat(17) && (p.optional = !0));
            const w = this.tsTryParseTypeAnnotation();
            w && (p.typeAnnotation = w);
          }
          parseClassProperty(p) {
            if (this.parseClassPropertyAnnotation(p), this.state.isAmbientContext && (!p.readonly || p.typeAnnotation) && this.match(29) && this.raise(ht.DeclareClassFieldHasInitializer, this.state.startLoc), p.abstract && this.match(29)) {
              const { key: w } = p;
              this.raise(ht.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: w.type !== "Identifier" || p.computed ? `[${this.input.slice(w.start, w.end)}]` : w.name });
            }
            return super.parseClassProperty(p);
          }
          parseClassPrivateProperty(p) {
            return p.abstract && this.raise(ht.PrivateElementHasAbstract, p), p.accessibility && this.raise(ht.PrivateElementHasAccessibility, p, { modifier: p.accessibility }), this.parseClassPropertyAnnotation(p), super.parseClassPrivateProperty(p);
          }
          parseClassAccessorProperty(p) {
            return this.parseClassPropertyAnnotation(p), p.optional && this.raise(ht.AccessorCannotBeOptional, p), super.parseClassAccessorProperty(p);
          }
          pushClassMethod(p, w, q, ne, pe, xe) {
            const Ce = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            Ce && pe && this.raise(ht.ConstructorHasTypeParameters, Ce);
            const { declare: Re = !1, kind: Ue } = w;
            !Re || Ue !== "get" && Ue !== "set" || this.raise(ht.DeclareAccessor, w, { kind: Ue }), Ce && (w.typeParameters = Ce), super.pushClassMethod(p, w, q, ne, pe, xe);
          }
          pushClassPrivateMethod(p, w, q, ne) {
            const pe = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            pe && (w.typeParameters = pe), super.pushClassPrivateMethod(p, w, q, ne);
          }
          declareClassPrivateMethodInScope(p, w) {
            p.type !== "TSDeclareMethod" && (p.type !== "MethodDefinition" || hasOwnProperty.call(p.value, "body")) && super.declareClassPrivateMethodInScope(p, w);
          }
          parseClassSuper(p) {
            super.parseClassSuper(p), p.superClass && (this.match(47) || this.match(51)) && (p.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (p.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(p, w, q, ne, pe, xe, Ce) {
            const Re = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return Re && (p.typeParameters = Re), super.parseObjPropValue(p, w, q, ne, pe, xe, Ce);
          }
          parseFunctionParams(p, w) {
            const q = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            q && (p.typeParameters = q), super.parseFunctionParams(p, w);
          }
          parseVarId(p, w) {
            super.parseVarId(p, w), p.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (p.definite = !0);
            const q = this.tsTryParseTypeAnnotation();
            q && (p.id.typeAnnotation = q, this.resetEndLocation(p.id));
          }
          parseAsyncArrowFromCallExpression(p, w) {
            return this.match(14) && (p.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(p, w);
          }
          parseMaybeAssign(p, w) {
            var q, ne, pe, xe, Ce;
            let Re, Ue, Ke, yt;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (Re = this.state.clone(), Ue = this.tryParse(() => super.parseMaybeAssign(p, w), Re), !Ue.error) return Ue.node;
              const { context: wt } = this.state, Ht = wt[wt.length - 1];
              Ht !== _.j_oTag && Ht !== _.j_expr || wt.pop();
            }
            if (!((q = Ue) != null && q.error || this.match(47))) return super.parseMaybeAssign(p, w);
            Re && Re !== this.state || (Re = this.state.clone());
            const $t = this.tryParse((wt) => {
              var Ht, Gr;
              yt = this.tsParseTypeParameters(this.tsParseConstModifier);
              const Vr = super.parseMaybeAssign(p, w);
              return (Vr.type !== "ArrowFunctionExpression" || (Ht = Vr.extra) != null && Ht.parenthesized) && wt(), ((Gr = yt) == null ? void 0 : Gr.params.length) !== 0 && this.resetStartLocationFromNode(Vr, yt), Vr.typeParameters = yt, Vr;
            }, Re);
            if (!$t.error && !$t.aborted) return yt && this.reportReservedArrowTypeParam(yt), $t.node;
            if (!Ue && (Ft(!this.hasPlugin("jsx")), Ke = this.tryParse(() => super.parseMaybeAssign(p, w), Re), !Ke.error)) return Ke.node;
            if ((ne = Ue) != null && ne.node) return this.state = Ue.failState, Ue.node;
            if ($t.node) return this.state = $t.failState, yt && this.reportReservedArrowTypeParam(yt), $t.node;
            if ((pe = Ke) != null && pe.node) return this.state = Ke.failState, Ke.node;
            throw ((xe = Ue) == null ? void 0 : xe.error) || $t.error || ((Ce = Ke) == null ? void 0 : Ce.error);
          }
          reportReservedArrowTypeParam(p) {
            var w;
            p.params.length !== 1 || p.params[0].constraint || (w = p.extra) != null && w.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(ht.ReservedArrowTypeParam, p);
          }
          parseMaybeUnary(p, w) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(p, w);
          }
          parseArrow(p) {
            if (this.match(14)) {
              const w = this.tryParse((q) => {
                const ne = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || q(), ne;
              });
              if (w.aborted) return;
              w.thrown || (w.error && (this.state = w.failState), p.returnType = w.node);
            }
            return super.parseArrow(p);
          }
          parseAssignableListItemTypes(p, w) {
            if (!(2 & w)) return p;
            this.eat(17) && (p.optional = !0);
            const q = this.tsTryParseTypeAnnotation();
            return q && (p.typeAnnotation = q), this.resetEndLocation(p), p;
          }
          isAssignable(p, w) {
            switch (p.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(p.expression, w);
              case "TSParameterProperty":
                return !0;
              default:
                return super.isAssignable(p, w);
            }
          }
          toAssignable(p, w = !1) {
            switch (p.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(p, w);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                w ? this.expressionScope.recordArrowParameterBindingError(ht.UnexpectedTypeCastInParameter, p) : this.raise(ht.UnexpectedTypeCastInParameter, p), this.toAssignable(p.expression, w);
                break;
              case "AssignmentExpression":
                w || p.left.type !== "TSTypeCastExpression" || (p.left = this.typeCastToParameter(p.left));
              default:
                super.toAssignable(p, w);
            }
          }
          toAssignableParenthesizedExpression(p, w) {
            switch (p.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(p.expression, w);
                break;
              default:
                super.toAssignable(p, w);
            }
          }
          checkToRestConversion(p, w) {
            switch (p.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(p.expression, !1);
                break;
              default:
                super.checkToRestConversion(p, w);
            }
          }
          isValidLVal(p, w, q) {
            return ne = { TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSInstantiationExpression: "expression", TSAsExpression: (q !== 64 || !w) && ["expression", !0], TSSatisfiesExpression: (q !== 64 || !w) && ["expression", !0], TSTypeAssertion: (q !== 64 || !w) && ["expression", !0] }, pe = p, hasOwnProperty.call(ne, pe) && ne[pe] || super.isValidLVal(p, w, q);
            var ne, pe;
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(p) {
            if (this.match(47) || this.match(51)) {
              const w = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const q = super.parseMaybeDecoratorArguments(p);
                return q.typeParameters = w, q;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(p);
          }
          checkCommaAfterRest(p) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === p ? (this.next(), !1) : super.checkCommaAfterRest(p);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(p, w) {
            const q = super.parseMaybeDefault(p, w);
            return q.type === "AssignmentPattern" && q.typeAnnotation && q.right.start < q.typeAnnotation.start && this.raise(ht.TypeAnnotationAfterAssign, q.typeAnnotation), q;
          }
          getTokenFromCode(p) {
            if (this.state.inType) {
              if (p === 62) return void this.finishOp(48, 1);
              if (p === 60) return void this.finishOp(47, 1);
            }
            super.getTokenFromCode(p);
          }
          reScan_lt_gt() {
            const { type: p } = this.state;
            p === 47 ? (this.state.pos -= 1, this.readToken_lt()) : p === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type: p } = this.state;
            return p === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : p;
          }
          toAssignableList(p, w, q) {
            for (let ne = 0; ne < p.length; ne++) {
              const pe = p[ne];
              (pe == null ? void 0 : pe.type) === "TSTypeCastExpression" && (p[ne] = this.typeCastToParameter(pe));
            }
            super.toAssignableList(p, w, q);
          }
          typeCastToParameter(p) {
            return p.expression.typeAnnotation = p.typeAnnotation, this.resetEndLocation(p.expression, p.typeAnnotation.loc.end), p.expression;
          }
          shouldParseArrow(p) {
            return this.match(14) ? p.every((w) => this.isAssignable(w, !0)) : super.shouldParseArrow(p);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(p) {
            if (this.match(47) || this.match(51)) {
              const w = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              w && (p.typeParameters = w);
            }
            return super.jsxParseOpeningElementAfterName(p);
          }
          getGetterSetterExpectedParamCount(p) {
            const w = super.getGetterSetterExpectedParamCount(p), q = this.getObjectOrClassMethodParams(p)[0];
            return q && this.isThisParam(q) ? w + 1 : w;
          }
          parseCatchClauseParam() {
            const p = super.parseCatchClauseParam(), w = this.tsTryParseTypeAnnotation();
            return w && (p.typeAnnotation = w, this.resetEndLocation(p)), p;
          }
          tsInAmbientContext(p) {
            const w = this.state.isAmbientContext;
            this.state.isAmbientContext = !0;
            try {
              return p();
            } finally {
              this.state.isAmbientContext = w;
            }
          }
          parseClass(p, w, q) {
            const ne = this.state.inAbstractClass;
            this.state.inAbstractClass = !!p.abstract;
            try {
              return super.parseClass(p, w, q);
            } finally {
              this.state.inAbstractClass = ne;
            }
          }
          tsParseAbstractDeclaration(p, w) {
            if (this.match(80)) return p.abstract = !0, this.maybeTakeDecorators(w, this.parseClass(p, !0, !1));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak()) return p.abstract = !0, this.raise(ht.NonClassMethodPropertyHasAbstractModifer, p), this.tsParseInterfaceDeclaration(p);
            } else this.unexpected(null, 80);
          }
          parseMethod(p, w, q, ne, pe, xe, Ce) {
            const Re = super.parseMethod(p, w, q, ne, pe, xe, Ce);
            if (Re.abstract && (this.hasPlugin("estree") ? Re.value.body : Re.body)) {
              const { key: Ue } = Re;
              this.raise(ht.AbstractMethodHasImplementation, Re, { methodName: Ue.type !== "Identifier" || Re.computed ? `[${this.input.slice(Ue.start, Ue.end)}]` : Ue.name });
            }
            return Re;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
          }
          parseExportSpecifier(p, w, q, ne) {
            return !w && ne ? (this.parseTypeOnlyImportExportSpecifier(p, !1, q), this.finishNode(p, "ExportSpecifier")) : (p.exportKind = "value", super.parseExportSpecifier(p, w, q, ne));
          }
          parseImportSpecifier(p, w, q, ne, pe) {
            return !w && ne ? (this.parseTypeOnlyImportExportSpecifier(p, !0, q), this.finishNode(p, "ImportSpecifier")) : (p.importKind = "value", super.parseImportSpecifier(p, w, q, ne, q ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(p, w, q) {
            const ne = w ? "imported" : "local", pe = w ? "local" : "exported";
            let xe, Ce = p[ne], Re = !1, Ue = !0;
            const Ke = Ce.loc.start;
            if (this.isContextual(93)) {
              const yt = this.parseIdentifier();
              if (this.isContextual(93)) {
                const $t = this.parseIdentifier();
                F(this.state.type) ? (Re = !0, Ce = yt, xe = w ? this.parseIdentifier() : this.parseModuleExportName(), Ue = !1) : (xe = $t, Ue = !1);
              } else F(this.state.type) ? (Ue = !1, xe = w ? this.parseIdentifier() : this.parseModuleExportName()) : (Re = !0, Ce = yt);
            } else F(this.state.type) && (Re = !0, w ? (Ce = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(Ce.name, Ce.loc.start, !0, !0)) : Ce = this.parseModuleExportName());
            Re && q && this.raise(w ? ht.TypeModifierIsUsedInTypeImports : ht.TypeModifierIsUsedInTypeExports, Ke), p[ne] = Ce, p[pe] = xe, p[w ? "importKind" : "exportKind"] = Re ? "type" : "value", Ue && this.eatContextual(93) && (p[pe] = w ? this.parseIdentifier() : this.parseModuleExportName()), p[pe] || (p[pe] = Dr(p[ne])), w && this.checkIdentifier(p[pe], Re ? 4098 : 4096);
          }
        }, v8intrinsic: (Te) => class extends Te {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const p = this.state.startLoc, w = this.startNode();
              if (this.next(), V(this.state.type)) {
                const q = this.parseIdentifierName(), ne = this.createIdentifier(w, q);
                if (ne.type = "V8IntrinsicIdentifier", this.match(10)) return ne;
              }
              this.unexpected(p);
            }
          }
          parseExprAtom(p) {
            return this.parseV8Intrinsic() || super.parseExprAtom(p);
          }
        }, placeholders: (Te) => class extends Te {
          parsePlaceholder(p) {
            if (this.match(144)) {
              const w = this.startNode();
              return this.next(), this.assertNoSpace(), w.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(w, p);
            }
          }
          finishPlaceholder(p, w) {
            let q = p;
            return q.expectedNode && q.type || (q = this.finishNode(q, "Placeholder")), q.expectedNode = w, q;
          }
          getTokenFromCode(p) {
            p === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(p);
          }
          parseExprAtom(p) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(p);
          }
          parseIdentifier(p) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(p);
          }
          checkReservedWord(p, w, q, ne) {
            p !== void 0 && super.checkReservedWord(p, w, q, ne);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(p, w, q) {
            return p === "Placeholder" || super.isValidLVal(p, w, q);
          }
          toAssignable(p, w) {
            p && p.type === "Placeholder" && p.expectedNode === "Expression" ? p.expectedNode = "Pattern" : super.toAssignable(p, w);
          }
          chStartsBindingIdentifier(p, w) {
            return super.chStartsBindingIdentifier(p, w) ? !0 : this.lookahead().type === 144;
          }
          verifyBreakContinue(p, w) {
            p.label && p.label.type === "Placeholder" || super.verifyBreakContinue(p, w);
          }
          parseExpressionStatement(p, w) {
            var q;
            if (w.type !== "Placeholder" || (q = w.extra) != null && q.parenthesized) return super.parseExpressionStatement(p, w);
            if (this.match(14)) {
              const pe = p;
              return pe.label = this.finishPlaceholder(w, "Identifier"), this.next(), pe.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(pe, "LabeledStatement");
            }
            this.semicolon();
            const ne = p;
            return ne.name = w.name, this.finishPlaceholder(ne, "Statement");
          }
          parseBlock(p, w, q) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(p, w, q);
          }
          parseFunctionId(p) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(p);
          }
          parseClass(p, w, q) {
            const ne = w ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const pe = this.state.strict, xe = this.parsePlaceholder("Identifier");
            if (xe) {
              if (!(this.match(81) || this.match(144) || this.match(5))) {
                if (q || !w) return p.id = null, p.body = this.finishPlaceholder(xe, "ClassBody"), this.finishNode(p, ne);
                throw this.raise(Sn.ClassNameIsRequired, this.state.startLoc);
              }
              p.id = xe;
            } else this.parseClassId(p, w, q);
            return super.parseClassSuper(p), p.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!p.superClass, pe), this.finishNode(p, ne);
          }
          parseExport(p, w) {
            const q = this.parsePlaceholder("Identifier");
            if (!q) return super.parseExport(p, w);
            const ne = p;
            if (!this.isContextual(98) && !this.match(12)) return ne.specifiers = [], ne.source = null, ne.declaration = this.finishPlaceholder(q, "Declaration"), this.finishNode(ne, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const pe = this.startNode();
            return pe.exported = q, ne.specifiers = [this.finishNode(pe, "ExportDefaultSpecifier")], super.parseExport(ne, w);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const p = this.nextTokenStart();
              if (this.isUnparsedContextual(p, "from") && this.input.startsWith(_e(144), this.nextTokenStartSince(p + 4))) return !0;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(p, w) {
            var q;
            return !((q = p.specifiers) == null || !q.length) || super.maybeParseExportDefaultSpecifier(p, w);
          }
          checkExport(p) {
            const { specifiers: w } = p;
            w != null && w.length && (p.specifiers = w.filter((q) => q.exported.type === "Placeholder")), super.checkExport(p), p.specifiers = w;
          }
          parseImport(p) {
            const w = this.parsePlaceholder("Identifier");
            if (!w) return super.parseImport(p);
            if (p.specifiers = [], !this.isContextual(98) && !this.match(12)) return p.source = this.finishPlaceholder(w, "StringLiteral"), this.semicolon(), this.finishNode(p, "ImportDeclaration");
            const q = this.startNodeAtNode(w);
            return q.local = w, p.specifiers.push(this.finishNode(q, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(p) || this.parseNamedImportSpecifiers(p)), this.expectContextual(98), p.source = this.parseImportSource(), this.semicolon(), this.finishNode(p, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(Sn.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        } }, Lt = Object.keys(So), ii = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
        class Ci extends Xt {
          checkProto(p, w, q, ne) {
            if (p.type === "SpreadElement" || this.isObjectMethod(p) || p.computed || p.shorthand) return;
            const pe = p.key;
            if ((pe.type === "Identifier" ? pe.name : pe.value) === "__proto__") {
              if (w) return void this.raise(I.RecordNoProto, pe);
              q.used && (ne ? ne.doubleProtoLoc === null && (ne.doubleProtoLoc = pe.loc.start) : this.raise(I.DuplicateProto, pe)), q.used = !0;
            }
          }
          shouldExitDescending(p, w) {
            return p.type === "ArrowFunctionExpression" && p.start === w;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const p = this.parseExpression();
            return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), p.comments = this.comments, p.errors = this.state.errors, this.options.tokens && (p.tokens = this.tokens), p;
          }
          parseExpression(p, w) {
            return p ? this.disallowInAnd(() => this.parseExpressionBase(w)) : this.allowInAnd(() => this.parseExpressionBase(w));
          }
          parseExpressionBase(p) {
            const w = this.state.startLoc, q = this.parseMaybeAssign(p);
            if (this.match(12)) {
              const ne = this.startNodeAt(w);
              for (ne.expressions = [q]; this.eat(12); ) ne.expressions.push(this.parseMaybeAssign(p));
              return this.toReferencedList(ne.expressions), this.finishNode(ne, "SequenceExpression");
            }
            return q;
          }
          parseMaybeAssignDisallowIn(p, w) {
            return this.disallowInAnd(() => this.parseMaybeAssign(p, w));
          }
          parseMaybeAssignAllowIn(p, w) {
            return this.allowInAnd(() => this.parseMaybeAssign(p, w));
          }
          setOptionalParametersError(p, w) {
            var q;
            p.optionalParametersLoc = (q = w == null ? void 0 : w.loc) != null ? q : this.state.startLoc;
          }
          parseMaybeAssign(p, w) {
            const q = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
              let Re = this.parseYield();
              return w && (Re = w.call(this, Re, q)), Re;
            }
            let ne;
            p ? ne = !1 : (p = new _n(), ne = !0);
            const { type: pe } = this.state;
            (pe === 10 || V(pe)) && (this.state.potentialArrowAt = this.state.start);
            let xe = this.parseMaybeConditional(p);
            if (w && (xe = w.call(this, xe, q)), (Ce = this.state.type) >= 29 && Ce <= 33) {
              const Re = this.startNodeAt(q), Ue = this.state.value;
              if (Re.operator = Ue, this.match(29)) {
                this.toAssignable(xe, !0), Re.left = xe;
                const Ke = q.index;
                p.doubleProtoLoc != null && p.doubleProtoLoc.index >= Ke && (p.doubleProtoLoc = null), p.shorthandAssignLoc != null && p.shorthandAssignLoc.index >= Ke && (p.shorthandAssignLoc = null), p.privateKeyLoc != null && p.privateKeyLoc.index >= Ke && (this.checkDestructuringPrivate(p), p.privateKeyLoc = null);
              } else Re.left = xe;
              return this.next(), Re.right = this.parseMaybeAssign(), this.checkLVal(xe, { in: this.finishNode(Re, "AssignmentExpression") }), Re;
            }
            var Ce;
            return ne && this.checkExpressionErrors(p, !0), xe;
          }
          parseMaybeConditional(p) {
            const w = this.state.startLoc, q = this.state.potentialArrowAt, ne = this.parseExprOps(p);
            return this.shouldExitDescending(ne, q) ? ne : this.parseConditional(ne, w, p);
          }
          parseConditional(p, w, q) {
            if (this.eat(17)) {
              const ne = this.startNodeAt(w);
              return ne.test = p, ne.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), ne.alternate = this.parseMaybeAssign(), this.finishNode(ne, "ConditionalExpression");
            }
            return p;
          }
          parseMaybeUnaryOrPrivate(p) {
            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(p);
          }
          parseExprOps(p) {
            const w = this.state.startLoc, q = this.state.potentialArrowAt, ne = this.parseMaybeUnaryOrPrivate(p);
            return this.shouldExitDescending(ne, q) ? ne : this.parseExprOp(ne, w, -1);
          }
          parseExprOp(p, w, q) {
            if (this.isPrivateName(p)) {
              const xe = this.getPrivateNameSV(p);
              (q >= Ae(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(I.PrivateInExpectedIn, p, { identifierName: xe }), this.classScope.usePrivateName(xe, p.loc.start);
            }
            const ne = this.state.type;
            if ((pe = ne) >= 39 && pe <= 59 && (this.prodParam.hasIn || !this.match(58))) {
              let xe = Ae(ne);
              if (xe > q) {
                if (ne === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return p;
                  this.checkPipelineAtInfixOperator(p, w);
                }
                const Ce = this.startNodeAt(w);
                Ce.left = p, Ce.operator = this.state.value;
                const Re = ne === 41 || ne === 42, Ue = ne === 40;
                if (Ue && (xe = Ae(42)), this.next(), ne === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(I.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                Ce.right = this.parseExprOpRightExpr(ne, xe);
                const Ke = this.finishNode(Ce, Re || Ue ? "LogicalExpression" : "BinaryExpression"), yt = this.state.type;
                if (Ue && (yt === 41 || yt === 42) || Re && yt === 40) throw this.raise(I.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(Ke, w, q);
              }
            }
            var pe;
            return p;
          }
          parseExprOpRightExpr(p, w) {
            const q = this.state.startLoc;
            if (p === 39) switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => this.parseHackPipeBody());
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(I.PipeBodyIsTighter, this.state.startLoc);
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(p, w), q);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(w));
            }
            return this.parseExprOpBaseRightExpr(p, w);
          }
          parseExprOpBaseRightExpr(p, w) {
            const q = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), q, p === 57 ? w - 1 : w);
          }
          parseHackPipeBody() {
            var p;
            const { startLoc: w } = this.state, q = this.parseMaybeAssign();
            return !b.has(q.type) || (p = q.extra) != null && p.parenthesized || this.raise(I.PipeUnparenthesizedBody, w, { type: q.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(I.PipeTopicUnused, w), q;
          }
          checkExponentialAfterUnary(p) {
            this.match(57) && this.raise(I.UnexpectedTokenUnaryExponentiation, p.argument);
          }
          parseMaybeUnary(p, w) {
            const q = this.state.startLoc, ne = this.isContextual(96);
            if (ne && this.isAwaitAllowed()) {
              this.next();
              const Ue = this.parseAwait(q);
              return w || this.checkExponentialAfterUnary(Ue), Ue;
            }
            const pe = this.match(34), xe = this.startNode();
            if (Ce = this.state.type, J[Ce]) {
              xe.operator = this.state.value, xe.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
              const Ue = this.match(89);
              if (this.next(), xe.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(p, !0), this.state.strict && Ue) {
                const Ke = xe.argument;
                Ke.type === "Identifier" ? this.raise(I.StrictDelete, xe) : this.hasPropertyAsPrivateName(Ke) && this.raise(I.DeletePrivateField, xe);
              }
              if (!pe) return w || this.checkExponentialAfterUnary(xe), this.finishNode(xe, "UnaryExpression");
            }
            var Ce;
            const Re = this.parseUpdate(xe, pe, p);
            if (ne) {
              const { type: Ue } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? K(Ue) : K(Ue) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(I.AwaitNotInAsyncContext, q), this.parseAwait(q);
            }
            return Re;
          }
          parseUpdate(p, w, q) {
            if (w) {
              const xe = p;
              return this.checkLVal(xe.argument, { in: this.finishNode(xe, "UpdateExpression") }), p;
            }
            const ne = this.state.startLoc;
            let pe = this.parseExprSubscripts(q);
            if (this.checkExpressionErrors(q, !1)) return pe;
            for (; this.state.type === 34 && !this.canInsertSemicolon(); ) {
              const xe = this.startNodeAt(ne);
              xe.operator = this.state.value, xe.prefix = !1, xe.argument = pe, this.next(), this.checkLVal(pe, { in: pe = this.finishNode(xe, "UpdateExpression") });
            }
            return pe;
          }
          parseExprSubscripts(p) {
            const w = this.state.startLoc, q = this.state.potentialArrowAt, ne = this.parseExprAtom(p);
            return this.shouldExitDescending(ne, q) ? ne : this.parseSubscripts(ne, w);
          }
          parseSubscripts(p, w, q) {
            const ne = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(p), stop: !1 };
            do
              p = this.parseSubscript(p, w, q, ne), ne.maybeAsyncArrow = !1;
            while (!ne.stop);
            return p;
          }
          parseSubscript(p, w, q, ne) {
            const { type: pe } = this.state;
            if (!q && pe === 15) return this.parseBind(p, w, q, ne);
            if (ce(pe)) return this.parseTaggedTemplateExpression(p, w, ne);
            let xe = !1;
            if (pe === 18) {
              if (q && (this.raise(I.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return ne.stop = !0, p;
              ne.optionalChainMember = xe = !0, this.next();
            }
            if (!q && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(p, w, ne, xe);
            {
              const Ce = this.eat(0);
              return Ce || xe || this.eat(16) ? this.parseMember(p, w, ne, Ce, xe) : (ne.stop = !0, p);
            }
          }
          parseMember(p, w, q, ne, pe) {
            const xe = this.startNodeAt(w);
            return xe.object = p, xe.computed = ne, ne ? (xe.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (p.type === "Super" && this.raise(I.SuperPrivateField, w), this.classScope.usePrivateName(this.state.value, this.state.startLoc), xe.property = this.parsePrivateName()) : xe.property = this.parseIdentifier(!0), q.optionalChainMember ? (xe.optional = pe, this.finishNode(xe, "OptionalMemberExpression")) : this.finishNode(xe, "MemberExpression");
          }
          parseBind(p, w, q, ne) {
            const pe = this.startNodeAt(w);
            return pe.object = p, this.next(), pe.callee = this.parseNoCallExpr(), ne.stop = !0, this.parseSubscripts(this.finishNode(pe, "BindExpression"), w, q);
          }
          parseCoverCallAndAsyncArrowHead(p, w, q, ne) {
            const pe = this.state.maybeInArrowParameters;
            let xe = null;
            this.state.maybeInArrowParameters = !0, this.next();
            const Ce = this.startNodeAt(w);
            Ce.callee = p;
            const { maybeAsyncArrow: Re, optionalChainMember: Ue } = q;
            Re && (this.expressionScope.enter(new dn(2)), xe = new _n()), Ue && (Ce.optional = ne), Ce.arguments = ne ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, p.type === "Import", p.type !== "Super", Ce, xe);
            let Ke = this.finishCallExpression(Ce, Ue);
            return Re && this.shouldParseAsyncArrow() && !ne ? (q.stop = !0, this.checkDestructuringPrivate(xe), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), Ke = this.parseAsyncArrowFromCallExpression(this.startNodeAt(w), Ke)) : (Re && (this.checkExpressionErrors(xe, !0), this.expressionScope.exit()), this.toReferencedArguments(Ke)), this.state.maybeInArrowParameters = pe, Ke;
          }
          toReferencedArguments(p, w) {
            this.toReferencedListDeep(p.arguments, w);
          }
          parseTaggedTemplateExpression(p, w, q) {
            const ne = this.startNodeAt(w);
            return ne.tag = p, ne.quasi = this.parseTemplate(!0), q.optionalChainMember && this.raise(I.OptionalChainingNoTemplate, w), this.finishNode(ne, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(p) {
            return p.type === "Identifier" && p.name === "async" && this.state.lastTokEndLoc.index === p.end && !this.canInsertSemicolon() && p.end - p.start == 5 && p.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(p, w) {
            if (p.callee.type === "Import") if (p.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), p.arguments.length === 0 || p.arguments.length > 2) this.raise(I.ImportCallArity, p, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
            else for (const q of p.arguments) q.type === "SpreadElement" && this.raise(I.ImportCallSpreadArgument, q);
            return this.finishNode(p, w ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(p, w, q, ne, pe) {
            const xe = [];
            let Ce = !0;
            const Re = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(p); ) {
              if (Ce) Ce = !1;
              else if (this.expect(12), this.match(p)) {
                !w || this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(I.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), ne && this.addTrailingCommaExtraToNode(ne), this.next();
                break;
              }
              xe.push(this.parseExprListItem(!1, pe, q));
            }
            return this.state.inFSharpPipelineDirectBody = Re, xe;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(p, w) {
            var q;
            return this.resetPreviousNodeTrailingComments(w), this.expect(19), this.parseArrowExpression(p, w.arguments, !0, (q = w.extra) == null ? void 0 : q.trailingCommaLoc), w.innerComments && Me(p, w.innerComments), w.callee.trailingComments && Me(p, w.callee.trailingComments), p;
          }
          parseNoCallExpr() {
            const p = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), p, !0);
          }
          parseExprAtom(p) {
            let w, q = null;
            const { type: ne } = this.state;
            switch (ne) {
              case 79:
                return this.parseSuper();
              case 83:
                return w = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(w) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(w) : this.finishNode(w, "Import") : (this.raise(I.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(w, "Import"));
              case 78:
                return w = this.startNode(), this.next(), this.finishNode(w, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), !1);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 134:
                return this.parseNumericLiteral(this.state.value);
              case 135:
                return this.parseBigIntLiteral(this.state.value);
              case 136:
                return this.parseDecimalLiteral(this.state.value);
              case 133:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(!0);
              case 86:
                return this.parseBooleanLiteral(!1);
              case 10: {
                const pe = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(pe);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
              case 0:
                return this.parseArrayLike(3, !0, !1, p);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
              case 5:
                return this.parseObjectLike(8, !1, !1, p);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                q = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(q, this.startNode()), !1);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(!1);
              case 15: {
                w = this.startNode(), this.next(), w.object = null;
                const pe = w.callee = this.parseNoCallExpr();
                if (pe.type === "MemberExpression") return this.finishNode(w, "BindExpression");
                throw this.raise(I.UnsupportedBind, pe);
              }
              case 138:
                return this.raise(I.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                const pe = this.getPluginOption("pipelineOperator", "proposal");
                if (pe) return this.parseTopicReference(pe);
                this.unexpected();
                break;
              }
              case 47: {
                const pe = this.input.codePointAt(this.nextTokenStart());
                be(pe) || pe === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (V(ne)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
                  const pe = this.state.potentialArrowAt === this.state.start, xe = this.state.containsEsc, Ce = this.parseIdentifier();
                  if (!xe && Ce.name === "async" && !this.canInsertSemicolon()) {
                    const { type: Re } = this.state;
                    if (Re === 68) return this.resetPreviousNodeTrailingComments(Ce), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(Ce));
                    if (V(Re)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(Ce)) : Ce;
                    if (Re === 90) return this.resetPreviousNodeTrailingComments(Ce), this.parseDo(this.startNodeAtNode(Ce), !0);
                  }
                  return pe && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(Ce), [Ce], !1)) : Ce;
                }
                this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(p, w) {
            const q = this.getPluginOption("pipelineOperator", "proposal");
            if (q) return this.state.type = p, this.state.value = w, this.state.pos--, this.state.end--, this.state.endLoc = f(this.state.endLoc, -1), this.parseTopicReference(q);
            this.unexpected();
          }
          parseTopicReference(p) {
            const w = this.startNode(), q = this.state.startLoc, ne = this.state.type;
            return this.next(), this.finishTopicReference(w, q, p, ne);
          }
          finishTopicReference(p, w, q, ne) {
            if (this.testTopicReferenceConfiguration(q, w, ne)) {
              const pe = q === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(q === "smart" ? I.PrimaryTopicNotAllowed : I.PipeTopicUnbound, w), this.registerTopicReference(), this.finishNode(p, pe);
            }
            throw this.raise(I.PipeTopicUnconfiguredToken, w, { token: _e(ne) });
          }
          testTopicReferenceConfiguration(p, w, q) {
            switch (p) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: _e(q) }]);
              case "smart":
                return q === 27;
              default:
                throw this.raise(I.PipeTopicRequiresHackPipes, w);
            }
          }
          parseAsyncArrowUnaryFunction(p) {
            this.prodParam.enter(Cr(!0, this.prodParam.hasYield));
            const w = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(I.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(p, w, !0);
          }
          parseDo(p, w) {
            this.expectPlugin("doExpressions"), w && this.expectPlugin("asyncDoExpressions"), p.async = w, this.next();
            const q = this.state.labels;
            return this.state.labels = [], w ? (this.prodParam.enter(2), p.body = this.parseBlock(), this.prodParam.exit()) : p.body = this.parseBlock(), this.state.labels = q, this.finishNode(p, "DoExpression");
          }
          parseSuper() {
            const p = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(I.UnexpectedSuper, p) : this.raise(I.SuperNotAllowed, p), this.match(10) || this.match(0) || this.match(16) || this.raise(I.UnsupportedSuper, p), this.finishNode(p, "Super");
          }
          parsePrivateName() {
            const p = this.startNode(), w = this.startNodeAt(f(this.state.startLoc, 1)), q = this.state.value;
            return this.next(), p.id = this.createIdentifier(w, q), this.finishNode(p, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const p = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const w = this.createIdentifier(this.startNodeAtNode(p), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(p, w, "sent");
            }
            return this.parseFunction(p);
          }
          parseMetaProperty(p, w, q) {
            p.meta = w;
            const ne = this.state.containsEsc;
            return p.property = this.parseIdentifier(!0), (p.property.name !== q || ne) && this.raise(I.UnsupportedMetaProperty, p.property, { target: w.name, onlyValidPropertyName: q }), this.finishNode(p, "MetaProperty");
          }
          parseImportMetaProperty(p) {
            const w = this.createIdentifier(this.startNodeAtNode(p), "import");
            if (this.next(), this.isContextual(101)) this.inModule || this.raise(I.ImportMetaOutsideModule, w), this.sawUnambiguousESM = !0;
            else if (this.isContextual(105) || this.isContextual(97)) {
              const q = this.isContextual(105);
              if (q || this.unexpected(), this.expectPlugin(q ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(I.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
              return this.next(), p.phase = q ? "source" : "defer", this.parseImportCall(p);
            }
            return this.parseMetaProperty(p, w, "meta");
          }
          parseLiteralAtNode(p, w, q) {
            return this.addExtra(q, "rawValue", p), this.addExtra(q, "raw", this.input.slice(q.start, this.state.end)), q.value = p, this.next(), this.finishNode(q, w);
          }
          parseLiteral(p, w) {
            const q = this.startNode();
            return this.parseLiteralAtNode(p, w, q);
          }
          parseStringLiteral(p) {
            return this.parseLiteral(p, "StringLiteral");
          }
          parseNumericLiteral(p) {
            return this.parseLiteral(p, "NumericLiteral");
          }
          parseBigIntLiteral(p) {
            return this.parseLiteral(p, "BigIntLiteral");
          }
          parseDecimalLiteral(p) {
            return this.parseLiteral(p, "DecimalLiteral");
          }
          parseRegExpLiteral(p) {
            const w = this.parseLiteral(p.value, "RegExpLiteral");
            return w.pattern = p.pattern, w.flags = p.flags, w;
          }
          parseBooleanLiteral(p) {
            const w = this.startNode();
            return w.value = p, this.next(), this.finishNode(w, "BooleanLiteral");
          }
          parseNullLiteral() {
            const p = this.startNode();
            return this.next(), this.finishNode(p, "NullLiteral");
          }
          parseParenAndDistinguishExpression(p) {
            const w = this.state.startLoc;
            let q;
            this.next(), this.expressionScope.enter(new dn(1));
            const ne = this.state.maybeInArrowParameters, pe = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
            const xe = this.state.startLoc, Ce = [], Re = new _n();
            let Ue, Ke, yt = !0;
            for (; !this.match(11); ) {
              if (yt) yt = !1;
              else if (this.expect(12, Re.optionalParametersLoc === null ? null : Re.optionalParametersLoc), this.match(11)) {
                Ke = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const Ht = this.state.startLoc;
                if (Ue = this.state.startLoc, Ce.push(this.parseParenItem(this.parseRestBinding(), Ht)), !this.checkCommaAfterRest(41)) break;
              } else Ce.push(this.parseMaybeAssignAllowIn(Re, this.parseParenItem));
            }
            const $t = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = ne, this.state.inFSharpPipelineDirectBody = pe;
            let wt = this.startNodeAt(w);
            return p && this.shouldParseArrow(Ce) && (wt = this.parseArrow(wt)) ? (this.checkDestructuringPrivate(Re), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(wt, Ce, !1), wt) : (this.expressionScope.exit(), Ce.length || this.unexpected(this.state.lastTokStartLoc), Ke && this.unexpected(Ke), Ue && this.unexpected(Ue), this.checkExpressionErrors(Re, !0), this.toReferencedListDeep(Ce, !0), Ce.length > 1 ? (q = this.startNodeAt(xe), q.expressions = Ce, this.finishNode(q, "SequenceExpression"), this.resetEndLocation(q, $t)) : q = Ce[0], this.wrapParenthesis(w, q));
          }
          wrapParenthesis(p, w) {
            if (!this.options.createParenthesizedExpressions) return this.addExtra(w, "parenthesized", !0), this.addExtra(w, "parenStart", p.index), this.takeSurroundingComments(w, p.index, this.state.lastTokEndLoc.index), w;
            const q = this.startNodeAt(p);
            return q.expression = w, this.finishNode(q, "ParenthesizedExpression");
          }
          shouldParseArrow(p) {
            return !this.canInsertSemicolon();
          }
          parseArrow(p) {
            if (this.eat(19)) return p;
          }
          parseParenItem(p, w) {
            return p;
          }
          parseNewOrNewTarget() {
            const p = this.startNode();
            if (this.next(), this.match(16)) {
              const w = this.createIdentifier(this.startNodeAtNode(p), "new");
              this.next();
              const q = this.parseMetaProperty(p, w, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(I.UnexpectedNewTarget, q), q;
            }
            return this.parseNew(p);
          }
          parseNew(p) {
            if (this.parseNewCallee(p), this.eat(10)) {
              const w = this.parseExprList(11);
              this.toReferencedList(w), p.arguments = w;
            } else p.arguments = [];
            return this.finishNode(p, "NewExpression");
          }
          parseNewCallee(p) {
            const w = this.match(83), q = this.parseNoCallExpr();
            p.callee = q, !w || q.type !== "Import" && q.type !== "ImportExpression" || this.raise(I.ImportCallNotNewExpression, q);
          }
          parseTemplateElement(p) {
            const { start: w, startLoc: q, end: ne, value: pe } = this.state, xe = w + 1, Ce = this.startNodeAt(f(q, 1));
            pe === null && (p || this.raise(I.InvalidEscapeSequenceTemplate, f(this.state.firstInvalidTemplateEscapePos, 1)));
            const Re = this.match(24), Ue = Re ? -1 : -2, Ke = ne + Ue;
            Ce.value = { raw: this.input.slice(xe, Ke).replace(/\r\n?/g, `
`), cooked: pe === null ? null : pe.slice(1, Ue) }, Ce.tail = Re, this.next();
            const yt = this.finishNode(Ce, "TemplateElement");
            return this.resetEndLocation(yt, f(this.state.lastTokEndLoc, Ue)), yt;
          }
          parseTemplate(p) {
            const w = this.startNode();
            let q = this.parseTemplateElement(p);
            const ne = [q], pe = [];
            for (; !q.tail; ) pe.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), ne.push(q = this.parseTemplateElement(p));
            return w.expressions = pe, w.quasis = ne, this.finishNode(w, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(p, w, q, ne) {
            q && this.expectPlugin("recordAndTuple");
            const pe = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const xe = /* @__PURE__ */ Object.create(null);
            let Ce = !0;
            const Re = this.startNode();
            for (Re.properties = [], this.next(); !this.match(p); ) {
              if (Ce) Ce = !1;
              else if (this.expect(12), this.match(p)) {
                this.addTrailingCommaExtraToNode(Re);
                break;
              }
              let Ke;
              w ? Ke = this.parseBindingProperty() : (Ke = this.parsePropertyDefinition(ne), this.checkProto(Ke, q, xe, ne)), q && !this.isObjectProperty(Ke) && Ke.type !== "SpreadElement" && this.raise(I.InvalidRecordProperty, Ke), Ke.shorthand && this.addExtra(Ke, "shorthand", !0), Re.properties.push(Ke);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = pe;
            let Ue = "ObjectExpression";
            return w ? Ue = "ObjectPattern" : q && (Ue = "RecordExpression"), this.finishNode(Re, Ue);
          }
          addTrailingCommaExtraToNode(p) {
            this.addExtra(p, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(p, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
          }
          maybeAsyncOrAccessorProp(p) {
            return !p.computed && p.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(p) {
            let w = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(I.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) w.push(this.parseDecorator());
            const q = this.startNode();
            let ne, pe = !1, xe = !1;
            if (this.match(21)) return w.length && this.unexpected(), this.parseSpread();
            w.length && (q.decorators = w, w = []), q.method = !1, p && (ne = this.state.startLoc);
            let Ce = this.eat(55);
            this.parsePropertyNamePrefixOperator(q);
            const Re = this.state.containsEsc;
            if (this.parsePropertyName(q, p), !Ce && !Re && this.maybeAsyncOrAccessorProp(q)) {
              const { key: Ue } = q, Ke = Ue.name;
              Ke !== "async" || this.hasPrecedingLineBreak() || (pe = !0, this.resetPreviousNodeTrailingComments(Ue), Ce = this.eat(55), this.parsePropertyName(q)), Ke !== "get" && Ke !== "set" || (xe = !0, this.resetPreviousNodeTrailingComments(Ue), q.kind = Ke, this.match(55) && (Ce = !0, this.raise(I.AccessorIsGenerator, this.state.curPosition(), { kind: Ke }), this.next()), this.parsePropertyName(q));
            }
            return this.parseObjPropValue(q, ne, Ce, pe, !1, xe, p);
          }
          getGetterSetterExpectedParamCount(p) {
            return p.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(p) {
            return p.params;
          }
          checkGetterSetterParams(p) {
            var w;
            const q = this.getGetterSetterExpectedParamCount(p), ne = this.getObjectOrClassMethodParams(p);
            ne.length !== q && this.raise(p.kind === "get" ? I.BadGetterArity : I.BadSetterArity, p), p.kind === "set" && ((w = ne[ne.length - 1]) == null ? void 0 : w.type) === "RestElement" && this.raise(I.BadSetterRestParameter, p);
          }
          parseObjectMethod(p, w, q, ne, pe) {
            if (pe) {
              const xe = this.parseMethod(p, w, !1, !1, !1, "ObjectMethod");
              return this.checkGetterSetterParams(xe), xe;
            }
            if (q || w || this.match(10)) return ne && this.unexpected(), p.kind = "method", p.method = !0, this.parseMethod(p, w, q, !1, !1, "ObjectMethod");
          }
          parseObjectProperty(p, w, q, ne) {
            if (p.shorthand = !1, this.eat(14)) return p.value = q ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(ne), this.finishNode(p, "ObjectProperty");
            if (!p.computed && p.key.type === "Identifier") {
              if (this.checkReservedWord(p.key.name, p.key.loc.start, !0, !1), q) p.value = this.parseMaybeDefault(w, Dr(p.key));
              else if (this.match(29)) {
                const pe = this.state.startLoc;
                ne != null ? ne.shorthandAssignLoc === null && (ne.shorthandAssignLoc = pe) : this.raise(I.InvalidCoverInitializedName, pe), p.value = this.parseMaybeDefault(w, Dr(p.key));
              } else p.value = Dr(p.key);
              return p.shorthand = !0, this.finishNode(p, "ObjectProperty");
            }
          }
          parseObjPropValue(p, w, q, ne, pe, xe, Ce) {
            const Re = this.parseObjectMethod(p, q, ne, pe, xe) || this.parseObjectProperty(p, w, pe, Ce);
            return Re || this.unexpected(), Re;
          }
          parsePropertyName(p, w) {
            if (this.eat(0)) p.computed = !0, p.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type: q, value: ne } = this.state;
              let pe;
              if (F(q)) pe = this.parseIdentifier(!0);
              else switch (q) {
                case 134:
                  pe = this.parseNumericLiteral(ne);
                  break;
                case 133:
                  pe = this.parseStringLiteral(ne);
                  break;
                case 135:
                  pe = this.parseBigIntLiteral(ne);
                  break;
                case 136:
                  pe = this.parseDecimalLiteral(ne);
                  break;
                case 138: {
                  const xe = this.state.startLoc;
                  w != null ? w.privateKeyLoc === null && (w.privateKeyLoc = xe) : this.raise(I.UnexpectedPrivateField, xe), pe = this.parsePrivateName();
                  break;
                }
                default:
                  this.unexpected();
              }
              p.key = pe, q !== 138 && (p.computed = !1);
            }
          }
          initFunction(p, w) {
            p.id = null, p.generator = !1, p.async = w;
          }
          parseMethod(p, w, q, ne, pe, xe, Ce = !1) {
            this.initFunction(p, q), p.generator = w, this.scope.enter(18 | (Ce ? 64 : 0) | (pe ? 32 : 0)), this.prodParam.enter(Cr(q, p.generator)), this.parseFunctionParams(p, ne);
            const Re = this.parseFunctionBodyAndFinish(p, xe, !0);
            return this.prodParam.exit(), this.scope.exit(), Re;
          }
          parseArrayLike(p, w, q, ne) {
            q && this.expectPlugin("recordAndTuple");
            const pe = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            const xe = this.startNode();
            return this.next(), xe.elements = this.parseExprList(p, !q, ne, xe), this.state.inFSharpPipelineDirectBody = pe, this.finishNode(xe, q ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(p, w, q, ne) {
            this.scope.enter(6);
            let pe = Cr(q, !1);
            !this.match(5) && this.prodParam.hasIn && (pe |= 8), this.prodParam.enter(pe), this.initFunction(p, q);
            const xe = this.state.maybeInArrowParameters;
            return w && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(p, w, ne)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(p, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = xe, this.finishNode(p, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(p, w, q) {
            this.toAssignableList(w, q, !1), p.params = w;
          }
          parseFunctionBodyAndFinish(p, w, q = !1) {
            return this.parseFunctionBody(p, !1, q), this.finishNode(p, w);
          }
          parseFunctionBody(p, w, q = !1) {
            const ne = w && !this.match(5);
            if (this.expressionScope.enter(vr()), ne) p.body = this.parseMaybeAssign(), this.checkParams(p, !1, w, !1);
            else {
              const pe = this.state.strict, xe = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), p.body = this.parseBlock(!0, !1, (Ce) => {
                const Re = !this.isSimpleParamList(p.params);
                Ce && Re && this.raise(I.IllegalLanguageModeDirective, p.kind !== "method" && p.kind !== "constructor" || !p.key ? p : p.key.loc.end);
                const Ue = !pe && this.state.strict;
                this.checkParams(p, !(this.state.strict || w || q || Re), w, Ue), this.state.strict && p.id && this.checkIdentifier(p.id, 65, Ue);
              }), this.prodParam.exit(), this.state.labels = xe;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(p) {
            return p.type === "Identifier";
          }
          isSimpleParamList(p) {
            for (let w = 0, q = p.length; w < q; w++) if (!this.isSimpleParameter(p[w])) return !1;
            return !0;
          }
          checkParams(p, w, q, ne = !0) {
            const pe = !w && /* @__PURE__ */ new Set(), xe = { type: "FormalParameters" };
            for (const Ce of p.params) this.checkLVal(Ce, { in: xe, binding: 5, checkClashes: pe, strictModeChanged: ne });
          }
          parseExprList(p, w, q, ne) {
            const pe = [];
            let xe = !0;
            for (; !this.eat(p); ) {
              if (xe) xe = !1;
              else if (this.expect(12), this.match(p)) {
                ne && this.addTrailingCommaExtraToNode(ne), this.next();
                break;
              }
              pe.push(this.parseExprListItem(w, q));
            }
            return pe;
          }
          parseExprListItem(p, w, q) {
            let ne;
            if (this.match(12)) p || this.raise(I.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), ne = null;
            else if (this.match(21)) {
              const pe = this.state.startLoc;
              ne = this.parseParenItem(this.parseSpread(w), pe);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), q || this.raise(I.UnexpectedArgumentPlaceholder, this.state.startLoc);
              const pe = this.startNode();
              this.next(), ne = this.finishNode(pe, "ArgumentPlaceholder");
            } else ne = this.parseMaybeAssignAllowIn(w, this.parseParenItem);
            return ne;
          }
          parseIdentifier(p) {
            const w = this.startNode(), q = this.parseIdentifierName(p);
            return this.createIdentifier(w, q);
          }
          createIdentifier(p, w) {
            return p.name = w, p.loc.identifierName = w, this.finishNode(p, "Identifier");
          }
          parseIdentifierName(p) {
            let w;
            const { startLoc: q, type: ne } = this.state;
            F(ne) ? w = this.state.value : this.unexpected();
            const pe = ne <= 92;
            return p ? pe && this.replaceToken(132) : this.checkReservedWord(w, q, pe, !1), this.next(), w;
          }
          checkReservedWord(p, w, q, ne) {
            if (!(p.length > 10) && function(pe) {
              return Pe.has(pe);
            }(p)) {
              if (q && function(pe) {
                return Fe.has(pe);
              }(p)) return void this.raise(I.UnexpectedKeyword, w, { keyword: p });
              if ((this.state.strict ? ne ? Se : le : Y)(p, this.inModule)) this.raise(I.UnexpectedReservedWord, w, { reservedWord: p });
              else if (p === "yield") {
                if (this.prodParam.hasYield) return void this.raise(I.YieldBindingIdentifier, w);
              } else if (p === "await") {
                if (this.prodParam.hasAwait) return void this.raise(I.AwaitBindingIdentifier, w);
                if (this.scope.inStaticBlock) return void this.raise(I.AwaitBindingIdentifierInStaticBlock, w);
                this.expressionScope.recordAsyncArrowParametersError(w);
              } else if (p === "arguments" && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(I.ArgumentsInClass, w);
            }
          }
          isAwaitAllowed() {
            return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
          }
          parseAwait(p) {
            const w = this.startNodeAt(p);
            return this.expressionScope.recordParameterInitializerError(I.AwaitExpressionFormalParameter, w), this.eat(55) && this.raise(I.ObsoleteAwaitStar, w), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (w.argument = this.parseMaybeUnary(null, !0)), this.finishNode(w, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak()) return !0;
            const { type: p } = this.state;
            return p === 53 || p === 10 || p === 0 || ce(p) || p === 102 && !this.state.containsEsc || p === 137 || p === 56 || this.hasPlugin("v8intrinsic") && p === 54;
          }
          parseYield() {
            const p = this.startNode();
            this.expressionScope.recordParameterInitializerError(I.YieldInParameter, p), this.next();
            let w = !1, q = null;
            if (!this.hasPrecedingLineBreak()) switch (w = this.eat(55), this.state.type) {
              case 13:
              case 139:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!w) break;
              default:
                q = this.parseMaybeAssign();
            }
            return p.delegate = w, p.argument = q, this.finishNode(p, "YieldExpression");
          }
          parseImportCall(p) {
            return this.next(), p.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (p.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (p.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(p, "ImportExpression");
          }
          checkPipelineAtInfixOperator(p, w) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && p.type === "SequenceExpression" && this.raise(I.PipelineHeadSequenceExpression, w);
          }
          parseSmartPipelineBodyInStyle(p, w) {
            if (this.isSimpleReference(p)) {
              const q = this.startNodeAt(w);
              return q.callee = p, this.finishNode(q, "PipelineBareFunction");
            }
            {
              const q = this.startNodeAt(w);
              return this.checkSmartPipeTopicBodyEarlyErrors(w), q.expression = p, this.finishNode(q, "PipelineTopicExpression");
            }
          }
          isSimpleReference(p) {
            switch (p.type) {
              case "MemberExpression":
                return !p.computed && this.isSimpleReference(p.object);
              case "Identifier":
                return !0;
              default:
                return !1;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(p) {
            if (this.match(19)) throw this.raise(I.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(I.PipelineTopicUnused, p);
          }
          withTopicBindingContext(p) {
            const w = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return p();
            } finally {
              this.state.topicContext = w;
            }
          }
          withSmartMixTopicForbiddingContext(p) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return p();
            {
              const w = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return p();
              } finally {
                this.state.topicContext = w;
              }
            }
          }
          withSoloAwaitPermittingContext(p) {
            const w = this.state.soloAwait;
            this.state.soloAwait = !0;
            try {
              return p();
            } finally {
              this.state.soloAwait = w;
            }
          }
          allowInAnd(p) {
            const w = this.prodParam.currentFlags();
            if (8 & ~w) {
              this.prodParam.enter(8 | w);
              try {
                return p();
              } finally {
                this.prodParam.exit();
              }
            }
            return p();
          }
          disallowInAnd(p) {
            const w = this.prodParam.currentFlags();
            if (8 & w) {
              this.prodParam.enter(-9 & w);
              try {
                return p();
              } finally {
                this.prodParam.exit();
              }
            }
            return p();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(p) {
            const w = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const q = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !0;
            const ne = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), w, p);
            return this.state.inFSharpPipelineDirectBody = q, ne;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const p = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            const w = this.startNodeAt(this.state.endLoc);
            this.next();
            const q = this.initializeScopes(!0);
            this.enterInitialScopes();
            try {
              p.body = this.parseProgram(w, 8, "module");
            } finally {
              q();
            }
            return this.finishNode(p, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(p) {
          }
        }
        const La = { kind: 1 }, Kp = { kind: 2 }, wo = /[\uD800-\uDFFF]/u, xo = /in(?:stanceof)?/y;
        class $l extends Ci {
          parseTopLevel(p, w) {
            return p.program = this.parseProgram(w), p.comments = this.comments, this.options.tokens && (p.tokens = function(q, ne) {
              for (let pe = 0; pe < q.length; pe++) {
                const xe = q[pe], { type: Ce } = xe;
                if (typeof Ce == "number") {
                  if (Ce === 138) {
                    const { loc: Re, start: Ue, value: Ke, end: yt } = xe, $t = Ue + 1, wt = f(Re.start, 1);
                    q.splice(pe, 1, new jr({ type: ee(27), value: "#", start: Ue, end: $t, startLoc: Re.start, endLoc: wt }), new jr({ type: ee(132), value: Ke, start: $t, end: yt, startLoc: wt, endLoc: Re.end })), pe++;
                    continue;
                  }
                  if (ce(Ce)) {
                    const { loc: Re, start: Ue, value: Ke, end: yt } = xe, $t = Ue + 1, wt = f(Re.start, 1);
                    let Ht, Gr, Vr, ur, hn;
                    Ht = ne.charCodeAt(Ue) === 96 ? new jr({ type: ee(22), value: "`", start: Ue, end: $t, startLoc: Re.start, endLoc: wt }) : new jr({ type: ee(8), value: "}", start: Ue, end: $t, startLoc: Re.start, endLoc: wt }), Ce === 24 ? (Vr = yt - 1, ur = f(Re.end, -1), Gr = Ke === null ? null : Ke.slice(1, -1), hn = new jr({ type: ee(22), value: "`", start: Vr, end: yt, startLoc: ur, endLoc: Re.end })) : (Vr = yt - 2, ur = f(Re.end, -2), Gr = Ke === null ? null : Ke.slice(1, -2), hn = new jr({ type: ee(23), value: "${", start: Vr, end: yt, startLoc: ur, endLoc: Re.end })), q.splice(pe, 1, Ht, new jr({ type: ee(20), value: Gr, start: $t, end: Vr, startLoc: wt, endLoc: ur }), hn), pe += 2;
                    continue;
                  }
                  xe.type = ee(Ce);
                }
              }
              return q;
            }(this.tokens, this.input)), this.finishNode(p, "File");
          }
          parseProgram(p, w = 139, q = this.options.sourceType) {
            if (p.sourceType = q, p.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(p, !0, !0, w), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [pe, xe] of Array.from(this.scope.undefinedExports)) this.raise(I.ModuleExportUndefined, xe, { localName: pe });
            let ne;
            return ne = w === 139 ? this.finishNode(p, "Program") : this.finishNodeAt(p, "Program", f(this.state.startLoc, -1)), ne;
          }
          stmtToDirective(p) {
            const w = p;
            w.type = "Directive", w.value = w.expression, delete w.expression;
            const q = w.value, ne = q.value, pe = this.input.slice(q.start, q.end), xe = q.value = pe.slice(1, -1);
            return this.addExtra(q, "raw", pe), this.addExtra(q, "rawValue", xe), this.addExtra(q, "expressionValue", ne), q.type = "DirectiveLiteral", w;
          }
          parseInterpreterDirective() {
            if (!this.match(28)) return null;
            const p = this.startNode();
            return p.value = this.state.value, this.next(), this.finishNode(p, "InterpreterDirective");
          }
          isLet() {
            return !!this.isContextual(100) && this.hasFollowingBindingAtom();
          }
          chStartsBindingIdentifier(p, w) {
            if (be(p)) {
              if (xo.lastIndex = w, xo.test(this.input)) {
                const q = this.codePointAtPos(xo.lastIndex);
                if (!Ie(q) && q !== 92) return !1;
              }
              return !0;
            }
            return p === 92;
          }
          chStartsBindingPattern(p) {
            return p === 91 || p === 123;
          }
          hasFollowingBindingAtom() {
            const p = this.nextTokenStart(), w = this.codePointAtPos(p);
            return this.chStartsBindingPattern(w) || this.chStartsBindingIdentifier(w, p);
          }
          hasInLineFollowingBindingIdentifier() {
            const p = this.nextTokenInLineStart(), w = this.codePointAtPos(p);
            return this.chStartsBindingIdentifier(w, p);
          }
          startsUsingForOf() {
            const { type: p, containsEsc: w } = this.lookahead();
            return !(p === 102 && !w) && (V(p) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), !0) : void 0);
          }
          startsAwaitUsing() {
            let p = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(p, "using")) {
              p = this.nextTokenInLineStartSince(p + 5);
              const w = this.codePointAtPos(p);
              if (this.chStartsBindingIdentifier(w, p)) return this.expectPlugin("explicitResourceManagement"), !0;
            }
            return !1;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(p = !1) {
            let w = 0;
            return this.options.annexB && !this.state.strict && (w |= 4, p && (w |= 8)), this.parseStatementLike(w);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(p) {
            let w = null;
            return this.match(26) && (w = this.parseDecorators(!0)), this.parseStatementContent(p, w);
          }
          parseStatementContent(p, w) {
            const q = this.state.type, ne = this.startNode(), pe = !!(2 & p), xe = !!(4 & p), Ce = 1 & p;
            switch (q) {
              case 60:
                return this.parseBreakContinueStatement(ne, !0);
              case 63:
                return this.parseBreakContinueStatement(ne, !1);
              case 64:
                return this.parseDebuggerStatement(ne);
              case 90:
                return this.parseDoWhileStatement(ne);
              case 91:
                return this.parseForStatement(ne);
              case 68:
                if (this.lookaheadCharCode() === 46) break;
                return xe || this.raise(this.state.strict ? I.StrictFunction : this.options.annexB ? I.SloppyFunctionAnnexB : I.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(ne, !1, !pe && xe);
              case 80:
                return pe || this.unexpected(), this.parseClass(this.maybeTakeDecorators(w, ne), !0);
              case 69:
                return this.parseIfStatement(ne);
              case 70:
                return this.parseReturnStatement(ne);
              case 71:
                return this.parseSwitchStatement(ne);
              case 72:
                return this.parseThrowStatement(ne);
              case 73:
                return this.parseTryStatement(ne);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? pe || this.raise(I.UnexpectedLexicalDeclaration, ne) : this.raise(I.AwaitUsingNotInAsyncContext, ne), this.next(), this.parseVarStatement(ne, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(I.UnexpectedUsingDeclaration, this.state.startLoc) : pe || this.raise(I.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(ne, "using");
              case 100: {
                if (this.state.containsEsc) break;
                const Ke = this.nextTokenStart(), yt = this.codePointAtPos(Ke);
                if (yt !== 91 && (!pe && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(yt, Ke) && yt !== 123))
                  break;
              }
              case 75:
                pe || this.raise(I.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                const Ke = this.state.value;
                return this.parseVarStatement(ne, Ke);
              }
              case 92:
                return this.parseWhileStatement(ne);
              case 76:
                return this.parseWithStatement(ne);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(ne);
              case 83: {
                const Ke = this.lookaheadCharCode();
                if (Ke === 40 || Ke === 46) break;
              }
              case 82: {
                let Ke;
                return this.options.allowImportExportEverywhere || Ce || this.raise(I.UnexpectedImportExport, this.state.startLoc), this.next(), q === 83 ? (Ke = this.parseImport(ne), Ke.type !== "ImportDeclaration" || Ke.importKind && Ke.importKind !== "value" || (this.sawUnambiguousESM = !0)) : (Ke = this.parseExport(ne, w), (Ke.type !== "ExportNamedDeclaration" || Ke.exportKind && Ke.exportKind !== "value") && (Ke.type !== "ExportAllDeclaration" || Ke.exportKind && Ke.exportKind !== "value") && Ke.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(Ke), Ke;
              }
              default:
                if (this.isAsyncFunction()) return pe || this.raise(I.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(ne, !0, !pe && xe);
            }
            const Re = this.state.value, Ue = this.parseExpression();
            return V(q) && Ue.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(ne, Re, Ue, p) : this.parseExpressionStatement(ne, Ue, w);
          }
          assertModuleNodeAllowed(p) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(I.ImportOutsideModule, p);
          }
          decoratorsEnabledBeforeExport() {
            return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
          }
          maybeTakeDecorators(p, w, q) {
            return p && (w.decorators && w.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(I.DecoratorsBeforeAfterExport, w.decorators[0]), w.decorators.unshift(...p)) : w.decorators = p, this.resetStartLocationFromNode(w, p[0]), q && this.resetStartLocationFromNode(q, w)), w;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(p) {
            const w = [];
            do
              w.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82)) p || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(I.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(I.UnexpectedLeadingDecorator, this.state.startLoc);
            return w;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            const p = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              const w = this.state.startLoc;
              let q;
              if (this.match(10)) {
                const ne = this.state.startLoc;
                this.next(), q = this.parseExpression(), this.expect(11), q = this.wrapParenthesis(ne, q);
                const pe = this.state.startLoc;
                p.expression = this.parseMaybeDecoratorArguments(q), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && p.expression !== q && this.raise(I.DecoratorArgumentsOutsideParentheses, pe);
              } else {
                for (q = this.parseIdentifier(!1); this.eat(16); ) {
                  const ne = this.startNodeAt(w);
                  ne.object = q, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), ne.property = this.parsePrivateName()) : ne.property = this.parseIdentifier(!0), ne.computed = !1, q = this.finishNode(ne, "MemberExpression");
                }
                p.expression = this.parseMaybeDecoratorArguments(q);
              }
            } else p.expression = this.parseExprSubscripts();
            return this.finishNode(p, "Decorator");
          }
          parseMaybeDecoratorArguments(p) {
            if (this.eat(10)) {
              const w = this.startNodeAtNode(p);
              return w.callee = p, w.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(w.arguments), this.finishNode(w, "CallExpression");
            }
            return p;
          }
          parseBreakContinueStatement(p, w) {
            return this.next(), this.isLineTerminator() ? p.label = null : (p.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(p, w), this.finishNode(p, w ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(p, w) {
            let q;
            for (q = 0; q < this.state.labels.length; ++q) {
              const ne = this.state.labels[q];
              if ((p.label == null || ne.name === p.label.name) && (ne.kind != null && (w || ne.kind === 1) || p.label && w))
                break;
            }
            if (q === this.state.labels.length) {
              const ne = w ? "BreakStatement" : "ContinueStatement";
              this.raise(I.IllegalBreakContinue, p, { type: ne });
            }
          }
          parseDebuggerStatement(p) {
            return this.next(), this.semicolon(), this.finishNode(p, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const p = this.parseExpression();
            return this.expect(11), p;
          }
          parseDoWhileStatement(p) {
            return this.next(), this.state.labels.push(La), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), p.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(p, "DoWhileStatement");
          }
          parseForStatement(p) {
            this.next(), this.state.labels.push(La);
            let w = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (w = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return w !== null && this.unexpected(w), this.parseFor(p, null);
            const q = this.isContextual(100);
            {
              const Re = this.isContextual(96) && this.startsAwaitUsing(), Ue = Re || this.isContextual(107) && this.startsUsingForOf(), Ke = q && this.hasFollowingBindingAtom() || Ue;
              if (this.match(74) || this.match(75) || Ke) {
                const yt = this.startNode();
                let $t;
                Re ? ($t = "await using", this.isAwaitAllowed() || this.raise(I.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : $t = this.state.value, this.next(), this.parseVar(yt, !0, $t);
                const wt = this.finishNode(yt, "VariableDeclaration"), Ht = this.match(58);
                return Ht && Ue && this.raise(I.ForInUsing, wt), (Ht || this.isContextual(102)) && wt.declarations.length === 1 ? this.parseForIn(p, wt, w) : (w !== null && this.unexpected(w), this.parseFor(p, wt));
              }
            }
            const ne = this.isContextual(95), pe = new _n(), xe = this.parseExpression(!0, pe), Ce = this.isContextual(102);
            if (Ce && (q && this.raise(I.ForOfLet, xe), w === null && ne && xe.type === "Identifier" && this.raise(I.ForOfAsync, xe)), Ce || this.match(58)) {
              this.checkDestructuringPrivate(pe), this.toAssignable(xe, !0);
              const Re = Ce ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(xe, { in: { type: Re } }), this.parseForIn(p, xe, w);
            }
            return this.checkExpressionErrors(pe, !0), w !== null && this.unexpected(w), this.parseFor(p, xe);
          }
          parseFunctionStatement(p, w, q) {
            return this.next(), this.parseFunction(p, 1 | (q ? 2 : 0) | (w ? 8 : 0));
          }
          parseIfStatement(p) {
            return this.next(), p.test = this.parseHeaderExpression(), p.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), p.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(p, "IfStatement");
          }
          parseReturnStatement(p) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(I.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? p.argument = null : (p.argument = this.parseExpression(), this.semicolon()), this.finishNode(p, "ReturnStatement");
          }
          parseSwitchStatement(p) {
            this.next(), p.discriminant = this.parseHeaderExpression();
            const w = p.cases = [];
            let q;
            this.expect(5), this.state.labels.push(Kp), this.scope.enter(0);
            for (let ne; !this.match(8); ) if (this.match(61) || this.match(65)) {
              const pe = this.match(61);
              q && this.finishNode(q, "SwitchCase"), w.push(q = this.startNode()), q.consequent = [], this.next(), pe ? q.test = this.parseExpression() : (ne && this.raise(I.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), ne = !0, q.test = null), this.expect(14);
            } else q ? q.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), q && this.finishNode(q, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(p, "SwitchStatement");
          }
          parseThrowStatement(p) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(I.NewlineAfterThrow, this.state.lastTokEndLoc), p.argument = this.parseExpression(), this.semicolon(), this.finishNode(p, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const p = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && p.type === "Identifier" ? 8 : 0), this.checkLVal(p, { in: { type: "CatchClause" }, binding: 9 }), p;
          }
          parseTryStatement(p) {
            if (this.next(), p.block = this.parseBlock(), p.handler = null, this.match(62)) {
              const w = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), w.param = this.parseCatchClauseParam(), this.expect(11)) : (w.param = null, this.scope.enter(0)), w.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), p.handler = this.finishNode(w, "CatchClause");
            }
            return p.finalizer = this.eat(67) ? this.parseBlock() : null, p.handler || p.finalizer || this.raise(I.NoCatchOrFinally, p), this.finishNode(p, "TryStatement");
          }
          parseVarStatement(p, w, q = !1) {
            return this.next(), this.parseVar(p, !1, w, q), this.semicolon(), this.finishNode(p, "VariableDeclaration");
          }
          parseWhileStatement(p) {
            return this.next(), p.test = this.parseHeaderExpression(), this.state.labels.push(La), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(p, "WhileStatement");
          }
          parseWithStatement(p) {
            return this.state.strict && this.raise(I.StrictWith, this.state.startLoc), this.next(), p.object = this.parseHeaderExpression(), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(p, "WithStatement");
          }
          parseEmptyStatement(p) {
            return this.next(), this.finishNode(p, "EmptyStatement");
          }
          parseLabeledStatement(p, w, q, ne) {
            for (const Ce of this.state.labels) Ce.name === w && this.raise(I.LabelRedeclaration, q, { labelName: w });
            const pe = (xe = this.state.type) >= 90 && xe <= 92 ? 1 : this.match(71) ? 2 : null;
            var xe;
            for (let Ce = this.state.labels.length - 1; Ce >= 0; Ce--) {
              const Re = this.state.labels[Ce];
              if (Re.statementStart !== p.start) break;
              Re.statementStart = this.state.start, Re.kind = pe;
            }
            return this.state.labels.push({ name: w, kind: pe, statementStart: this.state.start }), p.body = 8 & ne ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), p.label = q, this.finishNode(p, "LabeledStatement");
          }
          parseExpressionStatement(p, w, q) {
            return p.expression = w, this.semicolon(), this.finishNode(p, "ExpressionStatement");
          }
          parseBlock(p = !1, w = !0, q) {
            const ne = this.startNode();
            return p && this.state.strictErrors.clear(), this.expect(5), w && this.scope.enter(0), this.parseBlockBody(ne, p, !1, 8, q), w && this.scope.exit(), this.finishNode(ne, "BlockStatement");
          }
          isValidDirective(p) {
            return p.type === "ExpressionStatement" && p.expression.type === "StringLiteral" && !p.expression.extra.parenthesized;
          }
          parseBlockBody(p, w, q, ne, pe) {
            const xe = p.body = [], Ce = p.directives = [];
            this.parseBlockOrModuleBlockBody(xe, w ? Ce : void 0, q, ne, pe);
          }
          parseBlockOrModuleBlockBody(p, w, q, ne, pe) {
            const xe = this.state.strict;
            let Ce = !1, Re = !1;
            for (; !this.match(ne); ) {
              const Ue = q ? this.parseModuleItem() : this.parseStatementListItem();
              if (w && !Re) {
                if (this.isValidDirective(Ue)) {
                  const Ke = this.stmtToDirective(Ue);
                  w.push(Ke), Ce || Ke.value.value !== "use strict" || (Ce = !0, this.setStrict(!0));
                  continue;
                }
                Re = !0, this.state.strictErrors.clear();
              }
              p.push(Ue);
            }
            pe == null || pe.call(this, Ce), xe || this.setStrict(!1), this.next();
          }
          parseFor(p, w) {
            return p.init = w, this.semicolon(!1), p.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), p.update = this.match(11) ? null : this.parseExpression(), this.expect(11), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(p, "ForStatement");
          }
          parseForIn(p, w, q) {
            const ne = this.match(58);
            return this.next(), ne ? q !== null && this.unexpected(q) : p.await = q !== null, w.type !== "VariableDeclaration" || w.declarations[0].init == null || ne && this.options.annexB && !this.state.strict && w.kind === "var" && w.declarations[0].id.type === "Identifier" || this.raise(I.ForInOfLoopInitializer, w, { type: ne ? "ForInStatement" : "ForOfStatement" }), w.type === "AssignmentPattern" && this.raise(I.InvalidLhs, w, { ancestor: { type: "ForStatement" } }), p.left = w, p.right = ne ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(p, ne ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(p, w, q, ne = !1) {
            const pe = p.declarations = [];
            for (p.kind = q; ; ) {
              const xe = this.startNode();
              if (this.parseVarId(xe, q), xe.init = this.eat(29) ? w ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, xe.init !== null || ne || (xe.id.type === "Identifier" || w && (this.match(58) || this.isContextual(102)) ? q !== "const" && q !== "using" && q !== "await using" || this.match(58) || this.isContextual(102) || this.raise(I.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: q }) : this.raise(I.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" })), pe.push(this.finishNode(xe, "VariableDeclarator")), !this.eat(12)) break;
            }
            return p;
          }
          parseVarId(p, w) {
            const q = this.parseBindingAtom();
            this.checkLVal(q, { in: { type: "VariableDeclarator" }, binding: w === "var" ? 5 : 8201 }), p.id = q;
          }
          parseAsyncFunctionExpression(p) {
            return this.parseFunction(p, 8);
          }
          parseFunction(p, w = 0) {
            const q = 2 & w, ne = !!(1 & w), pe = ne && !(4 & w), xe = !!(8 & w);
            this.initFunction(p, xe), this.match(55) && (q && this.raise(I.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), p.generator = !0), ne && (p.id = this.parseFunctionId(pe));
            const Ce = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Cr(xe, p.generator)), ne || (p.id = this.parseFunctionId()), this.parseFunctionParams(p, !1), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(p, ne ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), ne && !q && this.registerFunctionStatementId(p), this.state.maybeInArrowParameters = Ce, p;
          }
          parseFunctionId(p) {
            return p || V(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(p, w) {
            this.expect(10), this.expressionScope.enter(new En(3)), p.params = this.parseBindingList(11, 41, 2 | (w ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(p) {
            p.id && this.scope.declareName(p.id.name, !this.options.annexB || this.state.strict || p.generator || p.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, p.id.loc.start);
          }
          parseClass(p, w, q) {
            this.next();
            const ne = this.state.strict;
            return this.state.strict = !0, this.parseClassId(p, w, q), this.parseClassSuper(p), p.body = this.parseClassBody(!!p.superClass, ne), this.finishNode(p, w ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(p) {
            return p.type === "Identifier" && p.name === "constructor" || p.type === "StringLiteral" && p.value === "constructor";
          }
          isNonstaticConstructor(p) {
            return !p.computed && !p.static && this.nameIsConstructor(p.key);
          }
          parseClassBody(p, w) {
            this.classScope.enter();
            const q = { hadConstructor: !1, hadSuperClass: p };
            let ne = [];
            const pe = this.startNode();
            if (pe.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (ne.length > 0) throw this.raise(I.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  ne.push(this.parseDecorator());
                  continue;
                }
                const xe = this.startNode();
                ne.length && (xe.decorators = ne, this.resetStartLocationFromNode(xe, ne[0]), ne = []), this.parseClassMember(pe, xe, q), xe.kind === "constructor" && xe.decorators && xe.decorators.length > 0 && this.raise(I.DecoratorConstructor, xe);
              }
            }), this.state.strict = w, this.next(), ne.length) throw this.raise(I.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(pe, "ClassBody");
          }
          parseClassMemberFromModifier(p, w) {
            const q = this.parseIdentifier(!0);
            if (this.isClassMethod()) {
              const ne = w;
              return ne.kind = "method", ne.computed = !1, ne.key = q, ne.static = !1, this.pushClassMethod(p, ne, !1, !1, !1, !1), !0;
            }
            if (this.isClassProperty()) {
              const ne = w;
              return ne.computed = !1, ne.key = q, ne.static = !1, p.body.push(this.parseClassProperty(ne)), !0;
            }
            return this.resetPreviousNodeTrailingComments(q), !1;
          }
          parseClassMember(p, w, q) {
            const ne = this.isContextual(106);
            if (ne) {
              if (this.parseClassMemberFromModifier(p, w)) return;
              if (this.eat(5)) return void this.parseClassStaticBlock(p, w);
            }
            this.parseClassMemberWithIsStatic(p, w, q, ne);
          }
          parseClassMemberWithIsStatic(p, w, q, ne) {
            const pe = w, xe = w, Ce = w, Re = w, Ue = w, Ke = pe, yt = pe;
            if (w.static = ne, this.parsePropertyNamePrefixOperator(w), this.eat(55)) {
              Ke.kind = "method";
              const ur = this.match(138);
              return this.parseClassElementName(Ke), ur ? void this.pushClassPrivateMethod(p, xe, !0, !1) : (this.isNonstaticConstructor(pe) && this.raise(I.ConstructorIsGenerator, pe.key), void this.pushClassMethod(p, pe, !0, !1, !1, !1));
            }
            const $t = !this.state.containsEsc && V(this.state.type), wt = this.parseClassElementName(w), Ht = $t ? wt.name : null, Gr = this.isPrivateName(wt), Vr = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(yt), this.isClassMethod()) {
              if (Ke.kind = "method", Gr) return void this.pushClassPrivateMethod(p, xe, !1, !1);
              const ur = this.isNonstaticConstructor(pe);
              let hn = !1;
              ur && (pe.kind = "constructor", q.hadConstructor && !this.hasPlugin("typescript") && this.raise(I.DuplicateConstructor, wt), ur && this.hasPlugin("typescript") && w.override && this.raise(I.OverrideOnConstructor, wt), q.hadConstructor = !0, hn = q.hadSuperClass), this.pushClassMethod(p, pe, !1, !1, ur, hn);
            } else if (this.isClassProperty()) Gr ? this.pushClassPrivateProperty(p, Re) : this.pushClassProperty(p, Ce);
            else if (Ht !== "async" || this.isLineTerminator()) if (Ht !== "get" && Ht !== "set" || this.match(55) && this.isLineTerminator()) if (Ht !== "accessor" || this.isLineTerminator()) this.isLineTerminator() ? Gr ? this.pushClassPrivateProperty(p, Re) : this.pushClassProperty(p, Ce) : this.unexpected();
            else {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(wt);
              const ur = this.match(138);
              this.parseClassElementName(Ce), this.pushClassAccessorProperty(p, Ue, ur);
            }
            else {
              this.resetPreviousNodeTrailingComments(wt), Ke.kind = Ht;
              const ur = this.match(138);
              this.parseClassElementName(pe), ur ? this.pushClassPrivateMethod(p, xe, !1, !1) : (this.isNonstaticConstructor(pe) && this.raise(I.ConstructorIsAccessor, pe.key), this.pushClassMethod(p, pe, !1, !1, !1, !1)), this.checkGetterSetterParams(pe);
            }
            else {
              this.resetPreviousNodeTrailingComments(wt);
              const ur = this.eat(55);
              yt.optional && this.unexpected(Vr), Ke.kind = "method";
              const hn = this.match(138);
              this.parseClassElementName(Ke), this.parsePostMemberNameModifiers(yt), hn ? this.pushClassPrivateMethod(p, xe, ur, !0) : (this.isNonstaticConstructor(pe) && this.raise(I.ConstructorIsAsync, pe.key), this.pushClassMethod(p, pe, ur, !0, !1, !1));
            }
          }
          parseClassElementName(p) {
            const { type: w, value: q } = this.state;
            if (w !== 132 && w !== 133 || !p.static || q !== "prototype" || this.raise(I.StaticPrototype, this.state.startLoc), w === 138) {
              q === "constructor" && this.raise(I.ConstructorClassPrivateField, this.state.startLoc);
              const ne = this.parsePrivateName();
              return p.key = ne, ne;
            }
            return this.parsePropertyName(p), p.key;
          }
          parseClassStaticBlock(p, w) {
            var q;
            this.scope.enter(208);
            const ne = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const pe = w.body = [];
            this.parseBlockOrModuleBlockBody(pe, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = ne, p.body.push(this.finishNode(w, "StaticBlock")), (q = w.decorators) != null && q.length && this.raise(I.DecoratorStaticBlock, w);
          }
          pushClassProperty(p, w) {
            !w.computed && this.nameIsConstructor(w.key) && this.raise(I.ConstructorClassField, w.key), p.body.push(this.parseClassProperty(w));
          }
          pushClassPrivateProperty(p, w) {
            const q = this.parseClassPrivateProperty(w);
            p.body.push(q), this.classScope.declarePrivateName(this.getPrivateNameSV(q.key), 0, q.key.loc.start);
          }
          pushClassAccessorProperty(p, w, q) {
            q || w.computed || !this.nameIsConstructor(w.key) || this.raise(I.ConstructorClassField, w.key);
            const ne = this.parseClassAccessorProperty(w);
            p.body.push(ne), q && this.classScope.declarePrivateName(this.getPrivateNameSV(ne.key), 0, ne.key.loc.start);
          }
          pushClassMethod(p, w, q, ne, pe, xe) {
            p.body.push(this.parseMethod(w, q, ne, pe, xe, "ClassMethod", !0));
          }
          pushClassPrivateMethod(p, w, q, ne) {
            const pe = this.parseMethod(w, q, ne, !1, !1, "ClassPrivateMethod", !0);
            p.body.push(pe);
            const xe = pe.kind === "get" ? pe.static ? 6 : 2 : pe.kind === "set" ? pe.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(pe, xe);
          }
          declareClassPrivateMethodInScope(p, w) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(p.key), w, p.key.loc.start);
          }
          parsePostMemberNameModifiers(p) {
          }
          parseClassPrivateProperty(p) {
            return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassPrivateProperty");
          }
          parseClassProperty(p) {
            return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassProperty");
          }
          parseClassAccessorProperty(p) {
            return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassAccessorProperty");
          }
          parseInitializer(p) {
            this.scope.enter(80), this.expressionScope.enter(vr()), this.prodParam.enter(0), p.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(p, w, q, ne = 8331) {
            if (V(this.state.type)) p.id = this.parseIdentifier(), w && this.declareNameFromIdentifier(p.id, ne);
            else {
              if (!q && w) throw this.raise(I.MissingClassName, this.state.startLoc);
              p.id = null;
            }
          }
          parseClassSuper(p) {
            p.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(p, w) {
            const q = this.parseMaybeImportPhase(p, !0), ne = this.maybeParseExportDefaultSpecifier(p, q), pe = !ne || this.eat(12), xe = pe && this.eatExportStar(p), Ce = xe && this.maybeParseExportNamespaceSpecifier(p), Re = pe && (!Ce || this.eat(12)), Ue = ne || xe;
            if (xe && !Ce) {
              if (ne && this.unexpected(), w) throw this.raise(I.UnsupportedDecoratorExport, p);
              return this.parseExportFrom(p, !0), this.finishNode(p, "ExportAllDeclaration");
            }
            const Ke = this.maybeParseExportNamedSpecifiers(p);
            let yt;
            if (ne && pe && !xe && !Ke && this.unexpected(null, 5), Ce && Re && this.unexpected(null, 98), Ue || Ke) {
              if (yt = !1, w) throw this.raise(I.UnsupportedDecoratorExport, p);
              this.parseExportFrom(p, Ue);
            } else yt = this.maybeParseExportDeclaration(p);
            if (Ue || Ke || yt) {
              var $t;
              const wt = p;
              if (this.checkExport(wt, !0, !1, !!wt.source), (($t = wt.declaration) == null ? void 0 : $t.type) === "ClassDeclaration") this.maybeTakeDecorators(w, wt.declaration, wt);
              else if (w) throw this.raise(I.UnsupportedDecoratorExport, p);
              return this.finishNode(wt, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              const wt = p, Ht = this.parseExportDefaultExpression();
              if (wt.declaration = Ht, Ht.type === "ClassDeclaration") this.maybeTakeDecorators(w, Ht, wt);
              else if (w) throw this.raise(I.UnsupportedDecoratorExport, p);
              return this.checkExport(wt, !0, !0), this.finishNode(wt, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(p) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(p, w) {
            if (w || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", w == null ? void 0 : w.loc.start);
              const q = w || this.parseIdentifier(!0), ne = this.startNodeAtNode(q);
              return ne.exported = q, p.specifiers = [this.finishNode(ne, "ExportDefaultSpecifier")], !0;
            }
            return !1;
          }
          maybeParseExportNamespaceSpecifier(p) {
            if (this.isContextual(93)) {
              var w;
              (w = p).specifiers != null || (w.specifiers = []);
              const q = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), q.exported = this.parseModuleExportName(), p.specifiers.push(this.finishNode(q, "ExportNamespaceSpecifier")), !0;
            }
            return !1;
          }
          maybeParseExportNamedSpecifiers(p) {
            if (this.match(5)) {
              const w = p;
              w.specifiers || (w.specifiers = []);
              const q = w.exportKind === "type";
              return w.specifiers.push(...this.parseExportSpecifiers(q)), w.source = null, w.declaration = null, this.hasPlugin("importAssertions") && (w.assertions = []), !0;
            }
            return !1;
          }
          maybeParseExportDeclaration(p) {
            return !!this.shouldParseExportDeclaration() && (p.specifiers = [], p.source = null, this.hasPlugin("importAssertions") && (p.assertions = []), p.declaration = this.parseExportDeclaration(p), !0);
          }
          isAsyncFunction() {
            if (!this.isContextual(95)) return !1;
            const p = this.nextTokenInLineStart();
            return this.isUnparsedContextual(p, "function");
          }
          parseExportDefaultExpression() {
            const p = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(p, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(p, 13);
            if (this.match(80)) return this.parseClass(p, !0, !0);
            if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(I.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
            if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(I.UnsupportedDefaultExport, this.state.startLoc);
            const w = this.parseMaybeAssignAllowIn();
            return this.semicolon(), w;
          }
          parseExportDeclaration(p) {
            return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            const { type: p } = this.state;
            if (V(p)) {
              if (p === 95 && !this.state.containsEsc || p === 100) return !1;
              if ((p === 130 || p === 129) && !this.state.containsEsc) {
                const { type: ne } = this.lookahead();
                if (V(ne) && ne !== 98 || ne === 5) return this.expectOnePlugin(["flow", "typescript"]), !1;
              }
            } else if (!this.match(65)) return !1;
            const w = this.nextTokenStart(), q = this.isUnparsedContextual(w, "from");
            if (this.input.charCodeAt(w) === 44 || V(this.state.type) && q) return !0;
            if (this.match(65) && q) {
              const ne = this.input.charCodeAt(this.nextTokenStartSince(w + 4));
              return ne === 34 || ne === 39;
            }
            return !1;
          }
          parseExportFrom(p, w) {
            this.eatContextual(98) ? (p.source = this.parseImportSource(), this.checkExport(p), this.maybeParseImportAttributes(p), this.checkJSONModuleImport(p)) : w && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type: p } = this.state;
            return p === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(I.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) || this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(I.UsingDeclarationExport, this.state.startLoc), !0) : p === 74 || p === 75 || p === 68 || p === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(p, w, q, ne) {
            var pe;
            if (w) {
              if (q) {
                if (this.checkDuplicateExports(p, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var xe;
                  const Ce = p.declaration;
                  Ce.type !== "Identifier" || Ce.name !== "from" || Ce.end - Ce.start != 4 || (xe = Ce.extra) != null && xe.parenthesized || this.raise(I.ExportDefaultFromAsIdentifier, Ce);
                }
              } else if ((pe = p.specifiers) != null && pe.length) for (const Ce of p.specifiers) {
                const { exported: Re } = Ce, Ue = Re.type === "Identifier" ? Re.name : Re.value;
                if (this.checkDuplicateExports(Ce, Ue), !ne && Ce.local) {
                  const { local: Ke } = Ce;
                  Ke.type !== "Identifier" ? this.raise(I.ExportBindingIsString, Ce, { localName: Ke.value, exportName: Ue }) : (this.checkReservedWord(Ke.name, Ke.loc.start, !0, !1), this.scope.checkLocalExport(Ke));
                }
              }
              else if (p.declaration) {
                const Ce = p.declaration;
                if (Ce.type === "FunctionDeclaration" || Ce.type === "ClassDeclaration") {
                  const { id: Re } = Ce;
                  if (!Re) throw new Error("Assertion failure");
                  this.checkDuplicateExports(p, Re.name);
                } else if (Ce.type === "VariableDeclaration") for (const Re of Ce.declarations) this.checkDeclaration(Re.id);
              }
            }
          }
          checkDeclaration(p) {
            if (p.type === "Identifier") this.checkDuplicateExports(p, p.name);
            else if (p.type === "ObjectPattern") for (const w of p.properties) this.checkDeclaration(w);
            else if (p.type === "ArrayPattern") for (const w of p.elements) w && this.checkDeclaration(w);
            else p.type === "ObjectProperty" ? this.checkDeclaration(p.value) : p.type === "RestElement" ? this.checkDeclaration(p.argument) : p.type === "AssignmentPattern" && this.checkDeclaration(p.left);
          }
          checkDuplicateExports(p, w) {
            this.exportedIdentifiers.has(w) && (w === "default" ? this.raise(I.DuplicateDefaultExport, p) : this.raise(I.DuplicateExport, p, { exportName: w })), this.exportedIdentifiers.add(w);
          }
          parseExportSpecifiers(p) {
            const w = [];
            let q = !0;
            for (this.expect(5); !this.eat(8); ) {
              if (q) q = !1;
              else if (this.expect(12), this.eat(8)) break;
              const ne = this.isContextual(130), pe = this.match(133), xe = this.startNode();
              xe.local = this.parseModuleExportName(), w.push(this.parseExportSpecifier(xe, pe, p, ne));
            }
            return w;
          }
          parseExportSpecifier(p, w, q, ne) {
            return this.eatContextual(93) ? p.exported = this.parseModuleExportName() : w ? p.exported = Wn(p.local) : p.exported || (p.exported = Dr(p.local)), this.finishNode(p, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(133)) {
              const p = this.parseStringLiteral(this.state.value), w = p.value.match(wo);
              return w && this.raise(I.ModuleExportNameHasLoneSurrogate, p, { surrogateCharCode: w[0].charCodeAt(0) }), p;
            }
            return this.parseIdentifier(!0);
          }
          isJSONModuleImport(p) {
            return p.assertions != null && p.assertions.some(({ key: w, value: q }) => q.value === "json" && (w.type === "Identifier" ? w.name === "type" : w.value === "type"));
          }
          checkImportReflection(p) {
            const { specifiers: w } = p, q = w.length === 1 ? w[0].type : null;
            if (p.phase === "source") q !== "ImportDefaultSpecifier" && this.raise(I.SourcePhaseImportRequiresDefault, w[0].loc.start);
            else if (p.phase === "defer") q !== "ImportNamespaceSpecifier" && this.raise(I.DeferImportRequiresNamespace, w[0].loc.start);
            else if (p.module) {
              var ne;
              q !== "ImportDefaultSpecifier" && this.raise(I.ImportReflectionNotBinding, w[0].loc.start), ((ne = p.assertions) == null ? void 0 : ne.length) > 0 && this.raise(I.ImportReflectionHasAssertion, w[0].loc.start);
            }
          }
          checkJSONModuleImport(p) {
            if (this.isJSONModuleImport(p) && p.type !== "ExportAllDeclaration") {
              const { specifiers: w } = p;
              if (w != null) {
                const q = w.find((ne) => {
                  let pe;
                  if (ne.type === "ExportSpecifier" ? pe = ne.local : ne.type === "ImportSpecifier" && (pe = ne.imported), pe !== void 0) return pe.type === "Identifier" ? pe.name !== "default" : pe.value !== "default";
                });
                q !== void 0 && this.raise(I.ImportJSONBindingNotDefault, q.loc.start);
              }
            }
          }
          isPotentialImportPhase(p) {
            return !p && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
          }
          applyImportPhase(p, w, q, ne) {
            w || (q === "module" ? (this.expectPlugin("importReflection", ne), p.module = !0) : this.hasPlugin("importReflection") && (p.module = !1), q === "source" ? (this.expectPlugin("sourcePhaseImports", ne), p.phase = "source") : q === "defer" ? (this.expectPlugin("deferredImportEvaluation", ne), p.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (p.phase = null));
          }
          parseMaybeImportPhase(p, w) {
            if (!this.isPotentialImportPhase(w)) return this.applyImportPhase(p, w, null), null;
            const q = this.parseIdentifier(!0), { type: ne } = this.state;
            return (F(ne) ? ne !== 98 || this.lookaheadCharCode() === 102 : ne !== 12) ? (this.resetPreviousIdentifierLeadingComments(q), this.applyImportPhase(p, w, q.name, q.loc.start), null) : (this.applyImportPhase(p, w, null), q);
          }
          isPrecedingIdImportPhase(p) {
            const { type: w } = this.state;
            return V(w) ? w !== 98 || this.lookaheadCharCode() === 102 : w !== 12;
          }
          parseImport(p) {
            return this.match(133) ? this.parseImportSourceAndAttributes(p) : this.parseImportSpecifiersAndAfter(p, this.parseMaybeImportPhase(p, !1));
          }
          parseImportSpecifiersAndAfter(p, w) {
            p.specifiers = [];
            const q = !this.maybeParseDefaultImportSpecifier(p, w) || this.eat(12), ne = q && this.maybeParseStarImportSpecifier(p);
            return q && !ne && this.parseNamedImportSpecifiers(p), this.expectContextual(98), this.parseImportSourceAndAttributes(p);
          }
          parseImportSourceAndAttributes(p) {
            return p.specifiers != null || (p.specifiers = []), p.source = this.parseImportSource(), this.maybeParseImportAttributes(p), this.checkImportReflection(p), this.checkJSONModuleImport(p), this.semicolon(), this.finishNode(p, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(133) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(p, w, q) {
            w.local = this.parseIdentifier(), p.specifiers.push(this.finishImportSpecifier(w, q));
          }
          finishImportSpecifier(p, w, q = 8201) {
            return this.checkLVal(p.local, { in: { type: w }, binding: q }), this.finishNode(p, w);
          }
          parseImportAttributes() {
            this.expect(5);
            const p = [], w = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) break;
              const q = this.startNode(), ne = this.state.value;
              if (w.has(ne) && this.raise(I.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: ne }), w.add(ne), this.match(133) ? q.key = this.parseStringLiteral(ne) : q.key = this.parseIdentifier(!0), this.expect(14), !this.match(133)) throw this.raise(I.ModuleAttributeInvalidValue, this.state.startLoc);
              q.value = this.parseStringLiteral(this.state.value), p.push(this.finishNode(q, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), p;
          }
          parseModuleAttributes() {
            const p = [], w = /* @__PURE__ */ new Set();
            do {
              const q = this.startNode();
              if (q.key = this.parseIdentifier(!0), q.key.name !== "type" && this.raise(I.ModuleAttributeDifferentFromType, q.key), w.has(q.key.name) && this.raise(I.ModuleAttributesWithDuplicateKeys, q.key, { key: q.key.name }), w.add(q.key.name), this.expect(14), !this.match(133)) throw this.raise(I.ModuleAttributeInvalidValue, this.state.startLoc);
              q.value = this.parseStringLiteral(this.state.value), p.push(this.finishNode(q, "ImportAttribute"));
            } while (this.eat(12));
            return p;
          }
          maybeParseImportAttributes(p) {
            let w, q = !1;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
              this.next(), this.hasPlugin("moduleAttributes") ? w = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), w = this.parseImportAttributes()), q = !0;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(I.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(p, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), w = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) w = [];
            else {
              if (!this.hasPlugin("moduleAttributes")) return;
              w = [];
            }
            !q && this.hasPlugin("importAssertions") ? p.assertions = w : p.attributes = w;
          }
          maybeParseDefaultImportSpecifier(p, w) {
            if (w) {
              const q = this.startNodeAtNode(w);
              return q.local = w, p.specifiers.push(this.finishImportSpecifier(q, "ImportDefaultSpecifier")), !0;
            }
            return !!F(this.state.type) && (this.parseImportSpecifierLocal(p, this.startNode(), "ImportDefaultSpecifier"), !0);
          }
          maybeParseStarImportSpecifier(p) {
            if (this.match(55)) {
              const w = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(p, w, "ImportNamespaceSpecifier"), !0;
            }
            return !1;
          }
          parseNamedImportSpecifiers(p) {
            let w = !0;
            for (this.expect(5); !this.eat(8); ) {
              if (w) w = !1;
              else {
                if (this.eat(14)) throw this.raise(I.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8)) break;
              }
              const q = this.startNode(), ne = this.match(133), pe = this.isContextual(130);
              q.imported = this.parseModuleExportName();
              const xe = this.parseImportSpecifier(q, ne, p.importKind === "type" || p.importKind === "typeof", pe, void 0);
              p.specifiers.push(xe);
            }
          }
          parseImportSpecifier(p, w, q, ne, pe) {
            if (this.eatContextual(93)) p.local = this.parseIdentifier();
            else {
              const { imported: xe } = p;
              if (w) throw this.raise(I.ImportBindingIsString, p, { importName: xe.value });
              this.checkReservedWord(xe.name, p.loc.start, !0, !0), p.local || (p.local = Dr(xe));
            }
            return this.finishImportSpecifier(p, "ImportSpecifier", pe);
          }
          isThisParam(p) {
            return p.type === "Identifier" && p.name === "this";
          }
        }
        class Tc extends $l {
          constructor(p, w) {
            super(p = function(q) {
              if (q == null) return Object.assign({}, ii);
              if (q.annexB != null && q.annexB !== !1) throw new Error("The `annexB` option can only be set to `false`.");
              const ne = {};
              for (const xe of Object.keys(ii)) {
                var pe;
                ne[xe] = (pe = q[xe]) != null ? pe : ii[xe];
              }
              return ne;
            }(p), w), this.options = p, this.initializeScopes(), this.plugins = function(q) {
              const ne = /* @__PURE__ */ new Map();
              for (const pe of q) {
                const [xe, Ce] = Array.isArray(pe) ? pe : [pe, {}];
                ne.has(xe) || ne.set(xe, Ce || {});
              }
              return ne;
            }(this.options.plugins), this.filename = p.sourceFilename;
          }
          getScopeHandler() {
            return Xe;
          }
          parse() {
            this.enterInitialScopes();
            const p = this.startNode(), w = this.startNode();
            return this.nextToken(), p.errors = null, this.parseTopLevel(p, w), p.errors = this.state.errors, p.comments.length = this.state.commentsLen, p;
          }
        }
        const Yp = function(Te) {
          const p = {};
          for (const w of Object.keys(Te)) p[w] = ee(Te[w]);
          return p;
        }(N);
        function ja(Te, p) {
          let w = Tc;
          return Te != null && Te.plugins && (function(q) {
            if (fr(q, "decorators")) {
              if (fr(q, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              const ne = en(q, "decorators", "decoratorsBeforeExport");
              if (ne != null && typeof ne != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
              const pe = en(q, "decorators", "allowCallParenthesized");
              if (pe != null && typeof pe != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (fr(q, "flow") && fr(q, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
            if (fr(q, "placeholders") && fr(q, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (fr(q, "pipelineOperator")) {
              const ne = en(q, "pipelineOperator", "proposal");
              if (!bi.includes(ne)) {
                const Ce = bi.map((Re) => `"${Re}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${Ce}.`);
              }
              const pe = ["recordAndTuple", { syntaxType: "hash" }], xe = fr(q, pe);
              if (ne === "hack") {
                if (fr(q, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (fr(q, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                const Ce = en(q, "pipelineOperator", "topicToken");
                if (!fa.includes(Ce)) {
                  const Re = fa.map((Ue) => `"${Ue}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${Re}.`);
                }
                if (Ce === "#" && xe) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(pe)}\`.`);
              } else if (ne === "smart" && xe) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(pe)}\`.`);
            }
            if (fr(q, "moduleAttributes")) {
              if (fr(q, "importAssertions") || fr(q, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
              if (en(q, "moduleAttributes", "version") !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (fr(q, "importAssertions") && fr(q, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
            if (fr(q, "recordAndTuple")) {
              const ne = en(q, "recordAndTuple", "syntaxType");
              if (ne != null) {
                const pe = ["hash", "bar"];
                if (!pe.includes(ne)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + pe.map((xe) => `'${xe}'`).join(", "));
              }
            }
            if (fr(q, "asyncDoExpressions") && !fr(q, "doExpressions")) {
              const ne = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw ne.missingPlugins = "doExpressions", ne;
            }
            if (fr(q, "optionalChainingAssign") && en(q, "optionalChainingAssign", "version") !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
          }(Te.plugins), w = function(q) {
            const ne = Lt.filter((Ce) => fr(q, Ce)), pe = ne.join("/");
            let xe = kn[pe];
            if (!xe) {
              xe = Tc;
              for (const Ce of ne) xe = So[Ce](xe);
              kn[pe] = xe;
            }
            return xe;
          }(Te.plugins)), new w(Te, p);
        }
        const kn = {};
        n.parse = function(Te, p) {
          var w;
          if (((w = p) == null ? void 0 : w.sourceType) !== "unambiguous") return ja(p, Te).parse();
          p = Object.assign({}, p);
          try {
            p.sourceType = "module";
            const q = ja(p, Te), ne = q.parse();
            if (q.sawUnambiguousESM) return ne;
            if (q.ambiguousScriptDifferentAst) try {
              return p.sourceType = "script", ja(p, Te).parse();
            } catch {
            }
            else ne.program.sourceType = "script";
            return ne;
          } catch (q) {
            try {
              return p.sourceType = "script", ja(p, Te).parse();
            } catch {
            }
            throw q;
          }
        }, n.parseExpression = function(Te, p) {
          const w = ja(p, Te);
          return w.options.strictMode && (w.state.strict = !0), w.getExpression();
        }, n.tokTypes = Yp;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-proposal-decorators/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), s = u("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js");
        n.default = (0, i.declare)((o, y) => {
          o.assertVersion(7);
          var { legacy: m } = y;
          const { version: g } = y;
          if (m || g === "legacy") return { name: "proposal-decorators", inherits: c.default, visitor: s.default };
          if (g && g !== "2018-09" && g !== "2021-12" && g !== "2022-03" && g !== "2023-01" && g !== "2023-05" && g !== "2023-11") throw new Error("The '.version' option must be one of 'legacy', '2023-11', '2023-05', '2023-01', '2022-03', or '2021-12'.");
          return o.assertVersion("^7.0.2"), (0, f.createClassFeaturePlugin)({ name: "proposal-decorators", api: o, feature: f.FEATURES.decorators, inherits: c.default, decoratorVersion: g });
        });
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        const c = i.template.statement(`
  DECORATOR(CLASS_REF = INNER) || CLASS_REF;
`), f = (0, i.template)(`
  CLASS_REF.prototype;
`), s = (0, i.template)(`
    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);
`), o = (0, i.template)(`
    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function(){
            return TEMP;
        }
    })
`), y = /* @__PURE__ */ new WeakSet();
        function m(O) {
          const D = (O.isClass() ? [O, ...O.get("body.body")] : O.get("properties")).reduce(($, I) => $.concat(I.node.decorators || []), []).filter(($) => !i.types.isIdentifier($.expression));
          if (D.length !== 0) return i.types.sequenceExpression(D.map(($) => {
            const I = $.expression, k = $.expression = O.scope.generateDeclaredUidIdentifier("dec");
            return i.types.assignmentExpression("=", k, I);
          }).concat([O.node]));
        }
        function g(O) {
          var D;
          return !((D = O.decorators) == null || !D.length);
        }
        function b(O) {
          return O.some((D) => {
            var $;
            return ($ = D.decorators) == null ? void 0 : $.length;
          });
        }
        function v(O, D, $) {
          const I = O.scope.generateDeclaredUidIdentifier(O.isClass() ? "class" : "obj"), k = $.reduce(function(L, M) {
            let x = [];
            if (M.decorators != null && (x = M.decorators, M.decorators = null), x.length === 0) return L;
            if (M.computed) throw O.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            const _ = i.types.isLiteral(M.key) ? M.key : i.types.stringLiteral(M.key.name), S = O.isClass() && !M.static ? f({ CLASS_REF: I }).expression : I;
            if (i.types.isClassProperty(M, { static: !1 })) {
              const C = O.scope.generateDeclaredUidIdentifier("descriptor"), R = M.value ? i.types.functionExpression(null, [], i.types.blockStatement([i.types.returnStatement(M.value)])) : i.types.nullLiteral();
              M.value = i.types.callExpression(D.addHelper("initializerWarningHelper"), [C, i.types.thisExpression()]), y.add(M.value), L.push(i.types.assignmentExpression("=", i.types.cloneNode(C), i.types.callExpression(D.addHelper("applyDecoratedDescriptor"), [i.types.cloneNode(S), i.types.cloneNode(_), i.types.arrayExpression(x.map((H) => i.types.cloneNode(H.expression))), i.types.objectExpression([i.types.objectProperty(i.types.identifier("configurable"), i.types.booleanLiteral(!0)), i.types.objectProperty(i.types.identifier("enumerable"), i.types.booleanLiteral(!0)), i.types.objectProperty(i.types.identifier("writable"), i.types.booleanLiteral(!0)), i.types.objectProperty(i.types.identifier("initializer"), R)])])));
            } else L.push(i.types.callExpression(D.addHelper("applyDecoratedDescriptor"), [i.types.cloneNode(S), i.types.cloneNode(_), i.types.arrayExpression(x.map((C) => i.types.cloneNode(C.expression))), i.types.isObjectProperty(M) || i.types.isClassProperty(M, { static: !0 }) ? o({ TEMP: O.scope.generateDeclaredUidIdentifier("init"), TARGET: i.types.cloneNode(S), PROPERTY: i.types.cloneNode(_) }).expression : s({ TARGET: i.types.cloneNode(S), PROPERTY: i.types.cloneNode(_) }).expression, i.types.cloneNode(S)]));
            return L;
          }, []);
          return i.types.sequenceExpression([i.types.assignmentExpression("=", i.types.cloneNode(I), O.node), i.types.sequenceExpression(k), i.types.cloneNode(I)]);
        }
        function T({ node: O, scope: D }) {
          if (!g(O) && !b(O.body.body)) return;
          const $ = O.id ? i.types.cloneNode(O.id) : D.generateUidIdentifier("class");
          return i.types.variableDeclaration("let", [i.types.variableDeclarator($, i.types.toExpression(O))]);
        }
        const E = { ExportDefaultDeclaration(O) {
          const D = O.get("declaration");
          if (!D.isClassDeclaration()) return;
          const $ = T(D);
          if ($) {
            const [I] = O.replaceWithMultiple([$, i.types.exportNamedDeclaration(null, [i.types.exportSpecifier(i.types.cloneNode($.declarations[0].id), i.types.identifier("default"))])]);
            D.node.id || O.scope.registerDeclaration(I);
          }
        }, ClassDeclaration(O) {
          const D = T(O);
          if (D) {
            const [$] = O.replaceWith(D), I = $.get("declarations.0"), k = I.node.id, L = O.scope.getOwnBinding(k.name);
            L.identifier = k, L.path = I;
          }
        }, ClassExpression(O, D) {
          const $ = m(O) || function(I) {
            if (!g(I.node)) return;
            const k = I.node.decorators || [];
            I.node.decorators = null;
            const L = I.scope.generateDeclaredUidIdentifier("class");
            return k.map((M) => M.expression).reverse().reduce(function(M, x) {
              return c({ CLASS_REF: i.types.cloneNode(L), DECORATOR: i.types.cloneNode(x), INNER: M }).expression;
            }, I.node);
          }(O) || function(I, k) {
            if (b(I.node.body.body)) return v(I, k, I.node.body.body);
          }(O, D);
          $ && O.replaceWith($);
        }, ObjectExpression(O, D) {
          const $ = m(O) || function(I, k) {
            if (b(I.node.properties)) return v(I, k, I.node.properties.filter((L) => L.type !== "SpreadElement"));
          }(O, D);
          $ && O.replaceWith($);
        }, AssignmentExpression(O, D) {
          y.has(O.node.right) && O.replaceWith(i.types.callExpression(D.addHelper("initializerDefineProperty"), [i.types.cloneNode(O.get("left.object").node), i.types.stringLiteral(O.get("left.property").node.name || O.get("left.property").node.value), i.types.cloneNode(O.get("right.arguments")[0].node), i.types.cloneNode(O.get("right.arguments")[1].node)]));
        }, CallExpression(O, D) {
          O.node.arguments.length === 3 && y.has(O.node.arguments[2]) && O.node.callee.name === D.addHelper("defineProperty").name && O.replaceWith(i.types.callExpression(D.addHelper("initializerDefineProperty"), [i.types.cloneNode(O.get("arguments")[0].node), i.types.cloneNode(O.get("arguments")[1].node), i.types.cloneNode(O.get("arguments.2.arguments")[0].node), i.types.cloneNode(O.get("arguments.2.arguments")[1].node)]));
        } };
        n.default = E;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-decorators/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js");
        n.default = (0, i.declare)((c, f) => {
          c.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          let { version: s } = f;
          {
            const { legacy: y } = f;
            if (y !== void 0) {
              if (typeof y != "boolean") throw new Error(".legacy must be a boolean.");
              if (s !== void 0) throw new Error("You can either use the .legacy or the .version option, not both.");
            }
            if (s === void 0) s = y ? "legacy" : "2018-09";
            else if (s !== "2023-11" && s !== "2023-05" && s !== "2023-01" && s !== "2022-03" && s !== "2021-12" && s !== "2018-09" && s !== "legacy") throw new Error("Unsupported decorators version: " + s);
            var { decoratorsBeforeExport: o } = f;
            if (o === void 0) {
              if (s === "2021-12" || s === "2022-03") o = !1;
              else if (s === "2018-09") throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.");
            } else {
              if (s === "legacy" || s === "2022-03" || s === "2023-01") throw new Error(`'decoratorsBeforeExport' can't be used with ${s} decorators.`);
              if (typeof o != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
          }
          return { name: "syntax-decorators", manipulateOptions({ generatorOpts: y }, m) {
            s === "legacy" ? m.plugins.push("decorators-legacy") : s === "2023-01" || s === "2023-05" || s === "2023-11" ? m.plugins.push(["decorators", { allowCallParenthesized: !1 }], "decoratorAutoAccessors") : s === "2022-03" ? m.plugins.push(["decorators", { decoratorsBeforeExport: !1, allowCallParenthesized: !1 }], "decoratorAutoAccessors") : s === "2021-12" ? (m.plugins.push(["decorators", { decoratorsBeforeExport: o }], "decoratorAutoAccessors"), y.decoratorsBeforeExport = o) : s === "2018-09" && (m.plugins.push(["decorators", { decoratorsBeforeExport: o }]), y.decoratorsBeforeExport = o);
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js");
        n.default = (0, i.declare)((c) => (c.assertVersion(7), { name: "syntax-import-assertions", manipulateOptions(f, s) {
          s.plugins.push("importAssertions");
        } }));
      }, "./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-jsx/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js");
        n.default = (0, i.declare)((c) => (c.assertVersion(7), { name: "syntax-jsx", manipulateOptions(f, s) {
          s.plugins.some((o) => (Array.isArray(o) ? o[0] : o) === "typescript") || s.plugins.push("jsx");
        } }));
      }, "./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-typescript/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = function(f, s) {
          const o = [];
          f.forEach((y, m) => {
            (Array.isArray(y) ? y[0] : y) === s && o.unshift(m);
          });
          for (const y of o) f.splice(y, 1);
        };
        n.default = (0, i.declare)((f, s) => {
          f.assertVersion(7);
          const { disallowAmbiguousJSXLike: o, dts: y } = s;
          var { isTSX: m } = s;
          return { name: "syntax-typescript", manipulateOptions(g, b) {
            {
              const { plugins: v } = b;
              c(v, "flow"), c(v, "jsx"), v.push("objectRestSpread", "classProperties"), m && v.push("jsx");
            }
            b.plugins.push(["typescript", { disallowAmbiguousJSXLike: o, dts: y }]);
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        n.default = (0, i.declare)((f) => (f.assertVersion(7), { name: "transform-export-namespace-from", inherits: f.version[0] === "8" ? void 0 : u("./node_modules/.pnpm/@babel+plugin-syntax-export-namespace-from@7.8.3_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-export-namespace-from/lib/index.js").A, visitor: { ExportNamedDeclaration(s) {
          var o;
          const { node: y, scope: m } = s, { specifiers: g } = y, b = c.types.isExportDefaultSpecifier(g[0]) ? 1 : 0;
          if (!c.types.isExportNamespaceSpecifier(g[b])) return;
          const v = [];
          b === 1 && v.push(c.types.exportNamedDeclaration(null, [g.shift()], y.source));
          const T = g.shift(), { exported: E } = T, O = m.generateUidIdentifier((o = E.name) != null ? o : E.value);
          v.push(c.types.importDeclaration([c.types.importNamespaceSpecifier(O)], c.types.cloneNode(y.source)), c.types.exportNamedDeclaration(null, [c.types.exportSpecifier(c.types.cloneNode(O), E)])), y.specifiers.length >= 1 && v.push(y);
          const [D] = s.replaceWithMultiple(v);
          s.scope.registerDeclaration(D);
        } } }));
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.transformDynamicImport = function(o, y, m) {
          const g = y ? f : s;
          o.replaceWith((0, c.buildDynamicImport)(o.node, !0, !1, (b) => g(b, m)));
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/index.js");
        const f = (o) => i.template.expression.ast`require(${o})`, s = (o, y) => i.types.callExpression(y.addHelper("interopRequireWildcard"), [f(o)]);
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.defineCommonJSHook = function(c, f) {
          let s = c.get(u);
          s || c.set(u, s = []), s.push(f);
        }, n.makeInvokers = function(c) {
          const f = c.get(u);
          return { getWrapperPayload: (...s) => i(f, (o) => o.getWrapperPayload == null ? void 0 : o.getWrapperPayload(...s)), wrapReference: (...s) => i(f, (o) => o.wrapReference == null ? void 0 : o.wrapReference(...s)), buildRequireWrapper: (...s) => i(f, (o) => o.buildRequireWrapper == null ? void 0 : o.buildRequireWrapper(...s)) };
        };
        const u = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
        function i(c, f) {
          if (c) for (const s of c) {
            const o = f(s);
            if (o != null) return o;
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, Object.defineProperty(n, "defineCommonJSHook", { enumerable: !0, get: function() {
          return m.defineCommonJSHook;
        } });
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-simple-access@7.24.7/node_modules/@babel/helper-simple-access/lib/index.js"), s = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), o = u("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"), y = u("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js"), m = u("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js");
        n.default = (0, i.declare)((g, b) => {
          var v, T, E;
          g.assertVersion(7);
          const { strictNamespace: O = !1, mjsStrictNamespace: D = O, allowTopLevelThis: $, strict: I, strictMode: k, noInterop: L, importInterop: M, lazy: x = !1, allowCommonJSExports: _ = !0, loose: S = !1 } = b, C = (v = g.assumption("constantReexports")) != null ? v : S, R = (T = g.assumption("enumerableModuleMeta")) != null ? T : S, H = (E = g.assumption("noIncompleteNsImportDetection")) != null && E;
          if (!(typeof x == "boolean" || typeof x == "function" || Array.isArray(x) && x.every((P) => typeof P == "string"))) throw new Error(".lazy must be a boolean, array of strings, or a function");
          if (typeof O != "boolean") throw new Error(".strictNamespace must be a boolean, or undefined");
          if (typeof D != "boolean") throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
          const z = (P) => s.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${P}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, U = { ReferencedIdentifier(P) {
            const W = P.node.name;
            if (W !== "module" && W !== "exports") return;
            const B = P.scope.getBinding(W);
            this.scope.getBinding(W) !== B || P.parentPath.isObjectProperty({ value: P.node }) && P.parentPath.parentPath.isObjectPattern() || P.parentPath.isAssignmentExpression({ left: P.node }) || P.isAssignmentExpression({ left: P.node }) || P.replaceWith(z(W));
          }, UpdateExpression(P) {
            const W = P.get("argument");
            if (!W.isIdentifier()) return;
            const B = W.node.name;
            if (B !== "module" && B !== "exports") return;
            const Q = P.scope.getBinding(B);
            this.scope.getBinding(B) === Q && P.replaceWith(s.types.assignmentExpression(P.node.operator[0] + "=", W.node, z(B)));
          }, AssignmentExpression(P) {
            const W = P.get("left");
            if (W.isIdentifier()) {
              const B = W.node.name;
              if (B !== "module" && B !== "exports") return;
              const Q = P.scope.getBinding(B);
              if (this.scope.getBinding(B) !== Q) return;
              const J = P.get("right");
              J.replaceWith(s.types.sequenceExpression([J.node, z(B)]));
            } else if (W.isPattern()) {
              const B = W.getOuterBindingIdentifiers(), Q = Object.keys(B).filter((J) => (J === "module" || J === "exports") && this.scope.getBinding(J) === P.scope.getBinding(J))[0];
              if (Q) {
                const J = P.get("right");
                J.replaceWith(s.types.sequenceExpression([J.node, z(Q)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs"), x && (0, m.defineCommonJSHook)(this.file, (0, y.lazyImportsHook)(x));
          }, visitor: { ["CallExpression" + (g.types.importExpression ? "|ImportExpression" : "")](P) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import") || P.isCallExpression() && !s.types.isImport(P.node.callee)) return;
            let { scope: W } = P;
            do
              W.rename("require");
            while (W = W.parent);
            (0, o.transformDynamicImport)(P, L, this.file);
          }, Program: { exit(P, W) {
            if (!(0, c.isModule)(P)) return;
            P.scope.rename("exports"), P.scope.rename("module"), P.scope.rename("require"), P.scope.rename("__filename"), P.scope.rename("__dirname"), _ || ((0, f.default)(P, /* @__PURE__ */ new Set(["module", "exports"]), !1), P.traverse(U, { scope: P.scope }));
            let B = (0, c.getModuleName)(this.file.opts, b);
            B && (B = s.types.stringLiteral(B));
            const Q = (0, m.makeInvokers)(this.file), { meta: J, headers: re } = (0, c.rewriteModuleStatementsAndPrepareHeader)(P, { exportName: "exports", constantReexports: C, enumerableModuleMeta: R, strict: I, strictMode: k, allowTopLevelThis: $, noInterop: L, importInterop: M, wrapReference: Q.wrapReference, getWrapperPayload: Q.getWrapperPayload, esNamespaceOnly: typeof W.filename == "string" && /\.mjs$/.test(W.filename) ? D : O, noIncompleteNsImportDetection: H, filename: this.file.opts.filename });
            for (const [G, N] of J.source) {
              const V = s.types.callExpression(s.types.identifier("require"), [s.types.stringLiteral(G)]);
              let F;
              if ((0, c.isSideEffectImport)(N)) {
                if (x && N.wrap === "function") throw new Error("Assertion failure");
                F = s.types.expressionStatement(V);
              } else {
                const X = (0, c.wrapInterop)(P, V, N.interop) || V;
                if (N.wrap) {
                  const K = Q.buildRequireWrapper(N.name, X, N.wrap, N.referenced);
                  if (K === !1) continue;
                  F = K;
                }
                F != null || (F = s.template.statement.ast`
                var ${N.name} = ${X};
              `);
              }
              F.loc = N.loc, re.push(F), re.push(...(0, c.buildNamespaceInitStatements)(J, N, C, Q.wrapReference));
            }
            (0, c.ensureStatementsHoisted)(re), P.unshiftContainer("body", re), P.get("body").forEach((G) => {
              re.indexOf(G.node) !== -1 && G.isVariableDeclaration() && G.scope.registerDeclaration(G);
            });
          } } } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.lazyImportsHook = void 0;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-module-transforms@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-module-transforms/lib/index.js");
        n.lazyImportsHook = (f) => ({ name: "@babel/plugin-transform-modules-commonjs/lazy", version: "7.24.7", getWrapperPayload: (s, o) => (0, c.isSideEffectImport)(o) || o.reexportAll ? null : f === !0 ? /\./.test(s) ? null : "lazy/function" : Array.isArray(f) ? f.indexOf(s) === -1 ? null : "lazy/function" : typeof f == "function" ? f(s) ? "lazy/function" : null : void 0, buildRequireWrapper(s, o, y, m) {
          if (y === "lazy/function") return !!m && i.template.statement.ast`
        function ${s}() {
          const data = ${o};
          ${s} = function(){ return data; };
          return data;
        }
      `;
        }, wrapReference(s, o) {
          if (o === "lazy/function") return i.types.callExpression(s, []);
        } });
      }, "./node_modules/.pnpm/@babel+plugin-transform-nullish-coalescing-operator@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js");
        n.default = (0, i.declare)((f, { loose: s = !1 }) => {
          var o;
          f.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          const y = (o = f.assumption("noDocumentAll")) != null ? o : s;
          return { name: "transform-nullish-coalescing-operator", inherits: f.version[0] === "8" ? void 0 : u("./node_modules/.pnpm/@babel+plugin-syntax-nullish-coalescing-operator@7.8.3_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib/index.js").A, visitor: { LogicalExpression(m) {
            const { node: g, scope: b } = m;
            if (g.operator !== "??") return;
            let v, T;
            if (b.isStatic(g.left)) v = g.left, T = c.types.cloneNode(g.left);
            else {
              if (b.path.isPattern()) return void m.replaceWith(c.template.statement.ast`(() => ${m.node})()`);
              v = b.generateUidIdentifierBasedOnNode(g.left), b.push({ id: c.types.cloneNode(v) }), T = c.types.assignmentExpression("=", v, g.left);
            }
            m.replaceWith(c.types.conditionalExpression(y ? c.types.binaryExpression("!=", T, c.types.nullLiteral()) : c.types.logicalExpression("&&", c.types.binaryExpression("!==", T, c.types.nullLiteral()), c.types.binaryExpression("!==", c.types.cloneNode(v), b.buildUndefinedNode())), c.types.cloneNode(v), g.right));
          } } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-optional-chaining@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 });
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.24.7/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        function s($) {
          const I = o($), { node: k, parentPath: L } = I;
          if (L.isLogicalExpression()) {
            const { operator: M, right: x } = L.node;
            if (M === "&&" || M === "||" || M === "??" && k === x) return s(L);
          }
          if (L.isSequenceExpression()) {
            const { expressions: M } = L.node;
            return M[M.length - 1] !== k || s(L);
          }
          return L.isConditional({ test: k }) || L.isUnaryExpression({ operator: "!" }) || L.isLoop({ test: k });
        }
        function o($) {
          let I = $;
          return $.findParent((k) => {
            if (!f.isTransparentExprWrapper(k.node)) return !0;
            I = k;
          }), I;
        }
        const y = ($) => $[$.length - 1];
        function m($) {
          return $ = f.skipTransparentExprWrapperNodes($), c.types.isIdentifier($) || c.types.isSuper($) || c.types.isMemberExpression($) && !$.computed && m($.object);
        }
        const g = c.template.expression("%%check%% === null || %%ref%% === void 0"), b = c.template.expression("%%check%% == null"), v = c.template.expression("%%check%% !== null && %%ref%% !== void 0"), T = c.template.expression("%%check%% != null");
        function E($, { pureGetters: I, noDocumentAll: k }, L, M, x) {
          const { scope: _ } = $;
          if (_.path.isPattern() && function(G) {
            let N = G;
            const { scope: V } = G;
            for (; N.isOptionalMemberExpression() || N.isOptionalCallExpression(); ) {
              const { node: F } = N, X = f.skipTransparentExprWrappers(N.isOptionalMemberExpression() ? N.get("object") : N.get("callee"));
              if (F.optional) return !V.isStatic(X.node);
              N = X;
            }
          }($)) return void L.replaceWith(c.template.expression.ast`(() => ${L.node})()`);
          const S = [];
          let C = $;
          for (; C.isOptionalMemberExpression() || C.isOptionalCallExpression(); ) {
            const { node: G } = C;
            G.optional && S.push(G), C.isOptionalMemberExpression() ? (C.node.type = "MemberExpression", C = f.skipTransparentExprWrappers(C.get("object"))) : C.isOptionalCallExpression() && (C.node.type = "CallExpression", C = f.skipTransparentExprWrappers(C.get("callee")));
          }
          if (S.length === 0) return;
          const R = [];
          let H;
          for (let G = S.length - 1; G >= 0; G--) {
            const N = S[G], V = c.types.isCallExpression(N), F = V ? N.callee : N.object, X = f.skipTransparentExprWrapperNodes(F);
            let K, ie;
            if (V && c.types.isIdentifier(X, { name: "eval" }) ? (ie = K = X, N.callee = c.types.sequenceExpression([c.types.numericLiteral(0), K])) : I && V && m(X) ? ie = K = N.callee : _.isStatic(X) ? ie = K = F : (H && !V || (H = _.generateUidIdentifierBasedOnNode(X), _.push({ id: c.types.cloneNode(H) })), K = H, ie = c.types.assignmentExpression("=", c.types.cloneNode(H), F), V ? N.callee = K : N.object = K), V && c.types.isMemberExpression(X)) if (I && m(X)) N.callee = F;
            else {
              const { object: _e } = X;
              let Ae;
              if (c.types.isSuper(_e)) Ae = c.types.thisExpression();
              else {
                const ce = _.maybeGenerateMemoised(_e);
                ce ? (Ae = ce, X.object = c.types.assignmentExpression("=", ce, _e)) : Ae = _e;
              }
              N.arguments.unshift(c.types.cloneNode(Ae)), N.callee = c.types.memberExpression(N.callee, c.types.identifier("call"));
            }
            const fe = { check: c.types.cloneNode(ie), ref: c.types.cloneNode(K) };
            Object.defineProperty(fe, "ref", { enumerable: !1 }), R.push(fe);
          }
          let z = L.node;
          x && (z = x(z));
          const U = c.types.isBooleanLiteral(M), P = U && M.value === !1, W = !U && c.types.isUnaryExpression(M, { operator: "void" }), B = c.types.isExpressionStatement(L.parent) && !L.isCompletionRecord() || c.types.isSequenceExpression(L.parent) && y(L.parent.expressions) !== L.node, Q = P ? k ? T : v : k ? b : g, J = P ? "&&" : "||", re = R.map(Q).reduce((G, N) => c.types.logicalExpression(J, G, N));
          L.replaceWith(U || W && B ? c.types.logicalExpression(J, re, z) : c.types.conditionalExpression(re, M, z));
        }
        function O($, I) {
          const { scope: k } = $, L = o($), { parentPath: M } = L;
          if (M.isUnaryExpression({ operator: "delete" })) E($, I, M, c.types.booleanLiteral(!0));
          else {
            let x;
            M.isCallExpression({ callee: L.node }) && $.isOptionalMemberExpression() && (x = (_) => {
              var S;
              const C = f.skipTransparentExprWrapperNodes(_.object);
              let R;
              return I.pureGetters && m(C) || (R = k.maybeGenerateMemoised(C), R && (_.object = c.types.assignmentExpression("=", R, C))), c.types.callExpression(c.types.memberExpression(_, c.types.identifier("bind")), [c.types.cloneNode((S = R) != null ? S : C)]);
            }), E($, I, $, s(L) ? c.types.booleanLiteral(!1) : k.buildUndefinedNode(), x);
          }
        }
        var D = i.declare(($, I) => {
          var k, L;
          $.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          const { loose: M = !1 } = I, x = (k = $.assumption("noDocumentAll")) != null ? k : M, _ = (L = $.assumption("pureGetters")) != null ? L : M;
          return { name: "transform-optional-chaining", inherits: $.version[0] === "8" ? void 0 : u("./node_modules/.pnpm/@babel+plugin-syntax-optional-chaining@7.8.3_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-optional-chaining/lib/index.js").A, visitor: { "OptionalCallExpression|OptionalMemberExpression"(S) {
            O(S, { noDocumentAll: x, pureGetters: _ });
          } } };
        });
        n.default = D, n.transform = O, n.transformOptionalChain = E;
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          const { name: s } = c.node.id, o = c.parentPath.isExportNamedDeclaration();
          let y = o;
          !y && f.isProgram(c.parent) && (y = c.parent.body.some((b) => f.isExportNamedDeclaration(b) && b.exportKind !== "type" && !b.source && b.specifiers.some((v) => f.isExportSpecifier(v) && v.exportKind !== "type" && v.local.name === s)));
          const { enumValues: m } = (0, i.translateEnumValues)(c, f);
          if (y) {
            const b = f.objectExpression(m.map(([v, T]) => f.objectProperty(f.isValidIdentifier(v) ? f.identifier(v) : f.stringLiteral(v), T)));
            return void (c.scope.hasOwnBinding(s) ? (o ? c.parentPath : c).replaceWith(f.expressionStatement(f.callExpression(f.memberExpression(f.identifier("Object"), f.identifier("assign")), [c.node.id, b]))) : (c.replaceWith(f.variableDeclaration("var", [f.variableDeclarator(c.node.id, b)])), c.scope.registerDeclaration(c)));
          }
          const g = new Map(m);
          c.scope.path.traverse({ Scope(b) {
            b.scope.hasOwnBinding(s) && b.skip();
          }, MemberExpression(b) {
            if (!f.isIdentifier(b.node.object, { name: s })) return;
            let v;
            if (b.node.computed) {
              if (!f.isStringLiteral(b.node.property)) return;
              v = b.node.property.value;
            } else {
              if (!f.isIdentifier(b.node.property)) return;
              v = b.node.property.name;
            }
            g.has(v) && b.replaceWith(f.cloneNode(g.get(v)));
          } }), c.remove();
        };
        var i = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/enum.js");
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/enum.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(O, D) {
          const { node: $, parentPath: I } = O;
          if ($.declare) return void O.remove();
          const k = $.id.name, { fill: L, data: M, isPure: x } = function(_, S, C) {
            const { enumValues: R, data: H, isPure: z } = T(_, S), U = R.map(([P, W]) => g(S.isStringLiteral(W), { ENUM: S.cloneNode(C), NAME: P, VALUE: W }));
            return { fill: { ID: S.cloneNode(C), ASSIGNMENTS: U }, data: H, isPure: z };
          }(O, D, $.id);
          switch (I.type) {
            case "BlockStatement":
            case "ExportNamedDeclaration":
            case "Program": {
              const _ = D.isProgram(O.parent), S = function H(z) {
                return z.isExportDeclaration() ? H(z.parentPath) : !!z.getData(k) || (z.setData(k, !0), !1);
              }(I);
              let C = D.objectExpression([]);
              (S || _) && (C = D.logicalExpression("||", D.cloneNode(L.ID), C));
              const R = o(Object.assign({}, L, { INIT: C }));
              x && (0, f.default)(R), S ? (I.isExportDeclaration() ? I : O).replaceWith(D.expressionStatement(D.assignmentExpression("=", D.cloneNode($.id), R))) : O.scope.registerDeclaration(O.replaceWith(D.variableDeclaration(_ ? "var" : "let", [D.variableDeclarator($.id, R)]))[0]), s.set(O.scope.getBindingIdentifier(k), M);
              break;
            }
            default:
              throw new Error(`Unexpected enum parent '${O.parent.type}`);
          }
        }, n.translateEnumValues = T;
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("assert"), f = u("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.24.7/node_modules/@babel/helper-annotate-as-pure/lib/index.js");
        const s = /* @__PURE__ */ new WeakMap(), o = i.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `), y = (0, i.template)(`
  ENUM["NAME"] = VALUE;
`), m = (0, i.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), g = (O, D) => (O ? y : m)(D);
        function b(O, D) {
          const { seen: $, path: I, t: k } = D, L = O.node.name;
          $.has(L) && !O.scope.hasOwnBinding(L) && (O.replaceWith(k.memberExpression(k.cloneNode(I.node.id), k.cloneNode(O.node))), O.skip());
        }
        const v = { ReferencedIdentifier: b };
        function T(O, D) {
          var $;
          const I = O.scope.getBindingIdentifier(O.node.id.name), k = ($ = s.get(I)) != null ? $ : /* @__PURE__ */ new Map();
          let L, M = -1, x = !0;
          const _ = O.get("members").map((S) => {
            const C = S.node, R = D.isIdentifier(C.id) ? C.id.name : C.id.value, H = S.get("initializer");
            let z;
            if (C.initializer) M = E(H, k), M !== void 0 ? (k.set(R, M), c(typeof M == "number" || typeof M == "string"), z = M === 1 / 0 || Number.isNaN(M) ? D.identifier(String(M)) : M === -1 / 0 ? D.unaryExpression("-", D.identifier("Infinity")) : D.valueToNode(M)) : (x && (x = H.isPure()), H.isReferencedIdentifier() ? b(H, { t: D, seen: k, path: O }) : H.traverse(v, { t: D, seen: k, path: O }), z = H.node, k.set(R, void 0));
            else if (typeof M == "number") M += 1, z = D.numericLiteral(M), k.set(R, M);
            else {
              if (typeof M == "string") throw O.buildCodeFrameError("Enum member must have initializer.");
              {
                const U = D.memberExpression(D.cloneNode(O.node.id), D.stringLiteral(L), !0);
                z = D.binaryExpression("+", D.numericLiteral(1), U), k.set(R, void 0);
              }
            }
            return L = R, [R, z];
          });
          return { isPure: x, data: k, enumValues: _ };
        }
        function E(O, D, $ = /* @__PURE__ */ new Set()) {
          return I(O);
          function I(L) {
            const M = L.node;
            switch (M.type) {
              case "MemberExpression":
              case "Identifier":
                return k(L, D, $);
              case "StringLiteral":
              case "NumericLiteral":
                return M.value;
              case "UnaryExpression":
                return function(x) {
                  const _ = I(x.get("argument"));
                  if (_ !== void 0)
                    switch (x.node.operator) {
                      case "+":
                        return _;
                      case "-":
                        return -_;
                      case "~":
                        return ~_;
                      default:
                        return;
                    }
                }(L);
              case "BinaryExpression":
                return function(x) {
                  const _ = I(x.get("left"));
                  if (_ === void 0) return;
                  const S = I(x.get("right"));
                  if (S !== void 0)
                    switch (x.node.operator) {
                      case "|":
                        return _ | S;
                      case "&":
                        return _ & S;
                      case ">>":
                        return _ >> S;
                      case ">>>":
                        return _ >>> S;
                      case "<<":
                        return _ << S;
                      case "^":
                        return _ ^ S;
                      case "*":
                        return _ * S;
                      case "/":
                        return _ / S;
                      case "+":
                        return _ + S;
                      case "-":
                        return _ - S;
                      case "%":
                        return _ % S;
                      case "**":
                        return Math.pow(_, S);
                      default:
                        return;
                    }
                }(L);
              case "ParenthesizedExpression":
                return I(L.get("expression"));
              case "TemplateLiteral": {
                if (M.quasis.length === 1) return M.quasis[0].value.cooked;
                const x = L.get("expressions"), _ = M.quasis;
                let S = "";
                for (let C = 0; C < _.length; C++) if (S += _[C].value.cooked, C + 1 < _.length) {
                  const R = k(x[C], D, $);
                  if (R === void 0) return;
                  S += R;
                }
                return S;
              }
              default:
                return;
            }
          }
          function k(L, M, x) {
            if (L.isMemberExpression()) {
              const _ = L.node, S = _.object, C = _.property;
              if (!i.types.isIdentifier(S) || (_.computed ? !i.types.isStringLiteral(C) : !i.types.isIdentifier(C))) return;
              const R = L.scope.getBindingIdentifier(S.name), H = s.get(R);
              return H ? H.get(C.computed ? C.value : C.name) : void 0;
            }
            if (L.isIdentifier()) {
              const _ = L.node.name;
              if (["Infinity", "NaN"].includes(_)) return Number(_);
              let S = M == null ? void 0 : M.get(_);
              return S !== void 0 ? S : x.has(L.node) ? void 0 : (x.add(L.node), S = E(L.resolve(), M, x), M == null || M.set(_, S), S);
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/global-types.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.GLOBAL_TYPES = void 0, n.isGlobalType = function({ scope: i }, c) {
          return !i.hasBinding(c) && (!!u.get(i).has(c) || (console.warn(`The exported identifier "${c}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${c}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1));
        }, n.registerGlobalType = function(i, c) {
          u.get(i).add(c);
        };
        const u = n.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-typescript/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.24.7_@babel+core@7.24.7/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), s = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"), o = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/enum.js"), y = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/global-types.js"), m = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/namespace.js");
        function g(O) {
          switch (O.parent.type) {
            case "TSTypeReference":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return !0;
            case "TSQualifiedName":
              return O.parentPath.findParent((D) => D.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
            case "ExportSpecifier":
              return O.parent.exportKind === "type" || O.parentPath.parent.exportKind === "type";
            default:
              return !1;
          }
        }
        const b = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakSet();
        function T(O) {
          const D = O.getBindingIdentifiers();
          for (const $ of Object.keys(D)) {
            const I = O.scope.getBinding($);
            I && I.identifier === D[$] && I.scope.removeBinding($);
          }
          O.opts.noScope = !0, O.remove(), O.opts.noScope = !1;
        }
        function E(O, D, $, I, k = "") {
          if (D.file.get("@babel/plugin-transform-modules-*") !== "commonjs") throw O.buildCodeFrameError(`\`${$}\` is only supported when compiling modules to CommonJS.
Please consider using \`${I}\`${k}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
        }
        n.default = (0, i.declare)((O, D) => {
          const { types: $, template: I } = O;
          O.assertVersion(7);
          const k = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/, { allowNamespaces: L = !0, jsxPragma: M = "React.createElement", jsxPragmaFrag: x = "React.Fragment", onlyRemoveTypeImports: _ = !1, optimizeConstEnums: S = !1 } = D;
          var { allowDeclareFields: C = !1 } = D;
          const R = { field(P) {
            const { node: W } = P;
            if (!C && W.declare) throw P.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
            if (W.declare) {
              if (W.value) throw P.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
              W.decorators || P.remove();
            } else if (W.definite) {
              if (W.value) throw P.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
              C || W.decorators || $.isClassPrivateProperty(W) || P.remove();
            } else W.abstract ? P.remove() : C || W.value || W.decorators || $.isClassPrivateProperty(W) || P.remove();
            W.accessibility && (W.accessibility = null), W.abstract && (W.abstract = null), W.readonly && (W.readonly = null), W.optional && (W.optional = null), W.typeAnnotation && (W.typeAnnotation = null), W.definite && (W.definite = null), W.declare && (W.declare = null), W.override && (W.override = null);
          }, method({ node: P }) {
            P.accessibility && (P.accessibility = null), P.abstract && (P.abstract = null), P.optional && (P.optional = null), P.override && (P.override = null);
          }, constructor(P, W) {
            P.node.accessibility && (P.node.accessibility = null);
            const B = [], { scope: Q } = P;
            for (const J of P.get("params")) {
              const re = J.node;
              if (re.type === "TSParameterProperty") {
                const G = re.parameter;
                if (v.has(G)) continue;
                let N;
                if (v.add(G), $.isIdentifier(G)) N = G;
                else {
                  if (!$.isAssignmentPattern(G) || !$.isIdentifier(G.left)) throw J.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                  N = G.left;
                }
                B.push(I.statement.ast`
              this.${$.cloneNode(N)} = ${$.cloneNode(N)}
            `), J.replaceWith(J.get("parameter")), Q.registerBinding("param", J);
              }
            }
            (0, f.injectInitialization)(W, P, B);
          } };
          return { name: "transform-typescript", inherits: c.default, visitor: { Pattern: z, Identifier: z, RestElement: z, Program: { enter(P, W) {
            const { file: B } = W;
            let Q = null, J = null;
            const re = P.scope;
            if (y.GLOBAL_TYPES.has(re) || y.GLOBAL_TYPES.set(re, /* @__PURE__ */ new Set()), B.ast.comments) for (const V of B.ast.comments) {
              const F = k.exec(V.value);
              F && (F[1] ? J = F[2] : Q = F[2]);
            }
            let G = Q || M;
            G && ([G] = G.split("."));
            let N = J || x;
            N && ([N] = N.split("."));
            for (let V of P.get("body")) if (V.isImportDeclaration()) {
              if (b.has(W.file.ast.program) || b.set(W.file.ast.program, !0), V.node.importKind === "type") {
                for (const ie of V.node.specifiers) (0, y.registerGlobalType)(re, ie.local.name);
                V.remove();
                continue;
              }
              const F = /* @__PURE__ */ new Set(), X = V.node.specifiers.length, K = () => X > 0 && X === F.size;
              for (const ie of V.node.specifiers) if (ie.type === "ImportSpecifier" && ie.importKind === "type") {
                (0, y.registerGlobalType)(re, ie.local.name);
                const fe = V.scope.getBinding(ie.local.name);
                fe && F.add(fe.path);
              }
              if (_) b.set(P.node, !1);
              else {
                if (V.node.specifiers.length === 0) {
                  b.set(P.node, !1);
                  continue;
                }
                for (const ie of V.node.specifiers) {
                  const fe = V.scope.getBinding(ie.local.name);
                  fe && !F.has(fe.path) && (U({ binding: fe, programPath: P, pragmaImportName: G, pragmaFragImportName: N }) ? F.add(fe.path) : b.set(P.node, !1));
                }
              }
              if (K() && !_) V.remove();
              else for (const ie of F) ie.remove();
            } else if (V.isExportDeclaration() && (V = V.get("declaration")), V.isVariableDeclaration({ declare: !0 })) for (const F of Object.keys(V.getBindingIdentifiers())) (0, y.registerGlobalType)(re, F);
            else (V.isTSTypeAliasDeclaration() || V.isTSDeclareFunction() && V.get("id").isIdentifier() || V.isTSInterfaceDeclaration() || V.isClassDeclaration({ declare: !0 }) || V.isTSEnumDeclaration({ declare: !0 }) || V.isTSModuleDeclaration({ declare: !0 }) && V.get("id").isIdentifier()) && (0, y.registerGlobalType)(re, V.node.id.name);
          }, exit(P) {
            P.node.sourceType === "module" && b.get(P.node) && P.pushContainer("body", $.exportNamedDeclaration());
          } }, ExportNamedDeclaration(P, W) {
            if (b.has(W.file.ast.program) || b.set(W.file.ast.program, !0), P.node.exportKind !== "type") if (P.node.source && P.node.specifiers.length > 0 && P.node.specifiers.every((B) => B.type === "ExportSpecifier" && B.exportKind === "type")) P.remove();
            else if (!P.node.source && P.node.specifiers.length > 0 && P.node.specifiers.every((B) => $.isExportSpecifier(B) && (0, y.isGlobalType)(P, B.local.name))) P.remove();
            else {
              if ($.isTSModuleDeclaration(P.node.declaration)) {
                const B = P.node.declaration, { id: Q } = B;
                if ($.isIdentifier(Q)) if (P.scope.hasOwnBinding(Q.name)) P.replaceWith(B);
                else {
                  const [J] = P.replaceWithMultiple([$.exportNamedDeclaration($.variableDeclaration("let", [$.variableDeclarator($.cloneNode(Q))])), B]);
                  P.scope.registerDeclaration(J);
                }
              }
              b.set(W.file.ast.program, !1);
            }
            else P.remove();
          }, ExportAllDeclaration(P) {
            P.node.exportKind === "type" && P.remove();
          }, ExportSpecifier(P) {
            (!P.parent.source && (0, y.isGlobalType)(P, P.node.local.name) || P.node.exportKind === "type") && P.remove();
          }, ExportDefaultDeclaration(P, W) {
            b.has(W.file.ast.program) || b.set(W.file.ast.program, !0), $.isIdentifier(P.node.declaration) && (0, y.isGlobalType)(P, P.node.declaration.name) ? P.remove() : b.set(W.file.ast.program, !1);
          }, TSDeclareFunction(P) {
            T(P);
          }, TSDeclareMethod(P) {
            T(P);
          }, VariableDeclaration(P) {
            P.node.declare && T(P);
          }, VariableDeclarator({ node: P }) {
            P.definite && (P.definite = null);
          }, TSIndexSignature(P) {
            P.remove();
          }, ClassDeclaration(P) {
            const { node: W } = P;
            W.declare && T(P);
          }, Class(P) {
            const { node: W } = P;
            W.typeParameters && (W.typeParameters = null), W.superTypeParameters && (W.superTypeParameters = null), W.implements && (W.implements = null), W.abstract && (W.abstract = null), P.get("body.body").forEach((B) => {
              B.isClassMethod() || B.isClassPrivateMethod() ? B.node.kind === "constructor" ? R.constructor(B, P) : R.method(B) : (B.isClassProperty() || B.isClassPrivateProperty() || B.isClassAccessorProperty()) && R.field(B);
            });
          }, Function(P) {
            const { node: W } = P;
            W.typeParameters && (W.typeParameters = null), W.returnType && (W.returnType = null);
            const B = W.params;
            B.length > 0 && $.isIdentifier(B[0], { name: "this" }) && B.shift();
          }, TSModuleDeclaration(P) {
            (0, m.default)(P, L);
          }, TSInterfaceDeclaration(P) {
            P.remove();
          }, TSTypeAliasDeclaration(P) {
            P.remove();
          }, TSEnumDeclaration(P) {
            S && P.node.const ? (0, s.default)(P, $) : (0, o.default)(P, $);
          }, TSImportEqualsDeclaration(P, W) {
            const { id: B, moduleReference: Q } = P.node;
            let J, re;
            $.isTSExternalModuleReference(Q) ? (E(P, W, `import ${B.name} = require(...);`, `import ${B.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), J = $.callExpression($.identifier("require"), [Q.expression]), re = "const") : (J = H(Q), re = "var"), P.replaceWith($.variableDeclaration(re, [$.variableDeclarator(B, J)])), P.scope.registerDeclaration(P);
          }, TSExportAssignment(P, W) {
            E(P, W, "export = <value>;", "export default <value>;"), P.replaceWith(I.statement.ast`module.exports = ${P.node.expression}`);
          }, TSTypeAssertion(P) {
            P.replaceWith(P.node.expression);
          }, ["TSAsExpression" + ($.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](P) {
            let { node: W } = P;
            do
              W = W.expression;
            while ($.isTSAsExpression(W) || $.isTSSatisfiesExpression != null && $.isTSSatisfiesExpression(W));
            P.replaceWith(W);
          }, [O.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](P) {
            P.replaceWith(P.node.expression);
          }, CallExpression(P) {
            P.node.typeParameters = null;
          }, OptionalCallExpression(P) {
            P.node.typeParameters = null;
          }, NewExpression(P) {
            P.node.typeParameters = null;
          }, JSXOpeningElement(P) {
            P.node.typeParameters = null;
          }, TaggedTemplateExpression(P) {
            P.node.typeParameters = null;
          } } };
          function H(P) {
            return $.isTSQualifiedName(P) ? $.memberExpression(H(P.left), P.right) : P;
          }
          function z({ node: P }) {
            P.typeAnnotation && (P.typeAnnotation = null), $.isIdentifier(P) && P.optional && (P.optional = null);
          }
          function U({ binding: P, programPath: W, pragmaImportName: B, pragmaFragImportName: Q }) {
            for (const re of P.referencePaths) if (!g(re)) return !1;
            if (P.identifier.name !== B && P.identifier.name !== Q) return !0;
            let J = !1;
            return W.traverse({ "JSXElement|JSXFragment"(re) {
              J = !0, re.stop();
            } }), !J;
          }
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/namespace.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(g, b) {
          if (g.node.declare || g.node.id.type === "StringLiteral") return void g.remove();
          if (!b) throw g.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const v = g.node.id.name, T = m(g, i.types.cloneNode(g.node, !0));
          if (T === null) {
            const E = g.findParent((O) => O.isProgram());
            (0, c.registerGlobalType)(E.scope, v), g.remove();
          } else g.scope.hasOwnBinding(v) ? g.replaceWith(T) : g.scope.registerDeclaration(g.replaceWithMultiple([f(v), T])[0]);
        };
        var i = u("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), c = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/global-types.js");
        function f(g) {
          return i.types.variableDeclaration("let", [i.types.variableDeclarator(i.types.identifier(g))]);
        }
        function s(g, b) {
          return i.types.memberExpression(i.types.identifier(g), i.types.identifier(b));
        }
        function o(g, b, v) {
          if (g.kind !== "const") throw v.file.buildCodeFrameError(g, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const { declarations: T } = g;
          if (T.every((D) => i.types.isIdentifier(D.id))) {
            for (const D of T) D.init = i.types.assignmentExpression("=", s(b, D.id.name), D.init);
            return [g];
          }
          const E = i.types.getBindingIdentifiers(g), O = [];
          for (const D in E) O.push(i.types.assignmentExpression("=", s(b, D), i.types.cloneNode(E[D])));
          return [g, i.types.expressionStatement(i.types.sequenceExpression(O))];
        }
        function y(g, b) {
          return g.hub.buildError(b, "Ambient modules cannot be nested in other modules or namespaces.", Error);
        }
        function m(g, b, v) {
          const T = /* @__PURE__ */ new Set(), E = b.id;
          i.types.assertIdentifier(E);
          const O = g.scope.generateUid(E.name), D = i.types.isTSModuleBlock(b.body) ? b.body.body : [i.types.exportNamedDeclaration(b.body)];
          let $ = !0;
          for (let k = 0; k < D.length; k++) {
            const L = D[k];
            switch (L.type) {
              case "TSModuleDeclaration": {
                if (!i.types.isIdentifier(L.id)) throw y(g, L);
                const M = m(g, L);
                if (M !== null) {
                  $ = !1;
                  const x = L.id.name;
                  T.has(x) ? D[k] = M : (T.add(x), D.splice(k++, 1, f(x), M));
                }
                continue;
              }
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration":
                $ = !1, T.add(L.id.name);
                continue;
              case "VariableDeclaration":
                $ = !1;
                for (const M in i.types.getBindingIdentifiers(L)) T.add(M);
                continue;
              default:
                $ && ($ = i.types.isTypeScript(L));
                continue;
              case "ExportNamedDeclaration":
            }
            if (!("declare" in L.declaration) || !L.declaration.declare) switch (L.declaration.type) {
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration": {
                $ = !1;
                const M = L.declaration.id.name;
                T.add(M), D.splice(k++, 1, L.declaration, i.types.expressionStatement(i.types.assignmentExpression("=", s(O, M), i.types.identifier(M))));
                break;
              }
              case "VariableDeclaration": {
                $ = !1;
                const M = o(L.declaration, O, g.hub);
                D.splice(k, M.length, ...M), k += M.length - 1;
                break;
              }
              case "TSModuleDeclaration": {
                if (!i.types.isIdentifier(L.declaration.id)) throw y(g, L.declaration);
                const M = m(g, L.declaration, i.types.identifier(O));
                if (M !== null) {
                  $ = !1;
                  const x = L.declaration.id.name;
                  T.has(x) ? D[k] = M : (T.add(x), D.splice(k++, 1, f(x), M));
                } else D.splice(k, 1), k--;
              }
            }
          }
          if ($) return null;
          let I = i.types.objectExpression([]);
          if (v) {
            const k = i.types.memberExpression(v, E);
            I = i.template.expression.ast`
      ${i.types.cloneNode(k)} ||
        (${i.types.cloneNode(k)} = ${I})
    `;
          }
          return i.template.statement.ast`
    (function (${i.types.identifier(O)}) {
      ${D}
    })(${E} || (${i.types.cloneNode(E)} = ${I}));
  `;
        }
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/preset-typescript/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 });
        var i = u("./node_modules/.pnpm/@babel+helper-plugin-utils@7.24.7/node_modules/@babel/helper-plugin-utils/lib/index.js"), c = u("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/index.js");
        u("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-jsx/lib/index.js");
        var f = u("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), s = u("./node_modules/.pnpm/@babel+helper-validator-option@7.24.7/node_modules/@babel/helper-validator-option/lib/index.js");
        function o(T) {
          return T && T.__esModule ? T : { default: T };
        }
        var y = o(c), m = o(f);
        const g = new s.OptionValidator("@babel/preset-typescript");
        var b = i.declare(function({ types: T }) {
          return { name: "preset-typescript/plugin-rewrite-ts-imports", visitor: { "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"({ node: E }) {
            const { source: O } = E;
            (T.isImportDeclaration(E) ? E.importKind : E.exportKind) === "value" && O && /[\\/]/.test(O.value) && (O.value = O.value.replace(/(\.[mc]?)ts$/, "$1js").replace(/\.tsx$/, ".js"));
          } } };
        }), v = i.declarePreset((T, E) => {
          T.assertVersion(7);
          const { allExtensions: O, ignoreExtensions: D, allowNamespaces: $, disallowAmbiguousJSXLike: I, isTSX: k, jsxPragma: L, jsxPragmaFrag: M, onlyRemoveTypeImports: x, optimizeConstEnums: _, rewriteImportExtensions: S } = function(H = {}) {
            let { allowNamespaces: z = !0, jsxPragma: U, onlyRemoveTypeImports: P } = H;
            const W = "ignoreExtensions", B = "disallowAmbiguousJSXLike", Q = "jsxPragmaFrag", J = "optimizeConstEnums", re = "rewriteImportExtensions", G = "allExtensions", N = "isTSX", V = g.validateStringOption(Q, H.jsxPragmaFrag, "React.Fragment");
            var F = g.validateBooleanOption(G, H.allExtensions, !1), X = g.validateBooleanOption(N, H.isTSX, !1);
            X && g.invariant(F, "isTSX:true requires allExtensions:true");
            const K = g.validateBooleanOption(W, H.ignoreExtensions, !1), ie = g.validateBooleanOption(B, H.disallowAmbiguousJSXLike, !1);
            ie && g.invariant(F, "disallowAmbiguousJSXLike:true requires allExtensions:true");
            const fe = { ignoreExtensions: K, allowNamespaces: z, disallowAmbiguousJSXLike: ie, jsxPragma: U, jsxPragmaFrag: V, onlyRemoveTypeImports: P, optimizeConstEnums: g.validateBooleanOption(J, H.optimizeConstEnums, !1), rewriteImportExtensions: g.validateBooleanOption(re, H.rewriteImportExtensions, !1) };
            return fe.allExtensions = F, fe.isTSX = X, fe;
          }(E), C = (H) => ({ allowDeclareFields: E.allowDeclareFields, allowNamespaces: $, disallowAmbiguousJSXLike: H, jsxPragma: L, jsxPragmaFrag: M, onlyRemoveTypeImports: x, optimizeConstEnums: _ }), R = (H, z) => [[y.default, Object.assign({ isTSX: H }, C(z))]];
          return { plugins: S ? [b] : [], overrides: O || D ? [{ plugins: R(k, I) }] : [{ test: /\.ts$/, plugins: R(!1, !1) }, { test: /\.mts$/, sourceType: "module", plugins: R(!1, !0) }, { test: /\.cts$/, sourceType: "unambiguous", plugins: [[m.default, { allowTopLevelThis: !0 }], [y.default, C(!0)]] }, { test: /\.tsx$/, plugins: R(!0, !1) }] };
        });
        n.default = v;
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/builder.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function y(m, g) {
          const b = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap(), T = g || (0, i.validate)(null);
          return Object.assign((E, ...O) => {
            if (typeof E == "string") {
              if (O.length > 1) throw new Error("Unexpected extra params.");
              return o((0, c.default)(m, E, (0, i.merge)(T, (0, i.validate)(O[0]))));
            }
            if (Array.isArray(E)) {
              let D = b.get(E);
              return D || (D = (0, f.default)(m, E, T), b.set(E, D)), o(D(O));
            }
            if (typeof E == "object" && E) {
              if (O.length > 0) throw new Error("Unexpected extra params.");
              return y(m, (0, i.merge)(T, (0, i.validate)(E)));
            }
            throw new Error("Unexpected template param " + typeof E);
          }, { ast: (E, ...O) => {
            if (typeof E == "string") {
              if (O.length > 1) throw new Error("Unexpected extra params.");
              return (0, c.default)(m, E, (0, i.merge)((0, i.merge)(T, (0, i.validate)(O[0])), s))();
            }
            if (Array.isArray(E)) {
              let D = v.get(E);
              return D || (D = (0, f.default)(m, E, (0, i.merge)(T, s)), v.set(E, D)), D(O)();
            }
            throw new Error("Unexpected template param " + typeof E);
          } });
        };
        var i = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/options.js"), c = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/string.js"), f = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/literal.js");
        const s = (0, i.validate)({ placeholderPattern: !1 });
        function o(y) {
          let m = "";
          try {
            throw new Error();
          } catch (g) {
            g.stack && (m = g.stack.split(`
`).slice(3).join(`
`));
          }
          return (g) => {
            try {
              return y(g);
            } catch (b) {
              throw b.stack += `
    =============
${m}`, b;
            }
          };
        }
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/formatters.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.statements = n.statement = n.smart = n.program = n.expression = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { assertExpressionStatement: c } = i;
        function f(o) {
          return { code: (y) => `/* @babel/template */;
${y}`, validate: () => {
          }, unwrap: (y) => o(y.program.body.slice(1)) };
        }
        n.smart = f((o) => o.length > 1 ? o : o[0]), n.statements = f((o) => o), n.statement = f((o) => {
          if (o.length === 0) throw new Error("Found nothing to return.");
          if (o.length > 1) throw new Error("Found multiple statements but wanted one");
          return o[0];
        });
        const s = n.expression = { code: (o) => `(
${o}
)`, validate: (o) => {
          if (o.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
          if (s.unwrap(o).start === 0) throw new Error("Parse result included parens.");
        }, unwrap: ({ program: o }) => {
          const [y] = o.body;
          return c(y), y.expression;
        } };
        n.program = { code: (o) => o, validate: () => {
        }, unwrap: (o) => o.program };
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.statements = n.statement = n.smart = n.program = n.expression = n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/formatters.js"), c = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/builder.js");
        const f = n.smart = (0, c.default)(i.smart), s = n.statement = (0, c.default)(i.statement), o = n.statements = (0, c.default)(i.statements), y = n.expression = (0, c.default)(i.expression), m = n.program = (0, c.default)(i.program);
        n.default = Object.assign(f.bind(void 0), { smart: f, statement: s, statements: o, expression: y, program: m, ast: f.ast });
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/literal.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o, y) {
          const { metadata: m, names: g } = function(b, v, T) {
            let E = "BABEL_TPL$";
            const O = v.join("");
            do
              E = "$$" + E;
            while (O.includes(E));
            const { names: D, code: $ } = function(k, L) {
              const M = [];
              let x = k[0];
              for (let _ = 1; _ < k.length; _++) {
                const S = `${L}${_ - 1}`;
                M.push(S), x += S + k[_];
              }
              return { names: M, code: x };
            }(v, E);
            return { metadata: (0, c.default)(b, b.code($), { parser: T.parser, placeholderWhitelist: new Set(D.concat(T.placeholderWhitelist ? Array.from(T.placeholderWhitelist) : [])), placeholderPattern: T.placeholderPattern, preserveComments: T.preserveComments, syntacticPlaceholders: T.syntacticPlaceholders }), names: D };
          }(s, o, y);
          return (b) => {
            const v = {};
            return b.forEach((T, E) => {
              v[g[E]] = T;
            }), (T) => {
              const E = (0, i.normalizeReplacements)(T);
              return E && Object.keys(E).forEach((O) => {
                if (hasOwnProperty.call(v, O)) throw new Error("Unexpected replacement overlap.");
              }), s.unwrap((0, f.default)(m, E ? Object.assign(E, v) : v));
            };
          };
        };
        var i = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/options.js"), c = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/parse.js"), f = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/options.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.merge = function(i, c) {
          const { placeholderWhitelist: f = i.placeholderWhitelist, placeholderPattern: s = i.placeholderPattern, preserveComments: o = i.preserveComments, syntacticPlaceholders: y = i.syntacticPlaceholders } = c;
          return { parser: Object.assign({}, i.parser, c.parser), placeholderWhitelist: f, placeholderPattern: s, preserveComments: o, syntacticPlaceholders: y };
        }, n.normalizeReplacements = function(i) {
          if (Array.isArray(i)) return i.reduce((c, f, s) => (c["$" + s] = f, c), {});
          if (typeof i == "object" || i == null) return i || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, n.validate = function(i) {
          if (i != null && typeof i != "object") throw new Error("Unknown template options.");
          const c = i || {}, { placeholderWhitelist: f, placeholderPattern: s, preserveComments: o, syntacticPlaceholders: y } = c, m = function(g, b) {
            if (g == null) return {};
            var v, T, E = {}, O = Object.keys(g);
            for (T = 0; T < O.length; T++) v = O[T], b.indexOf(v) >= 0 || (E[v] = g[v]);
            return E;
          }(c, u);
          if (f != null && !(f instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (s != null && !(s instanceof RegExp) && s !== !1) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (o != null && typeof o != "boolean") throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (y != null && typeof y != "boolean") throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (y === !0 && (f != null || s != null)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser: m, placeholderWhitelist: f || void 0, placeholderPattern: s ?? void 0, preserveComments: o ?? void 0, syntacticPlaceholders: y ?? void 0 };
        };
        const u = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/parse.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(k, L, M) {
          const { placeholderWhitelist: x, placeholderPattern: _, preserveComments: S, syntacticPlaceholders: C } = M, R = function(z, U, P) {
            const W = (U.plugins || []).slice();
            P !== !1 && W.push("placeholders"), U = Object.assign({ allowReturnOutsideFunction: !0, allowSuperOutsideMethod: !0, sourceType: "module" }, U, { plugins: W });
            try {
              return (0, c.parse)(z, U);
            } catch (B) {
              const Q = B.loc;
              throw Q && (B.message += `
` + (0, f.codeFrameColumns)(z, { start: Q }), B.code = "BABEL_TEMPLATE_PARSE_ERROR"), B;
            }
          }(L, M.parser, C);
          O(R, { preserveComments: S }), k.validate(R);
          const H = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: x, placeholderPattern: _, syntacticPlaceholders: C };
          return D(R, I, H), Object.assign({ ast: R }, H.syntactic.placeholders.length ? H.syntactic : H.legacy);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+parser@7.24.7/node_modules/@babel/parser/lib/index.js"), f = u("./stubs/babel-codeframe.js");
        const { isCallExpression: s, isExpressionStatement: o, isFunction: y, isIdentifier: m, isJSXIdentifier: g, isNewExpression: b, isPlaceholder: v, isStatement: T, isStringLiteral: E, removePropertiesDeep: O, traverse: D } = i, $ = /^[_$A-Z0-9]+$/;
        function I(k, L, M) {
          var x;
          let _, S = M.syntactic.placeholders.length > 0;
          if (v(k)) {
            if (M.syntacticPlaceholders === !1) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            _ = k.name.name, S = !0;
          } else {
            if (S || M.syntacticPlaceholders) return;
            if (m(k) || g(k)) _ = k.name;
            else {
              if (!E(k)) return;
              _ = k.value;
            }
          }
          if (S && (M.placeholderPattern != null || M.placeholderWhitelist != null)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (!(S || M.placeholderPattern !== !1 && (M.placeholderPattern || $).test(_) || (x = M.placeholderWhitelist) != null && x.has(_))) return;
          L = L.slice();
          const { node: C, key: R } = L[L.length - 1];
          let H;
          E(k) || v(k, { expectedNode: "StringLiteral" }) ? H = "string" : b(C) && R === "arguments" || s(C) && R === "arguments" || y(C) && R === "params" ? H = "param" : o(C) && !v(k) ? (H = "statement", L = L.slice(0, -1)) : H = T(k) && v(k) ? "statement" : "other";
          const { placeholders: z, placeholderNames: U } = S ? M.syntactic : M.legacy;
          z.push({ name: _, type: H, resolve: (P) => function(W, B) {
            let Q = W;
            for (let G = 0; G < B.length - 1; G++) {
              const { key: N, index: V } = B[G];
              Q = V === void 0 ? Q[N] : Q[N][V];
            }
            const { key: J, index: re } = B[B.length - 1];
            return { parent: Q, key: J, index: re };
          }(P, L), isDuplicate: U.has(_) }), U.add(_);
        }
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/populate.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(T, E) {
          const O = f(T.ast);
          return E && (T.placeholders.forEach((D) => {
            if (!hasOwnProperty.call(E, D.name)) {
              const $ = D.name;
              throw new Error(`Error: No substitution given for "${$}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${$}'])}
            - { placeholderPattern: /^${$}$/ }`);
            }
          }), Object.keys(E).forEach((D) => {
            if (!T.placeholderNames.has(D)) throw new Error(`Unknown substitution "${D}" given`);
          })), T.placeholders.slice().reverse().forEach((D) => {
            try {
              (function($, I, k) {
                $.isDuplicate && (Array.isArray(k) ? k = k.map((_) => f(_)) : typeof k == "object" && (k = f(k)));
                const { parent: L, key: M, index: x } = $.resolve(I);
                if ($.type === "string") {
                  if (typeof k == "string" && (k = b(k)), !k || !g(k)) throw new Error("Expected string substitution");
                } else if ($.type === "statement") x === void 0 ? k ? Array.isArray(k) ? k = c(k) : typeof k == "string" ? k = o(y(k)) : m(k) || (k = o(k)) : k = s() : k && !Array.isArray(k) && (typeof k == "string" && (k = y(k)), m(k) || (k = o(k)));
                else if ($.type === "param") {
                  if (typeof k == "string" && (k = y(k)), x === void 0) throw new Error("Assertion failure.");
                } else if (typeof k == "string" && (k = y(k)), Array.isArray(k)) throw new Error("Cannot replace single expression with an array.");
                if (x === void 0) v(L, M, k), L[M] = k;
                else {
                  const _ = L[M].slice();
                  $.type === "statement" || $.type === "param" ? k == null ? _.splice(x, 1) : Array.isArray(k) ? _.splice(x, 1, ...k) : _[x] = k : _[x] = k, v(L, M, _), L[M] = _;
                }
              })(D, O, E && E[D.name] || null);
            } catch ($) {
              throw $.message = `@babel/template placeholder "${D.name}": ${$.message}`, $;
            }
          }), O;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { blockStatement: c, cloneNode: f, emptyStatement: s, expressionStatement: o, identifier: y, isStatement: m, isStringLiteral: g, stringLiteral: b, validate: v } = i;
      }, "./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/string.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o, y) {
          let m;
          return o = s.code(o), (g) => {
            const b = (0, i.normalizeReplacements)(g);
            return m || (m = (0, c.default)(s, o, y)), s.unwrap((0, f.default)(m, b));
          };
        };
        var i = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/options.js"), c = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/parse.js"), f = u("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.clear = function() {
          c(), f();
        }, n.clearPath = c, n.clearScope = f, n.getCachedPaths = function(o, y) {
          var m;
          return (m = u.get(s)) == null ? void 0 : m.get(y);
        }, n.getOrCreateCachedPaths = function(o, y) {
          let m = u.get(s);
          m || u.set(s, m = /* @__PURE__ */ new WeakMap());
          let g = m.get(y);
          return g || m.set(y, g = /* @__PURE__ */ new Map()), g;
        }, n.scope = n.path = void 0;
        let u = n.path = /* @__PURE__ */ new WeakMap(), i = n.scope = /* @__PURE__ */ new WeakMap();
        function c() {
          n.path = u = /* @__PURE__ */ new WeakMap();
        }
        function f() {
          n.scope = i = /* @__PURE__ */ new WeakMap();
        }
        const s = Object.freeze({});
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/context.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: f } = c;
        n.default = class {
          constructor(s, o, y, m) {
            this.queue = null, this.priorityQueue = null, this.parentPath = m, this.scope = s, this.state = y, this.opts = o;
          }
          shouldVisit(s) {
            const o = this.opts;
            if (o.enter || o.exit || o[s.type]) return !0;
            const y = f[s.type];
            if (y == null || !y.length) return !1;
            for (const m of y) if (s[m]) return !0;
            return !1;
          }
          create(s, o, y, m) {
            return i.default.get({ parentPath: this.parentPath, parent: s, container: o, key: y, listKey: m });
          }
          maybeQueue(s, o) {
            this.queue && (o ? this.queue.push(s) : this.priorityQueue.push(s));
          }
          visitMultiple(s, o, y) {
            if (s.length === 0) return !1;
            const m = [];
            for (let g = 0; g < s.length; g++) {
              const b = s[g];
              b && this.shouldVisit(b) && m.push(this.create(o, s, g, y));
            }
            return this.visitQueue(m);
          }
          visitSingle(s, o) {
            return !!this.shouldVisit(s[o]) && this.visitQueue([this.create(s, s, o)]);
          }
          visitQueue(s) {
            this.queue = s, this.priorityQueue = [];
            const o = /* @__PURE__ */ new WeakSet();
            let y = !1, m = 0;
            for (; m < s.length; ) {
              const g = s[m];
              if (m++, g.resync(), g.contexts.length !== 0 && g.contexts[g.contexts.length - 1] === this || g.pushContext(this), g.key === null) continue;
              const { node: b } = g;
              if (!o.has(b)) {
                if (b && o.add(b), g.visit()) {
                  y = !0;
                  break;
                }
                if (this.priorityQueue.length && (y = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = s, y)) break;
              }
            }
            for (let g = 0; g < m; g++) s[g].popContext();
            return this.queue = null, y;
          }
          visit(s, o) {
            const y = s[o];
            return !!y && (Array.isArray(y) ? this.visitMultiple(y, s, o) : this.visitSingle(s, o));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/hub.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, n.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(u, i, c = TypeError) {
            return new c(i);
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "Hub", { enumerable: !0, get: function() {
          return m.default;
        } }), Object.defineProperty(n, "NodePath", { enumerable: !0, get: function() {
          return o.default;
        } }), Object.defineProperty(n, "Scope", { enumerable: !0, get: function() {
          return y.default;
        } }), n.visitors = n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/visitors.js");
        n.visitors = i;
        var c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js"), s = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/traverse-node.js"), o = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js"), y = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/index.js"), m = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/hub.js");
        const { VISITOR_KEYS: g, removeProperties: b, traverseFast: v } = c;
        function T(O, D = {}, $, I, k, L) {
          if (O) {
            if (!D.noScope && !$ && O.type !== "Program" && O.type !== "File") throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${O.type} node without passing scope and parentPath.`);
            if (!k && L) throw new Error("visitSelf can only be used when providing a NodePath.");
            g[O.type] && (i.explode(D), (0, s.traverseNode)(O, D, $, I, k, null, L));
          }
        }
        n.default = T;
        function E(O, D) {
          O.node.type === D.type && (D.has = !0, O.stop());
        }
        T.visitors = i, T.verify = i.verify, T.explode = i.explode, T.cheap = function(O, D) {
          v(O, D);
        }, T.node = function(O, D, $, I, k, L) {
          (0, s.traverseNode)(O, D, $, I, k, L);
        }, T.clearNode = function(O, D) {
          b(O, D);
        }, T.removeProperties = function(O, D) {
          return v(O, T.clearNode, D), O;
        }, T.hasType = function(O, D, $) {
          if ($ != null && $.includes(O.type)) return !1;
          if (O.type === D) return !0;
          const I = { has: !1, type: D };
          return T(O, { noScope: !0, denylist: $, enter: E }, null, I), I.has;
        }, T.cache = f;
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/ancestry.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.find = function(f) {
          let s = this;
          do
            if (f(s)) return s;
          while (s = s.parentPath);
          return null;
        }, n.findParent = function(f) {
          let s = this;
          for (; s = s.parentPath; ) if (f(s)) return s;
          return null;
        }, n.getAncestry = function() {
          let f = this;
          const s = [];
          do
            s.push(f);
          while (f = f.parentPath);
          return s;
        }, n.getDeepestCommonAncestorFrom = function(f, s) {
          if (!f.length) return this;
          if (f.length === 1) return f[0];
          let o, y, m = 1 / 0;
          const g = f.map((v) => {
            const T = [];
            do
              T.unshift(v);
            while ((v = v.parentPath) && v !== this);
            return T.length < m && (m = T.length), T;
          }), b = g[0];
          e: for (let v = 0; v < m; v++) {
            const T = b[v];
            for (const E of g) if (E[v] !== T) break e;
            o = v, y = T;
          }
          if (y) return s ? s(y, o, g) : y;
          throw new Error("Couldn't find intersection");
        }, n.getEarliestCommonAncestorFrom = function(f) {
          return this.getDeepestCommonAncestorFrom(f, function(s, o, y) {
            let m;
            const g = c[s.type];
            for (const b of y) {
              const v = b[o + 1];
              if (!m) {
                m = v;
                continue;
              }
              if (v.listKey && m.listKey === v.listKey && v.key < m.key) {
                m = v;
                continue;
              }
              g.indexOf(m.parentKey) > g.indexOf(v.parentKey) && (m = v);
            }
            return m;
          });
        }, n.getFunctionParent = function() {
          return this.findParent((f) => f.isFunction());
        }, n.getStatementParent = function() {
          let f = this;
          do {
            if (!f.parentPath || Array.isArray(f.container) && f.isStatement()) break;
            f = f.parentPath;
          } while (f);
          if (f && (f.isProgram() || f.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return f;
        }, n.inType = function(...f) {
          let s = this;
          for (; s; ) {
            for (const o of f) if (s.node.type === o) return !0;
            s = s.parentPath;
          }
          return !1;
        }, n.isAncestor = function(f) {
          return f.isDescendant(this);
        }, n.isDescendant = function(f) {
          return !!this.findParent((s) => s === f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: c } = i;
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/comments.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.addComment = function(o, y, m) {
          c(this.node, o, y, m);
        }, n.addComments = function(o, y) {
          f(this.node, o, y);
        }, n.shareCommentsWithSiblings = function() {
          if (typeof this.key == "string") return;
          const o = this.node;
          if (!o) return;
          const y = o.trailingComments, m = o.leadingComments;
          if (!y && !m) return;
          const g = this.getSibling(this.key - 1), b = this.getSibling(this.key + 1), v = !!g.node, T = !!b.node;
          v && (m && g.addComments("trailing", s(m, g.node.trailingComments)), y && !T && g.addComments("trailing", y)), T && (y && b.addComments("leading", s(y, b.node.leadingComments)), m && !v && b.addComments("leading", m));
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { addComment: c, addComments: f } = i;
        function s(o, y) {
          if (y == null || !y.length) return o;
          const m = new Set(y);
          return o.filter((g) => !m.has(g));
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/context.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._call = function(s) {
          if (!s) return !1;
          for (const o of s) {
            if (!o) continue;
            const y = this.node;
            if (!y) return !0;
            const m = o.call(this.state, this, this.state);
            if (m && typeof m == "object" && typeof m.then == "function") throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (m) throw new Error(`Unexpected return value from visitor method ${o}`);
            if (this.node !== y || this._traverseFlags > 0) return !0;
          }
          return !1;
        }, n._getQueueContexts = function() {
          let s = this, o = this.contexts;
          for (; !o.length && (s = s.parentPath, s); ) o = s.contexts;
          return o;
        }, n._resyncKey = function() {
          if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
              for (let s = 0; s < this.container.length; s++) if (this.container[s] === this.node) return void this.setKey(s);
            } else for (const s of Object.keys(this.container)) if (this.container[s] === this.node) return void this.setKey(s);
            this.key = null;
          }
        }, n._resyncList = function() {
          if (!this.parent || !this.inList) return;
          const s = this.parent[this.listKey];
          this.container !== s && (this.container = s || null);
        }, n._resyncParent = function() {
          this.parentPath && (this.parent = this.parentPath.node);
        }, n._resyncRemoved = function() {
          this.key != null && this.container && this.container[this.key] === this.node || this._markRemoved();
        }, n.call = function(s) {
          const o = this.opts;
          if (this.debug(s), this.node && this._call(o[s])) return !0;
          var y;
          return !!this.node && this._call((y = o[this.node.type]) == null ? void 0 : y[s]);
        }, n.isBlacklisted = n.isDenylisted = function() {
          var s;
          const o = (s = this.opts.denylist) != null ? s : this.opts.blacklist;
          return o && o.indexOf(this.node.type) > -1;
        }, n.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, n.pushContext = function(s) {
          this.contexts.push(s), this.setContext(s);
        }, n.requeue = function(s = this) {
          if (s.removed) return;
          const o = this.contexts;
          for (const y of o) y.maybeQueue(s);
        }, n.resync = function() {
          this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
        }, n.setContext = function(s) {
          return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, s && (this.context = s, this.state = s.state, this.opts = s.opts), this.setScope(), this;
        }, n.setKey = function(s) {
          var o;
          this.key = s, this.node = this.container[this.key], this.type = (o = this.node) == null ? void 0 : o.type;
        }, n.setScope = function() {
          var s, o;
          if ((s = this.opts) != null && s.noScope) return;
          let y, m = this.parentPath;
          for (((this.key === "key" || this.listKey === "decorators") && m.isMethod() || this.key === "discriminant" && m.isSwitchStatement()) && (m = m.parentPath); m && !y; ) {
            var g;
            if ((g = m.opts) != null && g.noScope) return;
            y = m.scope, m = m.parentPath;
          }
          this.scope = this.getScope(y), (o = this.scope) == null || o.init();
        }, n.setup = function(s, o, y, m) {
          this.listKey = y, this.container = o, this.parentPath = s || this.parentPath, this.setKey(m);
        }, n.skip = function() {
          this.shouldSkip = !0;
        }, n.skipKey = function(s) {
          this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[s] = !0;
        }, n.stop = function() {
          this._traverseFlags |= c.SHOULD_SKIP | c.SHOULD_STOP;
        }, n.visit = function() {
          var s, o;
          if (!this.node || this.isDenylisted() || (s = (o = this.opts).shouldSkip) != null && s.call(o, this)) return !1;
          const y = this.context;
          return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (f(this, y), this.debug("Recursing into..."), this.shouldStop = (0, i.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), f(this, y), this.call("exit"), this.shouldStop);
        };
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/traverse-node.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js");
        function f(s, o) {
          s.context !== o && (s.context = o, s.state = o.state, s.opts = o.opts);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/conversion.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.arrowFunctionToExpression = function({ allowInsertArrow: V = !0, allowInsertArrowWithRest: F = V, noNewArrows: X = !((K) => (K = arguments[0]) == null ? void 0 : K.specCompliant)() } = {}) {
          if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          const { thisBinding: K, fnPath: ie } = Q(this, X, V, F);
          if (ie.ensureBlock(), function(fe, _e) {
            fe.node.type = _e;
          }(ie, "FunctionExpression"), !X) {
            const fe = K ? null : ie.scope.generateUidIdentifier("arrowCheckId");
            return fe && ie.parentPath.scope.push({ id: fe, init: x([]) }), ie.get("body").unshiftContainer("body", T(b(this.hub.addHelper("newArrowCheck"), [U(), E(fe ? fe.name : K)]))), ie.replaceWith(b(k((0, f.default)(this, !0) || ie.node, E("bind")), [fe ? E(fe.name) : U()])), ie.get("callee.object");
          }
          return ie;
        }, n.ensureBlock = function() {
          const V = this.get("body"), F = V.node;
          if (Array.isArray(V)) throw new Error("Can't convert array path to a block statement");
          if (!F) throw new Error("Can't convert node without a body");
          if (V.isBlockStatement()) return F;
          const X = [];
          let K, ie, fe = "body";
          V.isStatement() ? (ie = "body", K = 0, X.push(V.node)) : (fe += ".body.0", this.isFunction() ? (K = "argument", X.push(S(V.node))) : (K = "expression", X.push(T(V.node)))), this.node.body = g(X);
          const _e = this.get(fe);
          return V.setup(_e, ie ? _e.node[ie] : _e.node, ie, K), this.node;
        }, n.toComputedKey = function() {
          let V;
          if (this.isMemberExpression()) V = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
            V = this.node.key;
          }
          return this.node.computed || O(V) && (V = H(V.name)), V;
        }, n.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          Q(this);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-function-name@7.24.7/node_modules/@babel/helper-function-name/lib/index.js"), s = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/visitors.js");
        const { arrowFunctionExpression: o, assignmentExpression: y, binaryExpression: m, blockStatement: g, callExpression: b, conditionalExpression: v, expressionStatement: T, identifier: E, isIdentifier: O, jsxIdentifier: D, logicalExpression: $, LOGICAL_OPERATORS: I, memberExpression: k, metaProperty: L, numericLiteral: M, objectExpression: x, restElement: _, returnStatement: S, sequenceExpression: C, spreadElement: R, stringLiteral: H, super: z, thisExpression: U, toExpression: P, unaryExpression: W } = i;
        n.arrowFunctionToShadowed = function() {
          this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
        };
        const B = (0, s.merge)([{ CallExpression(V, { allSuperCalls: F }) {
          V.get("callee").isSuper() && F.push(V);
        } }, c.default]);
        function Q(V, F = !0, X = !0, K = !0) {
          let ie, fe = V.findParent((ye) => ye.isArrowFunctionExpression() ? (ie != null || (ie = ye), !1) : ye.isFunction() || ye.isProgram() || ye.isClassProperty({ static: !1 }) || ye.isClassPrivateProperty({ static: !1 }));
          const _e = fe.isClassMethod({ kind: "constructor" });
          if (fe.isClassProperty() || fe.isClassPrivateProperty()) if (ie) fe = ie;
          else {
            if (!X) throw V.buildCodeFrameError("Unable to transform arrow inside class property");
            V.replaceWith(b(o([], P(V.node)), [])), fe = V.get("callee"), V = fe.get("body");
          }
          const { thisPaths: Ae, argumentsPaths: ce, newTargetPaths: ee, superProps: ae, superCalls: oe } = function(ye) {
            const we = [], ge = [], se = [], be = [], Ie = [];
            return ye.traverse(N, { thisPaths: we, argumentsPaths: ge, newTargetPaths: se, superProps: be, superCalls: Ie }), { thisPaths: we, argumentsPaths: ge, newTargetPaths: se, superProps: be, superCalls: Ie };
          }(V);
          if (_e && oe.length > 0) {
            if (!X) throw oe[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!K) throw oe[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            const ye = [];
            fe.traverse(B, { allSuperCalls: ye });
            const we = function(ge) {
              return G(ge, "supercall", () => {
                const se = ge.scope.generateUidIdentifier("args");
                return o([_(se)], b(z(), [R(E(se.name))]));
              });
            }(fe);
            ye.forEach((ge) => {
              const se = E(we);
              se.loc = ge.node.callee.loc, ge.get("callee").replaceWith(se);
            });
          }
          if (ce.length > 0) {
            const ye = G(fe, "arguments", () => {
              const we = () => E("arguments");
              return fe.scope.path.isProgram() ? v(m("===", W("typeof", we()), H("undefined")), fe.scope.buildUndefinedNode(), we()) : we();
            });
            ce.forEach((we) => {
              const ge = E(ye);
              ge.loc = we.node.loc, we.replaceWith(ge);
            });
          }
          if (ee.length > 0) {
            const ye = G(fe, "newtarget", () => L(E("new"), E("target")));
            ee.forEach((we) => {
              const ge = E(ye);
              ge.loc = we.node.loc, we.replaceWith(ge);
            });
          }
          if (ae.length > 0) {
            if (!X) throw ae[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            ae.reduce((ye, we) => ye.concat(function(ge) {
              if (ge.parentPath.isAssignmentExpression() && ge.parentPath.node.operator !== "=") {
                const be = ge.parentPath, Ie = be.node.operator.slice(0, -1), Oe = be.node.right, Be = function(Fe) {
                  return I.includes(Fe);
                }(Ie);
                if (ge.node.computed) {
                  const Fe = ge.scope.generateDeclaredUidIdentifier("tmp"), ue = ge.node.object, te = ge.node.property;
                  be.get("left").replaceWith(k(ue, y("=", Fe, te), !0)), be.get("right").replaceWith(se(Be ? "=" : Ie, k(ue, E(Fe.name), !0), Oe));
                } else {
                  const Fe = ge.node.object, ue = ge.node.property;
                  be.get("left").replaceWith(k(Fe, ue)), be.get("right").replaceWith(se(Be ? "=" : Ie, k(Fe, E(ue.name)), Oe));
                }
                return Be ? be.replaceWith($(Ie, be.node.left, be.node.right)) : be.node.operator = "=", [be.get("left"), be.get("right").get("left")];
              }
              if (ge.parentPath.isUpdateExpression()) {
                const be = ge.parentPath, Ie = ge.scope.generateDeclaredUidIdentifier("tmp"), Oe = ge.node.computed ? ge.scope.generateDeclaredUidIdentifier("prop") : null, Be = [y("=", Ie, k(ge.node.object, Oe ? y("=", Oe, ge.node.property) : ge.node.property, ge.node.computed)), y("=", k(ge.node.object, Oe ? E(Oe.name) : ge.node.property, ge.node.computed), m(ge.parentPath.node.operator[0], E(Ie.name), M(1)))];
                return ge.parentPath.node.prefix || Be.push(E(Ie.name)), be.replaceWith(C(Be)), [be.get("expressions.0.right"), be.get("expressions.1.left")];
              }
              return [ge];
              function se(be, Ie, Oe) {
                return be === "=" ? y("=", Ie, Oe) : m(be, Ie, Oe);
              }
            }(we)), []).forEach((ye) => {
              const we = ye.node.computed ? "" : ye.get("property").node.name, ge = ye.parentPath, se = ge.isAssignmentExpression({ left: ye.node }), be = ge.isCallExpression({ callee: ye.node }), Ie = ge.isTaggedTemplateExpression({ tag: ye.node }), Oe = function(ue, te, Y) {
                return G(ue, `superprop_${te ? "set" : "get"}:${Y || ""}`, () => {
                  const Ee = [];
                  let Se;
                  if (Y) Se = k(z(), E(Y));
                  else {
                    const Pe = ue.scope.generateUidIdentifier("prop");
                    Ee.unshift(Pe), Se = k(z(), E(Pe.name), !0);
                  }
                  if (te) {
                    const Pe = ue.scope.generateUidIdentifier("value");
                    Ee.push(Pe), Se = y("=", Se, E(Pe.name));
                  }
                  return o(Ee, Se);
                });
              }(fe, se, we), Be = [];
              if (ye.node.computed && Be.push(ye.get("property").node), se) {
                const ue = ge.node.right;
                Be.push(ue);
              }
              const Fe = b(E(Oe), Be);
              be ? (ge.unshiftContainer("arguments", U()), ye.replaceWith(k(Fe, E("call"))), Ae.push(ge.get("arguments.0"))) : se ? ge.replaceWith(Fe) : Ie ? (ye.replaceWith(b(k(Fe, E("bind"), !1), [U()])), Ae.push(ye.get("arguments.0"))) : ye.replaceWith(Fe);
            });
          }
          let me;
          return (Ae.length > 0 || !F) && (me = function(ye, we) {
            return G(ye, "this", (ge) => {
              if (!we || !J(ye)) return U();
              ye.traverse(re, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: ge });
            });
          }(fe, _e), (F || _e && J(fe)) && (Ae.forEach((ye) => {
            const we = ye.isJSX() ? D(me) : E(me);
            we.loc = ye.node.loc, ye.replaceWith(we);
          }), F || (me = null))), { thisBinding: me, fnPath: V };
        }
        function J(V) {
          return V.isClassMethod() && !!V.parentPath.parentPath.node.superClass;
        }
        const re = (0, s.merge)([{ CallExpression(V, { supers: F, thisBinding: X }) {
          V.get("callee").isSuper() && (F.has(V.node) || (F.add(V.node), V.replaceWithMultiple([V.node, y("=", E(X), E("this"))])));
        } }, c.default]);
        function G(V, F, X) {
          const K = "binding:" + F;
          let ie = V.getData(K);
          if (!ie) {
            const fe = V.scope.generateUidIdentifier(F);
            ie = fe.name, V.setData(K, ie), V.scope.push({ id: fe, init: X(ie) });
          }
          return ie;
        }
        const N = (0, s.merge)([{ ThisExpression(V, { thisPaths: F }) {
          F.push(V);
        }, JSXIdentifier(V, { thisPaths: F }) {
          V.node.name === "this" && (V.parentPath.isJSXMemberExpression({ object: V.node }) || V.parentPath.isJSXOpeningElement({ name: V.node })) && F.push(V);
        }, CallExpression(V, { superCalls: F }) {
          V.get("callee").isSuper() && F.push(V);
        }, MemberExpression(V, { superProps: F }) {
          V.get("object").isSuper() && F.push(V);
        }, Identifier(V, { argumentsPaths: F }) {
          if (!V.isReferencedIdentifier({ name: "arguments" })) return;
          let X = V.scope;
          do {
            if (X.hasOwnBinding("arguments")) return void X.rename("arguments");
            if (X.path.isFunction() && !X.path.isArrowFunctionExpression()) break;
          } while (X = X.parent);
          F.push(V);
        }, MetaProperty(V, { newTargetPaths: F }) {
          V.get("meta").isIdentifier({ name: "new" }) && V.get("property").isIdentifier({ name: "target" }) && F.push(V);
        } }, c.default]);
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/evaluation.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.evaluate = function() {
          const g = { confident: !0, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let b = y(this, g);
          return g.confident || (b = void 0), { confident: g.confident, deopt: g.deoptPath, value: b };
        }, n.evaluateTruthy = function() {
          const g = this.evaluate();
          if (g.confident) return !!g.value;
        };
        const u = ["Number", "String", "Math"], i = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], c = ["random"];
        function f(g) {
          return u.includes(g);
        }
        function s(g, b) {
          b.confident && (b.deoptPath = g, b.confident = !1);
        }
        const o = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
        function y(g, b) {
          const { node: v } = g, { seen: T } = b;
          if (T.has(v)) {
            const E = T.get(v);
            return E.resolved ? E.value : void s(g, b);
          }
          {
            const E = { resolved: !1 };
            T.set(v, E);
            const O = function(D, $) {
              if ($.confident) {
                if (D.isSequenceExpression()) {
                  const I = D.get("expressions");
                  return y(I[I.length - 1], $);
                }
                if (D.isStringLiteral() || D.isNumericLiteral() || D.isBooleanLiteral()) return D.node.value;
                if (D.isNullLiteral()) return null;
                if (D.isTemplateLiteral()) return m(D, D.node.quasis, $);
                if (D.isTaggedTemplateExpression() && D.get("tag").isMemberExpression()) {
                  const I = D.get("tag.object"), { node: { name: k } } = I, L = D.get("tag.property");
                  if (I.isIdentifier() && k === "String" && !D.scope.getBinding(k) && L.isIdentifier() && L.node.name === "raw") return m(D, D.node.quasi.quasis, $, !0);
                }
                if (D.isConditionalExpression()) {
                  const I = y(D.get("test"), $);
                  return $.confident ? y(I ? D.get("consequent") : D.get("alternate"), $) : void 0;
                }
                if (D.isExpressionWrapper()) return y(D.get("expression"), $);
                if (D.isMemberExpression() && !D.parentPath.isCallExpression({ callee: D.node })) {
                  const I = D.get("property"), k = D.get("object");
                  if (k.isLiteral()) {
                    const L = k.node.value, M = typeof L;
                    let x = null;
                    if (D.node.computed) {
                      if (x = y(I, $), !$.confident) return;
                    } else I.isIdentifier() && (x = I.node.name);
                    if (!(M !== "number" && M !== "string" || x == null || typeof x != "number" && typeof x != "string")) return L[x];
                  }
                }
                if (D.isReferencedIdentifier()) {
                  const I = D.scope.getBinding(D.node.name);
                  if (I) {
                    if (I.constantViolations.length > 0 || D.node.start < I.path.node.end) return void s(I.path, $);
                    if (I.hasValue) return I.value;
                  }
                  const k = D.node.name;
                  if (o.has(k)) return I ? void s(I.path, $) : o.get(k);
                  const L = D.resolve();
                  return L === D ? void s(D, $) : y(L, $);
                }
                if (D.isUnaryExpression({ prefix: !0 })) {
                  if (D.node.operator === "void") return;
                  const I = D.get("argument");
                  if (D.node.operator === "typeof" && (I.isFunction() || I.isClass())) return "function";
                  const k = y(I, $);
                  if (!$.confident) return;
                  switch (D.node.operator) {
                    case "!":
                      return !k;
                    case "+":
                      return +k;
                    case "-":
                      return -k;
                    case "~":
                      return ~k;
                    case "typeof":
                      return typeof k;
                  }
                }
                if (D.isArrayExpression()) {
                  const I = [], k = D.get("elements");
                  for (const L of k) {
                    const M = L.evaluate();
                    if (!M.confident) return void s(M.deopt, $);
                    I.push(M.value);
                  }
                  return I;
                }
                if (D.isObjectExpression()) {
                  const I = {}, k = D.get("properties");
                  for (const L of k) {
                    if (L.isObjectMethod() || L.isSpreadElement()) return void s(L, $);
                    const M = L.get("key");
                    let x;
                    if (L.node.computed) {
                      if (x = M.evaluate(), !x.confident) return void s(x.deopt, $);
                      x = x.value;
                    } else x = M.isIdentifier() ? M.node.name : M.node.value;
                    let _ = L.get("value").evaluate();
                    if (!_.confident) return void s(_.deopt, $);
                    _ = _.value, I[x] = _;
                  }
                  return I;
                }
                if (D.isLogicalExpression()) {
                  const I = $.confident, k = y(D.get("left"), $), L = $.confident;
                  $.confident = I;
                  const M = y(D.get("right"), $), x = $.confident;
                  switch (D.node.operator) {
                    case "||":
                      return $.confident = L && (!!k || x), $.confident ? k || M : void 0;
                    case "&&":
                      return $.confident = L && (!k || x), $.confident ? k && M : void 0;
                    case "??":
                      return $.confident = L && (k != null || x), $.confident ? k ?? M : void 0;
                  }
                }
                if (D.isBinaryExpression()) {
                  const I = y(D.get("left"), $);
                  if (!$.confident) return;
                  const k = y(D.get("right"), $);
                  if (!$.confident) return;
                  switch (D.node.operator) {
                    case "-":
                      return I - k;
                    case "+":
                      return I + k;
                    case "/":
                      return I / k;
                    case "*":
                      return I * k;
                    case "%":
                      return I % k;
                    case "**":
                      return Math.pow(I, k);
                    case "<":
                      return I < k;
                    case ">":
                      return I > k;
                    case "<=":
                      return I <= k;
                    case ">=":
                      return I >= k;
                    case "==":
                      return I == k;
                    case "!=":
                      return I != k;
                    case "===":
                      return I === k;
                    case "!==":
                      return I !== k;
                    case "|":
                      return I | k;
                    case "&":
                      return I & k;
                    case "^":
                      return I ^ k;
                    case "<<":
                      return I << k;
                    case ">>":
                      return I >> k;
                    case ">>>":
                      return I >>> k;
                  }
                }
                if (D.isCallExpression()) {
                  const I = D.get("callee");
                  let k, L;
                  if (I.isIdentifier() && !D.scope.getBinding(I.node.name) && (f(I.node.name) || function(M) {
                    return i.includes(M);
                  }(I.node.name)) && (L = jt[I.node.name]), I.isMemberExpression()) {
                    const M = I.get("object"), x = I.get("property");
                    if (M.isIdentifier() && x.isIdentifier() && f(M.node.name) && !function(_) {
                      return c.includes(_);
                    }(x.node.name)) {
                      k = jt[M.node.name];
                      const _ = x.node.name;
                      hasOwnProperty.call(k, _) && (L = k[_]);
                    }
                    if (M.isLiteral() && x.isIdentifier()) {
                      const _ = typeof M.node.value;
                      _ !== "string" && _ !== "number" || (k = M.node.value, L = k[x.node.name]);
                    }
                  }
                  if (L) {
                    const M = D.get("arguments").map((x) => y(x, $));
                    return $.confident ? L.apply(k, M) : void 0;
                  }
                }
                s(D, $);
              }
            }(g, b);
            return b.confident && (E.resolved = !0, E.value = O), O;
          }
        }
        function m(g, b, v, T = !1) {
          let E = "", O = 0;
          const D = g.isTemplateLiteral() ? g.get("expressions") : g.get("quasi.expressions");
          for (const $ of b) {
            if (!v.confident) break;
            E += T ? $.value.raw : $.value.cooked;
            const I = D[O++];
            I && (E += String(y(I, v)));
          }
          if (v.confident) return E;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/family.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._getKey = function(D, $) {
          const I = this.node, k = I[D];
          return Array.isArray(k) ? k.map((L, M) => i.default.get({ listKey: D, parentPath: this, parent: I, container: k, key: M }).setContext($)) : i.default.get({ parentPath: this, parent: I, container: I, key: D }).setContext($);
        }, n._getPattern = function(D, $) {
          let I = this;
          for (const k of D) I = k === "." ? I.parentPath : Array.isArray(I) ? I[k] : I.get(k, $);
          return I;
        }, n.get = function(D, $ = !0) {
          $ === !0 && ($ = this.context);
          const I = D.split(".");
          return I.length === 1 ? this._getKey(D, $) : this._getPattern(I, $);
        }, n.getAllNextSiblings = function() {
          let D = this.key, $ = this.getSibling(++D);
          const I = [];
          for (; $.node; ) I.push($), $ = this.getSibling(++D);
          return I;
        }, n.getAllPrevSiblings = function() {
          let D = this.key, $ = this.getSibling(--D);
          const I = [];
          for (; $.node; ) I.push($), $ = this.getSibling(--D);
          return I;
        }, n.getBindingIdentifierPaths = function(D = !1, $ = !1) {
          const I = [this], k = /* @__PURE__ */ Object.create(null);
          for (; I.length; ) {
            const L = I.shift();
            if (!L || !L.node) continue;
            const M = f.keys[L.node.type];
            if (L.isIdentifier()) D ? (k[L.node.name] = k[L.node.name] || []).push(L) : k[L.node.name] = L;
            else if (L.isExportDeclaration()) {
              const x = L.get("declaration");
              x.isDeclaration() && I.push(x);
            } else {
              if ($) {
                if (L.isFunctionDeclaration()) {
                  I.push(L.get("id"));
                  continue;
                }
                if (L.isFunctionExpression()) continue;
              }
              if (M) for (let x = 0; x < M.length; x++) {
                const _ = M[x], S = L.get(_);
                Array.isArray(S) ? I.push(...S) : S.node && I.push(S);
              }
            }
          }
          return k;
        }, n.getBindingIdentifiers = function(D) {
          return f(this.node, D);
        }, n.getCompletionRecords = function() {
          return O(this, { canHaveBreak: !1, shouldPopulateBreak: !1, inCaseClause: !1 }).map((D) => D.path);
        }, n.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, n.getOpposite = function() {
          return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
        }, n.getOuterBindingIdentifierPaths = function(D = !1) {
          return this.getBindingIdentifierPaths(D, !0);
        }, n.getOuterBindingIdentifiers = function(D) {
          return s(this.node, D);
        }, n.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, n.getSibling = function(D) {
          return i.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: D }).setContext(this.context);
        };
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { getBindingIdentifiers: f, getOuterBindingIdentifiers: s, numericLiteral: o, unaryExpression: y } = c, m = 0, g = 1;
        function b(D, $, I) {
          return D && $.push(...O(D, I)), $;
        }
        function v(D) {
          D.forEach(($) => {
            $.type = g;
          });
        }
        function T(D, $) {
          D.forEach((I) => {
            I.path.isBreakStatement({ label: null }) && ($ ? I.path.replaceWith(y("void", o(0))) : I.path.remove());
          });
        }
        function E(D, $) {
          const I = [];
          if ($.canHaveBreak) {
            let k = [];
            for (let L = 0; L < D.length; L++) {
              const M = D[L], x = Object.assign({}, $, { inCaseClause: !1 });
              M.isBlockStatement() && ($.inCaseClause || $.shouldPopulateBreak) ? x.shouldPopulateBreak = !0 : x.shouldPopulateBreak = !1;
              const _ = O(M, x);
              if (_.length > 0 && _.every((S) => S.type === g)) {
                k.length > 0 && _.every((S) => S.path.isBreakStatement({ label: null })) ? (v(k), I.push(...k), k.some((S) => S.path.isDeclaration()) && (I.push(..._), T(_, !0)), T(_, !1)) : (I.push(..._), $.shouldPopulateBreak || T(_, !0));
                break;
              }
              if (L === D.length - 1) I.push(..._);
              else {
                k = [];
                for (let S = 0; S < _.length; S++) {
                  const C = _[S];
                  C.type === g && I.push(C), C.type === m && k.push(C);
                }
              }
            }
          } else if (D.length) for (let k = D.length - 1; k >= 0; k--) {
            const L = O(D[k], $);
            if (L.length > 1 || L.length === 1 && !L[0].path.isVariableDeclaration()) {
              I.push(...L);
              break;
            }
          }
          return I;
        }
        function O(D, $) {
          let I = [];
          if (D.isIfStatement()) I = b(D.get("consequent"), I, $), I = b(D.get("alternate"), I, $);
          else {
            if (D.isDoExpression() || D.isFor() || D.isWhile() || D.isLabeledStatement()) return b(D.get("body"), I, $);
            if (D.isProgram() || D.isBlockStatement()) return E(D.get("body"), $);
            if (D.isFunction()) return O(D.get("body"), $);
            if (D.isTryStatement()) I = b(D.get("block"), I, $), I = b(D.get("handler"), I, $);
            else {
              if (D.isCatchClause()) return b(D.get("body"), I, $);
              if (D.isSwitchStatement()) return function(k, L, M) {
                let x = [];
                for (let _ = 0; _ < k.length; _++) {
                  const S = O(k[_], M), C = [], R = [];
                  for (const H of S) H.type === m && C.push(H), H.type === g && R.push(H);
                  C.length && (x = C), L.push(...R);
                }
                return L.push(...x), L;
              }(D.get("cases"), I, $);
              if (D.isSwitchCase()) return E(D.get("consequent"), { canHaveBreak: !0, shouldPopulateBreak: !1, inCaseClause: !0 });
              D.isBreakStatement() ? I.push(/* @__PURE__ */ function(k) {
                return { type: g, path: k };
              }(D)) : I.push(/* @__PURE__ */ function(k) {
                return { type: m, path: k };
              }(D));
            }
          }
          return I;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = n.SHOULD_STOP = n.SHOULD_SKIP = n.REMOVED = void 0;
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), c = u("./node_modules/.pnpm/debug@4.3.5/node_modules/debug/src/index.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js"), s = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/index.js"), o = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), y = o, m = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js"), g = u("./node_modules/.pnpm/@babel+generator@7.24.7/node_modules/@babel/generator/lib/index.js"), b = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/ancestry.js"), v = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/index.js"), T = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/replacement.js"), E = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/evaluation.js"), O = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/conversion.js"), D = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/introspection.js"), $ = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/context.js"), I = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/removal.js"), k = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/modification.js"), L = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/family.js"), M = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/comments.js"), x = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js");
        const { validate: _ } = o, S = c("babel"), C = (n.REMOVED = 1, n.SHOULD_STOP = 2, n.SHOULD_SKIP = 4, n.default = class V4 {
          constructor(z, U) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = U, this.hub = z, this.data = null, this.context = null, this.scope = null;
          }
          get removed() {
            return (1 & this._traverseFlags) > 0;
          }
          set removed(z) {
            z ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
          get shouldStop() {
            return (2 & this._traverseFlags) > 0;
          }
          set shouldStop(z) {
            z ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get shouldSkip() {
            return (4 & this._traverseFlags) > 0;
          }
          set shouldSkip(z) {
            z ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          static get({ hub: z, parentPath: U, parent: P, container: W, listKey: B, key: Q }) {
            if (!z && U && (z = U.hub), !P) throw new Error("To get a node path the parent needs to exist");
            const J = W[Q], re = m.getOrCreateCachedPaths(z, P);
            let G = re.get(J);
            return G || (G = new V4(z, P), J && re.set(J, G)), G.setup(U, W, B, Q), G;
          }
          getScope(z) {
            return this.isScope() ? new s.default(this) : z;
          }
          setData(z, U) {
            return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[z] = U;
          }
          getData(z, U) {
            this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
            let P = this.data[z];
            return P === void 0 && U !== void 0 && (P = this.data[z] = U), P;
          }
          hasNode() {
            return this.node != null;
          }
          buildCodeFrameError(z, U = SyntaxError) {
            return this.hub.buildError(this.node, z, U);
          }
          traverse(z, U) {
            (0, f.default)(this.node, z, this.scope, U, this);
          }
          set(z, U) {
            _(this.node, z, U), this.node[z] = U;
          }
          getPathLocation() {
            const z = [];
            let U = this;
            do {
              let P = U.key;
              U.inList && (P = `${U.listKey}[${P}]`), z.unshift(P);
            } while (U = U.parentPath);
            return z.join(".");
          }
          debug(z) {
            S.enabled && S(`${this.getPathLocation()} ${this.type}: ${z}`);
          }
          toString() {
            return (0, g.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(z) {
            z || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
        }), R = { findParent: b.findParent, find: b.find, getFunctionParent: b.getFunctionParent, getStatementParent: b.getStatementParent, getEarliestCommonAncestorFrom: b.getEarliestCommonAncestorFrom, getDeepestCommonAncestorFrom: b.getDeepestCommonAncestorFrom, getAncestry: b.getAncestry, isAncestor: b.isAncestor, isDescendant: b.isDescendant, inType: b.inType, getTypeAnnotation: v.getTypeAnnotation, _getTypeAnnotation: v._getTypeAnnotation, isBaseType: v.isBaseType, couldBeBaseType: v.couldBeBaseType, baseTypeStrictlyMatches: v.baseTypeStrictlyMatches, isGenericType: v.isGenericType, replaceWithMultiple: T.replaceWithMultiple, replaceWithSourceString: T.replaceWithSourceString, replaceWith: T.replaceWith, _replaceWith: T._replaceWith, replaceExpressionWithStatements: T.replaceExpressionWithStatements, replaceInline: T.replaceInline, evaluateTruthy: E.evaluateTruthy, evaluate: E.evaluate, toComputedKey: O.toComputedKey, ensureBlock: O.ensureBlock, unwrapFunctionEnvironment: O.unwrapFunctionEnvironment, arrowFunctionToExpression: O.arrowFunctionToExpression, matchesPattern: D.matchesPattern, has: D.has, isStatic: D.isStatic, is: D.is, isnt: D.isnt, equals: D.equals, isNodeType: D.isNodeType, canHaveVariableDeclarationOrExpression: D.canHaveVariableDeclarationOrExpression, canSwapBetweenExpressionAndStatement: D.canSwapBetweenExpressionAndStatement, isCompletionRecord: D.isCompletionRecord, isStatementOrBlock: D.isStatementOrBlock, referencesImport: D.referencesImport, getSource: D.getSource, willIMaybeExecuteBefore: D.willIMaybeExecuteBefore, _guessExecutionStatusRelativeTo: D._guessExecutionStatusRelativeTo, resolve: D.resolve, _resolve: D._resolve, isConstantExpression: D.isConstantExpression, isInStrictMode: D.isInStrictMode, call: $.call, _call: $._call, isDenylisted: $.isDenylisted, isBlacklisted: $.isBlacklisted, visit: $.visit, skip: $.skip, skipKey: $.skipKey, stop: $.stop, setScope: $.setScope, setContext: $.setContext, resync: $.resync, _resyncParent: $._resyncParent, _resyncKey: $._resyncKey, _resyncList: $._resyncList, _resyncRemoved: $._resyncRemoved, popContext: $.popContext, pushContext: $.pushContext, setup: $.setup, setKey: $.setKey, requeue: $.requeue, _getQueueContexts: $._getQueueContexts, remove: I.remove, _removeFromScope: I._removeFromScope, _callRemovalHooks: I._callRemovalHooks, _remove: I._remove, _markRemoved: I._markRemoved, _assertUnremoved: I._assertUnremoved, insertBefore: k.insertBefore, _containerInsert: k._containerInsert, _containerInsertBefore: k._containerInsertBefore, _containerInsertAfter: k._containerInsertAfter, insertAfter: k.insertAfter, updateSiblingKeys: k.updateSiblingKeys, _verifyNodeList: k._verifyNodeList, unshiftContainer: k.unshiftContainer, pushContainer: k.pushContainer, hoist: k.hoist, getOpposite: L.getOpposite, getCompletionRecords: L.getCompletionRecords, getSibling: L.getSibling, getPrevSibling: L.getPrevSibling, getNextSibling: L.getNextSibling, getAllNextSiblings: L.getAllNextSiblings, getAllPrevSiblings: L.getAllPrevSiblings, get: L.get, _getKey: L._getKey, _getPattern: L._getPattern, getBindingIdentifiers: L.getBindingIdentifiers, getOuterBindingIdentifiers: L.getOuterBindingIdentifiers, getBindingIdentifierPaths: L.getBindingIdentifierPaths, getOuterBindingIdentifierPaths: L.getOuterBindingIdentifierPaths, shareCommentsWithSiblings: M.shareCommentsWithSiblings, addComment: M.addComment, addComments: M.addComments };
        Object.assign(C.prototype, R), C.prototype.arrowFunctionToShadowed = O.arrowFunctionToShadowed, C.prototype._guessExecutionStatusRelativeToDifferentFunctions = D._guessExecutionStatusRelativeTo;
        for (const H of y.TYPES) {
          const z = `is${H}`, U = y[z];
          C.prototype[z] = function(P) {
            return U(this.node, P);
          }, C.prototype[`assert${H}`] = function(P) {
            if (!U(this.node, P)) throw new TypeError(`Expected node path of type ${H}`);
          };
        }
        Object.assign(C.prototype, x);
        for (const H of Object.keys(i)) H[0] !== "_" && (y.TYPES.includes(H) || y.TYPES.push(H));
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._getTypeAnnotation = function() {
          const H = this.node;
          if (!H) {
            if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
              const U = this.parentPath.parentPath, P = U.parentPath;
              return U.key === "left" && P.isForInStatement() ? _() : U.key === "left" && P.isForOfStatement() ? f() : S();
            }
            return;
          }
          if (H.typeAnnotation) return H.typeAnnotation;
          if (!C.has(H)) {
            C.add(H);
            try {
              var z;
              let U = i[H.type];
              if (U) return U.call(this, H);
              if (U = i[this.parentPath.type], (z = U) != null && z.validParent) return this.parentPath.getTypeAnnotation();
            } finally {
              C.delete(H);
            }
          }
        }, n.baseTypeStrictlyMatches = function(H) {
          const z = this.getTypeAnnotation(), U = H.getTypeAnnotation();
          return !s(z) && g(z) ? U.type === z.type : !1;
        }, n.couldBeBaseType = function(H) {
          const z = this.getTypeAnnotation();
          if (s(z)) return !0;
          if (M(z)) {
            for (const U of z.types) if (s(U) || R(H, U, !0)) return !0;
            return !1;
          }
          return R(H, z, !0);
        }, n.getTypeAnnotation = function() {
          let H = this.getData("typeAnnotation");
          return H ?? (H = this._getTypeAnnotation() || f(), (L(H) || $(H)) && (H = H.typeAnnotation), this.setData("typeAnnotation", H), H);
        }, n.isBaseType = function(H, z) {
          return R(H, this.getTypeAnnotation(), z);
        }, n.isGenericType = function(H) {
          const z = this.getTypeAnnotation();
          return H === "Array" && (D(z) || o(z) || k(z)) ? !0 : b(z) && v(z.id, { name: H }) || I(z) && v(z.typeName, { name: H });
        };
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/inferers.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { anyTypeAnnotation: f, isAnyTypeAnnotation: s, isArrayTypeAnnotation: o, isBooleanTypeAnnotation: y, isEmptyTypeAnnotation: m, isFlowBaseAnnotation: g, isGenericTypeAnnotation: b, isIdentifier: v, isMixedTypeAnnotation: T, isNumberTypeAnnotation: E, isStringTypeAnnotation: O, isTSArrayType: D, isTSTypeAnnotation: $, isTSTypeReference: I, isTupleTypeAnnotation: k, isTypeAnnotation: L, isUnionTypeAnnotation: M, isVoidTypeAnnotation: x, stringTypeAnnotation: _, voidTypeAnnotation: S } = c, C = /* @__PURE__ */ new WeakSet();
        function R(H, z, U) {
          if (H === "string") return O(z);
          if (H === "number") return E(z);
          if (H === "boolean") return y(z);
          if (H === "any") return s(z);
          if (H === "mixed") return T(z);
          if (H === "empty") return m(z);
          if (H === "void") return x(z);
          if (U) return !1;
          throw new Error(`Unknown base type ${H}`);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(v) {
          if (!this.isReferenced()) return;
          const T = this.scope.getBinding(v.name);
          if (T) return T.identifier.typeAnnotation ? T.identifier.typeAnnotation : function(E, O, D) {
            const $ = [], I = [];
            let k = m(E, O, I);
            const L = b(E, O, D);
            if (L) {
              const M = m(E, L.ifStatement);
              k = k.filter((x) => M.indexOf(x) < 0), $.push(L.typeAnnotation);
            }
            if (k.length) {
              k.push(...I);
              for (const M of k) $.push(M.getTypeAnnotation());
            }
            if ($.length)
              return (0, c.createUnionType)($);
          }(T, this, v.name);
          if (v.name === "undefined") return y();
          if (v.name === "NaN" || v.name === "Infinity") return o();
          v.name;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_NUMBER_BINARY_OPERATORS: f, createTypeAnnotationBasedOnTypeof: s, numberTypeAnnotation: o, voidTypeAnnotation: y } = i;
        function m(v, T, E) {
          const O = v.constantViolations.slice();
          return O.unshift(v.path), O.filter((D) => {
            const $ = (D = D.resolve())._guessExecutionStatusRelativeTo(T);
            return E && $ === "unknown" && E.push(D), $ === "before";
          });
        }
        function g(v, T) {
          const E = T.node.operator, O = T.get("right").resolve(), D = T.get("left").resolve();
          let $, I, k;
          if (D.isIdentifier({ name: v }) ? $ = O : O.isIdentifier({ name: v }) && ($ = D), $) return E === "===" ? $.getTypeAnnotation() : f.indexOf(E) >= 0 ? o() : void 0;
          if (E !== "===" && E !== "==" || (D.isUnaryExpression({ operator: "typeof" }) ? (I = D, k = O) : O.isUnaryExpression({ operator: "typeof" }) && (I = O, k = D), !I) || !I.get("argument").isIdentifier({ name: v }) || (k = k.resolve(), !k.isLiteral())) return;
          const L = k.node.value;
          return typeof L == "string" ? s(L) : void 0;
        }
        function b(v, T, E) {
          const O = function(I, k, L) {
            let M;
            for (; M = k.parentPath; ) {
              if (M.isIfStatement() || M.isConditionalExpression())
                return k.key === "test" ? void 0 : M;
              if (M.isFunction() && M.parentPath.scope.getBinding(L) !== I) return;
              k = M;
            }
          }(v, T, E);
          if (!O) return;
          const D = [O.get("test")], $ = [];
          for (let I = 0; I < D.length; I++) {
            const k = D[I];
            if (k.isLogicalExpression()) k.node.operator === "&&" && (D.push(k.get("left")), D.push(k.get("right")));
            else if (k.isBinaryExpression()) {
              const L = g(E, k);
              L && $.push(L);
            }
          }
          return $.length ? { typeAnnotation: (0, c.createUnionType)($), ifStatement: O } : b(v, O, E);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/inferers.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.ArrayExpression = R, n.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, n.BinaryExpression = function(Q) {
          const J = Q.operator;
          if (y.indexOf(J) >= 0) return I();
          if (s.indexOf(J) >= 0) return T();
          if (J === "+") {
            const re = this.get("right"), G = this.get("left");
            return G.isBaseType("number") && re.isBaseType("number") ? I() : G.isBaseType("string") || re.isBaseType("string") ? k() : M([k(), I()]);
          }
        }, n.BooleanLiteral = function() {
          return T();
        }, n.CallExpression = function() {
          const { callee: Q } = this.node;
          return U(Q) ? v(k()) : z(Q) || P(Q) || _(Q, { name: "Array" }) ? v(b()) : W(Q) ? v(L([k(), b()])) : B(this.get("callee"));
        }, n.ConditionalExpression = function() {
          const Q = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          return (0, f.createUnionType)(Q);
        }, n.ClassDeclaration = n.ClassExpression = n.FunctionDeclaration = n.ArrowFunctionExpression = n.FunctionExpression = function() {
          return O(D("Function"));
        }, Object.defineProperty(n, "Identifier", { enumerable: !0, get: function() {
          return c.default;
        } }), n.LogicalExpression = function() {
          const Q = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          return (0, f.createUnionType)(Q);
        }, n.NewExpression = function(Q) {
          if (Q.callee.type === "Identifier") return O(Q.callee);
        }, n.NullLiteral = function() {
          return $();
        }, n.NumericLiteral = function() {
          return I();
        }, n.ObjectExpression = function() {
          return O(D("Object"));
        }, n.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, n.RegExpLiteral = function() {
          return O(D("RegExp"));
        }, n.RestElement = H, n.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, n.StringLiteral = function() {
          return k();
        }, n.TSAsExpression = C, n.TSNonNullExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, n.TaggedTemplateExpression = function() {
          return B(this.get("tag"));
        }, n.TemplateLiteral = function() {
          return k();
        }, n.TypeCastExpression = S, n.UnaryExpression = function(Q) {
          const J = Q.operator;
          if (J === "void") return x();
          if (m.indexOf(J) >= 0) return I();
          if (g.indexOf(J) >= 0) return k();
          if (o.indexOf(J) >= 0) return T();
        }, n.UpdateExpression = function(Q) {
          const J = Q.operator;
          if (J === "++" || J === "--") return I();
        }, n.VariableDeclarator = function() {
          if (this.get("id").isIdentifier())
            return this.get("init").getTypeAnnotation();
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_BINARY_OPERATORS: s, BOOLEAN_UNARY_OPERATORS: o, NUMBER_BINARY_OPERATORS: y, NUMBER_UNARY_OPERATORS: m, STRING_UNARY_OPERATORS: g, anyTypeAnnotation: b, arrayTypeAnnotation: v, booleanTypeAnnotation: T, buildMatchMemberExpression: E, genericTypeAnnotation: O, identifier: D, nullLiteralTypeAnnotation: $, numberTypeAnnotation: I, stringTypeAnnotation: k, tupleTypeAnnotation: L, unionTypeAnnotation: M, voidTypeAnnotation: x, isIdentifier: _ } = i;
        function S(Q) {
          return Q.typeAnnotation;
        }
        function C(Q) {
          return Q.typeAnnotation;
        }
        function R() {
          return O(D("Array"));
        }
        function H() {
          return R();
        }
        S.validParent = !0, C.validParent = !0, H.validParent = !0;
        const z = E("Array.from"), U = E("Object.keys"), P = E("Object.values"), W = E("Object.entries");
        function B(Q) {
          if ((Q = Q.resolve()).isFunction()) {
            const { node: J } = Q;
            if (J.async) return J.generator ? O(D("AsyncIterator")) : O(D("Promise"));
            if (J.generator) return O(D("Iterator"));
            if (Q.node.returnType) return Q.node.returnType;
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/inference/util.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.createUnionType = function(m) {
          if (m.every((g) => o(g))) return c ? c(m) : s(m);
          if (m.every((g) => y(g)) && f) return f(m);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { createFlowUnionType: c, createTSUnionType: f, createUnionTypeAnnotation: s, isFlowType: o, isTSType: y } = i;
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/introspection.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._guessExecutionStatusRelativeTo = function(k) {
          return I(this, k, /* @__PURE__ */ new Map());
        }, n._resolve = function(k, L) {
          if (!(L && L.indexOf(this) >= 0))
            if ((L = L || []).push(this), this.isVariableDeclarator()) {
              if (this.get("id").isIdentifier()) return this.get("init").resolve(k, L);
            } else if (this.isReferencedIdentifier()) {
              const M = this.scope.getBinding(this.node.name);
              if (!M || !M.constant || M.kind === "module") return;
              if (M.path !== this) {
                const x = M.path.resolve(k, L);
                return this.find((_) => _.node === x.node) ? void 0 : x;
              }
            } else {
              if (this.isTypeCastExpression()) return this.get("expression").resolve(k, L);
              if (k && this.isMemberExpression()) {
                const M = this.toComputedKey();
                if (!m(M)) return;
                const x = M.value, _ = this.get("object").resolve(k, L);
                if (_.isObjectExpression()) {
                  const S = _.get("properties");
                  for (const C of S) {
                    if (!C.isProperty()) continue;
                    const R = C.get("key");
                    let H = C.isnt("computed") && R.isIdentifier({ name: x });
                    if (H = H || R.isLiteral({ value: x }), H) return C.get("value").resolve(k, L);
                  }
                } else if (_.isArrayExpression() && !isNaN(+x)) {
                  const S = _.get("elements")[x];
                  if (S) return S.resolve(k, L);
                }
              }
            }
        }, n.canHaveVariableDeclarationOrExpression = function() {
          return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
        }, n.canSwapBetweenExpressionAndStatement = function(k) {
          return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? s(k) : this.isBlockStatement() ? o(k) : !1;
        }, n.equals = function(k, L) {
          return this.node[k] === L;
        }, n.getSource = function() {
          const k = this.node;
          if (k.end) {
            const L = this.hub.getCode();
            if (L) return L.slice(k.start, k.end);
          }
          return "";
        }, n.has = T, n.is = void 0, n.isCompletionRecord = function(k) {
          let L = this, M = !0;
          do {
            const { type: x, container: _ } = L;
            if (!M && (L.isFunction() || x === "StaticBlock")) return !!k;
            if (M = !1, Array.isArray(_) && L.key !== _.length - 1) return !1;
          } while ((L = L.parentPath) && !L.isProgram() && !L.isDoExpression());
          return !0;
        }, n.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const k = this.scope.getBinding(this.node.name);
            return !!k && k.constant;
          }
          if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((k) => k.isConstantExpression()));
          if (this.isUnaryExpression()) return this.node.operator === "void" && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression()) {
            const { operator: k } = this.node;
            return k !== "in" && k !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          }
          return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({ name: "Symbol" }) && !this.scope.hasBinding("Symbol", { noGlobals: !0 }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", { noGlobals: !0 }) && this.get("arguments")[0].isStringLiteral() : !1;
        }, n.isInStrictMode = function() {
          return !!(this.isProgram() ? this : this.parentPath).find((L) => {
            if (L.isProgram({ sourceType: "module" }) || L.isClass()) return !0;
            if (L.isArrowFunctionExpression() && !L.get("body").isBlockStatement()) return !1;
            let M;
            if (L.isFunction()) M = L.node.body;
            else {
              if (!L.isProgram()) return !1;
              M = L.node;
            }
            for (const x of M.directives) if (x.value.value === "use strict") return !0;
          });
        }, n.isNodeType = function(k) {
          return b(this.type, k);
        }, n.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !s(this.container) && c.includes(this.key);
        }, n.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, n.isnt = function(k) {
          return !this.has(k);
        }, n.matchesPattern = function(k, L) {
          return v(this.node, k, L);
        }, n.referencesImport = function(k, L) {
          if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === L || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? g(this.node.property, { value: L }) : this.node.property.name === L)) {
              const S = this.get("object");
              return S.isReferencedIdentifier() && S.referencesImport(k, "*");
            }
            return !1;
          }
          const M = this.scope.getBinding(this.node.name);
          if (!M || M.kind !== "module") return !1;
          const x = M.path, _ = x.parentPath;
          return !_.isImportDeclaration() || _.node.source.value !== k ? !1 : !!(!L || x.isImportDefaultSpecifier() && L === "default" || x.isImportNamespaceSpecifier() && L === "*" || x.isImportSpecifier() && y(x.node.imported, { name: L }));
        }, n.resolve = function(k, L) {
          return this._resolve(k, L) || this;
        }, n.willIMaybeExecuteBefore = function(k) {
          return this._guessExecutionStatusRelativeTo(k) !== "after";
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { STATEMENT_OR_BLOCK_KEYS: c, VISITOR_KEYS: f, isBlockStatement: s, isExpression: o, isIdentifier: y, isLiteral: m, isStringLiteral: g, isType: b, matchesPattern: v } = i;
        function T(k) {
          var L;
          const M = (L = this.node) == null ? void 0 : L[k];
          return M && Array.isArray(M) ? !!M.length : !!M;
        }
        n.is = T;
        function E(k) {
          return k.isProgram() ? k : (k.parentPath.scope.getFunctionParent() || k.parentPath.scope.getProgramParent()).path;
        }
        function O(k, L) {
          switch (k) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return L === "right";
            case "ConditionalExpression":
            case "IfStatement":
              return L === "consequent" || L === "alternate";
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return L === "body";
            case "ForStatement":
              return L === "body" || L === "update";
            case "SwitchStatement":
              return L === "cases";
            case "TryStatement":
              return L === "handler";
            case "OptionalMemberExpression":
              return L === "property";
            case "OptionalCallExpression":
              return L === "arguments";
            default:
              return !1;
          }
        }
        function D(k, L) {
          for (let M = 0; M < L; M++) {
            const x = k[M];
            if (O(x.parent.type, x.parentKey)) return !0;
          }
          return !1;
        }
        const $ = Symbol();
        function I(k, L, M) {
          const x = { this: E(k), target: E(L) };
          if (x.target.node !== x.this.node) return function(U, P, W) {
            let B, Q = W.get(U.node);
            if (Q) {
              if (B = Q.get(P.node)) return B === $ ? "unknown" : B;
            } else W.set(U.node, Q = /* @__PURE__ */ new Map());
            Q.set(P.node, $);
            const J = function(re, G, N) {
              if (!G.isFunctionDeclaration()) return I(re, G, N) === "before" ? "before" : "unknown";
              if (G.parentPath.isExportDeclaration()) return "unknown";
              const V = G.scope.getBinding(G.node.id.name);
              if (!V.references) return "before";
              const F = V.referencePaths;
              let X;
              for (const K of F) {
                if (K.find((fe) => fe.node === G.node)) continue;
                if (K.key !== "callee" || !K.parentPath.isCallExpression()) return "unknown";
                const ie = I(re, K, N);
                if (X && X !== ie) return "unknown";
                X = ie;
              }
              return X;
            }(U, P, W);
            return Q.set(P.node, J), J;
          }(k, x.target, M);
          const _ = { target: L.getAncestry(), this: k.getAncestry() };
          if (_.target.indexOf(k) >= 0) return "after";
          if (_.this.indexOf(L) >= 0) return "before";
          let S;
          const C = { target: 0, this: 0 };
          for (; !S && C.this < _.this.length; ) {
            const U = _.this[C.this];
            C.target = _.target.indexOf(U), C.target >= 0 ? S = U : C.this++;
          }
          if (!S) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (D(_.this, C.this - 1) || D(_.target, C.target - 1)) return "unknown";
          const R = { this: _.this[C.this - 1], target: _.target[C.target - 1] };
          if (R.target.listKey && R.this.listKey && R.target.container === R.this.container) return R.target.key > R.this.key ? "before" : "after";
          const H = f[S.type], z = H.indexOf(R.this.parentKey);
          return H.indexOf(R.target.parentKey) > z ? "before" : "after";
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/hoister.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), c = i;
        const { react: f } = i, { cloneNode: s, jsxExpressionContainer: o, variableDeclaration: y, variableDeclarator: m } = c, g = { ReferencedIdentifier(b, v) {
          if (b.isJSXIdentifier() && f.isCompatTag(b.node.name) && !b.parentPath.isJSXMemberExpression()) return;
          if (b.node.name === "this") {
            let E = b.scope;
            do
              if (E.path.isFunction() && !E.path.isArrowFunctionExpression()) break;
            while (E = E.parent);
            E && v.breakOnScopePaths.push(E.path);
          }
          const T = b.scope.getBinding(b.node.name);
          if (T) {
            for (const E of T.constantViolations) if (E.scope !== T.path.scope) return v.mutableBinding = !0, void b.stop();
            T === v.scope.getBinding(b.node.name) && (v.bindings[b.node.name] = T);
          }
        } };
        n.default = class {
          constructor(b, v) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = v, this.path = b, this.attachAfter = !1;
          }
          isCompatibleScope(b) {
            for (const v of Object.keys(this.bindings)) {
              const T = this.bindings[v];
              if (!b.bindingIdentifierEquals(v, T.identifier)) return !1;
            }
            return !0;
          }
          getCompatibleScopes() {
            let b = this.path.scope;
            do
              if (!this.isCompatibleScope(b) || (this.scopes.push(b), this.breakOnScopePaths.indexOf(b.path) >= 0)) break;
            while (b = b.parent);
          }
          getAttachmentPath() {
            let b = this._getAttachmentPath();
            if (!b) return;
            let v = b.scope;
            if (v.path === b && (v = b.scope.parent), v.path.isProgram() || v.path.isFunction()) for (const T of Object.keys(this.bindings)) {
              if (!v.hasOwnBinding(T)) continue;
              const E = this.bindings[T];
              if (!(E.kind === "param" || E.path.parentKey === "params") && this.getAttachmentParentForPath(E.path).key >= b.key) {
                this.attachAfter = !0, b = E.path;
                for (const O of E.constantViolations) this.getAttachmentParentForPath(O).key > b.key && (b = O);
              }
            }
            return b;
          }
          _getAttachmentPath() {
            const b = this.scopes.pop();
            if (b) {
              if (b.path.isFunction()) {
                if (!this.hasOwnParamBindings(b)) return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === b) return;
                  const v = b.path.get("body").get("body");
                  for (let T = 0; T < v.length; T++) if (!v[T].node._blockHoist) return v[T];
                }
              } else if (b.path.isProgram()) return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const b = this.scopes.pop();
            if (b) return this.getAttachmentParentForPath(b.path);
          }
          getAttachmentParentForPath(b) {
            do
              if (!b.parentPath || Array.isArray(b.container) && b.isStatement()) return b;
            while (b = b.parentPath);
          }
          hasOwnParamBindings(b) {
            for (const v of Object.keys(this.bindings)) {
              if (!b.hasOwnBinding(v)) continue;
              const T = this.bindings[v];
              if (T.kind === "param" && T.constant) return !0;
            }
            return !1;
          }
          run() {
            if (this.path.traverse(g, this), this.mutableBinding) return;
            this.getCompatibleScopes();
            const b = this.getAttachmentPath();
            if (!b || b.getFunctionParent() === this.path.getFunctionParent()) return;
            let v = b.scope.generateUidIdentifier("ref");
            const T = m(v, this.path.node), E = this.attachAfter ? "insertAfter" : "insertBefore", [O] = b[E]([b.isVariableDeclarator() ? T : y("var", [T])]), D = this.path.parentPath;
            return D.isJSXElement() && this.path.container === D.node.children && (v = o(v)), this.path.replaceWith(s(v)), b.isVariableDeclarator() ? O.get("init") : O.get("declarations.0.init");
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.hooks = void 0, n.hooks = [function(u, i) {
          if (u.key === "test" && (i.isWhile() || i.isSwitchCase()) || u.key === "declaration" && i.isExportDeclaration() || u.key === "body" && i.isLabeledStatement() || u.listKey === "declarations" && i.isVariableDeclaration() && i.node.declarations.length === 1 || u.key === "expression" && i.isExpressionStatement()) return i.remove(), !0;
        }, function(u, i) {
          if (i.isSequenceExpression() && i.node.expressions.length === 1) return i.replaceWith(i.node.expressions[0]), !0;
        }, function(u, i) {
          if (i.isBinary()) return u.key === "left" ? i.replaceWith(i.node.right) : i.replaceWith(i.node.left), !0;
        }, function(u, i) {
          if (i.isIfStatement() && u.key === "consequent" || u.key === "body" && (i.isLoop() || i.isArrowFunctionExpression())) return u.replaceWith({ type: "BlockStatement", body: [] }), !0;
        }];
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isBindingIdentifier = function() {
          const { node: R, parent: H } = this, z = this.parentPath.parent;
          return b(R) && c(R, H, z);
        }, n.isBlockScoped = function() {
          return f(this.node);
        }, n.isExpression = function() {
          return this.isIdentifier() ? this.isReferencedIdentifier() : o(this.node);
        }, n.isFlow = function() {
          const { node: R } = this;
          return !!y(R) || (v(R) ? R.importKind === "type" || R.importKind === "typeof" : s(R) ? R.exportKind === "type" : !!T(R) && (R.importKind === "type" || R.importKind === "typeof"));
        }, n.isForAwaitStatement = function() {
          return S(this.node, { await: !0 });
        }, n.isGenerated = function() {
          return !this.isUser();
        }, n.isPure = function(R) {
          return this.scope.isPure(this.node, R);
        }, n.isReferenced = function() {
          return I(this.node, this.parent);
        }, n.isReferencedIdentifier = function(R) {
          const { node: H, parent: z } = this;
          return !b(H, R) && !O(z, R) && (!E(H, R) || C(H.name)) ? !1 : I(H, z, this.parentPath.parent);
        }, n.isReferencedMemberExpression = function() {
          const { node: R, parent: H } = this;
          return D(R) && I(R, H);
        }, n.isRestProperty = function() {
          var R;
          return $(this.node) && ((R = this.parentPath) == null ? void 0 : R.isObjectPattern());
        }, n.isScope = function() {
          return k(this.node, this.parent);
        }, n.isSpreadProperty = function() {
          var R;
          return $(this.node) && ((R = this.parentPath) == null ? void 0 : R.isObjectExpression());
        }, n.isStatement = function() {
          const { node: R, parent: H } = this;
          return L(R) ? !(x(R) && (g(H, { left: R }) || m(H, { init: R }))) : !1;
        }, n.isUser = function() {
          return this.node && !!this.node.loc;
        }, n.isVar = function() {
          return M(this.node);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { isBinding: c, isBlockScoped: f, isExportDeclaration: s, isExpression: o, isFlow: y, isForStatement: m, isForXStatement: g, isIdentifier: b, isImportDeclaration: v, isImportSpecifier: T, isJSXIdentifier: E, isJSXMemberExpression: O, isMemberExpression: D, isRestElement: $, isReferenced: I, isScope: k, isStatement: L, isVar: M, isVariableDeclaration: x, react: _, isForOfStatement: S } = i, { isCompatTag: C } = _;
        n.isExistentialTypeParam = function() {
          throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
        }, n.isNumericLiteralTypeAnnotation = function() {
          throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/virtual-types.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.Var = n.User = n.Statement = n.SpreadProperty = n.Scope = n.RestProperty = n.ReferencedMemberExpression = n.ReferencedIdentifier = n.Referenced = n.Pure = n.NumericLiteralTypeAnnotation = n.Generated = n.ForAwaitStatement = n.Flow = n.Expression = n.ExistentialTypeParam = n.BlockScoped = n.BindingIdentifier = void 0, n.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], n.ReferencedMemberExpression = ["MemberExpression"], n.BindingIdentifier = ["Identifier"], n.Statement = ["Statement"], n.Expression = ["Expression"], n.Scope = ["Scopable", "Pattern"], n.Referenced = null, n.BlockScoped = null, n.Var = ["VariableDeclaration"], n.User = null, n.Generated = null, n.Pure = null, n.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], n.RestProperty = ["RestElement"], n.SpreadProperty = ["RestElement"], n.ExistentialTypeParam = ["ExistsTypeAnnotation"], n.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], n.ForAwaitStatement = ["ForOfStatement"];
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/modification.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._containerInsert = function(S, C) {
          this.updateSiblingKeys(S, C.length);
          const R = [];
          this.container.splice(S, 0, ...C);
          for (let U = 0; U < C.length; U++) {
            var H;
            const P = S + U, W = this.getSibling(P);
            R.push(W), (H = this.context) != null && H.queue && W.pushContext(this.context);
          }
          const z = this._getQueueContexts();
          for (const U of R) {
            U.setScope(), U.debug("Inserted.");
            for (const P of z) P.maybeQueue(U, !0);
          }
          return R;
        }, n._containerInsertAfter = function(S) {
          return this._containerInsert(this.key + 1, S);
        }, n._containerInsertBefore = function(S) {
          return this._containerInsert(this.key, S);
        }, n._verifyNodeList = function(S) {
          if (!S) return [];
          Array.isArray(S) || (S = [S]);
          for (let C = 0; C < S.length; C++) {
            const R = S[C];
            let H;
            if (R ? typeof R != "object" ? H = "contains a non-object node" : R.type ? R instanceof f.default && (H = "has a NodePath when it expected a raw object") : H = "without a type" : H = "has falsy node", H) {
              const z = Array.isArray(R) ? "array" : typeof R;
              throw new Error(`Node list ${H} with the index of ${C} and type of ${z}`);
            }
          }
          return S;
        }, n.hoist = function(S = this.scope) {
          return new c.default(this, S).run();
        }, n.insertAfter = function(S) {
          if (this._assertUnremoved(), this.isSequenceExpression()) return x(this.get("expressions")).insertAfter(S);
          const C = this._verifyNodeList(S), { parentPath: R, parent: H } = this;
          if (R.isExpressionStatement() || R.isLabeledStatement() || D(H) || R.isExportDefaultDeclaration() && this.isDeclaration()) return R.insertAfter(C.map((z) => $(z) ? T(z) : z));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !R.isJSXElement() || R.isForStatement() && this.key === "init") {
            const z = this;
            if (z.node) {
              const U = z.node;
              let { scope: P } = this;
              if (P.path.isPattern()) return y(U), z.replaceWith(b(o([], U), [])), z.get("callee.body").insertAfter(C), [z];
              if (_(z)) C.unshift(U);
              else if (O(U) && L(U.callee)) C.unshift(U), C.push(M());
              else if (function(W, B) {
                if (!E(W) || !I(W.left)) return !1;
                const Q = B.getBlockParent();
                return Q.hasOwnBinding(W.left.name) && Q.getOwnBinding(W.left.name).constantViolations.length <= 1;
              }(U, P)) C.unshift(U), C.push(v(U.left));
              else if (P.isPure(U, !0)) C.push(U);
              else {
                R.isMethod({ computed: !0, key: U }) && (P = P.parent);
                const W = P.generateDeclaredUidIdentifier();
                C.unshift(T(m("=", v(W), U))), C.push(T(v(W)));
              }
            }
            return this.replaceExpressionWithStatements(C);
          }
          if (Array.isArray(this.container)) return this._containerInsertAfter(C);
          if (this.isStatementOrBlock()) {
            const z = this.node, U = z && (!this.isExpressionStatement() || z.expression != null);
            return this.replaceWith(g(U ? [z] : [])), this.pushContainer("body", C);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, n.insertBefore = function(S) {
          this._assertUnremoved();
          const C = this._verifyNodeList(S), { parentPath: R, parent: H } = this;
          if (R.isExpressionStatement() || R.isLabeledStatement() || D(H) || R.isExportDefaultDeclaration() && this.isDeclaration()) return R.insertBefore(C);
          if (this.isNodeType("Expression") && !this.isJSXElement() || R.isForStatement() && this.key === "init") return this.node && C.push(this.node), this.replaceExpressionWithStatements(C);
          if (Array.isArray(this.container)) return this._containerInsertBefore(C);
          if (this.isStatementOrBlock()) {
            const z = this.node, U = z && (!this.isExpressionStatement() || z.expression != null);
            return this.replaceWith(g(U ? [z] : [])), this.unshiftContainer("body", C);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, n.pushContainer = function(S, C) {
          this._assertUnremoved();
          const R = this._verifyNodeList(C), H = this.node[S];
          return f.default.get({ parentPath: this, parent: this.node, container: H, listKey: S, key: H.length }).setContext(this.context).replaceWithMultiple(R);
        }, n.unshiftContainer = function(S, C) {
          return this._assertUnremoved(), C = this._verifyNodeList(C), f.default.get({ parentPath: this, parent: this.node, container: this.node[S], listKey: S, key: 0 }).setContext(this.context)._containerInsertBefore(C);
        }, n.updateSiblingKeys = function(S, C) {
          if (!this.parent) return;
          const R = (0, i.getCachedPaths)(this.hub, this.parent) || [];
          for (const [, H] of R) typeof H.key == "number" && H.key >= S && (H.key += C);
        };
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/hoister.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js"), s = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { arrowFunctionExpression: o, assertExpression: y, assignmentExpression: m, blockStatement: g, callExpression: b, cloneNode: v, expressionStatement: T, isAssignmentExpression: E, isCallExpression: O, isExportNamedDeclaration: D, isExpression: $, isIdentifier: I, isSequenceExpression: k, isSuper: L, thisExpression: M } = s, x = (S) => S[S.length - 1];
        function _(S) {
          return k(S.parent) && (x(S.parent.expressions) !== S.node || _(S.parentPath));
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/removal.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._assertUnremoved = function() {
          if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }, n._callRemovalHooks = function() {
          if (this.parentPath) {
            for (const y of i.hooks) if (y(this, this.parentPath)) return !0;
          }
        }, n._markRemoved = function() {
          this._traverseFlags |= f.SHOULD_SKIP | f.REMOVED, this.parent && (0, c.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
        }, n._remove = function() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
        }, n._removeFromScope = function() {
          const y = o(this.node, !1, !1, !0);
          Object.keys(y).forEach((m) => this.scope.removeBinding(m));
        }, n.remove = function() {
          var y;
          if (this._assertUnremoved(), this.resync(), (y = this.opts) != null && y.noScope || this._removeFromScope(), this._callRemovalHooks()) return void this._markRemoved();
          this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
        };
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js"), s = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { getBindingIdentifiers: o } = s;
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/replacement.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n._replaceWith = function(F) {
          var X;
          if (!this.container) throw new ReferenceError("Container is falsy");
          this.inList ? G(this.parent, this.key, [F]) : G(this.parent, this.key, F), this.debug(`Replace with ${F == null ? void 0 : F.type}`), (X = (0, s.getCachedPaths)(this.hub, this.parent)) == null || X.set(F, this).delete(this.node), this.node = this.container[this.key] = F;
        }, n.replaceExpressionWithStatements = function(F) {
          this.resync();
          const X = [], K = V(F, X);
          if (K) {
            for (const ye of X) this.scope.push({ id: ye });
            return this.replaceWith(K)[0].get("expressions");
          }
          const ie = this.getFunctionParent(), fe = ie == null ? void 0 : ie.is("async"), _e = ie == null ? void 0 : ie.is("generator"), Ae = b([], E(F));
          this.replaceWith(D(Ae, []));
          const ce = this.get("callee");
          (0, m.default)(ce.get("body"), (ye) => {
            this.scope.push({ id: ye });
          }, "var");
          const ee = this.get("callee").getCompletionRecords();
          for (const ye of ee) {
            if (!ye.isExpressionStatement()) continue;
            const we = ye.findParent((ge) => ge.isLoop());
            if (we) {
              let ge = we.getData("expressionReplacementReturnUid");
              ge ? ge = M(ge.name) : (ge = ce.scope.generateDeclaredUidIdentifier("ret"), ce.get("body").pushContainer("body", J($(ge))), we.setData("expressionReplacementReturnUid", ge)), ye.get("expression").replaceWith(v("=", $(ge), ye.node.expression));
            } else ye.replaceWith(J(ye.node.expression));
          }
          ce.arrowFunctionToExpression();
          const ae = ce, oe = fe && c.default.hasType(this.get("callee.body").node, "AwaitExpression", g), me = _e && c.default.hasType(this.get("callee.body").node, "YieldExpression", g);
          return oe && (ae.set("async", !0), me || this.replaceWith(T(this.node))), me && (ae.set("generator", !0), this.replaceWith(N(this.node, !0))), ae.get("body.body");
        }, n.replaceInline = function(F) {
          if (this.resync(), Array.isArray(F)) {
            if (Array.isArray(this.container)) {
              F = this._verifyNodeList(F);
              const X = this._containerInsertAfter(F);
              return this.remove(), X;
            }
            return this.replaceWithMultiple(F);
          }
          return this.replaceWith(F);
        }, n.replaceWith = function(F) {
          if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
          let X = F instanceof f.default ? F.node : F;
          if (!X) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === X) return [this];
          if (this.isProgram() && !P(X)) throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(X)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if (typeof X == "string") throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let K = "";
          if (this.isNodeType("Statement") && H(X) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(X) || this.parentPath.isExportDefaultDeclaration() || (X = k(X), K = "expression")), this.isNodeType("Expression") && W(X) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(X)) return this.replaceExpressionWithStatements([X]);
          const ie = this.node;
          return ie && (S(X, ie), Q(ie)), this._replaceWith(X), this.type = X.type, this.setScope(), this.requeue(), [K ? this.get(K) : this];
        }, n.replaceWithMultiple = function(F) {
          var X;
          this.resync(), F = this._verifyNodeList(F), x(F[0], this.node), _(F[F.length - 1], this.node), (X = (0, s.getCachedPaths)(this.hub, this.parent)) == null || X.delete(this.node), this.node = this.container[this.key] = null;
          const K = this.insertAfter(F);
          return this.node ? this.requeue() : this.remove(), K;
        }, n.replaceWithSourceString = function(F) {
          let X;
          this.resync();
          try {
            F = `(${F})`, X = (0, o.parse)(F);
          } catch (ie) {
            const fe = ie.loc;
            throw fe && (ie.message += ` - make sure this is an expression.
` + (0, i.codeFrameColumns)(F, { start: { line: fe.line, column: fe.column + 1 } }), ie.code = "BABEL_REPLACE_SOURCE_ERROR"), ie;
          }
          const K = X.program.body[0].expression;
          return c.default.removeProperties(K), this.replaceWith(K);
        };
        var i = u("./stubs/babel-codeframe.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/index.js"), s = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js"), o = u("./node_modules/.pnpm/@babel+parser@7.24.7/node_modules/@babel/parser/lib/index.js"), y = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), m = u("./node_modules/.pnpm/@babel+helper-hoist-variables@7.24.7/node_modules/@babel/helper-hoist-variables/lib/index.js");
        const { FUNCTION_TYPES: g, arrowFunctionExpression: b, assignmentExpression: v, awaitExpression: T, blockStatement: E, buildUndefinedNode: O, callExpression: D, cloneNode: $, conditionalExpression: I, expressionStatement: k, getBindingIdentifiers: L, identifier: M, inheritLeadingComments: x, inheritTrailingComments: _, inheritsComments: S, isBlockStatement: C, isEmptyStatement: R, isExpression: H, isExpressionStatement: z, isIfStatement: U, isProgram: P, isStatement: W, isVariableDeclaration: B, removeComments: Q, returnStatement: J, sequenceExpression: re, validate: G, yieldExpression: N } = y;
        function V(F, X) {
          const K = [];
          let ie = !0;
          for (const fe of F) if (R(fe) || (ie = !1), H(fe)) K.push(fe);
          else if (z(fe)) K.push(fe.expression);
          else if (B(fe)) {
            if (fe.kind !== "var") return;
            for (const _e of fe.declarations) {
              const Ae = L(_e);
              for (const ce of Object.keys(Ae)) X.push($(Ae[ce]));
              _e.init && K.push(v("=", _e.id, _e.init));
            }
            ie = !0;
          } else if (U(fe)) {
            const _e = fe.consequent ? V([fe.consequent], X) : O(), Ae = fe.alternate ? V([fe.alternate], X) : O();
            if (!_e || !Ae) return;
            K.push(I(fe.test, _e, Ae));
          } else if (C(fe)) {
            const _e = V(fe.body, X);
            if (!_e) return;
            K.push(_e);
          } else {
            if (!R(fe)) return;
            F.indexOf(fe) === 0 && (ie = !0);
          }
          return ie && K.push(O()), K.length === 1 ? K[0] : re(K);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/binding.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0, n.default = class {
          constructor({ identifier: u, scope: i, path: c, kind: f }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = u, this.scope = i, this.path = c, this.kind = f, f !== "var" && f !== "hoisted" || !function(s) {
              for (let { parentPath: o, key: y } = s; o; { parentPath: o, key: y } = o) {
                if (o.isFunctionParent()) return !1;
                if (o.isWhile() || o.isForXStatement() || o.isForStatement() && y === "body") return !0;
              }
              return !1;
            }(c) || this.reassign(c), this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = !0;
          }
          setValue(u) {
            this.hasDeoptedValue || (this.hasValue = !0, this.value = u);
          }
          clearValue() {
            this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
          }
          reassign(u) {
            this.constant = !1, this.constantViolations.indexOf(u) === -1 && this.constantViolations.push(u);
          }
          reference(u) {
            this.referencePaths.indexOf(u) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(u));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/lib/renamer.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/index.js"), f = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/binding.js"), s = u("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js"), o = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), y = o, m = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/cache.js"), g = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/visitors.js");
        const { NOT_LOCAL_BINDING: b, callExpression: v, cloneNode: T, getBindingIdentifiers: E, identifier: O, isArrayExpression: D, isBinary: $, isCallExpression: I, isClass: k, isClassBody: L, isClassDeclaration: M, isExportAllDeclaration: x, isExportDefaultDeclaration: _, isExportNamedDeclaration: S, isFunctionDeclaration: C, isIdentifier: R, isImportDeclaration: H, isLiteral: z, isMemberExpression: U, isMethod: P, isModuleSpecifier: W, isNullLiteral: B, isObjectExpression: Q, isProperty: J, isPureish: re, isRegExpLiteral: G, isSuper: N, isTaggedTemplateExpression: V, isTemplateLiteral: F, isThisExpression: X, isUnaryExpression: K, isVariableDeclaration: ie, matchesPattern: fe, memberExpression: _e, numericLiteral: Ae, toIdentifier: ce, variableDeclaration: ee, variableDeclarator: ae, isRecordExpression: oe, isTupleExpression: me, isObjectProperty: ye, isTopicReference: we, isMetaProperty: ge, isPrivateName: se, isExportDeclaration: be, buildUndefinedNode: Ie } = o;
        function Oe(te, Y) {
          switch (te == null ? void 0 : te.type) {
            default:
              var le;
              if (H(te) || be(te)) if ((x(te) || S(te) || H(te)) && te.source) Oe(te.source, Y);
              else if ((S(te) || H(te)) && (le = te.specifiers) != null && le.length) for (const Ee of te.specifiers) Oe(Ee, Y);
              else (_(te) || S(te)) && te.declaration && Oe(te.declaration, Y);
              else W(te) ? Oe(te.local, Y) : !z(te) || B(te) || G(te) || F(te) || Y.push(te.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              Oe(te.object, Y), Oe(te.property, Y);
              break;
            case "Identifier":
            case "JSXIdentifier":
              Y.push(te.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              Oe(te.callee, Y);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const Ee of te.properties) Oe(Ee, Y);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              Oe(te.argument, Y);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              Oe(te.key, Y);
              break;
            case "ThisExpression":
              Y.push("this");
              break;
            case "Super":
              Y.push("super");
              break;
            case "Import":
              Y.push("import");
              break;
            case "DoExpression":
              Y.push("do");
              break;
            case "YieldExpression":
              Y.push("yield"), Oe(te.argument, Y);
              break;
            case "AwaitExpression":
              Y.push("await"), Oe(te.argument, Y);
              break;
            case "AssignmentExpression":
              Oe(te.left, Y);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              Oe(te.id, Y);
              break;
            case "ParenthesizedExpression":
              Oe(te.expression, Y);
              break;
            case "MetaProperty":
              Oe(te.meta, Y), Oe(te.property, Y);
              break;
            case "JSXElement":
              Oe(te.openingElement, Y);
              break;
            case "JSXOpeningElement":
              Oe(te.name, Y);
              break;
            case "JSXFragment":
              Oe(te.openingFragment, Y);
              break;
            case "JSXOpeningFragment":
              Y.push("Fragment");
              break;
            case "JSXNamespacedName":
              Oe(te.namespace, Y), Oe(te.name, Y);
          }
        }
        const Be = { ForStatement(te) {
          const Y = te.get("init");
          if (Y.isVar()) {
            const { scope: le } = te;
            (le.getFunctionParent() || le.getProgramParent()).registerBinding("var", Y);
          }
        }, Declaration(te) {
          te.isBlockScoped() || te.isImportDeclaration() || te.isExportDeclaration() || (te.scope.getFunctionParent() || te.scope.getProgramParent()).registerDeclaration(te);
        }, ImportDeclaration(te) {
          te.scope.getBlockParent().registerDeclaration(te);
        }, ReferencedIdentifier(te, Y) {
          Y.references.push(te);
        }, ForXStatement(te, Y) {
          const le = te.get("left");
          if (le.isPattern() || le.isIdentifier()) Y.constantViolations.push(te);
          else if (le.isVar()) {
            const { scope: Ee } = te;
            (Ee.getFunctionParent() || Ee.getProgramParent()).registerBinding("var", le);
          }
        }, ExportDeclaration: { exit(te) {
          const { node: Y, scope: le } = te;
          if (x(Y)) return;
          const Ee = Y.declaration;
          if (M(Ee) || C(Ee)) {
            const Se = Ee.id;
            if (!Se) return;
            const Pe = le.getBinding(Se.name);
            Pe == null || Pe.reference(te);
          } else if (ie(Ee)) for (const Se of Ee.declarations) for (const Pe of Object.keys(E(Se))) {
            const Ve = le.getBinding(Pe);
            Ve == null || Ve.reference(te);
          }
        } }, LabeledStatement(te) {
          te.scope.getBlockParent().registerDeclaration(te);
        }, AssignmentExpression(te, Y) {
          Y.assignments.push(te);
        }, UpdateExpression(te, Y) {
          Y.constantViolations.push(te);
        }, UnaryExpression(te, Y) {
          te.node.operator === "delete" && Y.constantViolations.push(te);
        }, BlockScoped(te) {
          let Y = te.scope;
          if (Y.path === te && (Y = Y.parent), Y.getBlockParent().registerDeclaration(te), te.isClassDeclaration() && te.node.id) {
            const le = te.node.id.name;
            te.scope.bindings[le] = te.scope.parent.getBinding(le);
          }
        }, CatchClause(te) {
          te.scope.registerBinding("let", te);
        }, Function(te) {
          const Y = te.get("params");
          for (const le of Y) te.scope.registerBinding("param", le);
          te.isFunctionExpression() && te.has("id") && !te.get("id").node[b] && te.scope.registerBinding("local", te.get("id"), te);
        }, ClassExpression(te) {
          te.has("id") && !te.get("id").node[b] && te.scope.registerBinding("local", te.get("id"), te);
        }, TSTypeAnnotation(te) {
          te.skip();
        } };
        let Fe = 0;
        class ue {
          constructor(Y) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            const { node: le } = Y, Ee = m.scope.get(le);
            if ((Ee == null ? void 0 : Ee.path) === Y) return Ee;
            m.scope.set(le, this), this.uid = Fe++, this.block = le, this.path = Y, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
          }
          get parent() {
            var Y;
            let le, Ee = this.path;
            do {
              var Se;
              const Pe = Ee.key === "key" || Ee.listKey === "decorators";
              Ee = Ee.parentPath, Pe && Ee.isMethod() && (Ee = Ee.parentPath), (Se = Ee) != null && Se.isScope() && (le = Ee);
            } while (Ee && !le);
            return (Y = le) == null ? void 0 : Y.scope;
          }
          get parentBlock() {
            return this.path.parent;
          }
          get hub() {
            return this.path.hub;
          }
          traverse(Y, le, Ee) {
            (0, c.default)(Y, le, this, Ee, this.path);
          }
          generateDeclaredUidIdentifier(Y) {
            const le = this.generateUidIdentifier(Y);
            return this.push({ id: le }), T(le);
          }
          generateUidIdentifier(Y) {
            return O(this.generateUid(Y));
          }
          generateUid(Y = "temp") {
            let le;
            Y = ce(Y).replace(/^_+/, "").replace(/[0-9]+$/g, "");
            let Ee = 1;
            do
              le = this._generateUid(Y, Ee), Ee++;
            while (this.hasLabel(le) || this.hasBinding(le) || this.hasGlobal(le) || this.hasReference(le));
            const Se = this.getProgramParent();
            return Se.references[le] = !0, Se.uids[le] = !0, le;
          }
          _generateUid(Y, le) {
            let Ee = Y;
            return le > 1 && (Ee += le), `_${Ee}`;
          }
          generateUidBasedOnNode(Y, le) {
            const Ee = [];
            Oe(Y, Ee);
            let Se = Ee.join("$");
            return Se = Se.replace(/^_/, "") || le || "ref", this.generateUid(Se.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(Y, le) {
            return O(this.generateUidBasedOnNode(Y, le));
          }
          isStatic(Y) {
            if (X(Y) || N(Y) || we(Y)) return !0;
            if (R(Y)) {
              const le = this.getBinding(Y.name);
              return le ? le.constant : this.hasBinding(Y.name);
            }
            return !1;
          }
          maybeGenerateMemoised(Y, le) {
            if (this.isStatic(Y)) return null;
            {
              const Ee = this.generateUidIdentifierBasedOnNode(Y);
              return le ? Ee : (this.push({ id: Ee }), T(Ee));
            }
          }
          checkBlockScopedCollisions(Y, le, Ee, Se) {
            if (le !== "param" && Y.kind !== "local" && (le === "let" || Y.kind === "let" || Y.kind === "const" || Y.kind === "module" || Y.kind === "param" && le === "const"))
              throw this.hub.buildError(Se, `Duplicate declaration "${Ee}"`, TypeError);
          }
          rename(Y, le) {
            const Ee = this.getBinding(Y);
            Ee && (le || (le = this.generateUidIdentifier(Y).name), new i.default(Ee, Y, le).rename(arguments[2]));
          }
          _renameFromMap(Y, le, Ee, Se) {
            Y[le] && (Y[Ee] = Se, Y[le] = null);
          }
          dump() {
            const Y = "-".repeat(60);
            console.log(Y);
            let le = this;
            do {
              console.log("#", le.block.type);
              for (const Ee of Object.keys(le.bindings)) {
                const Se = le.bindings[Ee];
                console.log(" -", Ee, { constant: Se.constant, references: Se.references, violations: Se.constantViolations.length, kind: Se.kind });
              }
            } while (le = le.parent);
            console.log(Y);
          }
          toArray(Y, le, Ee) {
            if (R(Y)) {
              const Ve = this.getBinding(Y.name);
              if (Ve != null && Ve.constant && Ve.path.isGenericType("Array")) return Y;
            }
            if (D(Y)) return Y;
            if (R(Y, { name: "arguments" })) return v(_e(_e(_e(O("Array"), O("prototype")), O("slice")), O("call")), [Y]);
            let Se;
            const Pe = [Y];
            return le === !0 ? Se = "toConsumableArray" : typeof le == "number" ? (Pe.push(Ae(le)), Se = "slicedToArray") : Se = "toArray", Ee && (Pe.unshift(this.hub.addHelper(Se)), Se = "maybeArrayLike"), v(this.hub.addHelper(Se), Pe);
          }
          hasLabel(Y) {
            return !!this.getLabel(Y);
          }
          getLabel(Y) {
            return this.labels.get(Y);
          }
          registerLabel(Y) {
            this.labels.set(Y.node.label.name, Y);
          }
          registerDeclaration(Y) {
            if (Y.isLabeledStatement()) this.registerLabel(Y);
            else if (Y.isFunctionDeclaration()) this.registerBinding("hoisted", Y.get("id"), Y);
            else if (Y.isVariableDeclaration()) {
              const le = Y.get("declarations"), { kind: Ee } = Y.node;
              for (const Se of le) this.registerBinding(Ee === "using" || Ee === "await using" ? "const" : Ee, Se);
            } else if (Y.isClassDeclaration()) {
              if (Y.node.declare) return;
              this.registerBinding("let", Y);
            } else if (Y.isImportDeclaration()) {
              const le = Y.node.importKind === "type" || Y.node.importKind === "typeof", Ee = Y.get("specifiers");
              for (const Se of Ee) {
                const Pe = le || Se.isImportSpecifier() && (Se.node.importKind === "type" || Se.node.importKind === "typeof");
                this.registerBinding(Pe ? "unknown" : "module", Se);
              }
            } else if (Y.isExportDeclaration()) {
              const le = Y.get("declaration");
              (le.isClassDeclaration() || le.isFunctionDeclaration() || le.isVariableDeclaration()) && this.registerDeclaration(le);
            } else this.registerBinding("unknown", Y);
          }
          buildUndefinedNode() {
            return Ie();
          }
          registerConstantViolation(Y) {
            const le = Y.getBindingIdentifiers();
            for (const Se of Object.keys(le)) {
              var Ee;
              (Ee = this.getBinding(Se)) == null || Ee.reassign(Y);
            }
          }
          registerBinding(Y, le, Ee = le) {
            if (!Y) throw new ReferenceError("no `kind`");
            if (le.isVariableDeclaration()) {
              const Ve = le.get("declarations");
              for (const Xe of Ve) this.registerBinding(Y, Xe);
              return;
            }
            const Se = this.getProgramParent(), Pe = le.getOuterBindingIdentifiers(!0);
            for (const Ve of Object.keys(Pe)) {
              Se.references[Ve] = !0;
              for (const Xe of Pe[Ve]) {
                const Ye = this.getOwnBinding(Ve);
                if (Ye) {
                  if (Ye.identifier === Xe) continue;
                  this.checkBlockScopedCollisions(Ye, Y, Ve, Xe);
                }
                Ye ? Ye.reassign(Ee) : this.bindings[Ve] = new f.default({ identifier: Xe, scope: this, path: Ee, kind: Y });
              }
            }
          }
          addGlobal(Y) {
            this.globals[Y.name] = Y;
          }
          hasUid(Y) {
            let le = this;
            do
              if (le.uids[Y]) return !0;
            while (le = le.parent);
            return !1;
          }
          hasGlobal(Y) {
            let le = this;
            do
              if (le.globals[Y]) return !0;
            while (le = le.parent);
            return !1;
          }
          hasReference(Y) {
            return !!this.getProgramParent().references[Y];
          }
          isPure(Y, le) {
            if (R(Y)) {
              const Ve = this.getBinding(Y.name);
              return !!Ve && (!le || Ve.constant);
            }
            if (X(Y) || ge(Y) || we(Y) || se(Y)) return !0;
            var Ee, Se, Pe;
            if (k(Y)) return !(Y.superClass && !this.isPure(Y.superClass, le)) && !(((Ee = Y.decorators) == null ? void 0 : Ee.length) > 0) && this.isPure(Y.body, le);
            if (L(Y)) {
              for (const Ve of Y.body) if (!this.isPure(Ve, le)) return !1;
              return !0;
            }
            if ($(Y)) return this.isPure(Y.left, le) && this.isPure(Y.right, le);
            if (D(Y) || me(Y)) {
              for (const Ve of Y.elements) if (Ve !== null && !this.isPure(Ve, le)) return !1;
              return !0;
            }
            if (Q(Y) || oe(Y)) {
              for (const Ve of Y.properties) if (!this.isPure(Ve, le)) return !1;
              return !0;
            }
            if (P(Y)) return !(Y.computed && !this.isPure(Y.key, le)) && !(((Se = Y.decorators) == null ? void 0 : Se.length) > 0);
            if (J(Y)) return !(Y.computed && !this.isPure(Y.key, le)) && !(((Pe = Y.decorators) == null ? void 0 : Pe.length) > 0) && !((ye(Y) || Y.static) && Y.value !== null && !this.isPure(Y.value, le));
            if (K(Y)) return this.isPure(Y.argument, le);
            if (F(Y)) {
              for (const Ve of Y.expressions) if (!this.isPure(Ve, le)) return !1;
              return !0;
            }
            return V(Y) ? fe(Y.tag, "String.raw") && !this.hasBinding("String", { noGlobals: !0 }) && this.isPure(Y.quasi, le) : U(Y) ? !Y.computed && R(Y.object) && Y.object.name === "Symbol" && R(Y.property) && Y.property.name !== "for" && !this.hasBinding("Symbol", { noGlobals: !0 }) : I(Y) ? fe(Y.callee, "Symbol.for") && !this.hasBinding("Symbol", { noGlobals: !0 }) && Y.arguments.length === 1 && y.isStringLiteral(Y.arguments[0]) : re(Y);
          }
          setData(Y, le) {
            return this.data[Y] = le;
          }
          getData(Y) {
            let le = this;
            do {
              const Ee = le.data[Y];
              if (Ee != null) return Ee;
            } while (le = le.parent);
          }
          removeData(Y) {
            let le = this;
            do
              le.data[Y] != null && (le.data[Y] = null);
            while (le = le.parent);
          }
          init() {
            this.inited || (this.inited = !0, this.crawl());
          }
          crawl() {
            const Y = this.path;
            this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
            const le = this.getProgramParent();
            if (le.crawling) return;
            const Ee = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = !0, Y.type !== "Program" && (0, g.isExplodedVisitor)(Be)) {
              for (const Pe of Be.enter) Pe.call(Ee, Y, Ee);
              const Se = Be[Y.type];
              if (Se) for (const Pe of Se.enter) Pe.call(Ee, Y, Ee);
            }
            Y.traverse(Be, Ee), this.crawling = !1;
            for (const Se of Ee.assignments) {
              const Pe = Se.getBindingIdentifiers();
              for (const Ve of Object.keys(Pe)) Se.scope.getBinding(Ve) || le.addGlobal(Pe[Ve]);
              Se.scope.registerConstantViolation(Se);
            }
            for (const Se of Ee.references) {
              const Pe = Se.scope.getBinding(Se.node.name);
              Pe ? Pe.reference(Se) : le.addGlobal(Se.node);
            }
            for (const Se of Ee.constantViolations) Se.scope.registerConstantViolation(Se);
          }
          push(Y) {
            let le = this.path;
            le.isPattern() ? le = this.getPatternParent().path : le.isBlockStatement() || le.isProgram() || (le = this.getBlockParent().path), le.isSwitchStatement() && (le = (this.getFunctionParent() || this.getProgramParent()).path);
            const { init: Ee, unique: Se, kind: Pe = "var", id: Ve } = Y;
            if (!Ee && !Se && (Pe === "var" || Pe === "let") && le.isFunction() && !le.node.name && I(le.parent, { callee: le.node }) && le.parent.arguments.length <= le.node.params.length && R(Ve)) return le.pushContainer("params", Ve), void le.scope.registerBinding("param", le.get("params")[le.node.params.length - 1]);
            (le.isLoop() || le.isCatchClause() || le.isFunction()) && (le.ensureBlock(), le = le.get("body"));
            const Xe = Y._blockHoist == null ? 2 : Y._blockHoist, Ye = `declaration:${Pe}:${Xe}`;
            let We = !Se && le.getData(Ye);
            if (!We) {
              const Me = ee(Pe, []);
              Me._blockHoist = Xe, [We] = le.unshiftContainer("body", [Me]), Se || le.setData(Ye, We);
            }
            const et = ae(Ve, Ee), De = We.node.declarations.push(et);
            le.scope.registerBinding(Pe, We.get("declarations")[De - 1]);
          }
          getProgramParent() {
            let Y = this;
            do
              if (Y.path.isProgram()) return Y;
            while (Y = Y.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let Y = this;
            do
              if (Y.path.isFunctionParent()) return Y;
            while (Y = Y.parent);
            return null;
          }
          getBlockParent() {
            let Y = this;
            do
              if (Y.path.isBlockParent()) return Y;
            while (Y = Y.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getPatternParent() {
            let Y = this;
            do
              if (!Y.path.isPattern()) return Y.getBlockParent();
            while (Y = Y.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const Y = /* @__PURE__ */ Object.create(null);
            let le = this;
            do {
              for (const Ee of Object.keys(le.bindings)) !(Ee in Y) && (Y[Ee] = le.bindings[Ee]);
              le = le.parent;
            } while (le);
            return Y;
          }
          getAllBindingsOfKind(...Y) {
            const le = /* @__PURE__ */ Object.create(null);
            for (const Ee of Y) {
              let Se = this;
              do {
                for (const Pe of Object.keys(Se.bindings)) {
                  const Ve = Se.bindings[Pe];
                  Ve.kind === Ee && (le[Pe] = Ve);
                }
                Se = Se.parent;
              } while (Se);
            }
            return le;
          }
          bindingIdentifierEquals(Y, le) {
            return this.getBindingIdentifier(Y) === le;
          }
          getBinding(Y) {
            let le, Ee = this;
            do {
              const Pe = Ee.getOwnBinding(Y);
              var Se;
              if (Pe) {
                if ((Se = le) == null || !Se.isPattern() || Pe.kind === "param" || Pe.kind === "local") return Pe;
              } else if (!Pe && Y === "arguments" && Ee.path.isFunction() && !Ee.path.isArrowFunctionExpression()) break;
              le = Ee.path;
            } while (Ee = Ee.parent);
          }
          getOwnBinding(Y) {
            return this.bindings[Y];
          }
          getBindingIdentifier(Y) {
            var le;
            return (le = this.getBinding(Y)) == null ? void 0 : le.identifier;
          }
          getOwnBindingIdentifier(Y) {
            const le = this.bindings[Y];
            return le == null ? void 0 : le.identifier;
          }
          hasOwnBinding(Y) {
            return !!this.getOwnBinding(Y);
          }
          hasBinding(Y, le) {
            var Ee, Se, Pe;
            return !!Y && (!!this.hasOwnBinding(Y) || (typeof le == "boolean" && (le = { noGlobals: le }), !!this.parentHasBinding(Y, le) || !((Ee = le) != null && Ee.noUids || !this.hasUid(Y)) || !((Se = le) != null && Se.noGlobals || !ue.globals.includes(Y)) || !((Pe = le) != null && Pe.noGlobals || !ue.contextVariables.includes(Y))));
          }
          parentHasBinding(Y, le) {
            var Ee;
            return (Ee = this.parent) == null ? void 0 : Ee.hasBinding(Y, le);
          }
          moveBindingTo(Y, le) {
            const Ee = this.getBinding(Y);
            Ee && (Ee.scope.removeOwnBinding(Y), Ee.scope = le, le.bindings[Y] = Ee);
          }
          removeOwnBinding(Y) {
            delete this.bindings[Y];
          }
          removeBinding(Y) {
            var le;
            (le = this.getBinding(Y)) == null || le.scope.removeOwnBinding(Y);
            let Ee = this;
            do
              Ee.uids[Y] && (Ee.uids[Y] = !1);
            while (Ee = Ee.parent);
          }
        }
        n.default = ue, ue.globals = Object.keys(s.builtin), ue.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/scope/lib/renamer.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+helper-split-export-declaration@7.24.7/node_modules/@babel/helper-split-export-declaration/lib/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js"), f = u("./node_modules/.pnpm/@babel+helper-environment-visitor@7.24.7/node_modules/@babel/helper-environment-visitor/lib/index.js"), s = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/traverse-node.js"), o = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/visitors.js");
        const y = { ReferencedIdentifier({ node: m }, g) {
          m.name === g.oldName && (m.name = g.newName);
        }, Scope(m, g) {
          m.scope.bindingIdentifierEquals(g.oldName, g.binding.identifier) || (m.skip(), m.isMethod() && (0, f.requeueComputedKeyAndDecorators)(m));
        }, ObjectProperty({ node: m, scope: g }, b) {
          const { name: v } = m.key;
          var T;
          !m.shorthand || v !== b.oldName && v !== b.newName || g.getBindingIdentifier(v) !== b.binding.identifier || (m.shorthand = !1, (T = m.extra) != null && T.shorthand && (m.extra.shorthand = !1));
        }, "AssignmentExpression|Declaration|VariableDeclarator"(m, g) {
          if (m.isVariableDeclaration()) return;
          const b = m.getOuterBindingIdentifiers();
          for (const v in b) v === g.oldName && (b[v].name = g.newName);
        } };
        n.default = class {
          constructor(m, g, b) {
            this.newName = b, this.oldName = g, this.binding = m;
          }
          maybeConvertFromExportDeclaration(m) {
            const g = m.parentPath;
            if (g.isExportDeclaration()) {
              if (g.isExportDefaultDeclaration()) {
                const { declaration: b } = g.node;
                if (c.isDeclaration(b) && !b.id) return;
              }
              g.isExportAllDeclaration() || (0, i.default)(g);
            }
          }
          maybeConvertFromClassFunctionDeclaration(m) {
            return m;
          }
          maybeConvertFromClassFunctionExpression(m) {
            return m;
          }
          rename() {
            const { binding: m, oldName: g, newName: b } = this, { scope: v, path: T } = m, E = T.find((D) => D.isDeclaration() || D.isFunctionExpression() || D.isClassExpression());
            E && E.getOuterBindingIdentifiers()[g] === m.identifier && this.maybeConvertFromExportDeclaration(E);
            const O = arguments[0] || v.block;
            (0, s.traverseNode)(O, (0, o.explode)(y), v, this, v.path, { discriminant: !0 }), arguments[0] || (v.removeOwnBinding(g), v.bindings[b] = m, this.binding.identifier.name = b), E && (this.maybeConvertFromClassFunctionDeclaration(T), this.maybeConvertFromClassFunctionExpression(T));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/traverse-node.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.traverseNode = function(s, o, y, m, g, b, v) {
          const T = f[s.type];
          if (!T) return !1;
          const E = new i.default(y, o, m, g);
          if (v) return (b == null || !b[g.parentKey]) && E.visitQueue([g]);
          for (const O of T) if ((b == null || !b[O]) && E.visit(s, O)) return !0;
          return !1;
        };
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/context.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: f } = c;
      }, "./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/visitors.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.explode = v, n.isExplodedVisitor = b, n.merge = function(L, M = [], x) {
          const _ = {};
          for (let S = 0; S < L.length; S++) {
            const C = v(L[S]), R = M[S];
            let H = C;
            (R || x) && (H = O(H, R, x)), k(_, H);
            for (const z of Object.keys(C)) {
              if (I(z)) continue;
              let U = C[z];
              (R || x) && (U = O(U, R, x)), k(_[z] || (_[z] = {}), U);
            }
          }
          return _;
        }, n.verify = T;
        var i = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), c = u("./node_modules/.pnpm/@babel+traverse@7.24.7/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
        const { DEPRECATED_KEYS: s, DEPRECATED_ALIASES: o, FLIPPED_ALIAS_KEYS: y, TYPES: m, __internal__deprecationWarning: g } = f;
        function b(L) {
          return L == null ? void 0 : L._exploded;
        }
        function v(L) {
          if (b(L)) return L;
          L._exploded = !0;
          for (const M of Object.keys(L)) {
            if (I(M)) continue;
            const x = M.split("|");
            if (x.length === 1) continue;
            const _ = L[M];
            delete L[M];
            for (const S of x) L[S] = _;
          }
          T(L), delete L.__esModule, function(M) {
            for (const x of Object.keys(M)) {
              if (I(x)) continue;
              const _ = M[x];
              typeof _ == "function" && (M[x] = { enter: _ });
            }
          }(L), D(L);
          for (const M of Object.keys(L)) {
            if (I(M) || !(M in i)) continue;
            const x = L[M];
            for (const S of Object.keys(x)) x[S] = $(M, x[S]);
            delete L[M];
            const _ = i[M];
            if (_ !== null) for (const S of _) L[S] ? k(L[S], x) : L[S] = x;
            else k(L, x);
          }
          for (const M of Object.keys(L)) {
            if (I(M)) continue;
            let x = y[M];
            if (M in s) {
              const S = s[M];
              g(M, S, "Visitor "), x = [S];
            } else if (M in o) {
              const S = o[M];
              g(M, S, "Visitor "), x = y[S];
            }
            if (!x) continue;
            const _ = L[M];
            delete L[M];
            for (const S of x) {
              const C = L[S];
              C ? k(C, _) : L[S] = Object.assign({}, _);
            }
          }
          for (const M of Object.keys(L)) I(M) || D(L[M]);
          return L;
        }
        function T(L) {
          if (!L._verified) {
            if (typeof L == "function") throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const M of Object.keys(L)) {
              if (M !== "enter" && M !== "exit" || E(M, L[M]), I(M)) continue;
              if (m.indexOf(M) < 0) throw new Error(`You gave us a visitor for the node type ${M} but it's not a valid type`);
              const x = L[M];
              if (typeof x == "object") for (const _ of Object.keys(x)) {
                if (_ !== "enter" && _ !== "exit") throw new Error(`You passed \`traverse()\` a visitor object with the property ${M} that has the invalid property ${_}`);
                E(`${M}.${_}`, x[_]);
              }
            }
            L._verified = !0;
          }
        }
        function E(L, M) {
          const x = [].concat(M);
          for (const _ of x) if (typeof _ != "function") throw new TypeError(`Non-function found defined in ${L} with type ${typeof _}`);
        }
        function O(L, M, x) {
          const _ = {};
          for (const S of ["enter", "exit"]) {
            let C = L[S];
            Array.isArray(C) && (C = C.map(function(R) {
              let H = R;
              return M && (H = function(z) {
                R.call(M, z, M);
              }), x && (H = x(M == null ? void 0 : M.key, S, H)), H !== R && (H.toString = () => R.toString()), H;
            }), _[S] = C);
          }
          return _;
        }
        function D(L) {
          L.enter && !Array.isArray(L.enter) && (L.enter = [L.enter]), L.exit && !Array.isArray(L.exit) && (L.exit = [L.exit]);
        }
        function $(L, M) {
          const x = c[`is${L}`], _ = function(S) {
            if (x.call(S)) return M.apply(this, arguments);
          };
          return _.toString = () => M.toString(), _;
        }
        function I(L) {
          return L[0] === "_" || L === "enter" || L === "exit" || L === "shouldSkip" || L === "denylist" || L === "noScope" || L === "skipKeys" || L === "blacklist";
        }
        function k(L, M) {
          for (const x of ["enter", "exit"]) M[x] && (L[x] = [].concat(L[x] || [], M[x]));
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/asserts/assertNode.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          if (!(0, i.default)(c)) {
            var f;
            const s = (f = c == null ? void 0 : c.type) != null ? f : JSON.stringify(c);
            throw new TypeError(`Not a valid node of type "${s}"`);
          }
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/asserts/generated/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.assertAccessor = function(s, o) {
          f("Accessor", s, o);
        }, n.assertAnyTypeAnnotation = function(s, o) {
          f("AnyTypeAnnotation", s, o);
        }, n.assertArgumentPlaceholder = function(s, o) {
          f("ArgumentPlaceholder", s, o);
        }, n.assertArrayExpression = function(s, o) {
          f("ArrayExpression", s, o);
        }, n.assertArrayPattern = function(s, o) {
          f("ArrayPattern", s, o);
        }, n.assertArrayTypeAnnotation = function(s, o) {
          f("ArrayTypeAnnotation", s, o);
        }, n.assertArrowFunctionExpression = function(s, o) {
          f("ArrowFunctionExpression", s, o);
        }, n.assertAssignmentExpression = function(s, o) {
          f("AssignmentExpression", s, o);
        }, n.assertAssignmentPattern = function(s, o) {
          f("AssignmentPattern", s, o);
        }, n.assertAwaitExpression = function(s, o) {
          f("AwaitExpression", s, o);
        }, n.assertBigIntLiteral = function(s, o) {
          f("BigIntLiteral", s, o);
        }, n.assertBinary = function(s, o) {
          f("Binary", s, o);
        }, n.assertBinaryExpression = function(s, o) {
          f("BinaryExpression", s, o);
        }, n.assertBindExpression = function(s, o) {
          f("BindExpression", s, o);
        }, n.assertBlock = function(s, o) {
          f("Block", s, o);
        }, n.assertBlockParent = function(s, o) {
          f("BlockParent", s, o);
        }, n.assertBlockStatement = function(s, o) {
          f("BlockStatement", s, o);
        }, n.assertBooleanLiteral = function(s, o) {
          f("BooleanLiteral", s, o);
        }, n.assertBooleanLiteralTypeAnnotation = function(s, o) {
          f("BooleanLiteralTypeAnnotation", s, o);
        }, n.assertBooleanTypeAnnotation = function(s, o) {
          f("BooleanTypeAnnotation", s, o);
        }, n.assertBreakStatement = function(s, o) {
          f("BreakStatement", s, o);
        }, n.assertCallExpression = function(s, o) {
          f("CallExpression", s, o);
        }, n.assertCatchClause = function(s, o) {
          f("CatchClause", s, o);
        }, n.assertClass = function(s, o) {
          f("Class", s, o);
        }, n.assertClassAccessorProperty = function(s, o) {
          f("ClassAccessorProperty", s, o);
        }, n.assertClassBody = function(s, o) {
          f("ClassBody", s, o);
        }, n.assertClassDeclaration = function(s, o) {
          f("ClassDeclaration", s, o);
        }, n.assertClassExpression = function(s, o) {
          f("ClassExpression", s, o);
        }, n.assertClassImplements = function(s, o) {
          f("ClassImplements", s, o);
        }, n.assertClassMethod = function(s, o) {
          f("ClassMethod", s, o);
        }, n.assertClassPrivateMethod = function(s, o) {
          f("ClassPrivateMethod", s, o);
        }, n.assertClassPrivateProperty = function(s, o) {
          f("ClassPrivateProperty", s, o);
        }, n.assertClassProperty = function(s, o) {
          f("ClassProperty", s, o);
        }, n.assertCompletionStatement = function(s, o) {
          f("CompletionStatement", s, o);
        }, n.assertConditional = function(s, o) {
          f("Conditional", s, o);
        }, n.assertConditionalExpression = function(s, o) {
          f("ConditionalExpression", s, o);
        }, n.assertContinueStatement = function(s, o) {
          f("ContinueStatement", s, o);
        }, n.assertDebuggerStatement = function(s, o) {
          f("DebuggerStatement", s, o);
        }, n.assertDecimalLiteral = function(s, o) {
          f("DecimalLiteral", s, o);
        }, n.assertDeclaration = function(s, o) {
          f("Declaration", s, o);
        }, n.assertDeclareClass = function(s, o) {
          f("DeclareClass", s, o);
        }, n.assertDeclareExportAllDeclaration = function(s, o) {
          f("DeclareExportAllDeclaration", s, o);
        }, n.assertDeclareExportDeclaration = function(s, o) {
          f("DeclareExportDeclaration", s, o);
        }, n.assertDeclareFunction = function(s, o) {
          f("DeclareFunction", s, o);
        }, n.assertDeclareInterface = function(s, o) {
          f("DeclareInterface", s, o);
        }, n.assertDeclareModule = function(s, o) {
          f("DeclareModule", s, o);
        }, n.assertDeclareModuleExports = function(s, o) {
          f("DeclareModuleExports", s, o);
        }, n.assertDeclareOpaqueType = function(s, o) {
          f("DeclareOpaqueType", s, o);
        }, n.assertDeclareTypeAlias = function(s, o) {
          f("DeclareTypeAlias", s, o);
        }, n.assertDeclareVariable = function(s, o) {
          f("DeclareVariable", s, o);
        }, n.assertDeclaredPredicate = function(s, o) {
          f("DeclaredPredicate", s, o);
        }, n.assertDecorator = function(s, o) {
          f("Decorator", s, o);
        }, n.assertDirective = function(s, o) {
          f("Directive", s, o);
        }, n.assertDirectiveLiteral = function(s, o) {
          f("DirectiveLiteral", s, o);
        }, n.assertDoExpression = function(s, o) {
          f("DoExpression", s, o);
        }, n.assertDoWhileStatement = function(s, o) {
          f("DoWhileStatement", s, o);
        }, n.assertEmptyStatement = function(s, o) {
          f("EmptyStatement", s, o);
        }, n.assertEmptyTypeAnnotation = function(s, o) {
          f("EmptyTypeAnnotation", s, o);
        }, n.assertEnumBody = function(s, o) {
          f("EnumBody", s, o);
        }, n.assertEnumBooleanBody = function(s, o) {
          f("EnumBooleanBody", s, o);
        }, n.assertEnumBooleanMember = function(s, o) {
          f("EnumBooleanMember", s, o);
        }, n.assertEnumDeclaration = function(s, o) {
          f("EnumDeclaration", s, o);
        }, n.assertEnumDefaultedMember = function(s, o) {
          f("EnumDefaultedMember", s, o);
        }, n.assertEnumMember = function(s, o) {
          f("EnumMember", s, o);
        }, n.assertEnumNumberBody = function(s, o) {
          f("EnumNumberBody", s, o);
        }, n.assertEnumNumberMember = function(s, o) {
          f("EnumNumberMember", s, o);
        }, n.assertEnumStringBody = function(s, o) {
          f("EnumStringBody", s, o);
        }, n.assertEnumStringMember = function(s, o) {
          f("EnumStringMember", s, o);
        }, n.assertEnumSymbolBody = function(s, o) {
          f("EnumSymbolBody", s, o);
        }, n.assertExistsTypeAnnotation = function(s, o) {
          f("ExistsTypeAnnotation", s, o);
        }, n.assertExportAllDeclaration = function(s, o) {
          f("ExportAllDeclaration", s, o);
        }, n.assertExportDeclaration = function(s, o) {
          f("ExportDeclaration", s, o);
        }, n.assertExportDefaultDeclaration = function(s, o) {
          f("ExportDefaultDeclaration", s, o);
        }, n.assertExportDefaultSpecifier = function(s, o) {
          f("ExportDefaultSpecifier", s, o);
        }, n.assertExportNamedDeclaration = function(s, o) {
          f("ExportNamedDeclaration", s, o);
        }, n.assertExportNamespaceSpecifier = function(s, o) {
          f("ExportNamespaceSpecifier", s, o);
        }, n.assertExportSpecifier = function(s, o) {
          f("ExportSpecifier", s, o);
        }, n.assertExpression = function(s, o) {
          f("Expression", s, o);
        }, n.assertExpressionStatement = function(s, o) {
          f("ExpressionStatement", s, o);
        }, n.assertExpressionWrapper = function(s, o) {
          f("ExpressionWrapper", s, o);
        }, n.assertFile = function(s, o) {
          f("File", s, o);
        }, n.assertFlow = function(s, o) {
          f("Flow", s, o);
        }, n.assertFlowBaseAnnotation = function(s, o) {
          f("FlowBaseAnnotation", s, o);
        }, n.assertFlowDeclaration = function(s, o) {
          f("FlowDeclaration", s, o);
        }, n.assertFlowPredicate = function(s, o) {
          f("FlowPredicate", s, o);
        }, n.assertFlowType = function(s, o) {
          f("FlowType", s, o);
        }, n.assertFor = function(s, o) {
          f("For", s, o);
        }, n.assertForInStatement = function(s, o) {
          f("ForInStatement", s, o);
        }, n.assertForOfStatement = function(s, o) {
          f("ForOfStatement", s, o);
        }, n.assertForStatement = function(s, o) {
          f("ForStatement", s, o);
        }, n.assertForXStatement = function(s, o) {
          f("ForXStatement", s, o);
        }, n.assertFunction = function(s, o) {
          f("Function", s, o);
        }, n.assertFunctionDeclaration = function(s, o) {
          f("FunctionDeclaration", s, o);
        }, n.assertFunctionExpression = function(s, o) {
          f("FunctionExpression", s, o);
        }, n.assertFunctionParent = function(s, o) {
          f("FunctionParent", s, o);
        }, n.assertFunctionTypeAnnotation = function(s, o) {
          f("FunctionTypeAnnotation", s, o);
        }, n.assertFunctionTypeParam = function(s, o) {
          f("FunctionTypeParam", s, o);
        }, n.assertGenericTypeAnnotation = function(s, o) {
          f("GenericTypeAnnotation", s, o);
        }, n.assertIdentifier = function(s, o) {
          f("Identifier", s, o);
        }, n.assertIfStatement = function(s, o) {
          f("IfStatement", s, o);
        }, n.assertImmutable = function(s, o) {
          f("Immutable", s, o);
        }, n.assertImport = function(s, o) {
          f("Import", s, o);
        }, n.assertImportAttribute = function(s, o) {
          f("ImportAttribute", s, o);
        }, n.assertImportDeclaration = function(s, o) {
          f("ImportDeclaration", s, o);
        }, n.assertImportDefaultSpecifier = function(s, o) {
          f("ImportDefaultSpecifier", s, o);
        }, n.assertImportExpression = function(s, o) {
          f("ImportExpression", s, o);
        }, n.assertImportNamespaceSpecifier = function(s, o) {
          f("ImportNamespaceSpecifier", s, o);
        }, n.assertImportOrExportDeclaration = function(s, o) {
          f("ImportOrExportDeclaration", s, o);
        }, n.assertImportSpecifier = function(s, o) {
          f("ImportSpecifier", s, o);
        }, n.assertIndexedAccessType = function(s, o) {
          f("IndexedAccessType", s, o);
        }, n.assertInferredPredicate = function(s, o) {
          f("InferredPredicate", s, o);
        }, n.assertInterfaceDeclaration = function(s, o) {
          f("InterfaceDeclaration", s, o);
        }, n.assertInterfaceExtends = function(s, o) {
          f("InterfaceExtends", s, o);
        }, n.assertInterfaceTypeAnnotation = function(s, o) {
          f("InterfaceTypeAnnotation", s, o);
        }, n.assertInterpreterDirective = function(s, o) {
          f("InterpreterDirective", s, o);
        }, n.assertIntersectionTypeAnnotation = function(s, o) {
          f("IntersectionTypeAnnotation", s, o);
        }, n.assertJSX = function(s, o) {
          f("JSX", s, o);
        }, n.assertJSXAttribute = function(s, o) {
          f("JSXAttribute", s, o);
        }, n.assertJSXClosingElement = function(s, o) {
          f("JSXClosingElement", s, o);
        }, n.assertJSXClosingFragment = function(s, o) {
          f("JSXClosingFragment", s, o);
        }, n.assertJSXElement = function(s, o) {
          f("JSXElement", s, o);
        }, n.assertJSXEmptyExpression = function(s, o) {
          f("JSXEmptyExpression", s, o);
        }, n.assertJSXExpressionContainer = function(s, o) {
          f("JSXExpressionContainer", s, o);
        }, n.assertJSXFragment = function(s, o) {
          f("JSXFragment", s, o);
        }, n.assertJSXIdentifier = function(s, o) {
          f("JSXIdentifier", s, o);
        }, n.assertJSXMemberExpression = function(s, o) {
          f("JSXMemberExpression", s, o);
        }, n.assertJSXNamespacedName = function(s, o) {
          f("JSXNamespacedName", s, o);
        }, n.assertJSXOpeningElement = function(s, o) {
          f("JSXOpeningElement", s, o);
        }, n.assertJSXOpeningFragment = function(s, o) {
          f("JSXOpeningFragment", s, o);
        }, n.assertJSXSpreadAttribute = function(s, o) {
          f("JSXSpreadAttribute", s, o);
        }, n.assertJSXSpreadChild = function(s, o) {
          f("JSXSpreadChild", s, o);
        }, n.assertJSXText = function(s, o) {
          f("JSXText", s, o);
        }, n.assertLVal = function(s, o) {
          f("LVal", s, o);
        }, n.assertLabeledStatement = function(s, o) {
          f("LabeledStatement", s, o);
        }, n.assertLiteral = function(s, o) {
          f("Literal", s, o);
        }, n.assertLogicalExpression = function(s, o) {
          f("LogicalExpression", s, o);
        }, n.assertLoop = function(s, o) {
          f("Loop", s, o);
        }, n.assertMemberExpression = function(s, o) {
          f("MemberExpression", s, o);
        }, n.assertMetaProperty = function(s, o) {
          f("MetaProperty", s, o);
        }, n.assertMethod = function(s, o) {
          f("Method", s, o);
        }, n.assertMiscellaneous = function(s, o) {
          f("Miscellaneous", s, o);
        }, n.assertMixedTypeAnnotation = function(s, o) {
          f("MixedTypeAnnotation", s, o);
        }, n.assertModuleDeclaration = function(s, o) {
          (0, c.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), f("ModuleDeclaration", s, o);
        }, n.assertModuleExpression = function(s, o) {
          f("ModuleExpression", s, o);
        }, n.assertModuleSpecifier = function(s, o) {
          f("ModuleSpecifier", s, o);
        }, n.assertNewExpression = function(s, o) {
          f("NewExpression", s, o);
        }, n.assertNoop = function(s, o) {
          f("Noop", s, o);
        }, n.assertNullLiteral = function(s, o) {
          f("NullLiteral", s, o);
        }, n.assertNullLiteralTypeAnnotation = function(s, o) {
          f("NullLiteralTypeAnnotation", s, o);
        }, n.assertNullableTypeAnnotation = function(s, o) {
          f("NullableTypeAnnotation", s, o);
        }, n.assertNumberLiteral = function(s, o) {
          (0, c.default)("assertNumberLiteral", "assertNumericLiteral"), f("NumberLiteral", s, o);
        }, n.assertNumberLiteralTypeAnnotation = function(s, o) {
          f("NumberLiteralTypeAnnotation", s, o);
        }, n.assertNumberTypeAnnotation = function(s, o) {
          f("NumberTypeAnnotation", s, o);
        }, n.assertNumericLiteral = function(s, o) {
          f("NumericLiteral", s, o);
        }, n.assertObjectExpression = function(s, o) {
          f("ObjectExpression", s, o);
        }, n.assertObjectMember = function(s, o) {
          f("ObjectMember", s, o);
        }, n.assertObjectMethod = function(s, o) {
          f("ObjectMethod", s, o);
        }, n.assertObjectPattern = function(s, o) {
          f("ObjectPattern", s, o);
        }, n.assertObjectProperty = function(s, o) {
          f("ObjectProperty", s, o);
        }, n.assertObjectTypeAnnotation = function(s, o) {
          f("ObjectTypeAnnotation", s, o);
        }, n.assertObjectTypeCallProperty = function(s, o) {
          f("ObjectTypeCallProperty", s, o);
        }, n.assertObjectTypeIndexer = function(s, o) {
          f("ObjectTypeIndexer", s, o);
        }, n.assertObjectTypeInternalSlot = function(s, o) {
          f("ObjectTypeInternalSlot", s, o);
        }, n.assertObjectTypeProperty = function(s, o) {
          f("ObjectTypeProperty", s, o);
        }, n.assertObjectTypeSpreadProperty = function(s, o) {
          f("ObjectTypeSpreadProperty", s, o);
        }, n.assertOpaqueType = function(s, o) {
          f("OpaqueType", s, o);
        }, n.assertOptionalCallExpression = function(s, o) {
          f("OptionalCallExpression", s, o);
        }, n.assertOptionalIndexedAccessType = function(s, o) {
          f("OptionalIndexedAccessType", s, o);
        }, n.assertOptionalMemberExpression = function(s, o) {
          f("OptionalMemberExpression", s, o);
        }, n.assertParenthesizedExpression = function(s, o) {
          f("ParenthesizedExpression", s, o);
        }, n.assertPattern = function(s, o) {
          f("Pattern", s, o);
        }, n.assertPatternLike = function(s, o) {
          f("PatternLike", s, o);
        }, n.assertPipelineBareFunction = function(s, o) {
          f("PipelineBareFunction", s, o);
        }, n.assertPipelinePrimaryTopicReference = function(s, o) {
          f("PipelinePrimaryTopicReference", s, o);
        }, n.assertPipelineTopicExpression = function(s, o) {
          f("PipelineTopicExpression", s, o);
        }, n.assertPlaceholder = function(s, o) {
          f("Placeholder", s, o);
        }, n.assertPrivate = function(s, o) {
          f("Private", s, o);
        }, n.assertPrivateName = function(s, o) {
          f("PrivateName", s, o);
        }, n.assertProgram = function(s, o) {
          f("Program", s, o);
        }, n.assertProperty = function(s, o) {
          f("Property", s, o);
        }, n.assertPureish = function(s, o) {
          f("Pureish", s, o);
        }, n.assertQualifiedTypeIdentifier = function(s, o) {
          f("QualifiedTypeIdentifier", s, o);
        }, n.assertRecordExpression = function(s, o) {
          f("RecordExpression", s, o);
        }, n.assertRegExpLiteral = function(s, o) {
          f("RegExpLiteral", s, o);
        }, n.assertRegexLiteral = function(s, o) {
          (0, c.default)("assertRegexLiteral", "assertRegExpLiteral"), f("RegexLiteral", s, o);
        }, n.assertRestElement = function(s, o) {
          f("RestElement", s, o);
        }, n.assertRestProperty = function(s, o) {
          (0, c.default)("assertRestProperty", "assertRestElement"), f("RestProperty", s, o);
        }, n.assertReturnStatement = function(s, o) {
          f("ReturnStatement", s, o);
        }, n.assertScopable = function(s, o) {
          f("Scopable", s, o);
        }, n.assertSequenceExpression = function(s, o) {
          f("SequenceExpression", s, o);
        }, n.assertSpreadElement = function(s, o) {
          f("SpreadElement", s, o);
        }, n.assertSpreadProperty = function(s, o) {
          (0, c.default)("assertSpreadProperty", "assertSpreadElement"), f("SpreadProperty", s, o);
        }, n.assertStandardized = function(s, o) {
          f("Standardized", s, o);
        }, n.assertStatement = function(s, o) {
          f("Statement", s, o);
        }, n.assertStaticBlock = function(s, o) {
          f("StaticBlock", s, o);
        }, n.assertStringLiteral = function(s, o) {
          f("StringLiteral", s, o);
        }, n.assertStringLiteralTypeAnnotation = function(s, o) {
          f("StringLiteralTypeAnnotation", s, o);
        }, n.assertStringTypeAnnotation = function(s, o) {
          f("StringTypeAnnotation", s, o);
        }, n.assertSuper = function(s, o) {
          f("Super", s, o);
        }, n.assertSwitchCase = function(s, o) {
          f("SwitchCase", s, o);
        }, n.assertSwitchStatement = function(s, o) {
          f("SwitchStatement", s, o);
        }, n.assertSymbolTypeAnnotation = function(s, o) {
          f("SymbolTypeAnnotation", s, o);
        }, n.assertTSAnyKeyword = function(s, o) {
          f("TSAnyKeyword", s, o);
        }, n.assertTSArrayType = function(s, o) {
          f("TSArrayType", s, o);
        }, n.assertTSAsExpression = function(s, o) {
          f("TSAsExpression", s, o);
        }, n.assertTSBaseType = function(s, o) {
          f("TSBaseType", s, o);
        }, n.assertTSBigIntKeyword = function(s, o) {
          f("TSBigIntKeyword", s, o);
        }, n.assertTSBooleanKeyword = function(s, o) {
          f("TSBooleanKeyword", s, o);
        }, n.assertTSCallSignatureDeclaration = function(s, o) {
          f("TSCallSignatureDeclaration", s, o);
        }, n.assertTSConditionalType = function(s, o) {
          f("TSConditionalType", s, o);
        }, n.assertTSConstructSignatureDeclaration = function(s, o) {
          f("TSConstructSignatureDeclaration", s, o);
        }, n.assertTSConstructorType = function(s, o) {
          f("TSConstructorType", s, o);
        }, n.assertTSDeclareFunction = function(s, o) {
          f("TSDeclareFunction", s, o);
        }, n.assertTSDeclareMethod = function(s, o) {
          f("TSDeclareMethod", s, o);
        }, n.assertTSEntityName = function(s, o) {
          f("TSEntityName", s, o);
        }, n.assertTSEnumDeclaration = function(s, o) {
          f("TSEnumDeclaration", s, o);
        }, n.assertTSEnumMember = function(s, o) {
          f("TSEnumMember", s, o);
        }, n.assertTSExportAssignment = function(s, o) {
          f("TSExportAssignment", s, o);
        }, n.assertTSExpressionWithTypeArguments = function(s, o) {
          f("TSExpressionWithTypeArguments", s, o);
        }, n.assertTSExternalModuleReference = function(s, o) {
          f("TSExternalModuleReference", s, o);
        }, n.assertTSFunctionType = function(s, o) {
          f("TSFunctionType", s, o);
        }, n.assertTSImportEqualsDeclaration = function(s, o) {
          f("TSImportEqualsDeclaration", s, o);
        }, n.assertTSImportType = function(s, o) {
          f("TSImportType", s, o);
        }, n.assertTSIndexSignature = function(s, o) {
          f("TSIndexSignature", s, o);
        }, n.assertTSIndexedAccessType = function(s, o) {
          f("TSIndexedAccessType", s, o);
        }, n.assertTSInferType = function(s, o) {
          f("TSInferType", s, o);
        }, n.assertTSInstantiationExpression = function(s, o) {
          f("TSInstantiationExpression", s, o);
        }, n.assertTSInterfaceBody = function(s, o) {
          f("TSInterfaceBody", s, o);
        }, n.assertTSInterfaceDeclaration = function(s, o) {
          f("TSInterfaceDeclaration", s, o);
        }, n.assertTSIntersectionType = function(s, o) {
          f("TSIntersectionType", s, o);
        }, n.assertTSIntrinsicKeyword = function(s, o) {
          f("TSIntrinsicKeyword", s, o);
        }, n.assertTSLiteralType = function(s, o) {
          f("TSLiteralType", s, o);
        }, n.assertTSMappedType = function(s, o) {
          f("TSMappedType", s, o);
        }, n.assertTSMethodSignature = function(s, o) {
          f("TSMethodSignature", s, o);
        }, n.assertTSModuleBlock = function(s, o) {
          f("TSModuleBlock", s, o);
        }, n.assertTSModuleDeclaration = function(s, o) {
          f("TSModuleDeclaration", s, o);
        }, n.assertTSNamedTupleMember = function(s, o) {
          f("TSNamedTupleMember", s, o);
        }, n.assertTSNamespaceExportDeclaration = function(s, o) {
          f("TSNamespaceExportDeclaration", s, o);
        }, n.assertTSNeverKeyword = function(s, o) {
          f("TSNeverKeyword", s, o);
        }, n.assertTSNonNullExpression = function(s, o) {
          f("TSNonNullExpression", s, o);
        }, n.assertTSNullKeyword = function(s, o) {
          f("TSNullKeyword", s, o);
        }, n.assertTSNumberKeyword = function(s, o) {
          f("TSNumberKeyword", s, o);
        }, n.assertTSObjectKeyword = function(s, o) {
          f("TSObjectKeyword", s, o);
        }, n.assertTSOptionalType = function(s, o) {
          f("TSOptionalType", s, o);
        }, n.assertTSParameterProperty = function(s, o) {
          f("TSParameterProperty", s, o);
        }, n.assertTSParenthesizedType = function(s, o) {
          f("TSParenthesizedType", s, o);
        }, n.assertTSPropertySignature = function(s, o) {
          f("TSPropertySignature", s, o);
        }, n.assertTSQualifiedName = function(s, o) {
          f("TSQualifiedName", s, o);
        }, n.assertTSRestType = function(s, o) {
          f("TSRestType", s, o);
        }, n.assertTSSatisfiesExpression = function(s, o) {
          f("TSSatisfiesExpression", s, o);
        }, n.assertTSStringKeyword = function(s, o) {
          f("TSStringKeyword", s, o);
        }, n.assertTSSymbolKeyword = function(s, o) {
          f("TSSymbolKeyword", s, o);
        }, n.assertTSThisType = function(s, o) {
          f("TSThisType", s, o);
        }, n.assertTSTupleType = function(s, o) {
          f("TSTupleType", s, o);
        }, n.assertTSType = function(s, o) {
          f("TSType", s, o);
        }, n.assertTSTypeAliasDeclaration = function(s, o) {
          f("TSTypeAliasDeclaration", s, o);
        }, n.assertTSTypeAnnotation = function(s, o) {
          f("TSTypeAnnotation", s, o);
        }, n.assertTSTypeAssertion = function(s, o) {
          f("TSTypeAssertion", s, o);
        }, n.assertTSTypeElement = function(s, o) {
          f("TSTypeElement", s, o);
        }, n.assertTSTypeLiteral = function(s, o) {
          f("TSTypeLiteral", s, o);
        }, n.assertTSTypeOperator = function(s, o) {
          f("TSTypeOperator", s, o);
        }, n.assertTSTypeParameter = function(s, o) {
          f("TSTypeParameter", s, o);
        }, n.assertTSTypeParameterDeclaration = function(s, o) {
          f("TSTypeParameterDeclaration", s, o);
        }, n.assertTSTypeParameterInstantiation = function(s, o) {
          f("TSTypeParameterInstantiation", s, o);
        }, n.assertTSTypePredicate = function(s, o) {
          f("TSTypePredicate", s, o);
        }, n.assertTSTypeQuery = function(s, o) {
          f("TSTypeQuery", s, o);
        }, n.assertTSTypeReference = function(s, o) {
          f("TSTypeReference", s, o);
        }, n.assertTSUndefinedKeyword = function(s, o) {
          f("TSUndefinedKeyword", s, o);
        }, n.assertTSUnionType = function(s, o) {
          f("TSUnionType", s, o);
        }, n.assertTSUnknownKeyword = function(s, o) {
          f("TSUnknownKeyword", s, o);
        }, n.assertTSVoidKeyword = function(s, o) {
          f("TSVoidKeyword", s, o);
        }, n.assertTaggedTemplateExpression = function(s, o) {
          f("TaggedTemplateExpression", s, o);
        }, n.assertTemplateElement = function(s, o) {
          f("TemplateElement", s, o);
        }, n.assertTemplateLiteral = function(s, o) {
          f("TemplateLiteral", s, o);
        }, n.assertTerminatorless = function(s, o) {
          f("Terminatorless", s, o);
        }, n.assertThisExpression = function(s, o) {
          f("ThisExpression", s, o);
        }, n.assertThisTypeAnnotation = function(s, o) {
          f("ThisTypeAnnotation", s, o);
        }, n.assertThrowStatement = function(s, o) {
          f("ThrowStatement", s, o);
        }, n.assertTopicReference = function(s, o) {
          f("TopicReference", s, o);
        }, n.assertTryStatement = function(s, o) {
          f("TryStatement", s, o);
        }, n.assertTupleExpression = function(s, o) {
          f("TupleExpression", s, o);
        }, n.assertTupleTypeAnnotation = function(s, o) {
          f("TupleTypeAnnotation", s, o);
        }, n.assertTypeAlias = function(s, o) {
          f("TypeAlias", s, o);
        }, n.assertTypeAnnotation = function(s, o) {
          f("TypeAnnotation", s, o);
        }, n.assertTypeCastExpression = function(s, o) {
          f("TypeCastExpression", s, o);
        }, n.assertTypeParameter = function(s, o) {
          f("TypeParameter", s, o);
        }, n.assertTypeParameterDeclaration = function(s, o) {
          f("TypeParameterDeclaration", s, o);
        }, n.assertTypeParameterInstantiation = function(s, o) {
          f("TypeParameterInstantiation", s, o);
        }, n.assertTypeScript = function(s, o) {
          f("TypeScript", s, o);
        }, n.assertTypeofTypeAnnotation = function(s, o) {
          f("TypeofTypeAnnotation", s, o);
        }, n.assertUnaryExpression = function(s, o) {
          f("UnaryExpression", s, o);
        }, n.assertUnaryLike = function(s, o) {
          f("UnaryLike", s, o);
        }, n.assertUnionTypeAnnotation = function(s, o) {
          f("UnionTypeAnnotation", s, o);
        }, n.assertUpdateExpression = function(s, o) {
          f("UpdateExpression", s, o);
        }, n.assertUserWhitespacable = function(s, o) {
          f("UserWhitespacable", s, o);
        }, n.assertV8IntrinsicIdentifier = function(s, o) {
          f("V8IntrinsicIdentifier", s, o);
        }, n.assertVariableDeclaration = function(s, o) {
          f("VariableDeclaration", s, o);
        }, n.assertVariableDeclarator = function(s, o) {
          f("VariableDeclarator", s, o);
        }, n.assertVariance = function(s, o) {
          f("Variance", s, o);
        }, n.assertVoidTypeAnnotation = function(s, o) {
          f("VoidTypeAnnotation", s, o);
        }, n.assertWhile = function(s, o) {
          f("While", s, o);
        }, n.assertWhileStatement = function(s, o) {
          f("WhileStatement", s, o);
        }, n.assertWithStatement = function(s, o) {
          f("WithStatement", s, o);
        }, n.assertYieldExpression = function(s, o) {
          f("YieldExpression", s, o);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/is.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function f(s, o, y) {
          if (!(0, i.default)(s, o, y)) throw new Error(`Expected type "${s}" with option ${JSON.stringify(y)}, but instead got "${o.type}".`);
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          const s = (0, c.default)(f);
          return s.length === 1 ? s[0] : (0, i.unionTypeAnnotation)(s);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
        n.default = function(c) {
          switch (c) {
            case "string":
              return (0, i.stringTypeAnnotation)();
            case "number":
              return (0, i.numberTypeAnnotation)();
            case "undefined":
              return (0, i.voidTypeAnnotation)();
            case "boolean":
              return (0, i.booleanTypeAnnotation)();
            case "function":
              return (0, i.genericTypeAnnotation)((0, i.identifier)("Function"));
            case "object":
              return (0, i.genericTypeAnnotation)((0, i.identifier)("Object"));
            case "symbol":
              return (0, i.genericTypeAnnotation)((0, i.identifier)("Symbol"));
            case "bigint":
              return (0, i.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + c);
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.anyTypeAnnotation = function() {
          return { type: "AnyTypeAnnotation" };
        }, n.argumentPlaceholder = function() {
          return { type: "ArgumentPlaceholder" };
        }, n.arrayExpression = function(m = []) {
          return (0, i.default)({ type: "ArrayExpression", elements: m });
        }, n.arrayPattern = function(m) {
          return (0, i.default)({ type: "ArrayPattern", elements: m });
        }, n.arrayTypeAnnotation = function(m) {
          return (0, i.default)({ type: "ArrayTypeAnnotation", elementType: m });
        }, n.arrowFunctionExpression = function(m, g, b = !1) {
          return (0, i.default)({ type: "ArrowFunctionExpression", params: m, body: g, async: b, expression: null });
        }, n.assignmentExpression = function(m, g, b) {
          return (0, i.default)({ type: "AssignmentExpression", operator: m, left: g, right: b });
        }, n.assignmentPattern = function(m, g) {
          return (0, i.default)({ type: "AssignmentPattern", left: m, right: g });
        }, n.awaitExpression = function(m) {
          return (0, i.default)({ type: "AwaitExpression", argument: m });
        }, n.bigIntLiteral = function(m) {
          return (0, i.default)({ type: "BigIntLiteral", value: m });
        }, n.binaryExpression = function(m, g, b) {
          return (0, i.default)({ type: "BinaryExpression", operator: m, left: g, right: b });
        }, n.bindExpression = function(m, g) {
          return (0, i.default)({ type: "BindExpression", object: m, callee: g });
        }, n.blockStatement = function(m, g = []) {
          return (0, i.default)({ type: "BlockStatement", body: m, directives: g });
        }, n.booleanLiteral = function(m) {
          return (0, i.default)({ type: "BooleanLiteral", value: m });
        }, n.booleanLiteralTypeAnnotation = function(m) {
          return (0, i.default)({ type: "BooleanLiteralTypeAnnotation", value: m });
        }, n.booleanTypeAnnotation = function() {
          return { type: "BooleanTypeAnnotation" };
        }, n.breakStatement = function(m = null) {
          return (0, i.default)({ type: "BreakStatement", label: m });
        }, n.callExpression = function(m, g) {
          return (0, i.default)({ type: "CallExpression", callee: m, arguments: g });
        }, n.catchClause = function(m = null, g) {
          return (0, i.default)({ type: "CatchClause", param: m, body: g });
        }, n.classAccessorProperty = function(m, g = null, b = null, v = null, T = !1, E = !1) {
          return (0, i.default)({ type: "ClassAccessorProperty", key: m, value: g, typeAnnotation: b, decorators: v, computed: T, static: E });
        }, n.classBody = function(m) {
          return (0, i.default)({ type: "ClassBody", body: m });
        }, n.classDeclaration = function(m = null, g = null, b, v = null) {
          return (0, i.default)({ type: "ClassDeclaration", id: m, superClass: g, body: b, decorators: v });
        }, n.classExpression = function(m = null, g = null, b, v = null) {
          return (0, i.default)({ type: "ClassExpression", id: m, superClass: g, body: b, decorators: v });
        }, n.classImplements = function(m, g = null) {
          return (0, i.default)({ type: "ClassImplements", id: m, typeParameters: g });
        }, n.classMethod = function(m = "method", g, b, v, T = !1, E = !1, O = !1, D = !1) {
          return (0, i.default)({ type: "ClassMethod", kind: m, key: g, params: b, body: v, computed: T, static: E, generator: O, async: D });
        }, n.classPrivateMethod = function(m = "method", g, b, v, T = !1) {
          return (0, i.default)({ type: "ClassPrivateMethod", kind: m, key: g, params: b, body: v, static: T });
        }, n.classPrivateProperty = function(m, g = null, b = null, v = !1) {
          return (0, i.default)({ type: "ClassPrivateProperty", key: m, value: g, decorators: b, static: v });
        }, n.classProperty = function(m, g = null, b = null, v = null, T = !1, E = !1) {
          return (0, i.default)({ type: "ClassProperty", key: m, value: g, typeAnnotation: b, decorators: v, computed: T, static: E });
        }, n.conditionalExpression = function(m, g, b) {
          return (0, i.default)({ type: "ConditionalExpression", test: m, consequent: g, alternate: b });
        }, n.continueStatement = function(m = null) {
          return (0, i.default)({ type: "ContinueStatement", label: m });
        }, n.debuggerStatement = function() {
          return { type: "DebuggerStatement" };
        }, n.decimalLiteral = function(m) {
          return (0, i.default)({ type: "DecimalLiteral", value: m });
        }, n.declareClass = function(m, g = null, b = null, v) {
          return (0, i.default)({ type: "DeclareClass", id: m, typeParameters: g, extends: b, body: v });
        }, n.declareExportAllDeclaration = function(m) {
          return (0, i.default)({ type: "DeclareExportAllDeclaration", source: m });
        }, n.declareExportDeclaration = function(m = null, g = null, b = null) {
          return (0, i.default)({ type: "DeclareExportDeclaration", declaration: m, specifiers: g, source: b });
        }, n.declareFunction = function(m) {
          return (0, i.default)({ type: "DeclareFunction", id: m });
        }, n.declareInterface = function(m, g = null, b = null, v) {
          return (0, i.default)({ type: "DeclareInterface", id: m, typeParameters: g, extends: b, body: v });
        }, n.declareModule = function(m, g, b = null) {
          return (0, i.default)({ type: "DeclareModule", id: m, body: g, kind: b });
        }, n.declareModuleExports = function(m) {
          return (0, i.default)({ type: "DeclareModuleExports", typeAnnotation: m });
        }, n.declareOpaqueType = function(m, g = null, b = null) {
          return (0, i.default)({ type: "DeclareOpaqueType", id: m, typeParameters: g, supertype: b });
        }, n.declareTypeAlias = function(m, g = null, b) {
          return (0, i.default)({ type: "DeclareTypeAlias", id: m, typeParameters: g, right: b });
        }, n.declareVariable = function(m) {
          return (0, i.default)({ type: "DeclareVariable", id: m });
        }, n.declaredPredicate = function(m) {
          return (0, i.default)({ type: "DeclaredPredicate", value: m });
        }, n.decorator = function(m) {
          return (0, i.default)({ type: "Decorator", expression: m });
        }, n.directive = function(m) {
          return (0, i.default)({ type: "Directive", value: m });
        }, n.directiveLiteral = function(m) {
          return (0, i.default)({ type: "DirectiveLiteral", value: m });
        }, n.doExpression = function(m, g = !1) {
          return (0, i.default)({ type: "DoExpression", body: m, async: g });
        }, n.doWhileStatement = function(m, g) {
          return (0, i.default)({ type: "DoWhileStatement", test: m, body: g });
        }, n.emptyStatement = function() {
          return { type: "EmptyStatement" };
        }, n.emptyTypeAnnotation = function() {
          return { type: "EmptyTypeAnnotation" };
        }, n.enumBooleanBody = function(m) {
          return (0, i.default)({ type: "EnumBooleanBody", members: m, explicitType: null, hasUnknownMembers: null });
        }, n.enumBooleanMember = function(m) {
          return (0, i.default)({ type: "EnumBooleanMember", id: m, init: null });
        }, n.enumDeclaration = function(m, g) {
          return (0, i.default)({ type: "EnumDeclaration", id: m, body: g });
        }, n.enumDefaultedMember = function(m) {
          return (0, i.default)({ type: "EnumDefaultedMember", id: m });
        }, n.enumNumberBody = function(m) {
          return (0, i.default)({ type: "EnumNumberBody", members: m, explicitType: null, hasUnknownMembers: null });
        }, n.enumNumberMember = function(m, g) {
          return (0, i.default)({ type: "EnumNumberMember", id: m, init: g });
        }, n.enumStringBody = function(m) {
          return (0, i.default)({ type: "EnumStringBody", members: m, explicitType: null, hasUnknownMembers: null });
        }, n.enumStringMember = function(m, g) {
          return (0, i.default)({ type: "EnumStringMember", id: m, init: g });
        }, n.enumSymbolBody = function(m) {
          return (0, i.default)({ type: "EnumSymbolBody", members: m, hasUnknownMembers: null });
        }, n.existsTypeAnnotation = function() {
          return { type: "ExistsTypeAnnotation" };
        }, n.exportAllDeclaration = function(m) {
          return (0, i.default)({ type: "ExportAllDeclaration", source: m });
        }, n.exportDefaultDeclaration = function(m) {
          return (0, i.default)({ type: "ExportDefaultDeclaration", declaration: m });
        }, n.exportDefaultSpecifier = function(m) {
          return (0, i.default)({ type: "ExportDefaultSpecifier", exported: m });
        }, n.exportNamedDeclaration = function(m = null, g = [], b = null) {
          return (0, i.default)({ type: "ExportNamedDeclaration", declaration: m, specifiers: g, source: b });
        }, n.exportNamespaceSpecifier = function(m) {
          return (0, i.default)({ type: "ExportNamespaceSpecifier", exported: m });
        }, n.exportSpecifier = function(m, g) {
          return (0, i.default)({ type: "ExportSpecifier", local: m, exported: g });
        }, n.expressionStatement = function(m) {
          return (0, i.default)({ type: "ExpressionStatement", expression: m });
        }, n.file = function(m, g = null, b = null) {
          return (0, i.default)({ type: "File", program: m, comments: g, tokens: b });
        }, n.forInStatement = function(m, g, b) {
          return (0, i.default)({ type: "ForInStatement", left: m, right: g, body: b });
        }, n.forOfStatement = function(m, g, b, v = !1) {
          return (0, i.default)({ type: "ForOfStatement", left: m, right: g, body: b, await: v });
        }, n.forStatement = function(m = null, g = null, b = null, v) {
          return (0, i.default)({ type: "ForStatement", init: m, test: g, update: b, body: v });
        }, n.functionDeclaration = function(m = null, g, b, v = !1, T = !1) {
          return (0, i.default)({ type: "FunctionDeclaration", id: m, params: g, body: b, generator: v, async: T });
        }, n.functionExpression = function(m = null, g, b, v = !1, T = !1) {
          return (0, i.default)({ type: "FunctionExpression", id: m, params: g, body: b, generator: v, async: T });
        }, n.functionTypeAnnotation = function(m = null, g, b = null, v) {
          return (0, i.default)({ type: "FunctionTypeAnnotation", typeParameters: m, params: g, rest: b, returnType: v });
        }, n.functionTypeParam = function(m = null, g) {
          return (0, i.default)({ type: "FunctionTypeParam", name: m, typeAnnotation: g });
        }, n.genericTypeAnnotation = function(m, g = null) {
          return (0, i.default)({ type: "GenericTypeAnnotation", id: m, typeParameters: g });
        }, n.identifier = function(m) {
          return (0, i.default)({ type: "Identifier", name: m });
        }, n.ifStatement = function(m, g, b = null) {
          return (0, i.default)({ type: "IfStatement", test: m, consequent: g, alternate: b });
        }, n.import = function() {
          return { type: "Import" };
        }, n.importAttribute = function(m, g) {
          return (0, i.default)({ type: "ImportAttribute", key: m, value: g });
        }, n.importDeclaration = function(m, g) {
          return (0, i.default)({ type: "ImportDeclaration", specifiers: m, source: g });
        }, n.importDefaultSpecifier = function(m) {
          return (0, i.default)({ type: "ImportDefaultSpecifier", local: m });
        }, n.importExpression = function(m, g = null) {
          return (0, i.default)({ type: "ImportExpression", source: m, options: g });
        }, n.importNamespaceSpecifier = function(m) {
          return (0, i.default)({ type: "ImportNamespaceSpecifier", local: m });
        }, n.importSpecifier = function(m, g) {
          return (0, i.default)({ type: "ImportSpecifier", local: m, imported: g });
        }, n.indexedAccessType = function(m, g) {
          return (0, i.default)({ type: "IndexedAccessType", objectType: m, indexType: g });
        }, n.inferredPredicate = function() {
          return { type: "InferredPredicate" };
        }, n.interfaceDeclaration = function(m, g = null, b = null, v) {
          return (0, i.default)({ type: "InterfaceDeclaration", id: m, typeParameters: g, extends: b, body: v });
        }, n.interfaceExtends = function(m, g = null) {
          return (0, i.default)({ type: "InterfaceExtends", id: m, typeParameters: g });
        }, n.interfaceTypeAnnotation = function(m = null, g) {
          return (0, i.default)({ type: "InterfaceTypeAnnotation", extends: m, body: g });
        }, n.interpreterDirective = function(m) {
          return (0, i.default)({ type: "InterpreterDirective", value: m });
        }, n.intersectionTypeAnnotation = function(m) {
          return (0, i.default)({ type: "IntersectionTypeAnnotation", types: m });
        }, n.jSXAttribute = n.jsxAttribute = function(m, g = null) {
          return (0, i.default)({ type: "JSXAttribute", name: m, value: g });
        }, n.jSXClosingElement = n.jsxClosingElement = function(m) {
          return (0, i.default)({ type: "JSXClosingElement", name: m });
        }, n.jSXClosingFragment = n.jsxClosingFragment = function() {
          return { type: "JSXClosingFragment" };
        }, n.jSXElement = n.jsxElement = function(m, g = null, b, v = null) {
          return (0, i.default)({ type: "JSXElement", openingElement: m, closingElement: g, children: b, selfClosing: v });
        }, n.jSXEmptyExpression = n.jsxEmptyExpression = function() {
          return { type: "JSXEmptyExpression" };
        }, n.jSXExpressionContainer = n.jsxExpressionContainer = function(m) {
          return (0, i.default)({ type: "JSXExpressionContainer", expression: m });
        }, n.jSXFragment = n.jsxFragment = function(m, g, b) {
          return (0, i.default)({ type: "JSXFragment", openingFragment: m, closingFragment: g, children: b });
        }, n.jSXIdentifier = n.jsxIdentifier = function(m) {
          return (0, i.default)({ type: "JSXIdentifier", name: m });
        }, n.jSXMemberExpression = n.jsxMemberExpression = function(m, g) {
          return (0, i.default)({ type: "JSXMemberExpression", object: m, property: g });
        }, n.jSXNamespacedName = n.jsxNamespacedName = function(m, g) {
          return (0, i.default)({ type: "JSXNamespacedName", namespace: m, name: g });
        }, n.jSXOpeningElement = n.jsxOpeningElement = function(m, g, b = !1) {
          return (0, i.default)({ type: "JSXOpeningElement", name: m, attributes: g, selfClosing: b });
        }, n.jSXOpeningFragment = n.jsxOpeningFragment = function() {
          return { type: "JSXOpeningFragment" };
        }, n.jSXSpreadAttribute = n.jsxSpreadAttribute = function(m) {
          return (0, i.default)({ type: "JSXSpreadAttribute", argument: m });
        }, n.jSXSpreadChild = n.jsxSpreadChild = function(m) {
          return (0, i.default)({ type: "JSXSpreadChild", expression: m });
        }, n.jSXText = n.jsxText = function(m) {
          return (0, i.default)({ type: "JSXText", value: m });
        }, n.labeledStatement = function(m, g) {
          return (0, i.default)({ type: "LabeledStatement", label: m, body: g });
        }, n.logicalExpression = function(m, g, b) {
          return (0, i.default)({ type: "LogicalExpression", operator: m, left: g, right: b });
        }, n.memberExpression = function(m, g, b = !1, v = null) {
          return (0, i.default)({ type: "MemberExpression", object: m, property: g, computed: b, optional: v });
        }, n.metaProperty = function(m, g) {
          return (0, i.default)({ type: "MetaProperty", meta: m, property: g });
        }, n.mixedTypeAnnotation = function() {
          return { type: "MixedTypeAnnotation" };
        }, n.moduleExpression = function(m) {
          return (0, i.default)({ type: "ModuleExpression", body: m });
        }, n.newExpression = function(m, g) {
          return (0, i.default)({ type: "NewExpression", callee: m, arguments: g });
        }, n.noop = function() {
          return { type: "Noop" };
        }, n.nullLiteral = function() {
          return { type: "NullLiteral" };
        }, n.nullLiteralTypeAnnotation = function() {
          return { type: "NullLiteralTypeAnnotation" };
        }, n.nullableTypeAnnotation = function(m) {
          return (0, i.default)({ type: "NullableTypeAnnotation", typeAnnotation: m });
        }, n.numberLiteral = function(m) {
          return (0, c.default)("NumberLiteral", "NumericLiteral", "The node type "), f(m);
        }, n.numberLiteralTypeAnnotation = function(m) {
          return (0, i.default)({ type: "NumberLiteralTypeAnnotation", value: m });
        }, n.numberTypeAnnotation = function() {
          return { type: "NumberTypeAnnotation" };
        }, n.numericLiteral = f, n.objectExpression = function(m) {
          return (0, i.default)({ type: "ObjectExpression", properties: m });
        }, n.objectMethod = function(m = "method", g, b, v, T = !1, E = !1, O = !1) {
          return (0, i.default)({ type: "ObjectMethod", kind: m, key: g, params: b, body: v, computed: T, generator: E, async: O });
        }, n.objectPattern = function(m) {
          return (0, i.default)({ type: "ObjectPattern", properties: m });
        }, n.objectProperty = function(m, g, b = !1, v = !1, T = null) {
          return (0, i.default)({ type: "ObjectProperty", key: m, value: g, computed: b, shorthand: v, decorators: T });
        }, n.objectTypeAnnotation = function(m, g = [], b = [], v = [], T = !1) {
          return (0, i.default)({ type: "ObjectTypeAnnotation", properties: m, indexers: g, callProperties: b, internalSlots: v, exact: T });
        }, n.objectTypeCallProperty = function(m) {
          return (0, i.default)({ type: "ObjectTypeCallProperty", value: m, static: null });
        }, n.objectTypeIndexer = function(m = null, g, b, v = null) {
          return (0, i.default)({ type: "ObjectTypeIndexer", id: m, key: g, value: b, variance: v, static: null });
        }, n.objectTypeInternalSlot = function(m, g, b, v, T) {
          return (0, i.default)({ type: "ObjectTypeInternalSlot", id: m, value: g, optional: b, static: v, method: T });
        }, n.objectTypeProperty = function(m, g, b = null) {
          return (0, i.default)({ type: "ObjectTypeProperty", key: m, value: g, variance: b, kind: null, method: null, optional: null, proto: null, static: null });
        }, n.objectTypeSpreadProperty = function(m) {
          return (0, i.default)({ type: "ObjectTypeSpreadProperty", argument: m });
        }, n.opaqueType = function(m, g = null, b = null, v) {
          return (0, i.default)({ type: "OpaqueType", id: m, typeParameters: g, supertype: b, impltype: v });
        }, n.optionalCallExpression = function(m, g, b) {
          return (0, i.default)({ type: "OptionalCallExpression", callee: m, arguments: g, optional: b });
        }, n.optionalIndexedAccessType = function(m, g) {
          return (0, i.default)({ type: "OptionalIndexedAccessType", objectType: m, indexType: g, optional: null });
        }, n.optionalMemberExpression = function(m, g, b = !1, v) {
          return (0, i.default)({ type: "OptionalMemberExpression", object: m, property: g, computed: b, optional: v });
        }, n.parenthesizedExpression = function(m) {
          return (0, i.default)({ type: "ParenthesizedExpression", expression: m });
        }, n.pipelineBareFunction = function(m) {
          return (0, i.default)({ type: "PipelineBareFunction", callee: m });
        }, n.pipelinePrimaryTopicReference = function() {
          return { type: "PipelinePrimaryTopicReference" };
        }, n.pipelineTopicExpression = function(m) {
          return (0, i.default)({ type: "PipelineTopicExpression", expression: m });
        }, n.placeholder = function(m, g) {
          return (0, i.default)({ type: "Placeholder", expectedNode: m, name: g });
        }, n.privateName = function(m) {
          return (0, i.default)({ type: "PrivateName", id: m });
        }, n.program = function(m, g = [], b = "script", v = null) {
          return (0, i.default)({ type: "Program", body: m, directives: g, sourceType: b, interpreter: v });
        }, n.qualifiedTypeIdentifier = function(m, g) {
          return (0, i.default)({ type: "QualifiedTypeIdentifier", id: m, qualification: g });
        }, n.recordExpression = function(m) {
          return (0, i.default)({ type: "RecordExpression", properties: m });
        }, n.regExpLiteral = s, n.regexLiteral = function(m, g = "") {
          return (0, c.default)("RegexLiteral", "RegExpLiteral", "The node type "), s(m, g);
        }, n.restElement = o, n.restProperty = function(m) {
          return (0, c.default)("RestProperty", "RestElement", "The node type "), o(m);
        }, n.returnStatement = function(m = null) {
          return (0, i.default)({ type: "ReturnStatement", argument: m });
        }, n.sequenceExpression = function(m) {
          return (0, i.default)({ type: "SequenceExpression", expressions: m });
        }, n.spreadElement = y, n.spreadProperty = function(m) {
          return (0, c.default)("SpreadProperty", "SpreadElement", "The node type "), y(m);
        }, n.staticBlock = function(m) {
          return (0, i.default)({ type: "StaticBlock", body: m });
        }, n.stringLiteral = function(m) {
          return (0, i.default)({ type: "StringLiteral", value: m });
        }, n.stringLiteralTypeAnnotation = function(m) {
          return (0, i.default)({ type: "StringLiteralTypeAnnotation", value: m });
        }, n.stringTypeAnnotation = function() {
          return { type: "StringTypeAnnotation" };
        }, n.super = function() {
          return { type: "Super" };
        }, n.switchCase = function(m = null, g) {
          return (0, i.default)({ type: "SwitchCase", test: m, consequent: g });
        }, n.switchStatement = function(m, g) {
          return (0, i.default)({ type: "SwitchStatement", discriminant: m, cases: g });
        }, n.symbolTypeAnnotation = function() {
          return { type: "SymbolTypeAnnotation" };
        }, n.taggedTemplateExpression = function(m, g) {
          return (0, i.default)({ type: "TaggedTemplateExpression", tag: m, quasi: g });
        }, n.templateElement = function(m, g = !1) {
          return (0, i.default)({ type: "TemplateElement", value: m, tail: g });
        }, n.templateLiteral = function(m, g) {
          return (0, i.default)({ type: "TemplateLiteral", quasis: m, expressions: g });
        }, n.thisExpression = function() {
          return { type: "ThisExpression" };
        }, n.thisTypeAnnotation = function() {
          return { type: "ThisTypeAnnotation" };
        }, n.throwStatement = function(m) {
          return (0, i.default)({ type: "ThrowStatement", argument: m });
        }, n.topicReference = function() {
          return { type: "TopicReference" };
        }, n.tryStatement = function(m, g = null, b = null) {
          return (0, i.default)({ type: "TryStatement", block: m, handler: g, finalizer: b });
        }, n.tSAnyKeyword = n.tsAnyKeyword = function() {
          return { type: "TSAnyKeyword" };
        }, n.tSArrayType = n.tsArrayType = function(m) {
          return (0, i.default)({ type: "TSArrayType", elementType: m });
        }, n.tSAsExpression = n.tsAsExpression = function(m, g) {
          return (0, i.default)({ type: "TSAsExpression", expression: m, typeAnnotation: g });
        }, n.tSBigIntKeyword = n.tsBigIntKeyword = function() {
          return { type: "TSBigIntKeyword" };
        }, n.tSBooleanKeyword = n.tsBooleanKeyword = function() {
          return { type: "TSBooleanKeyword" };
        }, n.tSCallSignatureDeclaration = n.tsCallSignatureDeclaration = function(m = null, g, b = null) {
          return (0, i.default)({ type: "TSCallSignatureDeclaration", typeParameters: m, parameters: g, typeAnnotation: b });
        }, n.tSConditionalType = n.tsConditionalType = function(m, g, b, v) {
          return (0, i.default)({ type: "TSConditionalType", checkType: m, extendsType: g, trueType: b, falseType: v });
        }, n.tSConstructSignatureDeclaration = n.tsConstructSignatureDeclaration = function(m = null, g, b = null) {
          return (0, i.default)({ type: "TSConstructSignatureDeclaration", typeParameters: m, parameters: g, typeAnnotation: b });
        }, n.tSConstructorType = n.tsConstructorType = function(m = null, g, b = null) {
          return (0, i.default)({ type: "TSConstructorType", typeParameters: m, parameters: g, typeAnnotation: b });
        }, n.tSDeclareFunction = n.tsDeclareFunction = function(m = null, g = null, b, v = null) {
          return (0, i.default)({ type: "TSDeclareFunction", id: m, typeParameters: g, params: b, returnType: v });
        }, n.tSDeclareMethod = n.tsDeclareMethod = function(m = null, g, b = null, v, T = null) {
          return (0, i.default)({ type: "TSDeclareMethod", decorators: m, key: g, typeParameters: b, params: v, returnType: T });
        }, n.tSEnumDeclaration = n.tsEnumDeclaration = function(m, g) {
          return (0, i.default)({ type: "TSEnumDeclaration", id: m, members: g });
        }, n.tSEnumMember = n.tsEnumMember = function(m, g = null) {
          return (0, i.default)({ type: "TSEnumMember", id: m, initializer: g });
        }, n.tSExportAssignment = n.tsExportAssignment = function(m) {
          return (0, i.default)({ type: "TSExportAssignment", expression: m });
        }, n.tSExpressionWithTypeArguments = n.tsExpressionWithTypeArguments = function(m, g = null) {
          return (0, i.default)({ type: "TSExpressionWithTypeArguments", expression: m, typeParameters: g });
        }, n.tSExternalModuleReference = n.tsExternalModuleReference = function(m) {
          return (0, i.default)({ type: "TSExternalModuleReference", expression: m });
        }, n.tSFunctionType = n.tsFunctionType = function(m = null, g, b = null) {
          return (0, i.default)({ type: "TSFunctionType", typeParameters: m, parameters: g, typeAnnotation: b });
        }, n.tSImportEqualsDeclaration = n.tsImportEqualsDeclaration = function(m, g) {
          return (0, i.default)({ type: "TSImportEqualsDeclaration", id: m, moduleReference: g, isExport: null });
        }, n.tSImportType = n.tsImportType = function(m, g = null, b = null) {
          return (0, i.default)({ type: "TSImportType", argument: m, qualifier: g, typeParameters: b });
        }, n.tSIndexSignature = n.tsIndexSignature = function(m, g = null) {
          return (0, i.default)({ type: "TSIndexSignature", parameters: m, typeAnnotation: g });
        }, n.tSIndexedAccessType = n.tsIndexedAccessType = function(m, g) {
          return (0, i.default)({ type: "TSIndexedAccessType", objectType: m, indexType: g });
        }, n.tSInferType = n.tsInferType = function(m) {
          return (0, i.default)({ type: "TSInferType", typeParameter: m });
        }, n.tSInstantiationExpression = n.tsInstantiationExpression = function(m, g = null) {
          return (0, i.default)({ type: "TSInstantiationExpression", expression: m, typeParameters: g });
        }, n.tSInterfaceBody = n.tsInterfaceBody = function(m) {
          return (0, i.default)({ type: "TSInterfaceBody", body: m });
        }, n.tSInterfaceDeclaration = n.tsInterfaceDeclaration = function(m, g = null, b = null, v) {
          return (0, i.default)({ type: "TSInterfaceDeclaration", id: m, typeParameters: g, extends: b, body: v });
        }, n.tSIntersectionType = n.tsIntersectionType = function(m) {
          return (0, i.default)({ type: "TSIntersectionType", types: m });
        }, n.tSIntrinsicKeyword = n.tsIntrinsicKeyword = function() {
          return { type: "TSIntrinsicKeyword" };
        }, n.tSLiteralType = n.tsLiteralType = function(m) {
          return (0, i.default)({ type: "TSLiteralType", literal: m });
        }, n.tSMappedType = n.tsMappedType = function(m, g = null, b = null) {
          return (0, i.default)({ type: "TSMappedType", typeParameter: m, typeAnnotation: g, nameType: b });
        }, n.tSMethodSignature = n.tsMethodSignature = function(m, g = null, b, v = null) {
          return (0, i.default)({ type: "TSMethodSignature", key: m, typeParameters: g, parameters: b, typeAnnotation: v, kind: null });
        }, n.tSModuleBlock = n.tsModuleBlock = function(m) {
          return (0, i.default)({ type: "TSModuleBlock", body: m });
        }, n.tSModuleDeclaration = n.tsModuleDeclaration = function(m, g) {
          return (0, i.default)({ type: "TSModuleDeclaration", id: m, body: g });
        }, n.tSNamedTupleMember = n.tsNamedTupleMember = function(m, g, b = !1) {
          return (0, i.default)({ type: "TSNamedTupleMember", label: m, elementType: g, optional: b });
        }, n.tSNamespaceExportDeclaration = n.tsNamespaceExportDeclaration = function(m) {
          return (0, i.default)({ type: "TSNamespaceExportDeclaration", id: m });
        }, n.tSNeverKeyword = n.tsNeverKeyword = function() {
          return { type: "TSNeverKeyword" };
        }, n.tSNonNullExpression = n.tsNonNullExpression = function(m) {
          return (0, i.default)({ type: "TSNonNullExpression", expression: m });
        }, n.tSNullKeyword = n.tsNullKeyword = function() {
          return { type: "TSNullKeyword" };
        }, n.tSNumberKeyword = n.tsNumberKeyword = function() {
          return { type: "TSNumberKeyword" };
        }, n.tSObjectKeyword = n.tsObjectKeyword = function() {
          return { type: "TSObjectKeyword" };
        }, n.tSOptionalType = n.tsOptionalType = function(m) {
          return (0, i.default)({ type: "TSOptionalType", typeAnnotation: m });
        }, n.tSParameterProperty = n.tsParameterProperty = function(m) {
          return (0, i.default)({ type: "TSParameterProperty", parameter: m });
        }, n.tSParenthesizedType = n.tsParenthesizedType = function(m) {
          return (0, i.default)({ type: "TSParenthesizedType", typeAnnotation: m });
        }, n.tSPropertySignature = n.tsPropertySignature = function(m, g = null) {
          return (0, i.default)({ type: "TSPropertySignature", key: m, typeAnnotation: g, kind: null });
        }, n.tSQualifiedName = n.tsQualifiedName = function(m, g) {
          return (0, i.default)({ type: "TSQualifiedName", left: m, right: g });
        }, n.tSRestType = n.tsRestType = function(m) {
          return (0, i.default)({ type: "TSRestType", typeAnnotation: m });
        }, n.tSSatisfiesExpression = n.tsSatisfiesExpression = function(m, g) {
          return (0, i.default)({ type: "TSSatisfiesExpression", expression: m, typeAnnotation: g });
        }, n.tSStringKeyword = n.tsStringKeyword = function() {
          return { type: "TSStringKeyword" };
        }, n.tSSymbolKeyword = n.tsSymbolKeyword = function() {
          return { type: "TSSymbolKeyword" };
        }, n.tSThisType = n.tsThisType = function() {
          return { type: "TSThisType" };
        }, n.tSTupleType = n.tsTupleType = function(m) {
          return (0, i.default)({ type: "TSTupleType", elementTypes: m });
        }, n.tSTypeAliasDeclaration = n.tsTypeAliasDeclaration = function(m, g = null, b) {
          return (0, i.default)({ type: "TSTypeAliasDeclaration", id: m, typeParameters: g, typeAnnotation: b });
        }, n.tSTypeAnnotation = n.tsTypeAnnotation = function(m) {
          return (0, i.default)({ type: "TSTypeAnnotation", typeAnnotation: m });
        }, n.tSTypeAssertion = n.tsTypeAssertion = function(m, g) {
          return (0, i.default)({ type: "TSTypeAssertion", typeAnnotation: m, expression: g });
        }, n.tSTypeLiteral = n.tsTypeLiteral = function(m) {
          return (0, i.default)({ type: "TSTypeLiteral", members: m });
        }, n.tSTypeOperator = n.tsTypeOperator = function(m) {
          return (0, i.default)({ type: "TSTypeOperator", typeAnnotation: m, operator: null });
        }, n.tSTypeParameter = n.tsTypeParameter = function(m = null, g = null, b) {
          return (0, i.default)({ type: "TSTypeParameter", constraint: m, default: g, name: b });
        }, n.tSTypeParameterDeclaration = n.tsTypeParameterDeclaration = function(m) {
          return (0, i.default)({ type: "TSTypeParameterDeclaration", params: m });
        }, n.tSTypeParameterInstantiation = n.tsTypeParameterInstantiation = function(m) {
          return (0, i.default)({ type: "TSTypeParameterInstantiation", params: m });
        }, n.tSTypePredicate = n.tsTypePredicate = function(m, g = null, b = null) {
          return (0, i.default)({ type: "TSTypePredicate", parameterName: m, typeAnnotation: g, asserts: b });
        }, n.tSTypeQuery = n.tsTypeQuery = function(m, g = null) {
          return (0, i.default)({ type: "TSTypeQuery", exprName: m, typeParameters: g });
        }, n.tSTypeReference = n.tsTypeReference = function(m, g = null) {
          return (0, i.default)({ type: "TSTypeReference", typeName: m, typeParameters: g });
        }, n.tSUndefinedKeyword = n.tsUndefinedKeyword = function() {
          return { type: "TSUndefinedKeyword" };
        }, n.tSUnionType = n.tsUnionType = function(m) {
          return (0, i.default)({ type: "TSUnionType", types: m });
        }, n.tSUnknownKeyword = n.tsUnknownKeyword = function() {
          return { type: "TSUnknownKeyword" };
        }, n.tSVoidKeyword = n.tsVoidKeyword = function() {
          return { type: "TSVoidKeyword" };
        }, n.tupleExpression = function(m = []) {
          return (0, i.default)({ type: "TupleExpression", elements: m });
        }, n.tupleTypeAnnotation = function(m) {
          return (0, i.default)({ type: "TupleTypeAnnotation", types: m });
        }, n.typeAlias = function(m, g = null, b) {
          return (0, i.default)({ type: "TypeAlias", id: m, typeParameters: g, right: b });
        }, n.typeAnnotation = function(m) {
          return (0, i.default)({ type: "TypeAnnotation", typeAnnotation: m });
        }, n.typeCastExpression = function(m, g) {
          return (0, i.default)({ type: "TypeCastExpression", expression: m, typeAnnotation: g });
        }, n.typeParameter = function(m = null, g = null, b = null) {
          return (0, i.default)({ type: "TypeParameter", bound: m, default: g, variance: b, name: null });
        }, n.typeParameterDeclaration = function(m) {
          return (0, i.default)({ type: "TypeParameterDeclaration", params: m });
        }, n.typeParameterInstantiation = function(m) {
          return (0, i.default)({ type: "TypeParameterInstantiation", params: m });
        }, n.typeofTypeAnnotation = function(m) {
          return (0, i.default)({ type: "TypeofTypeAnnotation", argument: m });
        }, n.unaryExpression = function(m, g, b = !0) {
          return (0, i.default)({ type: "UnaryExpression", operator: m, argument: g, prefix: b });
        }, n.unionTypeAnnotation = function(m) {
          return (0, i.default)({ type: "UnionTypeAnnotation", types: m });
        }, n.updateExpression = function(m, g, b = !1) {
          return (0, i.default)({ type: "UpdateExpression", operator: m, argument: g, prefix: b });
        }, n.v8IntrinsicIdentifier = function(m) {
          return (0, i.default)({ type: "V8IntrinsicIdentifier", name: m });
        }, n.variableDeclaration = function(m, g) {
          return (0, i.default)({ type: "VariableDeclaration", kind: m, declarations: g });
        }, n.variableDeclarator = function(m, g = null) {
          return (0, i.default)({ type: "VariableDeclarator", id: m, init: g });
        }, n.variance = function(m) {
          return (0, i.default)({ type: "Variance", kind: m });
        }, n.voidTypeAnnotation = function() {
          return { type: "VoidTypeAnnotation" };
        }, n.whileStatement = function(m, g) {
          return (0, i.default)({ type: "WhileStatement", test: m, body: g });
        }, n.withStatement = function(m, g) {
          return (0, i.default)({ type: "WithStatement", object: m, body: g });
        }, n.yieldExpression = function(m = null, g = !1) {
          return (0, i.default)({ type: "YieldExpression", argument: m, delegate: g });
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/validateNode.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function f(m) {
          return (0, i.default)({ type: "NumericLiteral", value: m });
        }
        function s(m, g = "") {
          return (0, i.default)({ type: "RegExpLiteral", pattern: m, flags: g });
        }
        function o(m) {
          return (0, i.default)({ type: "RestElement", argument: m });
        }
        function y(m) {
          return (0, i.default)({ type: "SpreadElement", argument: m });
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/uppercase.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "AnyTypeAnnotation", { enumerable: !0, get: function() {
          return i.anyTypeAnnotation;
        } }), Object.defineProperty(n, "ArgumentPlaceholder", { enumerable: !0, get: function() {
          return i.argumentPlaceholder;
        } }), Object.defineProperty(n, "ArrayExpression", { enumerable: !0, get: function() {
          return i.arrayExpression;
        } }), Object.defineProperty(n, "ArrayPattern", { enumerable: !0, get: function() {
          return i.arrayPattern;
        } }), Object.defineProperty(n, "ArrayTypeAnnotation", { enumerable: !0, get: function() {
          return i.arrayTypeAnnotation;
        } }), Object.defineProperty(n, "ArrowFunctionExpression", { enumerable: !0, get: function() {
          return i.arrowFunctionExpression;
        } }), Object.defineProperty(n, "AssignmentExpression", { enumerable: !0, get: function() {
          return i.assignmentExpression;
        } }), Object.defineProperty(n, "AssignmentPattern", { enumerable: !0, get: function() {
          return i.assignmentPattern;
        } }), Object.defineProperty(n, "AwaitExpression", { enumerable: !0, get: function() {
          return i.awaitExpression;
        } }), Object.defineProperty(n, "BigIntLiteral", { enumerable: !0, get: function() {
          return i.bigIntLiteral;
        } }), Object.defineProperty(n, "BinaryExpression", { enumerable: !0, get: function() {
          return i.binaryExpression;
        } }), Object.defineProperty(n, "BindExpression", { enumerable: !0, get: function() {
          return i.bindExpression;
        } }), Object.defineProperty(n, "BlockStatement", { enumerable: !0, get: function() {
          return i.blockStatement;
        } }), Object.defineProperty(n, "BooleanLiteral", { enumerable: !0, get: function() {
          return i.booleanLiteral;
        } }), Object.defineProperty(n, "BooleanLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.booleanLiteralTypeAnnotation;
        } }), Object.defineProperty(n, "BooleanTypeAnnotation", { enumerable: !0, get: function() {
          return i.booleanTypeAnnotation;
        } }), Object.defineProperty(n, "BreakStatement", { enumerable: !0, get: function() {
          return i.breakStatement;
        } }), Object.defineProperty(n, "CallExpression", { enumerable: !0, get: function() {
          return i.callExpression;
        } }), Object.defineProperty(n, "CatchClause", { enumerable: !0, get: function() {
          return i.catchClause;
        } }), Object.defineProperty(n, "ClassAccessorProperty", { enumerable: !0, get: function() {
          return i.classAccessorProperty;
        } }), Object.defineProperty(n, "ClassBody", { enumerable: !0, get: function() {
          return i.classBody;
        } }), Object.defineProperty(n, "ClassDeclaration", { enumerable: !0, get: function() {
          return i.classDeclaration;
        } }), Object.defineProperty(n, "ClassExpression", { enumerable: !0, get: function() {
          return i.classExpression;
        } }), Object.defineProperty(n, "ClassImplements", { enumerable: !0, get: function() {
          return i.classImplements;
        } }), Object.defineProperty(n, "ClassMethod", { enumerable: !0, get: function() {
          return i.classMethod;
        } }), Object.defineProperty(n, "ClassPrivateMethod", { enumerable: !0, get: function() {
          return i.classPrivateMethod;
        } }), Object.defineProperty(n, "ClassPrivateProperty", { enumerable: !0, get: function() {
          return i.classPrivateProperty;
        } }), Object.defineProperty(n, "ClassProperty", { enumerable: !0, get: function() {
          return i.classProperty;
        } }), Object.defineProperty(n, "ConditionalExpression", { enumerable: !0, get: function() {
          return i.conditionalExpression;
        } }), Object.defineProperty(n, "ContinueStatement", { enumerable: !0, get: function() {
          return i.continueStatement;
        } }), Object.defineProperty(n, "DebuggerStatement", { enumerable: !0, get: function() {
          return i.debuggerStatement;
        } }), Object.defineProperty(n, "DecimalLiteral", { enumerable: !0, get: function() {
          return i.decimalLiteral;
        } }), Object.defineProperty(n, "DeclareClass", { enumerable: !0, get: function() {
          return i.declareClass;
        } }), Object.defineProperty(n, "DeclareExportAllDeclaration", { enumerable: !0, get: function() {
          return i.declareExportAllDeclaration;
        } }), Object.defineProperty(n, "DeclareExportDeclaration", { enumerable: !0, get: function() {
          return i.declareExportDeclaration;
        } }), Object.defineProperty(n, "DeclareFunction", { enumerable: !0, get: function() {
          return i.declareFunction;
        } }), Object.defineProperty(n, "DeclareInterface", { enumerable: !0, get: function() {
          return i.declareInterface;
        } }), Object.defineProperty(n, "DeclareModule", { enumerable: !0, get: function() {
          return i.declareModule;
        } }), Object.defineProperty(n, "DeclareModuleExports", { enumerable: !0, get: function() {
          return i.declareModuleExports;
        } }), Object.defineProperty(n, "DeclareOpaqueType", { enumerable: !0, get: function() {
          return i.declareOpaqueType;
        } }), Object.defineProperty(n, "DeclareTypeAlias", { enumerable: !0, get: function() {
          return i.declareTypeAlias;
        } }), Object.defineProperty(n, "DeclareVariable", { enumerable: !0, get: function() {
          return i.declareVariable;
        } }), Object.defineProperty(n, "DeclaredPredicate", { enumerable: !0, get: function() {
          return i.declaredPredicate;
        } }), Object.defineProperty(n, "Decorator", { enumerable: !0, get: function() {
          return i.decorator;
        } }), Object.defineProperty(n, "Directive", { enumerable: !0, get: function() {
          return i.directive;
        } }), Object.defineProperty(n, "DirectiveLiteral", { enumerable: !0, get: function() {
          return i.directiveLiteral;
        } }), Object.defineProperty(n, "DoExpression", { enumerable: !0, get: function() {
          return i.doExpression;
        } }), Object.defineProperty(n, "DoWhileStatement", { enumerable: !0, get: function() {
          return i.doWhileStatement;
        } }), Object.defineProperty(n, "EmptyStatement", { enumerable: !0, get: function() {
          return i.emptyStatement;
        } }), Object.defineProperty(n, "EmptyTypeAnnotation", { enumerable: !0, get: function() {
          return i.emptyTypeAnnotation;
        } }), Object.defineProperty(n, "EnumBooleanBody", { enumerable: !0, get: function() {
          return i.enumBooleanBody;
        } }), Object.defineProperty(n, "EnumBooleanMember", { enumerable: !0, get: function() {
          return i.enumBooleanMember;
        } }), Object.defineProperty(n, "EnumDeclaration", { enumerable: !0, get: function() {
          return i.enumDeclaration;
        } }), Object.defineProperty(n, "EnumDefaultedMember", { enumerable: !0, get: function() {
          return i.enumDefaultedMember;
        } }), Object.defineProperty(n, "EnumNumberBody", { enumerable: !0, get: function() {
          return i.enumNumberBody;
        } }), Object.defineProperty(n, "EnumNumberMember", { enumerable: !0, get: function() {
          return i.enumNumberMember;
        } }), Object.defineProperty(n, "EnumStringBody", { enumerable: !0, get: function() {
          return i.enumStringBody;
        } }), Object.defineProperty(n, "EnumStringMember", { enumerable: !0, get: function() {
          return i.enumStringMember;
        } }), Object.defineProperty(n, "EnumSymbolBody", { enumerable: !0, get: function() {
          return i.enumSymbolBody;
        } }), Object.defineProperty(n, "ExistsTypeAnnotation", { enumerable: !0, get: function() {
          return i.existsTypeAnnotation;
        } }), Object.defineProperty(n, "ExportAllDeclaration", { enumerable: !0, get: function() {
          return i.exportAllDeclaration;
        } }), Object.defineProperty(n, "ExportDefaultDeclaration", { enumerable: !0, get: function() {
          return i.exportDefaultDeclaration;
        } }), Object.defineProperty(n, "ExportDefaultSpecifier", { enumerable: !0, get: function() {
          return i.exportDefaultSpecifier;
        } }), Object.defineProperty(n, "ExportNamedDeclaration", { enumerable: !0, get: function() {
          return i.exportNamedDeclaration;
        } }), Object.defineProperty(n, "ExportNamespaceSpecifier", { enumerable: !0, get: function() {
          return i.exportNamespaceSpecifier;
        } }), Object.defineProperty(n, "ExportSpecifier", { enumerable: !0, get: function() {
          return i.exportSpecifier;
        } }), Object.defineProperty(n, "ExpressionStatement", { enumerable: !0, get: function() {
          return i.expressionStatement;
        } }), Object.defineProperty(n, "File", { enumerable: !0, get: function() {
          return i.file;
        } }), Object.defineProperty(n, "ForInStatement", { enumerable: !0, get: function() {
          return i.forInStatement;
        } }), Object.defineProperty(n, "ForOfStatement", { enumerable: !0, get: function() {
          return i.forOfStatement;
        } }), Object.defineProperty(n, "ForStatement", { enumerable: !0, get: function() {
          return i.forStatement;
        } }), Object.defineProperty(n, "FunctionDeclaration", { enumerable: !0, get: function() {
          return i.functionDeclaration;
        } }), Object.defineProperty(n, "FunctionExpression", { enumerable: !0, get: function() {
          return i.functionExpression;
        } }), Object.defineProperty(n, "FunctionTypeAnnotation", { enumerable: !0, get: function() {
          return i.functionTypeAnnotation;
        } }), Object.defineProperty(n, "FunctionTypeParam", { enumerable: !0, get: function() {
          return i.functionTypeParam;
        } }), Object.defineProperty(n, "GenericTypeAnnotation", { enumerable: !0, get: function() {
          return i.genericTypeAnnotation;
        } }), Object.defineProperty(n, "Identifier", { enumerable: !0, get: function() {
          return i.identifier;
        } }), Object.defineProperty(n, "IfStatement", { enumerable: !0, get: function() {
          return i.ifStatement;
        } }), Object.defineProperty(n, "Import", { enumerable: !0, get: function() {
          return i.import;
        } }), Object.defineProperty(n, "ImportAttribute", { enumerable: !0, get: function() {
          return i.importAttribute;
        } }), Object.defineProperty(n, "ImportDeclaration", { enumerable: !0, get: function() {
          return i.importDeclaration;
        } }), Object.defineProperty(n, "ImportDefaultSpecifier", { enumerable: !0, get: function() {
          return i.importDefaultSpecifier;
        } }), Object.defineProperty(n, "ImportExpression", { enumerable: !0, get: function() {
          return i.importExpression;
        } }), Object.defineProperty(n, "ImportNamespaceSpecifier", { enumerable: !0, get: function() {
          return i.importNamespaceSpecifier;
        } }), Object.defineProperty(n, "ImportSpecifier", { enumerable: !0, get: function() {
          return i.importSpecifier;
        } }), Object.defineProperty(n, "IndexedAccessType", { enumerable: !0, get: function() {
          return i.indexedAccessType;
        } }), Object.defineProperty(n, "InferredPredicate", { enumerable: !0, get: function() {
          return i.inferredPredicate;
        } }), Object.defineProperty(n, "InterfaceDeclaration", { enumerable: !0, get: function() {
          return i.interfaceDeclaration;
        } }), Object.defineProperty(n, "InterfaceExtends", { enumerable: !0, get: function() {
          return i.interfaceExtends;
        } }), Object.defineProperty(n, "InterfaceTypeAnnotation", { enumerable: !0, get: function() {
          return i.interfaceTypeAnnotation;
        } }), Object.defineProperty(n, "InterpreterDirective", { enumerable: !0, get: function() {
          return i.interpreterDirective;
        } }), Object.defineProperty(n, "IntersectionTypeAnnotation", { enumerable: !0, get: function() {
          return i.intersectionTypeAnnotation;
        } }), Object.defineProperty(n, "JSXAttribute", { enumerable: !0, get: function() {
          return i.jsxAttribute;
        } }), Object.defineProperty(n, "JSXClosingElement", { enumerable: !0, get: function() {
          return i.jsxClosingElement;
        } }), Object.defineProperty(n, "JSXClosingFragment", { enumerable: !0, get: function() {
          return i.jsxClosingFragment;
        } }), Object.defineProperty(n, "JSXElement", { enumerable: !0, get: function() {
          return i.jsxElement;
        } }), Object.defineProperty(n, "JSXEmptyExpression", { enumerable: !0, get: function() {
          return i.jsxEmptyExpression;
        } }), Object.defineProperty(n, "JSXExpressionContainer", { enumerable: !0, get: function() {
          return i.jsxExpressionContainer;
        } }), Object.defineProperty(n, "JSXFragment", { enumerable: !0, get: function() {
          return i.jsxFragment;
        } }), Object.defineProperty(n, "JSXIdentifier", { enumerable: !0, get: function() {
          return i.jsxIdentifier;
        } }), Object.defineProperty(n, "JSXMemberExpression", { enumerable: !0, get: function() {
          return i.jsxMemberExpression;
        } }), Object.defineProperty(n, "JSXNamespacedName", { enumerable: !0, get: function() {
          return i.jsxNamespacedName;
        } }), Object.defineProperty(n, "JSXOpeningElement", { enumerable: !0, get: function() {
          return i.jsxOpeningElement;
        } }), Object.defineProperty(n, "JSXOpeningFragment", { enumerable: !0, get: function() {
          return i.jsxOpeningFragment;
        } }), Object.defineProperty(n, "JSXSpreadAttribute", { enumerable: !0, get: function() {
          return i.jsxSpreadAttribute;
        } }), Object.defineProperty(n, "JSXSpreadChild", { enumerable: !0, get: function() {
          return i.jsxSpreadChild;
        } }), Object.defineProperty(n, "JSXText", { enumerable: !0, get: function() {
          return i.jsxText;
        } }), Object.defineProperty(n, "LabeledStatement", { enumerable: !0, get: function() {
          return i.labeledStatement;
        } }), Object.defineProperty(n, "LogicalExpression", { enumerable: !0, get: function() {
          return i.logicalExpression;
        } }), Object.defineProperty(n, "MemberExpression", { enumerable: !0, get: function() {
          return i.memberExpression;
        } }), Object.defineProperty(n, "MetaProperty", { enumerable: !0, get: function() {
          return i.metaProperty;
        } }), Object.defineProperty(n, "MixedTypeAnnotation", { enumerable: !0, get: function() {
          return i.mixedTypeAnnotation;
        } }), Object.defineProperty(n, "ModuleExpression", { enumerable: !0, get: function() {
          return i.moduleExpression;
        } }), Object.defineProperty(n, "NewExpression", { enumerable: !0, get: function() {
          return i.newExpression;
        } }), Object.defineProperty(n, "Noop", { enumerable: !0, get: function() {
          return i.noop;
        } }), Object.defineProperty(n, "NullLiteral", { enumerable: !0, get: function() {
          return i.nullLiteral;
        } }), Object.defineProperty(n, "NullLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.nullLiteralTypeAnnotation;
        } }), Object.defineProperty(n, "NullableTypeAnnotation", { enumerable: !0, get: function() {
          return i.nullableTypeAnnotation;
        } }), Object.defineProperty(n, "NumberLiteral", { enumerable: !0, get: function() {
          return i.numberLiteral;
        } }), Object.defineProperty(n, "NumberLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.numberLiteralTypeAnnotation;
        } }), Object.defineProperty(n, "NumberTypeAnnotation", { enumerable: !0, get: function() {
          return i.numberTypeAnnotation;
        } }), Object.defineProperty(n, "NumericLiteral", { enumerable: !0, get: function() {
          return i.numericLiteral;
        } }), Object.defineProperty(n, "ObjectExpression", { enumerable: !0, get: function() {
          return i.objectExpression;
        } }), Object.defineProperty(n, "ObjectMethod", { enumerable: !0, get: function() {
          return i.objectMethod;
        } }), Object.defineProperty(n, "ObjectPattern", { enumerable: !0, get: function() {
          return i.objectPattern;
        } }), Object.defineProperty(n, "ObjectProperty", { enumerable: !0, get: function() {
          return i.objectProperty;
        } }), Object.defineProperty(n, "ObjectTypeAnnotation", { enumerable: !0, get: function() {
          return i.objectTypeAnnotation;
        } }), Object.defineProperty(n, "ObjectTypeCallProperty", { enumerable: !0, get: function() {
          return i.objectTypeCallProperty;
        } }), Object.defineProperty(n, "ObjectTypeIndexer", { enumerable: !0, get: function() {
          return i.objectTypeIndexer;
        } }), Object.defineProperty(n, "ObjectTypeInternalSlot", { enumerable: !0, get: function() {
          return i.objectTypeInternalSlot;
        } }), Object.defineProperty(n, "ObjectTypeProperty", { enumerable: !0, get: function() {
          return i.objectTypeProperty;
        } }), Object.defineProperty(n, "ObjectTypeSpreadProperty", { enumerable: !0, get: function() {
          return i.objectTypeSpreadProperty;
        } }), Object.defineProperty(n, "OpaqueType", { enumerable: !0, get: function() {
          return i.opaqueType;
        } }), Object.defineProperty(n, "OptionalCallExpression", { enumerable: !0, get: function() {
          return i.optionalCallExpression;
        } }), Object.defineProperty(n, "OptionalIndexedAccessType", { enumerable: !0, get: function() {
          return i.optionalIndexedAccessType;
        } }), Object.defineProperty(n, "OptionalMemberExpression", { enumerable: !0, get: function() {
          return i.optionalMemberExpression;
        } }), Object.defineProperty(n, "ParenthesizedExpression", { enumerable: !0, get: function() {
          return i.parenthesizedExpression;
        } }), Object.defineProperty(n, "PipelineBareFunction", { enumerable: !0, get: function() {
          return i.pipelineBareFunction;
        } }), Object.defineProperty(n, "PipelinePrimaryTopicReference", { enumerable: !0, get: function() {
          return i.pipelinePrimaryTopicReference;
        } }), Object.defineProperty(n, "PipelineTopicExpression", { enumerable: !0, get: function() {
          return i.pipelineTopicExpression;
        } }), Object.defineProperty(n, "Placeholder", { enumerable: !0, get: function() {
          return i.placeholder;
        } }), Object.defineProperty(n, "PrivateName", { enumerable: !0, get: function() {
          return i.privateName;
        } }), Object.defineProperty(n, "Program", { enumerable: !0, get: function() {
          return i.program;
        } }), Object.defineProperty(n, "QualifiedTypeIdentifier", { enumerable: !0, get: function() {
          return i.qualifiedTypeIdentifier;
        } }), Object.defineProperty(n, "RecordExpression", { enumerable: !0, get: function() {
          return i.recordExpression;
        } }), Object.defineProperty(n, "RegExpLiteral", { enumerable: !0, get: function() {
          return i.regExpLiteral;
        } }), Object.defineProperty(n, "RegexLiteral", { enumerable: !0, get: function() {
          return i.regexLiteral;
        } }), Object.defineProperty(n, "RestElement", { enumerable: !0, get: function() {
          return i.restElement;
        } }), Object.defineProperty(n, "RestProperty", { enumerable: !0, get: function() {
          return i.restProperty;
        } }), Object.defineProperty(n, "ReturnStatement", { enumerable: !0, get: function() {
          return i.returnStatement;
        } }), Object.defineProperty(n, "SequenceExpression", { enumerable: !0, get: function() {
          return i.sequenceExpression;
        } }), Object.defineProperty(n, "SpreadElement", { enumerable: !0, get: function() {
          return i.spreadElement;
        } }), Object.defineProperty(n, "SpreadProperty", { enumerable: !0, get: function() {
          return i.spreadProperty;
        } }), Object.defineProperty(n, "StaticBlock", { enumerable: !0, get: function() {
          return i.staticBlock;
        } }), Object.defineProperty(n, "StringLiteral", { enumerable: !0, get: function() {
          return i.stringLiteral;
        } }), Object.defineProperty(n, "StringLiteralTypeAnnotation", { enumerable: !0, get: function() {
          return i.stringLiteralTypeAnnotation;
        } }), Object.defineProperty(n, "StringTypeAnnotation", { enumerable: !0, get: function() {
          return i.stringTypeAnnotation;
        } }), Object.defineProperty(n, "Super", { enumerable: !0, get: function() {
          return i.super;
        } }), Object.defineProperty(n, "SwitchCase", { enumerable: !0, get: function() {
          return i.switchCase;
        } }), Object.defineProperty(n, "SwitchStatement", { enumerable: !0, get: function() {
          return i.switchStatement;
        } }), Object.defineProperty(n, "SymbolTypeAnnotation", { enumerable: !0, get: function() {
          return i.symbolTypeAnnotation;
        } }), Object.defineProperty(n, "TSAnyKeyword", { enumerable: !0, get: function() {
          return i.tsAnyKeyword;
        } }), Object.defineProperty(n, "TSArrayType", { enumerable: !0, get: function() {
          return i.tsArrayType;
        } }), Object.defineProperty(n, "TSAsExpression", { enumerable: !0, get: function() {
          return i.tsAsExpression;
        } }), Object.defineProperty(n, "TSBigIntKeyword", { enumerable: !0, get: function() {
          return i.tsBigIntKeyword;
        } }), Object.defineProperty(n, "TSBooleanKeyword", { enumerable: !0, get: function() {
          return i.tsBooleanKeyword;
        } }), Object.defineProperty(n, "TSCallSignatureDeclaration", { enumerable: !0, get: function() {
          return i.tsCallSignatureDeclaration;
        } }), Object.defineProperty(n, "TSConditionalType", { enumerable: !0, get: function() {
          return i.tsConditionalType;
        } }), Object.defineProperty(n, "TSConstructSignatureDeclaration", { enumerable: !0, get: function() {
          return i.tsConstructSignatureDeclaration;
        } }), Object.defineProperty(n, "TSConstructorType", { enumerable: !0, get: function() {
          return i.tsConstructorType;
        } }), Object.defineProperty(n, "TSDeclareFunction", { enumerable: !0, get: function() {
          return i.tsDeclareFunction;
        } }), Object.defineProperty(n, "TSDeclareMethod", { enumerable: !0, get: function() {
          return i.tsDeclareMethod;
        } }), Object.defineProperty(n, "TSEnumDeclaration", { enumerable: !0, get: function() {
          return i.tsEnumDeclaration;
        } }), Object.defineProperty(n, "TSEnumMember", { enumerable: !0, get: function() {
          return i.tsEnumMember;
        } }), Object.defineProperty(n, "TSExportAssignment", { enumerable: !0, get: function() {
          return i.tsExportAssignment;
        } }), Object.defineProperty(n, "TSExpressionWithTypeArguments", { enumerable: !0, get: function() {
          return i.tsExpressionWithTypeArguments;
        } }), Object.defineProperty(n, "TSExternalModuleReference", { enumerable: !0, get: function() {
          return i.tsExternalModuleReference;
        } }), Object.defineProperty(n, "TSFunctionType", { enumerable: !0, get: function() {
          return i.tsFunctionType;
        } }), Object.defineProperty(n, "TSImportEqualsDeclaration", { enumerable: !0, get: function() {
          return i.tsImportEqualsDeclaration;
        } }), Object.defineProperty(n, "TSImportType", { enumerable: !0, get: function() {
          return i.tsImportType;
        } }), Object.defineProperty(n, "TSIndexSignature", { enumerable: !0, get: function() {
          return i.tsIndexSignature;
        } }), Object.defineProperty(n, "TSIndexedAccessType", { enumerable: !0, get: function() {
          return i.tsIndexedAccessType;
        } }), Object.defineProperty(n, "TSInferType", { enumerable: !0, get: function() {
          return i.tsInferType;
        } }), Object.defineProperty(n, "TSInstantiationExpression", { enumerable: !0, get: function() {
          return i.tsInstantiationExpression;
        } }), Object.defineProperty(n, "TSInterfaceBody", { enumerable: !0, get: function() {
          return i.tsInterfaceBody;
        } }), Object.defineProperty(n, "TSInterfaceDeclaration", { enumerable: !0, get: function() {
          return i.tsInterfaceDeclaration;
        } }), Object.defineProperty(n, "TSIntersectionType", { enumerable: !0, get: function() {
          return i.tsIntersectionType;
        } }), Object.defineProperty(n, "TSIntrinsicKeyword", { enumerable: !0, get: function() {
          return i.tsIntrinsicKeyword;
        } }), Object.defineProperty(n, "TSLiteralType", { enumerable: !0, get: function() {
          return i.tsLiteralType;
        } }), Object.defineProperty(n, "TSMappedType", { enumerable: !0, get: function() {
          return i.tsMappedType;
        } }), Object.defineProperty(n, "TSMethodSignature", { enumerable: !0, get: function() {
          return i.tsMethodSignature;
        } }), Object.defineProperty(n, "TSModuleBlock", { enumerable: !0, get: function() {
          return i.tsModuleBlock;
        } }), Object.defineProperty(n, "TSModuleDeclaration", { enumerable: !0, get: function() {
          return i.tsModuleDeclaration;
        } }), Object.defineProperty(n, "TSNamedTupleMember", { enumerable: !0, get: function() {
          return i.tsNamedTupleMember;
        } }), Object.defineProperty(n, "TSNamespaceExportDeclaration", { enumerable: !0, get: function() {
          return i.tsNamespaceExportDeclaration;
        } }), Object.defineProperty(n, "TSNeverKeyword", { enumerable: !0, get: function() {
          return i.tsNeverKeyword;
        } }), Object.defineProperty(n, "TSNonNullExpression", { enumerable: !0, get: function() {
          return i.tsNonNullExpression;
        } }), Object.defineProperty(n, "TSNullKeyword", { enumerable: !0, get: function() {
          return i.tsNullKeyword;
        } }), Object.defineProperty(n, "TSNumberKeyword", { enumerable: !0, get: function() {
          return i.tsNumberKeyword;
        } }), Object.defineProperty(n, "TSObjectKeyword", { enumerable: !0, get: function() {
          return i.tsObjectKeyword;
        } }), Object.defineProperty(n, "TSOptionalType", { enumerable: !0, get: function() {
          return i.tsOptionalType;
        } }), Object.defineProperty(n, "TSParameterProperty", { enumerable: !0, get: function() {
          return i.tsParameterProperty;
        } }), Object.defineProperty(n, "TSParenthesizedType", { enumerable: !0, get: function() {
          return i.tsParenthesizedType;
        } }), Object.defineProperty(n, "TSPropertySignature", { enumerable: !0, get: function() {
          return i.tsPropertySignature;
        } }), Object.defineProperty(n, "TSQualifiedName", { enumerable: !0, get: function() {
          return i.tsQualifiedName;
        } }), Object.defineProperty(n, "TSRestType", { enumerable: !0, get: function() {
          return i.tsRestType;
        } }), Object.defineProperty(n, "TSSatisfiesExpression", { enumerable: !0, get: function() {
          return i.tsSatisfiesExpression;
        } }), Object.defineProperty(n, "TSStringKeyword", { enumerable: !0, get: function() {
          return i.tsStringKeyword;
        } }), Object.defineProperty(n, "TSSymbolKeyword", { enumerable: !0, get: function() {
          return i.tsSymbolKeyword;
        } }), Object.defineProperty(n, "TSThisType", { enumerable: !0, get: function() {
          return i.tsThisType;
        } }), Object.defineProperty(n, "TSTupleType", { enumerable: !0, get: function() {
          return i.tsTupleType;
        } }), Object.defineProperty(n, "TSTypeAliasDeclaration", { enumerable: !0, get: function() {
          return i.tsTypeAliasDeclaration;
        } }), Object.defineProperty(n, "TSTypeAnnotation", { enumerable: !0, get: function() {
          return i.tsTypeAnnotation;
        } }), Object.defineProperty(n, "TSTypeAssertion", { enumerable: !0, get: function() {
          return i.tsTypeAssertion;
        } }), Object.defineProperty(n, "TSTypeLiteral", { enumerable: !0, get: function() {
          return i.tsTypeLiteral;
        } }), Object.defineProperty(n, "TSTypeOperator", { enumerable: !0, get: function() {
          return i.tsTypeOperator;
        } }), Object.defineProperty(n, "TSTypeParameter", { enumerable: !0, get: function() {
          return i.tsTypeParameter;
        } }), Object.defineProperty(n, "TSTypeParameterDeclaration", { enumerable: !0, get: function() {
          return i.tsTypeParameterDeclaration;
        } }), Object.defineProperty(n, "TSTypeParameterInstantiation", { enumerable: !0, get: function() {
          return i.tsTypeParameterInstantiation;
        } }), Object.defineProperty(n, "TSTypePredicate", { enumerable: !0, get: function() {
          return i.tsTypePredicate;
        } }), Object.defineProperty(n, "TSTypeQuery", { enumerable: !0, get: function() {
          return i.tsTypeQuery;
        } }), Object.defineProperty(n, "TSTypeReference", { enumerable: !0, get: function() {
          return i.tsTypeReference;
        } }), Object.defineProperty(n, "TSUndefinedKeyword", { enumerable: !0, get: function() {
          return i.tsUndefinedKeyword;
        } }), Object.defineProperty(n, "TSUnionType", { enumerable: !0, get: function() {
          return i.tsUnionType;
        } }), Object.defineProperty(n, "TSUnknownKeyword", { enumerable: !0, get: function() {
          return i.tsUnknownKeyword;
        } }), Object.defineProperty(n, "TSVoidKeyword", { enumerable: !0, get: function() {
          return i.tsVoidKeyword;
        } }), Object.defineProperty(n, "TaggedTemplateExpression", { enumerable: !0, get: function() {
          return i.taggedTemplateExpression;
        } }), Object.defineProperty(n, "TemplateElement", { enumerable: !0, get: function() {
          return i.templateElement;
        } }), Object.defineProperty(n, "TemplateLiteral", { enumerable: !0, get: function() {
          return i.templateLiteral;
        } }), Object.defineProperty(n, "ThisExpression", { enumerable: !0, get: function() {
          return i.thisExpression;
        } }), Object.defineProperty(n, "ThisTypeAnnotation", { enumerable: !0, get: function() {
          return i.thisTypeAnnotation;
        } }), Object.defineProperty(n, "ThrowStatement", { enumerable: !0, get: function() {
          return i.throwStatement;
        } }), Object.defineProperty(n, "TopicReference", { enumerable: !0, get: function() {
          return i.topicReference;
        } }), Object.defineProperty(n, "TryStatement", { enumerable: !0, get: function() {
          return i.tryStatement;
        } }), Object.defineProperty(n, "TupleExpression", { enumerable: !0, get: function() {
          return i.tupleExpression;
        } }), Object.defineProperty(n, "TupleTypeAnnotation", { enumerable: !0, get: function() {
          return i.tupleTypeAnnotation;
        } }), Object.defineProperty(n, "TypeAlias", { enumerable: !0, get: function() {
          return i.typeAlias;
        } }), Object.defineProperty(n, "TypeAnnotation", { enumerable: !0, get: function() {
          return i.typeAnnotation;
        } }), Object.defineProperty(n, "TypeCastExpression", { enumerable: !0, get: function() {
          return i.typeCastExpression;
        } }), Object.defineProperty(n, "TypeParameter", { enumerable: !0, get: function() {
          return i.typeParameter;
        } }), Object.defineProperty(n, "TypeParameterDeclaration", { enumerable: !0, get: function() {
          return i.typeParameterDeclaration;
        } }), Object.defineProperty(n, "TypeParameterInstantiation", { enumerable: !0, get: function() {
          return i.typeParameterInstantiation;
        } }), Object.defineProperty(n, "TypeofTypeAnnotation", { enumerable: !0, get: function() {
          return i.typeofTypeAnnotation;
        } }), Object.defineProperty(n, "UnaryExpression", { enumerable: !0, get: function() {
          return i.unaryExpression;
        } }), Object.defineProperty(n, "UnionTypeAnnotation", { enumerable: !0, get: function() {
          return i.unionTypeAnnotation;
        } }), Object.defineProperty(n, "UpdateExpression", { enumerable: !0, get: function() {
          return i.updateExpression;
        } }), Object.defineProperty(n, "V8IntrinsicIdentifier", { enumerable: !0, get: function() {
          return i.v8IntrinsicIdentifier;
        } }), Object.defineProperty(n, "VariableDeclaration", { enumerable: !0, get: function() {
          return i.variableDeclaration;
        } }), Object.defineProperty(n, "VariableDeclarator", { enumerable: !0, get: function() {
          return i.variableDeclarator;
        } }), Object.defineProperty(n, "Variance", { enumerable: !0, get: function() {
          return i.variance;
        } }), Object.defineProperty(n, "VoidTypeAnnotation", { enumerable: !0, get: function() {
          return i.voidTypeAnnotation;
        } }), Object.defineProperty(n, "WhileStatement", { enumerable: !0, get: function() {
          return i.whileStatement;
        } }), Object.defineProperty(n, "WithStatement", { enumerable: !0, get: function() {
          return i.withStatement;
        } }), Object.defineProperty(n, "YieldExpression", { enumerable: !0, get: function() {
          return i.yieldExpression;
        } });
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/productions.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.buildUndefinedNode = function() {
          return (0, i.unaryExpression)("void", (0, i.numericLiteral)(0), !0);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/react/buildChildren.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          const s = [];
          for (let o = 0; o < f.children.length; o++) {
            let y = f.children[o];
            (0, i.isJSXText)(y) ? (0, c.default)(y, s) : ((0, i.isJSXExpressionContainer)(y) && (y = y.expression), (0, i.isJSXEmptyExpression)(y) || s.push(y));
          }
          return s;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s) {
          const o = s.map((m) => (0, f.isTSTypeAnnotation)(m) ? m.typeAnnotation : m), y = (0, c.default)(o);
          return y.length === 1 ? y[0] : (0, i.tsUnionType)(y);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/validateNode.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          const s = c.BUILDER_KEYS[f.type];
          for (const o of s) (0, i.default)(f, o, f[o]);
          return f;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/validate.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/clone.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return (0, i.default)(c, !1);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneDeep.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return (0, i.default)(c);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return (0, i.default)(c, !0, !0);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(g, b = !0, v = !1) {
          return y(g, b, v, /* @__PURE__ */ new Map());
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
        const { hasOwn: f } = { hasOwn: Function.call.bind(Object.prototype.hasOwnProperty) };
        function s(g, b, v, T) {
          return g && typeof g.type == "string" ? y(g, b, v, T) : g;
        }
        function o(g, b, v, T) {
          return Array.isArray(g) ? g.map((E) => s(E, b, v, T)) : s(g, b, v, T);
        }
        function y(g, b = !0, v = !1, T) {
          if (!g) return g;
          const { type: E } = g, O = { type: g.type };
          if ((0, c.isIdentifier)(g)) O.name = g.name, f(g, "optional") && typeof g.optional == "boolean" && (O.optional = g.optional), f(g, "typeAnnotation") && (O.typeAnnotation = b ? o(g.typeAnnotation, !0, v, T) : g.typeAnnotation);
          else {
            if (!f(i.NODE_FIELDS, E)) throw new Error(`Unknown node type: "${E}"`);
            for (const D of Object.keys(i.NODE_FIELDS[E])) f(g, D) && (O[D] = b ? (0, c.isFile)(g) && D === "comments" ? m(g.comments, b, v, T) : o(g[D], !0, v, T) : g[D]);
          }
          return f(g, "loc") && (O.loc = v ? null : g.loc), f(g, "leadingComments") && (O.leadingComments = m(g.leadingComments, b, v, T)), f(g, "innerComments") && (O.innerComments = m(g.innerComments, b, v, T)), f(g, "trailingComments") && (O.trailingComments = m(g.trailingComments, b, v, T)), f(g, "extra") && (O.extra = Object.assign({}, g.extra)), O;
        }
        function m(g, b, v, T) {
          return g && b ? g.map((E) => {
            const O = T.get(E);
            if (O) return O;
            const { type: D, value: $, loc: I } = E, k = { type: D, value: $, loc: I };
            return v && (k.loc = null), T.set(E, k), k;
          }) : g;
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return (0, i.default)(c, !1, !0);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/addComment.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f, s, o) {
          return (0, i.default)(c, f, [{ type: o ? "CommentLine" : "CommentBlock", value: s }]);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/addComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/addComments.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(u, i, c) {
          if (!c || !u) return u;
          const f = `${i}Comments`;
          return u[f] ? i === "leading" ? u[f] = c.concat(u[f]) : u[f].push(...c) : u[f] = c, u;
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritInnerComments.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          (0, i.default)("innerComments", c, f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritLeadingComments.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          (0, i.default)("leadingComments", c, f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritTrailingComments.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          (0, i.default)("trailingComments", c, f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritsComments.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o) {
          return (0, i.default)(s, o), (0, c.default)(s, o), (0, f.default)(s, o), s;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritInnerComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/removeComments.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return i.COMMENT_KEYS.forEach((f) => {
            c[f] = null;
          }), c;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/generated/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.WHILE_TYPES = n.USERWHITESPACABLE_TYPES = n.UNARYLIKE_TYPES = n.TYPESCRIPT_TYPES = n.TSTYPE_TYPES = n.TSTYPEELEMENT_TYPES = n.TSENTITYNAME_TYPES = n.TSBASETYPE_TYPES = n.TERMINATORLESS_TYPES = n.STATEMENT_TYPES = n.STANDARDIZED_TYPES = n.SCOPABLE_TYPES = n.PUREISH_TYPES = n.PROPERTY_TYPES = n.PRIVATE_TYPES = n.PATTERN_TYPES = n.PATTERNLIKE_TYPES = n.OBJECTMEMBER_TYPES = n.MODULESPECIFIER_TYPES = n.MODULEDECLARATION_TYPES = n.MISCELLANEOUS_TYPES = n.METHOD_TYPES = n.LVAL_TYPES = n.LOOP_TYPES = n.LITERAL_TYPES = n.JSX_TYPES = n.IMPORTOREXPORTDECLARATION_TYPES = n.IMMUTABLE_TYPES = n.FUNCTION_TYPES = n.FUNCTIONPARENT_TYPES = n.FOR_TYPES = n.FORXSTATEMENT_TYPES = n.FLOW_TYPES = n.FLOWTYPE_TYPES = n.FLOWPREDICATE_TYPES = n.FLOWDECLARATION_TYPES = n.FLOWBASEANNOTATION_TYPES = n.EXPRESSION_TYPES = n.EXPRESSIONWRAPPER_TYPES = n.EXPORTDECLARATION_TYPES = n.ENUMMEMBER_TYPES = n.ENUMBODY_TYPES = n.DECLARATION_TYPES = n.CONDITIONAL_TYPES = n.COMPLETIONSTATEMENT_TYPES = n.CLASS_TYPES = n.BLOCK_TYPES = n.BLOCKPARENT_TYPES = n.BINARY_TYPES = n.ACCESSOR_TYPES = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
        n.STANDARDIZED_TYPES = i.FLIPPED_ALIAS_KEYS.Standardized, n.EXPRESSION_TYPES = i.FLIPPED_ALIAS_KEYS.Expression, n.BINARY_TYPES = i.FLIPPED_ALIAS_KEYS.Binary, n.SCOPABLE_TYPES = i.FLIPPED_ALIAS_KEYS.Scopable, n.BLOCKPARENT_TYPES = i.FLIPPED_ALIAS_KEYS.BlockParent, n.BLOCK_TYPES = i.FLIPPED_ALIAS_KEYS.Block, n.STATEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.Statement, n.TERMINATORLESS_TYPES = i.FLIPPED_ALIAS_KEYS.Terminatorless, n.COMPLETIONSTATEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.CompletionStatement, n.CONDITIONAL_TYPES = i.FLIPPED_ALIAS_KEYS.Conditional, n.LOOP_TYPES = i.FLIPPED_ALIAS_KEYS.Loop, n.WHILE_TYPES = i.FLIPPED_ALIAS_KEYS.While, n.EXPRESSIONWRAPPER_TYPES = i.FLIPPED_ALIAS_KEYS.ExpressionWrapper, n.FOR_TYPES = i.FLIPPED_ALIAS_KEYS.For, n.FORXSTATEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.ForXStatement, n.FUNCTION_TYPES = i.FLIPPED_ALIAS_KEYS.Function, n.FUNCTIONPARENT_TYPES = i.FLIPPED_ALIAS_KEYS.FunctionParent, n.PUREISH_TYPES = i.FLIPPED_ALIAS_KEYS.Pureish, n.DECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.Declaration, n.PATTERNLIKE_TYPES = i.FLIPPED_ALIAS_KEYS.PatternLike, n.LVAL_TYPES = i.FLIPPED_ALIAS_KEYS.LVal, n.TSENTITYNAME_TYPES = i.FLIPPED_ALIAS_KEYS.TSEntityName, n.LITERAL_TYPES = i.FLIPPED_ALIAS_KEYS.Literal, n.IMMUTABLE_TYPES = i.FLIPPED_ALIAS_KEYS.Immutable, n.USERWHITESPACABLE_TYPES = i.FLIPPED_ALIAS_KEYS.UserWhitespacable, n.METHOD_TYPES = i.FLIPPED_ALIAS_KEYS.Method, n.OBJECTMEMBER_TYPES = i.FLIPPED_ALIAS_KEYS.ObjectMember, n.PROPERTY_TYPES = i.FLIPPED_ALIAS_KEYS.Property, n.UNARYLIKE_TYPES = i.FLIPPED_ALIAS_KEYS.UnaryLike, n.PATTERN_TYPES = i.FLIPPED_ALIAS_KEYS.Pattern, n.CLASS_TYPES = i.FLIPPED_ALIAS_KEYS.Class;
        const c = n.IMPORTOREXPORTDECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
        n.EXPORTDECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.ExportDeclaration, n.MODULESPECIFIER_TYPES = i.FLIPPED_ALIAS_KEYS.ModuleSpecifier, n.ACCESSOR_TYPES = i.FLIPPED_ALIAS_KEYS.Accessor, n.PRIVATE_TYPES = i.FLIPPED_ALIAS_KEYS.Private, n.FLOW_TYPES = i.FLIPPED_ALIAS_KEYS.Flow, n.FLOWTYPE_TYPES = i.FLIPPED_ALIAS_KEYS.FlowType, n.FLOWBASEANNOTATION_TYPES = i.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, n.FLOWDECLARATION_TYPES = i.FLIPPED_ALIAS_KEYS.FlowDeclaration, n.FLOWPREDICATE_TYPES = i.FLIPPED_ALIAS_KEYS.FlowPredicate, n.ENUMBODY_TYPES = i.FLIPPED_ALIAS_KEYS.EnumBody, n.ENUMMEMBER_TYPES = i.FLIPPED_ALIAS_KEYS.EnumMember, n.JSX_TYPES = i.FLIPPED_ALIAS_KEYS.JSX, n.MISCELLANEOUS_TYPES = i.FLIPPED_ALIAS_KEYS.Miscellaneous, n.TYPESCRIPT_TYPES = i.FLIPPED_ALIAS_KEYS.TypeScript, n.TSTYPEELEMENT_TYPES = i.FLIPPED_ALIAS_KEYS.TSTypeElement, n.TSTYPE_TYPES = i.FLIPPED_ALIAS_KEYS.TSType, n.TSBASETYPE_TYPES = i.FLIPPED_ALIAS_KEYS.TSBaseType, n.MODULEDECLARATION_TYPES = c;
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.UPDATE_OPERATORS = n.UNARY_OPERATORS = n.STRING_UNARY_OPERATORS = n.STATEMENT_OR_BLOCK_KEYS = n.NUMBER_UNARY_OPERATORS = n.NUMBER_BINARY_OPERATORS = n.NOT_LOCAL_BINDING = n.LOGICAL_OPERATORS = n.INHERIT_KEYS = n.FOR_INIT_KEYS = n.FLATTENABLE_KEYS = n.EQUALITY_BINARY_OPERATORS = n.COMPARISON_BINARY_OPERATORS = n.COMMENT_KEYS = n.BOOLEAN_UNARY_OPERATORS = n.BOOLEAN_NUMBER_BINARY_OPERATORS = n.BOOLEAN_BINARY_OPERATORS = n.BLOCK_SCOPED_SYMBOL = n.BINARY_OPERATORS = n.ASSIGNMENT_OPERATORS = void 0, n.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], n.FLATTENABLE_KEYS = ["body", "expressions"], n.FOR_INIT_KEYS = ["left", "init"], n.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const u = n.LOGICAL_OPERATORS = ["||", "&&", "??"], i = (n.UPDATE_OPERATORS = ["++", "--"], n.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="]), c = n.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], f = n.COMPARISON_BINARY_OPERATORS = [...c, "in", "instanceof"], s = n.BOOLEAN_BINARY_OPERATORS = [...f, ...i], o = n.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], y = (n.BINARY_OPERATORS = ["+", ...o, ...s, "|>"], n.ASSIGNMENT_OPERATORS = ["=", "+=", ...o.map((b) => b + "="), ...u.map((b) => b + "=")], n.BOOLEAN_UNARY_OPERATORS = ["delete", "!"]), m = n.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], g = n.STRING_UNARY_OPERATORS = ["typeof"];
        n.UNARY_OPERATORS = ["void", "throw", ...y, ...m, ...g], n.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] }, n.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), n.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/ensureBlock.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f = "body") {
          const s = (0, i.default)(c[f], c);
          return c[f] = s, s;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toBlock.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function y(m, g) {
          const b = [];
          let v = !0;
          for (const T of m) if ((0, c.isEmptyStatement)(T) || (v = !1), (0, c.isExpression)(T)) b.push(T);
          else if ((0, c.isExpressionStatement)(T)) b.push(T.expression);
          else if ((0, c.isVariableDeclaration)(T)) {
            if (T.kind !== "var") return;
            for (const E of T.declarations) {
              const O = (0, i.default)(E);
              for (const D of Object.keys(O)) g.push({ kind: T.kind, id: (0, o.default)(O[D]) });
              E.init && b.push((0, f.assignmentExpression)("=", E.id, E.init));
            }
            v = !0;
          } else if ((0, c.isIfStatement)(T)) {
            const E = T.consequent ? y([T.consequent], g) : (0, s.buildUndefinedNode)(), O = T.alternate ? y([T.alternate], g) : (0, s.buildUndefinedNode)();
            if (!E || !O) return;
            b.push((0, f.conditionalExpression)(T.test, E, O));
          } else if ((0, c.isBlockStatement)(T)) {
            const E = y(T.body, g);
            if (!E) return;
            b.push(E);
          } else {
            if (!(0, c.isEmptyStatement)(T)) return;
            m.indexOf(T) === 0 && (v = !0);
          }
          return v && b.push((0, s.buildUndefinedNode)()), b.length === 1 ? b[0] : (0, f.sequenceExpression)(b);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js"), s = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/productions.js"), o = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return (c = (0, i.default)(c)) !== "eval" && c !== "arguments" || (c = "_" + c), c;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toIdentifier.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toBlock.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s) {
          if ((0, i.isBlockStatement)(f)) return f;
          let o = [];
          return (0, i.isEmptyStatement)(f) ? o = [] : ((0, i.isStatement)(f) || (f = (0, i.isFunction)(s) ? (0, c.returnStatement)(f) : (0, c.expressionStatement)(f)), o = [f]), (0, c.blockStatement)(o);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toComputedKey.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s = f.key || f.property) {
          return !f.computed && (0, i.isIdentifier)(s) && (s = (0, c.stringLiteral)(s.name)), s;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toExpression.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
        n.default = function(c) {
          if ((0, i.isExpressionStatement)(c) && (c = c.expression), (0, i.isExpression)(c)) return c;
          if ((0, i.isClass)(c) ? c.type = "ClassExpression" : (0, i.isFunction)(c) && (c.type = "FunctionExpression"), !(0, i.isExpression)(c)) throw new Error(`cannot turn ${c.type} to an expression`);
          return c;
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toIdentifier.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          f += "";
          let s = "";
          for (const o of f) s += (0, c.isIdentifierChar)(o.codePointAt(0)) ? o : "-";
          return s = s.replace(/^[-0-9]+/, ""), s = s.replace(/[-\s]+(.)?/g, function(o, y) {
            return y ? y.toUpperCase() : "";
          }), (0, i.default)(s) || (s = `_${s}`), s || "_";
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), c = u("./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toKeyAlias.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = s;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");
        function s(o, y = o.key) {
          let m;
          return o.kind === "method" ? s.increment() + "" : (m = (0, i.isIdentifier)(y) ? y.name : (0, i.isStringLiteral)(y) ? JSON.stringify(y.value) : JSON.stringify((0, f.default)((0, c.default)(y))), o.computed && (m = `[${m}]`), o.static && (m = `static:${m}`), m);
        }
        s.uid = 0, s.increment = function() {
          return s.uid >= Number.MAX_SAFE_INTEGER ? s.uid = 0 : s.uid++;
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toSequenceExpression.js": (h, n, u) => {
        n.default = function(c, f) {
          if (c == null || !c.length) return;
          const s = [], o = (0, i.default)(c, s);
          if (o) {
            for (const y of s) f.push(y);
            return o;
          }
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toStatement.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
        n.default = function(f, s) {
          if ((0, i.isStatement)(f)) return f;
          let o, y = !1;
          if ((0, i.isClass)(f)) y = !0, o = "ClassDeclaration";
          else if ((0, i.isFunction)(f)) y = !0, o = "FunctionDeclaration";
          else if ((0, i.isAssignmentExpression)(f)) return (0, c.expressionStatement)(f);
          if (y && !f.id && (o = !1), !o) {
            if (s) return !1;
            throw new Error(`cannot turn ${f.type} to a statement`);
          }
          return f.type = o, f;
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/valueToNode.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
        n.default = function s(o) {
          if (o === void 0) return (0, c.identifier)("undefined");
          if (o === !0 || o === !1) return (0, c.booleanLiteral)(o);
          if (o === null) return (0, c.nullLiteral)();
          if (typeof o == "string") return (0, c.stringLiteral)(o);
          if (typeof o == "number") {
            let y;
            if (Number.isFinite(o)) y = (0, c.numericLiteral)(Math.abs(o));
            else {
              let m;
              m = Number.isNaN(o) ? (0, c.numericLiteral)(0) : (0, c.numericLiteral)(1), y = (0, c.binaryExpression)("/", m, (0, c.numericLiteral)(0));
            }
            return (o < 0 || Object.is(o, -0)) && (y = (0, c.unaryExpression)("-", y)), y;
          }
          if (function(y) {
            return f(y) === "[object RegExp]";
          }(o)) {
            const y = o.source, m = o.toString().match(/\/([a-z]+|)$/)[1];
            return (0, c.regExpLiteral)(y, m);
          }
          if (Array.isArray(o)) return (0, c.arrayExpression)(o.map(s));
          if (function(y) {
            if (typeof y != "object" || y === null || Object.prototype.toString.call(y) !== "[object Object]") return !1;
            const m = Object.getPrototypeOf(y);
            return m === null || Object.getPrototypeOf(m) === null;
          }(o)) {
            const y = [];
            for (const m of Object.keys(o)) {
              let g;
              g = (0, i.default)(m) ? (0, c.identifier)(m) : (0, c.stringLiteral)(m), y.push((0, c.objectProperty)(g, s(o[m])));
            }
            return (0, c.objectExpression)(y);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        const f = Function.call.bind(Object.prototype.toString);
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/core.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.patternLikeCommon = n.functionTypeAnnotationCommon = n.functionDeclarationCommon = n.functionCommon = n.classMethodOrPropertyCommon = n.classMethodOrDeclareMethodCommon = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/is.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), f = u("./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/index.js"), s = u("./node_modules/.pnpm/@babel+helper-string-parser@7.24.7/node_modules/@babel/helper-string-parser/lib/index.js"), o = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js"), y = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js");
        const m = (0, y.defineAliasedType)("Standardized");
        m("ArrayExpression", { fields: { elements: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: Ze.env.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), m("AssignmentExpression", { fields: { operator: { validate: function() {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return (0, y.assertValueType)("string");
          const D = (0, y.assertOneOf)(...o.ASSIGNMENT_OPERATORS), $ = (0, y.assertOneOf)("=");
          return function(I, k, L) {
            ((0, i.default)("Pattern", I.left) ? $ : D)(I, k, L);
          };
        }() }, left: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, y.assertNodeType)("LVal", "OptionalMemberExpression") }, right: { validate: (0, y.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), m("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, y.assertOneOf)(...o.BINARY_OPERATORS) }, left: { validate: function() {
          const D = (0, y.assertNodeType)("Expression"), $ = (0, y.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(I, k, L) {
            (I.operator === "in" ? $ : D)(I, k, L);
          }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
        }() }, right: { validate: (0, y.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), m("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, y.assertValueType)("string") } } }), m("Directive", { visitor: ["value"], fields: { value: { validate: (0, y.assertNodeType)("DirectiveLiteral") } } }), m("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, y.assertValueType)("string") } } }), m("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), m("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, y.assertNodeType)("Identifier"), optional: !0 } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), m("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, y.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Expression", "SpreadElement", "ArgumentPlaceholder"))) } }, Ze.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, y.assertOneOf)(!0, !1), optional: !0 } }, { typeArguments: { validate: (0, y.assertNodeType)("TypeParameterInstantiation"), optional: !0 }, typeParameters: { validate: (0, y.assertNodeType)("TSTypeParameterInstantiation"), optional: !0 } }) }), m("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, y.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: !0 }, body: { validate: (0, y.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), m("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, y.assertNodeType)("Expression") }, consequent: { validate: (0, y.assertNodeType)("Expression") }, alternate: { validate: (0, y.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), m("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, y.assertNodeType)("Identifier"), optional: !0 } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), m("DebuggerStatement", { aliases: ["Statement"] }), m("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, y.assertNodeType)("Expression") }, body: { validate: (0, y.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), m("EmptyStatement", { aliases: ["Statement"] }), m("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, y.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), m("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, y.assertNodeType)("Program") }, comments: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.assertEach)((0, y.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: !0 }, tokens: { validate: (0, y.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: !0 } } }), m("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, y.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, y.assertNodeType)("Expression") }, body: { validate: (0, y.assertNodeType)("Statement") } } }), m("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, y.assertNodeType)("VariableDeclaration", "Expression"), optional: !0 }, test: { validate: (0, y.assertNodeType)("Expression"), optional: !0 }, update: { validate: (0, y.assertNodeType)("Expression"), optional: !0 }, body: { validate: (0, y.assertNodeType)("Statement") } } });
        const g = () => ({ params: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: !1 }, async: { default: !1 } });
        n.functionCommon = g;
        const b = () => ({ returnType: { validate: (0, y.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, typeParameters: { validate: (0, y.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: !0 } });
        n.functionTypeAnnotationCommon = b;
        const v = () => Object.assign({}, g(), { declare: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, id: { validate: (0, y.assertNodeType)("Identifier"), optional: !0 } });
        n.functionDeclarationCommon = v, m("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, v(), b(), { body: { validate: (0, y.assertNodeType)("BlockStatement") }, predicate: { validate: (0, y.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0 } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: function() {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return () => {
          };
          const D = (0, y.assertNodeType)("Identifier");
          return function($, I, k) {
            (0, i.default)("ExportDefaultDeclaration", $) || D(k, "id", k.id);
          };
        }() }), m("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, g(), b(), { id: { validate: (0, y.assertNodeType)("Identifier"), optional: !0 }, body: { validate: (0, y.assertNodeType)("BlockStatement") }, predicate: { validate: (0, y.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0 } }) });
        const T = () => ({ typeAnnotation: { validate: (0, y.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, optional: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 } });
        n.patternLikeCommon = T, m("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, T(), { name: { validate: (0, y.chain)((0, y.assertValueType)("string"), Object.assign(function(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && !(0, c.default)(I, !1)) throw new TypeError(`"${I}" is not a valid identifier name`);
        }, { type: "string" })) } }), validate(D, $, I) {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return;
          const k = /\.(\w+)$/.exec($);
          if (!k) return;
          const [, L] = k, M = { computed: !1 };
          if (L === "property") {
            if ((0, i.default)("MemberExpression", D, M) || (0, i.default)("OptionalMemberExpression", D, M)) return;
          } else if (L === "key") {
            if ((0, i.default)("Property", D, M) || (0, i.default)("Method", D, M)) return;
          } else if (L === "exported") {
            if ((0, i.default)("ExportSpecifier", D)) return;
          } else if (L === "imported") {
            if ((0, i.default)("ImportSpecifier", D, { imported: I })) return;
          } else if (L === "meta" && (0, i.default)("MetaProperty", D, { meta: I })) return;
          if (((0, f.isKeyword)(I.name) || (0, f.isReservedWord)(I.name, !1)) && I.name !== "this") throw new TypeError(`"${I.name}" is not a valid identifier`);
        } }), m("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, y.assertNodeType)("Expression") }, consequent: { validate: (0, y.assertNodeType)("Statement") }, alternate: { optional: !0, validate: (0, y.assertNodeType)("Statement") } } }), m("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, y.assertNodeType)("Identifier") }, body: { validate: (0, y.assertNodeType)("Statement") } } }), m("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, y.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), m("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, y.chain)((0, y.assertValueType)("number"), Object.assign(function(D, $, I) {
        }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), m("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), m("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, y.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), m("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, y.assertValueType)("string") }, flags: { validate: (0, y.chain)((0, y.assertValueType)("string"), Object.assign(function(D, $, I) {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return;
          const k = /[^gimsuy]/.exec(I);
          if (k) throw new TypeError(`"${k[0]}" is not a valid RegExp flag`);
        }, { type: "string" })), default: "" } } }), m("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, y.assertOneOf)(...o.LOGICAL_OPERATORS) }, left: { validate: (0, y.assertNodeType)("Expression") }, right: { validate: (0, y.assertNodeType)("Expression") } } }), m("MemberExpression", { builder: ["object", "property", "computed", ...Ze.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, y.assertNodeType)("Expression", "Super") }, property: { validate: function() {
          const D = (0, y.assertNodeType)("Identifier", "PrivateName"), $ = (0, y.assertNodeType)("Expression"), I = function(k, L, M) {
            (k.computed ? $ : D)(k, L, M);
          };
          return I.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], I;
        }() }, computed: { default: !1 } }, Ze.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, y.assertOneOf)(!0, !1), optional: !0 } }) }), m("NewExpression", { inherits: "CallExpression" }), m("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceType: { validate: (0, y.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, y.assertNodeType)("InterpreterDirective"), default: null, optional: !0 }, directives: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), m("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), m("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, g(), b(), { kind: Object.assign({ validate: (0, y.assertOneOf)("method", "get", "set") }, Ze.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: !1 }, key: { validate: function() {
          const D = (0, y.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), $ = (0, y.assertNodeType)("Expression"), I = function(k, L, M) {
            (k.computed ? $ : D)(k, L, M);
          };
          return I.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], I;
        }() }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 }, body: { validate: (0, y.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), m("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...Ze.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: !1 }, key: { validate: function() {
          const D = (0, y.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), $ = (0, y.assertNodeType)("Expression");
          return Object.assign(function(I, k, L) {
            (I.computed ? $ : D)(I, k, L);
          }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
        }() }, value: { validate: (0, y.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, y.chain)((0, y.assertValueType)("boolean"), Object.assign(function(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && I && D.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, { type: "boolean" }), function(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && I && !(0, i.default)("Identifier", D.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }), default: !1 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: function() {
          const D = (0, y.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), $ = (0, y.assertNodeType)("Expression");
          return function(I, k, L) {
            Ze.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ObjectPattern", I) ? D : $)(L, "value", L.value);
          };
        }() }), m("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, T(), { argument: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, y.assertNodeType)("LVal") } }), validate(D, $) {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return;
          const I = /(\w+)\[(\d+)\]/.exec($);
          if (!I) throw new Error("Internal Babel error: malformed key.");
          const [, k, L] = I;
          if (D[k].length > +L + 1) throw new TypeError(`RestElement must be last element of ${k}`);
        } }), m("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, y.assertNodeType)("Expression"), optional: !0 } } }), m("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), m("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, y.assertNodeType)("Expression") } } }), m("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, y.assertNodeType)("Expression"), optional: !0 }, consequent: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Statement"))) } } }), m("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, y.assertNodeType)("Expression") }, cases: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("SwitchCase"))) } } }), m("ThisExpression", { aliases: ["Expression"] }), m("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, y.assertNodeType)("Expression") } } }), m("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, y.chain)((0, y.assertNodeType)("BlockStatement"), Object.assign(function(D) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && !D.handler && !D.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: !0, validate: (0, y.assertNodeType)("CatchClause") }, finalizer: { optional: !0, validate: (0, y.assertNodeType)("BlockStatement") } } }), m("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: !0 }, argument: { validate: (0, y.assertNodeType)("Expression") }, operator: { validate: (0, y.assertOneOf)(...o.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), m("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: !1 }, argument: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.assertNodeType)("Identifier", "MemberExpression") : (0, y.assertNodeType)("Expression") }, operator: { validate: (0, y.assertOneOf)(...o.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), m("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, kind: { validate: (0, y.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("VariableDeclarator"))) } }, validate(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && (0, i.default)("ForXStatement", D, { left: I }) && I.declarations.length !== 1) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${D.type}`);
        } }), m("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: function() {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return (0, y.assertNodeType)("LVal");
          const D = (0, y.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), $ = (0, y.assertNodeType)("Identifier");
          return function(I, k, L) {
            (I.init ? D : $)(I, k, L);
          };
        }() }, definite: { optional: !0, validate: (0, y.assertValueType)("boolean") }, init: { optional: !0, validate: (0, y.assertNodeType)("Expression") } } }), m("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, y.assertNodeType)("Expression") }, body: { validate: (0, y.assertNodeType)("Statement") } } }), m("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, y.assertNodeType)("Expression") }, body: { validate: (0, y.assertNodeType)("Statement") } } }), m("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, T(), { left: { validate: (0, y.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, y.assertNodeType)("Expression") }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 } }) }), m("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, T(), { elements: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), m("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, g(), b(), { expression: { validate: (0, y.assertValueType)("boolean") }, body: { validate: (0, y.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, y.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0 } }) }), m("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } }), m("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, y.assertNodeType)("Identifier"), optional: !0 }, typeParameters: { validate: (0, y.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: !0 }, body: { validate: (0, y.assertNodeType)("ClassBody") }, superClass: { optional: !0, validate: (0, y.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, y.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 }, implements: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 }, mixins: { validate: (0, y.assertNodeType)("InterfaceExtends"), optional: !0 } } }), m("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, y.assertNodeType)("Identifier"), optional: !0 }, typeParameters: { validate: (0, y.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: !0 }, body: { validate: (0, y.assertNodeType)("ClassBody") }, superClass: { optional: !0, validate: (0, y.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, y.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 }, implements: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 }, mixins: { validate: (0, y.assertNodeType)("InterfaceExtends"), optional: !0 }, declare: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, abstract: { validate: (0, y.assertValueType)("boolean"), optional: !0 } }, validate: function() {
          const D = (0, y.assertNodeType)("Identifier");
          return function($, I, k) {
            Ze.env.BABEL_TYPES_8_BREAKING && ((0, i.default)("ExportDefaultDeclaration", $) || D(k, "id", k.id));
          };
        }() }), m("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, y.assertNodeType)("StringLiteral") }, exportKind: (0, y.validateOptional)((0, y.assertOneOf)("type", "value")), attributes: { optional: !0, validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportAttribute"))) }, assertions: { optional: !0, validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportAttribute"))) } } }), m("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, y.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, y.validateOptional)((0, y.assertOneOf)("value")) } }), m("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: !0, validate: (0, y.chain)((0, y.assertNodeType)("Declaration"), Object.assign(function(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && I && D.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, { oneOfNodeTypes: ["Declaration"] }), function(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && I && D.source) throw new TypeError("Cannot export a declaration from a source");
        }) }, attributes: { optional: !0, validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportAttribute"))) }, assertions: { optional: !0, validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)(function() {
          const D = (0, y.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), $ = (0, y.assertNodeType)("ExportSpecifier");
          return Ze.env.BABEL_TYPES_8_BREAKING ? function(I, k, L) {
            (I.source ? D : $)(I, k, L);
          } : D;
        }())) }, source: { validate: (0, y.assertNodeType)("StringLiteral"), optional: !0 }, exportKind: (0, y.validateOptional)((0, y.assertOneOf)("type", "value")) } }), m("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, y.assertNodeType)("Identifier") }, exported: { validate: (0, y.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, y.assertOneOf)("type", "value"), optional: !0 } } }), m("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return (0, y.assertNodeType)("VariableDeclaration", "LVal");
          const D = (0, y.assertNodeType)("VariableDeclaration"), $ = (0, y.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(I, k, L) {
            (0, i.default)("VariableDeclaration", L) ? D(I, k, L) : $(I, k, L);
          };
        }() }, right: { validate: (0, y.assertNodeType)("Expression") }, body: { validate: (0, y.assertNodeType)("Statement") }, await: { default: !1 } } }), m("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: !0, validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportAttribute"))) }, assertions: { optional: !0, validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportAttribute"))) }, module: { optional: !0, validate: (0, y.assertValueType)("boolean") }, phase: { default: null, validate: (0, y.assertOneOf)("source", "defer") }, specifiers: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, y.assertNodeType)("StringLiteral") }, importKind: { validate: (0, y.assertOneOf)("type", "typeof", "value"), optional: !0 } } }), m("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, y.assertNodeType)("Identifier") } } }), m("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, y.assertNodeType)("Identifier") } } }), m("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, y.assertNodeType)("Identifier") }, imported: { validate: (0, y.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, y.assertOneOf)("type", "typeof", "value"), optional: !0 } } }), m("ImportExpression", { visitor: ["source", "options"], aliases: ["Expression"], fields: { phase: { default: null, validate: (0, y.assertOneOf)("source", "defer") }, source: { validate: (0, y.assertNodeType)("Expression") }, options: { validate: (0, y.assertNodeType)("Expression"), optional: !0 } } }), m("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, y.chain)((0, y.assertNodeType)("Identifier"), Object.assign(function(D, $, I) {
          if (!Ze.env.BABEL_TYPES_8_BREAKING) return;
          let k;
          switch (I.name) {
            case "function":
              k = "sent";
              break;
            case "new":
              k = "target";
              break;
            case "import":
              k = "meta";
          }
          if (!(0, i.default)("Identifier", D.property, { name: k })) throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, y.assertNodeType)("Identifier") } } });
        const E = () => ({ abstract: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, accessibility: { validate: (0, y.assertOneOf)("public", "private", "protected"), optional: !0 }, static: { default: !1 }, override: { default: !1 }, computed: { default: !1 }, optional: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, key: { validate: (0, y.chain)(function() {
          const D = (0, y.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), $ = (0, y.assertNodeType)("Expression");
          return function(I, k, L) {
            (I.computed ? $ : D)(I, k, L);
          };
        }(), (0, y.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
        n.classMethodOrPropertyCommon = E;
        const O = () => Object.assign({}, g(), E(), { params: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, y.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, y.chain)((0, y.assertValueType)("string"), (0, y.assertOneOf)("public", "private", "protected")), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 } });
        n.classMethodOrDeclareMethodCommon = O, m("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, O(), b(), { body: { validate: (0, y.assertNodeType)("BlockStatement") } }) }), m("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, T(), { properties: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), m("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, y.assertNodeType)("Expression") } } }), m("Super", { aliases: ["Expression"] }), m("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, y.assertNodeType)("Expression") }, quasi: { validate: (0, y.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, y.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 } } }), m("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, y.chain)((0, y.assertShape)({ raw: { validate: (0, y.assertValueType)("string") }, cooked: { validate: (0, y.assertValueType)("string"), optional: !0 } }), function(D) {
          const $ = D.value.raw;
          let I = !1;
          const k = () => {
            throw new Error("Internal @babel/types error.");
          }, { str: L, firstInvalidLoc: M } = (0, s.readStringContents)("template", $, 0, 0, 0, { unterminated() {
            I = !0;
          }, strictNumericEscape: k, invalidEscapeSequence: k, numericSeparatorInEscapeSequence: k, unexpectedNumericSeparator: k, invalidDigit: k, invalidCodePoint: k });
          if (!I) throw new Error("Invalid raw");
          D.value.cooked = M ? null : L;
        }) }, tail: { default: !1 } } }), m("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Expression", "TSType")), function(D, $, I) {
          if (D.quasis.length !== I.length + 1) throw new TypeError(`Number of ${D.type} quasis should be exactly one more than the number of expressions.
Expected ${I.length + 1} quasis but got ${D.quasis.length}`);
        }) } } }), m("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, y.chain)((0, y.assertValueType)("boolean"), Object.assign(function(D, $, I) {
          if (Ze.env.BABEL_TYPES_8_BREAKING && I && !D.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })), default: !1 }, argument: { optional: !0, validate: (0, y.assertNodeType)("Expression") } } }), m("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, y.assertNodeType)("Expression") } } }), m("Import", { aliases: ["Expression"] }), m("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, y.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), m("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, y.assertNodeType)("Identifier") } } }), m("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, y.assertNodeType)("Expression") }, property: { validate: function() {
          const D = (0, y.assertNodeType)("Identifier"), $ = (0, y.assertNodeType)("Expression");
          return Object.assign(function(I, k, L) {
            (I.computed ? $ : D)(I, k, L);
          }, { oneOfNodeTypes: ["Expression", "Identifier"] });
        }() }, computed: { default: !1 }, optional: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.chain)((0, y.assertValueType)("boolean"), (0, y.assertOptionalChainStart)()) : (0, y.assertValueType)("boolean") } } }), m("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, y.assertNodeType)("Expression") }, arguments: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Expression", "SpreadElement", "ArgumentPlaceholder"))) }, optional: { validate: Ze.env.BABEL_TYPES_8_BREAKING ? (0, y.chain)((0, y.assertValueType)("boolean"), (0, y.assertOptionalChainStart)()) : (0, y.assertValueType)("boolean") }, typeArguments: { validate: (0, y.assertNodeType)("TypeParameterInstantiation"), optional: !0 }, typeParameters: { validate: (0, y.assertNodeType)("TSTypeParameterInstantiation"), optional: !0 } } }), m("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, E(), { value: { validate: (0, y.assertNodeType)("Expression"), optional: !0 }, definite: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, typeAnnotation: { validate: (0, y.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 }, readonly: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, declare: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, variance: { validate: (0, y.assertNodeType)("Variance"), optional: !0 } }) }), m("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, E(), { key: { validate: (0, y.chain)(function() {
          const D = (0, y.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), $ = (0, y.assertNodeType)("Expression");
          return function(I, k, L) {
            (I.computed ? $ : D)(I, k, L);
          };
        }(), (0, y.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, y.assertNodeType)("Expression"), optional: !0 }, definite: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, typeAnnotation: { validate: (0, y.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 }, readonly: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, declare: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, variance: { validate: (0, y.assertNodeType)("Variance"), optional: !0 } }) }), m("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, y.assertNodeType)("PrivateName") }, value: { validate: (0, y.assertNodeType)("Expression"), optional: !0 }, typeAnnotation: { validate: (0, y.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: !0 }, decorators: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Decorator"))), optional: !0 }, static: { validate: (0, y.assertValueType)("boolean"), default: !1 }, readonly: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, definite: { validate: (0, y.assertValueType)("boolean"), optional: !0 }, variance: { validate: (0, y.assertNodeType)("Variance"), optional: !0 } } }), m("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, O(), b(), { kind: { validate: (0, y.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, y.assertNodeType)("PrivateName") }, body: { validate: (0, y.assertNodeType)("BlockStatement") } }) }), m("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, y.assertNodeType)("Identifier") } } }), m("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, y.chain)((0, y.assertValueType)("array"), (0, y.assertEach)((0, y.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/deprecated-aliases.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.DEPRECATED_ALIASES = void 0, n.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/experimental.js": (h, n, u) => {
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js");
        (0, i.default)("ArgumentPlaceholder", {}), (0, i.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: Ze.env.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, i.assertNodeType)("Expression") }, callee: { validate: (0, i.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, i.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, i.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, i.assertNodeType)("StringLiteral") } } }), (0, i.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } } }), (0, i.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, i.assertNodeType)("BlockStatement") }, async: { validate: (0, i.assertValueType)("boolean"), default: !1 } } }), (0, i.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, i.assertNodeType)("Identifier") } } }), (0, i.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, i.default)("TupleExpression", { fields: { elements: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, i.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, i.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, i.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, i.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, i.default)("TopicReference", { aliases: ["Expression"] }), (0, i.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, i.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, i.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, i.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/flow.js": (h, n, u) => {
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js");
        const c = (0, i.defineAliasedType)("Flow"), f = (s) => {
          const o = s === "DeclareClass";
          c(s, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...o ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), extends: (0, i.validateOptional)((0, i.arrayOfType)("InterfaceExtends")) }, o ? { mixins: (0, i.validateOptional)((0, i.arrayOfType)("InterfaceExtends")), implements: (0, i.validateOptional)((0, i.arrayOfType)("ClassImplements")) } : {}, { body: (0, i.validateType)("ObjectTypeAnnotation") }) });
        };
        c("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, i.validateType)("FlowType") } }), c("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterInstantiation") } }), f("DeclareClass"), c("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), predicate: (0, i.validateOptionalType)("DeclaredPredicate") } }), f("DeclareInterface"), c("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)(["Identifier", "StringLiteral"]), body: (0, i.validateType)("BlockStatement"), kind: (0, i.validateOptional)((0, i.assertOneOf)("CommonJS", "ES")) } }), c("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, i.validateType)("TypeAnnotation") } }), c("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), right: (0, i.validateType)("FlowType") } }), c("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, i.validateOptionalType)("FlowType"), impltype: (0, i.validateOptionalType)("FlowType") } }), c("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier") } }), c("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, i.validateOptionalType)("Flow"), specifiers: (0, i.validateOptional)((0, i.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, i.validateOptionalType)("StringLiteral"), default: (0, i.validateOptional)((0, i.assertValueType)("boolean")) } }), c("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, i.validateType)("StringLiteral"), exportKind: (0, i.validateOptional)((0, i.assertOneOf)("type", "value")) } }), c("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, i.validateType)("Flow") } }), c("ExistsTypeAnnotation", { aliases: ["FlowType"] }), c("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), params: (0, i.validate)((0, i.arrayOfType)("FunctionTypeParam")), rest: (0, i.validateOptionalType)("FunctionTypeParam"), this: (0, i.validateOptionalType)("FunctionTypeParam"), returnType: (0, i.validateType)("FlowType") } }), c("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, i.validateOptionalType)("Identifier"), typeAnnotation: (0, i.validateType)("FlowType"), optional: (0, i.validateOptional)((0, i.assertValueType)("boolean")) } }), c("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, i.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, i.validateOptionalType)("TypeParameterInstantiation") } }), c("InferredPredicate", { aliases: ["FlowPredicate"] }), c("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, i.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, i.validateOptionalType)("TypeParameterInstantiation") } }), f("InterfaceDeclaration"), c("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, i.validateOptional)((0, i.arrayOfType)("InterfaceExtends")), body: (0, i.validateType)("ObjectTypeAnnotation") } }), c("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), c("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, i.validateType)("FlowType") } }), c("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, i.validate)((0, i.assertValueType)("number")) } }), c("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, i.validate)((0, i.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, i.arrayOfType)("ObjectTypeIndexer"), optional: !0, default: [] }, callProperties: { validate: (0, i.arrayOfType)("ObjectTypeCallProperty"), optional: !0, default: [] }, internalSlots: { validate: (0, i.arrayOfType)("ObjectTypeInternalSlot"), optional: !0, default: [] }, exact: { validate: (0, i.assertValueType)("boolean"), default: !1 }, inexact: (0, i.validateOptional)((0, i.assertValueType)("boolean")) } }), c("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, i.validateType)("Identifier"), value: (0, i.validateType)("FlowType"), optional: (0, i.validate)((0, i.assertValueType)("boolean")), static: (0, i.validate)((0, i.assertValueType)("boolean")), method: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, i.validateType)("FlowType"), static: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, i.validateOptionalType)("Identifier"), key: (0, i.validateType)("FlowType"), value: (0, i.validateType)("FlowType"), static: (0, i.validate)((0, i.assertValueType)("boolean")), variance: (0, i.validateOptionalType)("Variance") } }), c("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, i.validateType)(["Identifier", "StringLiteral"]), value: (0, i.validateType)("FlowType"), kind: (0, i.validate)((0, i.assertOneOf)("init", "get", "set")), static: (0, i.validate)((0, i.assertValueType)("boolean")), proto: (0, i.validate)((0, i.assertValueType)("boolean")), optional: (0, i.validate)((0, i.assertValueType)("boolean")), variance: (0, i.validateOptionalType)("Variance"), method: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, i.validateType)("FlowType") } }), c("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, i.validateOptionalType)("FlowType"), impltype: (0, i.validateType)("FlowType") } }), c("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, i.validateType)("Identifier"), qualification: (0, i.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), c("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, i.validate)((0, i.assertValueType)("string")) } }), c("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), c("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, i.validateType)("FlowType") } }), c("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TypeParameterDeclaration"), right: (0, i.validateType)("FlowType") } }), c("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("FlowType") } }), c("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, i.validateType)("Expression"), typeAnnotation: (0, i.validateType)("TypeAnnotation") } }), c("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, i.validate)((0, i.assertValueType)("string")), bound: (0, i.validateOptionalType)("TypeAnnotation"), default: (0, i.validateOptionalType)("FlowType"), variance: (0, i.validateOptionalType)("Variance") } }), c("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, i.validate)((0, i.arrayOfType)("TypeParameter")) } }), c("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), c("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, i.validate)((0, i.arrayOfType)("FlowType")) } }), c("Variance", { builder: ["kind"], fields: { kind: (0, i.validate)((0, i.assertOneOf)("minus", "plus")) } }), c("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, i.validateType)("Identifier"), body: (0, i.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), c("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, i.validate)((0, i.assertValueType)("boolean")), members: (0, i.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, i.validate)((0, i.assertValueType)("boolean")), members: (0, i.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, i.validate)((0, i.assertValueType)("boolean")), members: (0, i.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, i.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, i.validate)((0, i.assertValueType)("boolean")) } }), c("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, i.validateType)("Identifier"), init: (0, i.validateType)("BooleanLiteral") } }), c("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, i.validateType)("Identifier"), init: (0, i.validateType)("NumericLiteral") } }), c("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, i.validateType)("Identifier"), init: (0, i.validateType)("StringLiteral") } }), c("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, i.validateType)("Identifier") } }), c("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, i.validateType)("FlowType"), indexType: (0, i.validateType)("FlowType") } }), c("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, i.validateType)("FlowType"), indexType: (0, i.validateType)("FlowType"), optional: (0, i.validate)((0, i.assertValueType)("boolean")) } });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), Object.defineProperty(n, "ALIAS_KEYS", { enumerable: !0, get: function() {
          return c.ALIAS_KEYS;
        } }), Object.defineProperty(n, "BUILDER_KEYS", { enumerable: !0, get: function() {
          return c.BUILDER_KEYS;
        } }), Object.defineProperty(n, "DEPRECATED_ALIASES", { enumerable: !0, get: function() {
          return s.DEPRECATED_ALIASES;
        } }), Object.defineProperty(n, "DEPRECATED_KEYS", { enumerable: !0, get: function() {
          return c.DEPRECATED_KEYS;
        } }), Object.defineProperty(n, "FLIPPED_ALIAS_KEYS", { enumerable: !0, get: function() {
          return c.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(n, "NODE_FIELDS", { enumerable: !0, get: function() {
          return c.NODE_FIELDS;
        } }), Object.defineProperty(n, "NODE_PARENT_VALIDATIONS", { enumerable: !0, get: function() {
          return c.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(n, "PLACEHOLDERS", { enumerable: !0, get: function() {
          return f.PLACEHOLDERS;
        } }), Object.defineProperty(n, "PLACEHOLDERS_ALIAS", { enumerable: !0, get: function() {
          return f.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(n, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: !0, get: function() {
          return f.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), n.TYPES = void 0, Object.defineProperty(n, "VISITOR_KEYS", { enumerable: !0, get: function() {
          return c.VISITOR_KEYS;
        } });
        var i = u("./node_modules/.pnpm/to-fast-properties@2.0.0/node_modules/to-fast-properties/index.js");
        u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/core.js"), u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/flow.js"), u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/jsx.js"), u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/misc.js"), u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/experimental.js"), u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/typescript.js");
        var c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/placeholders.js"), s = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/deprecated-aliases.js");
        Object.keys(s.DEPRECATED_ALIASES).forEach((o) => {
          c.FLIPPED_ALIAS_KEYS[o] = c.FLIPPED_ALIAS_KEYS[s.DEPRECATED_ALIASES[o]];
        }), i(c.VISITOR_KEYS), i(c.ALIAS_KEYS), i(c.FLIPPED_ALIAS_KEYS), i(c.NODE_FIELDS), i(c.BUILDER_KEYS), i(c.DEPRECATED_KEYS), i(f.PLACEHOLDERS_ALIAS), i(f.PLACEHOLDERS_FLIPPED_ALIAS), n.TYPES = [].concat(Object.keys(c.VISITOR_KEYS), Object.keys(c.FLIPPED_ALIAS_KEYS), Object.keys(c.DEPRECATED_KEYS));
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/jsx.js": (h, n, u) => {
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js");
        const c = (0, i.defineAliasedType)("JSX");
        c("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, i.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: !0, validate: (0, i.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), c("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, i.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), c("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, i.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: !0, validate: (0, i.assertNodeType)("JSXClosingElement") }, children: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, i.assertValueType)("boolean"), optional: !0 } }) }), c("JSXEmptyExpression", {}), c("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, i.assertNodeType)("Expression", "JSXEmptyExpression") } } }), c("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, i.assertNodeType)("Expression") } } }), c("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, i.assertValueType)("string") } } }), c("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, i.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, i.assertNodeType)("JSXIdentifier") } } }), c("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, i.assertNodeType)("JSXIdentifier") }, name: { validate: (0, i.assertNodeType)("JSXIdentifier") } } }), c("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, i.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: !1 }, attributes: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, i.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: !0 } } }), c("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, i.assertNodeType)("Expression") } } }), c("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, i.assertValueType)("string") } } }), c("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, i.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, i.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), c("JSXOpeningFragment", { aliases: ["Immutable"] }), c("JSXClosingFragment", { aliases: ["Immutable"] });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/misc.js": (h, n, u) => {
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/placeholders.js");
        const f = (0, i.defineAliasedType)("Miscellaneous");
        f("Noop", { visitor: [] }), f("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, i.assertNodeType)("Identifier") }, expectedNode: { validate: (0, i.assertOneOf)(...c.PLACEHOLDERS) } } }), f("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, i.assertValueType)("string") } } });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/placeholders.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.PLACEHOLDERS_FLIPPED_ALIAS = n.PLACEHOLDERS_ALIAS = n.PLACEHOLDERS = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js");
        const c = n.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], f = n.PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        for (const o of c) {
          const y = i.ALIAS_KEYS[o];
          y != null && y.length && (f[o] = y);
        }
        const s = n.PLACEHOLDERS_FLIPPED_ALIAS = {};
        Object.keys(f).forEach((o) => {
          f[o].forEach((y) => {
            hasOwnProperty.call(s, y) || (s[y] = []), s[y].push(o);
          });
        });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/typescript.js": (h, n, u) => {
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/core.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/is.js");
        const s = (0, i.defineAliasedType)("TypeScript"), o = (0, i.assertValueType)("boolean"), y = () => ({ returnType: { validate: (0, i.assertNodeType)("TSTypeAnnotation", "Noop"), optional: !0 }, typeParameters: { validate: (0, i.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: !0 } });
        s("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, i.assertOneOf)("public", "private", "protected"), optional: !0 }, readonly: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, parameter: { validate: (0, i.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, decorators: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("Decorator"))), optional: !0 } } }), s("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, c.functionDeclarationCommon)(), y()) }), s("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, c.classMethodOrDeclareMethodCommon)(), y()) }), s("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, i.validateType)("TSEntityName"), right: (0, i.validateType)("Identifier") } });
        const m = () => ({ typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, i.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation") }), g = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: m() };
        s("TSCallSignatureDeclaration", g), s("TSConstructSignatureDeclaration", g);
        const b = () => ({ key: (0, i.validateType)("Expression"), computed: { default: !1 }, optional: (0, i.validateOptional)(o) });
        s("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation"], fields: Object.assign({}, b(), { readonly: (0, i.validateOptional)(o), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation"), kind: { validate: (0, i.assertOneOf)("get", "set") } }) }), s("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, m(), b(), { kind: { validate: (0, i.assertOneOf)("method", "get", "set") } }) }), s("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, i.validateOptional)(o), static: (0, i.validateOptional)(o), parameters: (0, i.validateArrayOfType)("Identifier"), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation") } });
        const v = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const D of v) s(D, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        s("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const T = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        s("TSFunctionType", Object.assign({}, T, { fields: m() })), s("TSConstructorType", Object.assign({}, T, { fields: Object.assign({}, m(), { abstract: (0, i.validateOptional)(o) }) })), s("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, i.validateType)("TSEntityName"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, i.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, i.validateOptionalType)("TSTypeAnnotation"), asserts: (0, i.validateOptional)(o) } }), s("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, i.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, i.validateArrayOfType)("TSTypeElement") } }), s("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, i.validateType)("TSType") } }), s("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, i.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), s("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("TSType") } }), s("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("TSType") } }), s("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, i.validateType)("Identifier"), optional: { validate: o, default: !1 }, elementType: (0, i.validateType)("TSType") } });
        const E = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, i.validateArrayOfType)("TSType") } };
        s("TSUnionType", E), s("TSIntersectionType", E), s("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, i.validateType)("TSType"), extendsType: (0, i.validateType)("TSType"), trueType: (0, i.validateType)("TSType"), falseType: (0, i.validateType)("TSType") } }), s("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, i.validateType)("TSTypeParameter") } }), s("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, i.validateType)("TSType") } }), s("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, i.validate)((0, i.assertValueType)("string")), typeAnnotation: (0, i.validateType)("TSType") } }), s("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, i.validateType)("TSType"), indexType: (0, i.validateType)("TSType") } }), s("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, i.validateOptional)((0, i.assertOneOf)(!0, !1, "+", "-")), typeParameter: (0, i.validateType)("TSTypeParameter"), optional: (0, i.validateOptional)((0, i.assertOneOf)(!0, !1, "+", "-")), typeAnnotation: (0, i.validateOptionalType)("TSType"), nameType: (0, i.validateOptionalType)("TSType") } }), s("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
          const D = (0, i.assertNodeType)("NumericLiteral", "BigIntLiteral"), $ = (0, i.assertOneOf)("-"), I = (0, i.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function k(L, M, x) {
            (0, f.default)("UnaryExpression", x) ? ($(x, "operator", x.operator), D(x, "argument", x.argument)) : I(L, M, x);
          }
          return k.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], k;
        }() } } }), s("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, i.validateType)("TSEntityName"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } }), s("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, i.validateOptional)(o), id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, i.validateOptional)((0, i.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, i.validateType)("TSInterfaceBody") } }), s("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, i.validateArrayOfType)("TSTypeElement") } }), s("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, i.validateOptional)(o), id: (0, i.validateType)("Identifier"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, i.validateType)("TSType") } }), s("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, i.validateType)("Expression"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation") } });
        const O = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, i.validateType)("Expression"), typeAnnotation: (0, i.validateType)("TSType") } };
        s("TSAsExpression", O), s("TSSatisfiesExpression", O), s("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, i.validateType)("TSType"), expression: (0, i.validateType)("Expression") } }), s("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, i.validateOptional)(o), const: (0, i.validateOptional)(o), id: (0, i.validateType)("Identifier"), members: (0, i.validateArrayOfType)("TSEnumMember"), initializer: (0, i.validateOptionalType)("Expression") } }), s("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, i.validateType)(["Identifier", "StringLiteral"]), initializer: (0, i.validateOptionalType)("Expression") } }), s("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, i.validateOptional)(o), global: (0, i.validateOptional)(o), id: (0, i.validateType)(["Identifier", "StringLiteral"]), body: (0, i.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), s("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, i.validateArrayOfType)("Statement") } }), s("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, i.validateType)("StringLiteral"), qualifier: (0, i.validateOptionalType)("TSEntityName"), typeParameters: (0, i.validateOptionalType)("TSTypeParameterInstantiation"), options: { validate: (0, i.assertNodeType)("Expression"), optional: !0 } } }), s("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, i.validate)(o), id: (0, i.validateType)("Identifier"), moduleReference: (0, i.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, i.assertOneOf)("type", "value"), optional: !0 } } }), s("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, i.validateType)("StringLiteral") } }), s("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, i.validateType)("Expression") } }), s("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, i.validateType)("Expression") } }), s("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, i.validateType)("Identifier") } }), s("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, i.assertNodeType)("TSType") } } }), s("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("TSType"))) } } }), s("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, i.chain)((0, i.assertValueType)("array"), (0, i.assertEach)((0, i.assertNodeType)("TSTypeParameter"))) } } }), s("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, i.assertValueType)("string") }, in: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, out: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, const: { validate: (0, i.assertValueType)("boolean"), optional: !0 }, constraint: { validate: (0, i.assertNodeType)("TSType"), optional: !0 }, default: { validate: (0, i.assertNodeType)("TSType"), optional: !0 } } });
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/utils.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.VISITOR_KEYS = n.NODE_PARENT_VALIDATIONS = n.NODE_FIELDS = n.FLIPPED_ALIAS_KEYS = n.DEPRECATED_KEYS = n.BUILDER_KEYS = n.ALIAS_KEYS = void 0, n.arrayOf = O, n.arrayOfType = D, n.assertEach = $, n.assertNodeOrValueType = function(...C) {
          function R(H, z, U) {
            for (const P of C) if (v(U) === P || (0, i.default)(P, U)) return void (0, c.validateChild)(H, z, U);
            throw new TypeError(`Property ${z} of ${H.type} expected node to be of a type ${JSON.stringify(C)} but instead got ${JSON.stringify(U == null ? void 0 : U.type)}`);
          }
          return R.oneOfNodeOrValueTypes = C, R;
        }, n.assertNodeType = I, n.assertOneOf = function(...C) {
          function R(H, z, U) {
            if (C.indexOf(U) < 0) throw new TypeError(`Property ${z} expected value to be one of ${JSON.stringify(C)} but got ${JSON.stringify(U)}`);
          }
          return R.oneOf = C, R;
        }, n.assertOptionalChainStart = function() {
          return function(C) {
            var R;
            let H = C;
            for (; C; ) {
              const { type: z } = H;
              if (z !== "OptionalCallExpression") {
                if (z !== "OptionalMemberExpression") break;
                if (H.optional) return;
                H = H.object;
              } else {
                if (H.optional) return;
                H = H.callee;
              }
            }
            throw new TypeError(`Non-optional ${C.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(R = H) == null ? void 0 : R.type}`);
          };
        }, n.assertShape = function(C) {
          function R(H, z, U) {
            const P = [];
            for (const W of Object.keys(C)) try {
              (0, c.validateField)(H, W, U[W], C[W]);
            } catch (B) {
              if (B instanceof TypeError) {
                P.push(B.message);
                continue;
              }
              throw B;
            }
            if (P.length) throw new TypeError(`Property ${z} of ${H.type} expected to have the following:
${P.join(`
`)}`);
          }
          return R.shapeOf = C, R;
        }, n.assertValueType = k, n.chain = L, n.default = S, n.defineAliasedType = function(...C) {
          return (R, H = {}) => {
            let z = H.aliases;
            var U;
            z || (H.inherits && (z = (U = _[H.inherits].aliases) == null ? void 0 : U.slice()), z != null || (z = []), H.aliases = z);
            const P = C.filter((W) => !z.includes(W));
            z.unshift(...P), S(R, H);
          };
        }, n.typeIs = E, n.validate = T, n.validateArrayOfType = function(C) {
          return T(D(C));
        }, n.validateOptional = function(C) {
          return { validate: C, optional: !0 };
        }, n.validateOptionalType = function(C) {
          return { validate: E(C), optional: !0 };
        }, n.validateType = function(C) {
          return T(E(C));
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/is.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/validate.js");
        const f = n.VISITOR_KEYS = {}, s = n.ALIAS_KEYS = {}, o = n.FLIPPED_ALIAS_KEYS = {}, y = n.NODE_FIELDS = {}, m = n.BUILDER_KEYS = {}, g = n.DEPRECATED_KEYS = {}, b = n.NODE_PARENT_VALIDATIONS = {};
        function v(C) {
          return Array.isArray(C) ? "array" : C === null ? "null" : typeof C;
        }
        function T(C) {
          return { validate: C };
        }
        function E(C) {
          return typeof C == "string" ? I(C) : I(...C);
        }
        function O(C) {
          return L(k("array"), $(C));
        }
        function D(C) {
          return O(E(C));
        }
        function $(C) {
          function R(H, z, U) {
            if (Array.isArray(U)) for (let P = 0; P < U.length; P++) {
              const W = `${z}[${P}]`, B = U[P];
              C(H, W, B), Ze.env.BABEL_TYPES_8_BREAKING && (0, c.validateChild)(H, W, B);
            }
          }
          return R.each = C, R;
        }
        function I(...C) {
          function R(H, z, U) {
            for (const P of C) if ((0, i.default)(P, U)) return void (0, c.validateChild)(H, z, U);
            throw new TypeError(`Property ${z} of ${H.type} expected node to be of a type ${JSON.stringify(C)} but instead got ${JSON.stringify(U == null ? void 0 : U.type)}`);
          }
          return R.oneOfNodeTypes = C, R;
        }
        function k(C) {
          function R(H, z, U) {
            if (v(U) !== C) throw new TypeError(`Property ${z} expected type of ${C} but got ${v(U)}`);
          }
          return R.type = C, R;
        }
        function L(...C) {
          function R(...H) {
            for (const z of C) z(...H);
          }
          if (R.chainOf = C, C.length >= 2 && "type" in C[0] && C[0].type === "array" && !("each" in C[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return R;
        }
        const M = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], x = ["default", "optional", "deprecated", "validate"], _ = {};
        function S(C, R = {}) {
          const H = R.inherits && _[R.inherits] || {};
          let z = R.fields;
          if (!z && (z = {}, H.fields)) {
            const B = Object.getOwnPropertyNames(H.fields);
            for (const Q of B) {
              const J = H.fields[Q], re = J.default;
              if (Array.isArray(re) ? re.length > 0 : re && typeof re == "object") throw new Error("field defaults can only be primitives or empty arrays currently");
              z[Q] = { default: Array.isArray(re) ? [] : re, optional: J.optional, deprecated: J.deprecated, validate: J.validate };
            }
          }
          const U = R.visitor || H.visitor || [], P = R.aliases || H.aliases || [], W = R.builder || H.builder || R.visitor || [];
          for (const B of Object.keys(R)) if (M.indexOf(B) === -1) throw new Error(`Unknown type option "${B}" on ${C}`);
          R.deprecatedAlias && (g[R.deprecatedAlias] = C);
          for (const B of U.concat(W)) z[B] = z[B] || {};
          for (const B of Object.keys(z)) {
            const Q = z[B];
            Q.default !== void 0 && W.indexOf(B) === -1 && (Q.optional = !0), Q.default === void 0 ? Q.default = null : Q.validate || Q.default == null || (Q.validate = k(v(Q.default)));
            for (const J of Object.keys(Q)) if (x.indexOf(J) === -1) throw new Error(`Unknown field key "${J}" on ${C}.${B}`);
          }
          f[C] = R.visitor = U, m[C] = R.builder = W, y[C] = R.fields = z, s[C] = R.aliases = P, P.forEach((B) => {
            o[B] = o[B] || [], o[B].push(C);
          }), R.validate && (b[C] = R.validate), _[C] = R;
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 });
        var i = { react: !0, assertNode: !0, createTypeAnnotationBasedOnTypeof: !0, createUnionTypeAnnotation: !0, createFlowUnionType: !0, createTSUnionType: !0, cloneNode: !0, clone: !0, cloneDeep: !0, cloneDeepWithoutLoc: !0, cloneWithoutLoc: !0, addComment: !0, addComments: !0, inheritInnerComments: !0, inheritLeadingComments: !0, inheritsComments: !0, inheritTrailingComments: !0, removeComments: !0, ensureBlock: !0, toBindingIdentifierName: !0, toBlock: !0, toComputedKey: !0, toExpression: !0, toIdentifier: !0, toKeyAlias: !0, toStatement: !0, valueToNode: !0, appendToMemberExpression: !0, inherits: !0, prependToMemberExpression: !0, removeProperties: !0, removePropertiesDeep: !0, removeTypeDuplicates: !0, getBindingIdentifiers: !0, getOuterBindingIdentifiers: !0, traverse: !0, traverseFast: !0, shallowEqual: !0, is: !0, isBinding: !0, isBlockScoped: !0, isImmutable: !0, isLet: !0, isNode: !0, isNodesEquivalent: !0, isPlaceholderType: !0, isReferenced: !0, isScope: !0, isSpecifierDefault: !0, isType: !0, isValidES3Identifier: !0, isValidIdentifier: !0, isVar: !0, matchesPattern: !0, validate: !0, buildMatchMemberExpression: !0, __internal__deprecationWarning: !0 };
        Object.defineProperty(n, "__internal__deprecationWarning", { enumerable: !0, get: function() {
          return Ye.default;
        } }), Object.defineProperty(n, "addComment", { enumerable: !0, get: function() {
          return L.default;
        } }), Object.defineProperty(n, "addComments", { enumerable: !0, get: function() {
          return M.default;
        } }), Object.defineProperty(n, "appendToMemberExpression", { enumerable: !0, get: function() {
          return F.default;
        } }), Object.defineProperty(n, "assertNode", { enumerable: !0, get: function() {
          return o.default;
        } }), Object.defineProperty(n, "buildMatchMemberExpression", { enumerable: !0, get: function() {
          return Ve.default;
        } }), Object.defineProperty(n, "clone", { enumerable: !0, get: function() {
          return D.default;
        } }), Object.defineProperty(n, "cloneDeep", { enumerable: !0, get: function() {
          return $.default;
        } }), Object.defineProperty(n, "cloneDeepWithoutLoc", { enumerable: !0, get: function() {
          return I.default;
        } }), Object.defineProperty(n, "cloneNode", { enumerable: !0, get: function() {
          return O.default;
        } }), Object.defineProperty(n, "cloneWithoutLoc", { enumerable: !0, get: function() {
          return k.default;
        } }), Object.defineProperty(n, "createFlowUnionType", { enumerable: !0, get: function() {
          return g.default;
        } }), Object.defineProperty(n, "createTSUnionType", { enumerable: !0, get: function() {
          return b.default;
        } }), Object.defineProperty(n, "createTypeAnnotationBasedOnTypeof", { enumerable: !0, get: function() {
          return m.default;
        } }), Object.defineProperty(n, "createUnionTypeAnnotation", { enumerable: !0, get: function() {
          return g.default;
        } }), Object.defineProperty(n, "ensureBlock", { enumerable: !0, get: function() {
          return U.default;
        } }), Object.defineProperty(n, "getBindingIdentifiers", { enumerable: !0, get: function() {
          return Ae.default;
        } }), Object.defineProperty(n, "getOuterBindingIdentifiers", { enumerable: !0, get: function() {
          return ce.default;
        } }), Object.defineProperty(n, "inheritInnerComments", { enumerable: !0, get: function() {
          return x.default;
        } }), Object.defineProperty(n, "inheritLeadingComments", { enumerable: !0, get: function() {
          return _.default;
        } }), Object.defineProperty(n, "inheritTrailingComments", { enumerable: !0, get: function() {
          return C.default;
        } }), Object.defineProperty(n, "inherits", { enumerable: !0, get: function() {
          return X.default;
        } }), Object.defineProperty(n, "inheritsComments", { enumerable: !0, get: function() {
          return S.default;
        } }), Object.defineProperty(n, "is", { enumerable: !0, get: function() {
          return me.default;
        } }), Object.defineProperty(n, "isBinding", { enumerable: !0, get: function() {
          return ye.default;
        } }), Object.defineProperty(n, "isBlockScoped", { enumerable: !0, get: function() {
          return we.default;
        } }), Object.defineProperty(n, "isImmutable", { enumerable: !0, get: function() {
          return ge.default;
        } }), Object.defineProperty(n, "isLet", { enumerable: !0, get: function() {
          return se.default;
        } }), Object.defineProperty(n, "isNode", { enumerable: !0, get: function() {
          return be.default;
        } }), Object.defineProperty(n, "isNodesEquivalent", { enumerable: !0, get: function() {
          return Ie.default;
        } }), Object.defineProperty(n, "isPlaceholderType", { enumerable: !0, get: function() {
          return Oe.default;
        } }), Object.defineProperty(n, "isReferenced", { enumerable: !0, get: function() {
          return Be.default;
        } }), Object.defineProperty(n, "isScope", { enumerable: !0, get: function() {
          return Fe.default;
        } }), Object.defineProperty(n, "isSpecifierDefault", { enumerable: !0, get: function() {
          return ue.default;
        } }), Object.defineProperty(n, "isType", { enumerable: !0, get: function() {
          return te.default;
        } }), Object.defineProperty(n, "isValidES3Identifier", { enumerable: !0, get: function() {
          return Y.default;
        } }), Object.defineProperty(n, "isValidIdentifier", { enumerable: !0, get: function() {
          return le.default;
        } }), Object.defineProperty(n, "isVar", { enumerable: !0, get: function() {
          return Ee.default;
        } }), Object.defineProperty(n, "matchesPattern", { enumerable: !0, get: function() {
          return Se.default;
        } }), Object.defineProperty(n, "prependToMemberExpression", { enumerable: !0, get: function() {
          return K.default;
        } }), n.react = void 0, Object.defineProperty(n, "removeComments", { enumerable: !0, get: function() {
          return R.default;
        } }), Object.defineProperty(n, "removeProperties", { enumerable: !0, get: function() {
          return ie.default;
        } }), Object.defineProperty(n, "removePropertiesDeep", { enumerable: !0, get: function() {
          return fe.default;
        } }), Object.defineProperty(n, "removeTypeDuplicates", { enumerable: !0, get: function() {
          return _e.default;
        } }), Object.defineProperty(n, "shallowEqual", { enumerable: !0, get: function() {
          return oe.default;
        } }), Object.defineProperty(n, "toBindingIdentifierName", { enumerable: !0, get: function() {
          return P.default;
        } }), Object.defineProperty(n, "toBlock", { enumerable: !0, get: function() {
          return W.default;
        } }), Object.defineProperty(n, "toComputedKey", { enumerable: !0, get: function() {
          return B.default;
        } }), Object.defineProperty(n, "toExpression", { enumerable: !0, get: function() {
          return Q.default;
        } }), Object.defineProperty(n, "toIdentifier", { enumerable: !0, get: function() {
          return J.default;
        } }), Object.defineProperty(n, "toKeyAlias", { enumerable: !0, get: function() {
          return re.default;
        } }), Object.defineProperty(n, "toStatement", { enumerable: !0, get: function() {
          return G.default;
        } }), Object.defineProperty(n, "traverse", { enumerable: !0, get: function() {
          return ee.default;
        } }), Object.defineProperty(n, "traverseFast", { enumerable: !0, get: function() {
          return ae.default;
        } }), Object.defineProperty(n, "validate", { enumerable: !0, get: function() {
          return Pe.default;
        } }), Object.defineProperty(n, "valueToNode", { enumerable: !0, get: function() {
          return N.default;
        } });
        var c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/react/isReactComponent.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/react/isCompatTag.js"), s = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/react/buildChildren.js"), o = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/asserts/assertNode.js"), y = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/asserts/generated/index.js");
        Object.keys(y).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === y[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return y[We];
          } }));
        });
        var m = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"), g = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"), b = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"), v = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
        Object.keys(v).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === v[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return v[We];
          } }));
        });
        var T = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/uppercase.js");
        Object.keys(T).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === T[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return T[We];
          } }));
        });
        var E = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/productions.js");
        Object.keys(E).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === E[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return E[We];
          } }));
        });
        var O = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneNode.js"), D = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/clone.js"), $ = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneDeep.js"), I = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"), k = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"), L = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/addComment.js"), M = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/addComments.js"), x = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritInnerComments.js"), _ = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), S = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritsComments.js"), C = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), R = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/removeComments.js"), H = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/generated/index.js");
        Object.keys(H).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === H[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return H[We];
          } }));
        });
        var z = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js");
        Object.keys(z).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === z[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return z[We];
          } }));
        });
        var U = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/ensureBlock.js"), P = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"), W = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toBlock.js"), B = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toComputedKey.js"), Q = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toExpression.js"), J = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toIdentifier.js"), re = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toKeyAlias.js"), G = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toStatement.js"), N = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/valueToNode.js"), V = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
        Object.keys(V).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === V[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return V[We];
          } }));
        });
        var F = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"), X = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/inherits.js"), K = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"), ie = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/removeProperties.js"), fe = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"), _e = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"), Ae = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), ce = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"), ee = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/traverse/traverse.js");
        Object.keys(ee).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === ee[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return ee[We];
          } }));
        });
        var ae = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/traverse/traverseFast.js"), oe = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/shallowEqual.js"), me = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/is.js"), ye = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isBinding.js"), we = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isBlockScoped.js"), ge = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isImmutable.js"), se = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isLet.js"), be = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isNode.js"), Ie = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"), Oe = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), Be = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isReferenced.js"), Fe = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isScope.js"), ue = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"), te = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isType.js"), Y = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"), le = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), Ee = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isVar.js"), Se = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/matchesPattern.js"), Pe = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/validate.js"), Ve = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"), Xe = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
        Object.keys(Xe).forEach(function(We) {
          We !== "default" && We !== "__esModule" && (Object.prototype.hasOwnProperty.call(i, We) || We in n && n[We] === Xe[We] || Object.defineProperty(n, We, { enumerable: !0, get: function() {
            return Xe[We];
          } }));
        });
        var Ye = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        n.react = { isReactComponent: c.default, isCompatTag: f.default, buildChildren: s.default }, n.toSequenceExpression = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/converters/toSequenceExpression.js").default;
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f, s = !1) {
          return c.object = (0, i.memberExpression)(c.object, c.property, c.computed), c.property = f, c.computed = !!s, c;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function f(s) {
          const o = Array.from(s), y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set(), b = [];
          for (let v = 0; v < o.length; v++) {
            const T = o[v];
            if (T && !(b.indexOf(T) >= 0)) {
              if ((0, i.isAnyTypeAnnotation)(T)) return [T];
              if ((0, i.isFlowBaseAnnotation)(T)) m.set(T.type, T);
              else if ((0, i.isUnionTypeAnnotation)(T)) g.has(T.types) || (o.push(...T.types), g.add(T.types));
              else if ((0, i.isGenericTypeAnnotation)(T)) {
                const E = c(T.id);
                if (y.has(E)) {
                  let O = y.get(E);
                  O.typeParameters ? T.typeParameters && (O.typeParameters.params.push(...T.typeParameters.params), O.typeParameters.params = f(O.typeParameters.params)) : O = T.typeParameters;
                } else y.set(E, T);
              } else b.push(T);
            }
          }
          for (const [, v] of m) b.push(v);
          for (const [, v] of y) b.push(v);
          return b;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
        function c(f) {
          return (0, i.isIdentifier)(f) ? f.name : `${f.id.name}.${c(f.qualification)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/inherits.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s) {
          if (!f || !s) return f;
          for (const o of i.INHERIT_KEYS.optional) f[o] == null && (f[o] = s[o]);
          for (const o of Object.keys(s)) o[0] === "_" && o !== "__clone" && (f[o] = s[o]);
          for (const o of i.INHERIT_KEYS.force) f[o] = s[o];
          return (0, c.default)(f, s), f;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/comments/inheritsComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s) {
          if ((0, c.isSuper)(f.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
          return f.object = (0, i.memberExpression)(s, f.object), f;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/removeProperties.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o = {}) {
          const y = o.preserveComments ? c : f;
          for (const g of y) s[g] != null && (s[g] = void 0);
          for (const g of Object.keys(s)) g[0] === "_" && s[g] != null && (s[g] = void 0);
          const m = Object.getOwnPropertySymbols(s);
          for (const g of m) s[g] = null;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js");
        const c = ["tokens", "start", "end", "loc", "raw", "rawValue"], f = [...i.COMMENT_KEYS, "comments", ...c];
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s) {
          return (0, i.default)(f, c.default, s), f;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/traverse/traverseFast.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/removeProperties.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function f(s) {
          const o = Array.from(s), y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Set(), b = [];
          for (let v = 0; v < o.length; v++) {
            const T = o[v];
            if (T && !(b.indexOf(T) >= 0)) {
              if ((0, i.isTSAnyKeyword)(T)) return [T];
              if ((0, i.isTSBaseType)(T)) m.set(T.type, T);
              else if ((0, i.isTSUnionType)(T)) g.has(T.types) || (o.push(...T.types), g.add(T.types));
              else if ((0, i.isTSTypeReference)(T) && T.typeParameters) {
                const E = c(T.typeName);
                if (y.has(E)) {
                  let O = y.get(E);
                  O.typeParameters ? T.typeParameters && (O.typeParameters.params.push(...T.typeParameters.params), O.typeParameters.params = f(O.typeParameters.params)) : O = T.typeParameters;
                } else y.set(E, T);
              } else b.push(T);
            }
          }
          for (const [, v] of m) b.push(v);
          for (const [, v] of y) b.push(v);
          return b;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
        function c(f) {
          return (0, i.isIdentifier)(f) ? f.name : `${f.right.name}.${c(f.left)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = c;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
        function c(f, s, o, y) {
          const m = [].concat(f), g = /* @__PURE__ */ Object.create(null);
          for (; m.length; ) {
            const b = m.shift();
            if (!b || y && ((0, i.isAssignmentExpression)(b) || (0, i.isUnaryExpression)(b) || (0, i.isUpdateExpression)(b))) continue;
            if ((0, i.isIdentifier)(b)) {
              s ? (g[b.name] = g[b.name] || []).push(b) : g[b.name] = b;
              continue;
            }
            if ((0, i.isExportDeclaration)(b) && !(0, i.isExportAllDeclaration)(b)) {
              (0, i.isDeclaration)(b.declaration) && m.push(b.declaration);
              continue;
            }
            if (o) {
              if ((0, i.isFunctionDeclaration)(b)) {
                m.push(b.id);
                continue;
              }
              if ((0, i.isFunctionExpression)(b)) continue;
            }
            const v = c.keys[b.type];
            if (v) for (let T = 0; T < v.length; T++) {
              const E = b[v[T]];
              E && (Array.isArray(E) ? m.push(...E) : m.push(E));
            }
          }
          return g;
        }
        c.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
        n.default = function(c, f) {
          return (0, i.default)(c, f, !0);
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/traverse/traverse.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s, o) {
          typeof s == "function" && (s = { enter: s });
          const { enter: y, exit: m } = s;
          c(f, y, m, o, []);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
        function c(f, s, o, y, m) {
          const g = i.VISITOR_KEYS[f.type];
          if (g) {
            s && s(f, m, y);
            for (const b of g) {
              const v = f[b];
              if (Array.isArray(v)) for (let T = 0; T < v.length; T++) {
                const E = v[T];
                E && (m.push({ node: f, key: b, index: T }), c(E, s, o, y, m), m.pop());
              }
              else v && (m.push({ node: f, key: b }), c(v, s, o, y, m), m.pop());
            }
            o && o(f, m, y);
          }
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/traverse/traverseFast.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function c(f, s, o) {
          if (!f) return;
          const y = i.VISITOR_KEYS[f.type];
          if (y) {
            s(f, o = o || {});
            for (const m of y) {
              const g = f[m];
              if (Array.isArray(g)) for (const b of g) c(b, s, o);
              else c(g, s, o);
            }
          }
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/deprecationWarning.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(i, c, f = "") {
          if (u.has(i)) return;
          u.add(i);
          const { internal: s, trace: o } = function(y, m) {
            const { stackTraceLimit: g, prepareStackTrace: b } = Error;
            let v;
            if (Error.stackTraceLimit = 1 + y + m, Error.prepareStackTrace = function(E, O) {
              v = O;
            }, new Error().stack, Error.stackTraceLimit = g, Error.prepareStackTrace = b, !v) return { internal: !1, trace: "" };
            const T = v.slice(1 + y, 1 + y + m);
            return { internal: /[\\/]@babel[\\/]/.test(T[1].getFileName()), trace: T.map((E) => `    at ${E}`).join(`
`) };
          }(1, 2);
          s || console.warn(`${f}\`${i}\` has been deprecated, please migrate to \`${c}\`
${o}`);
        };
        const u = /* @__PURE__ */ new Set();
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/inherit.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(u, i, c) {
          i && c && (i[u] = Array.from(new Set([].concat(i[u], c[u]).filter(Boolean))));
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f, s) {
          const o = f.value.split(/\r\n|\n|\r/);
          let y = 0;
          for (let g = 0; g < o.length; g++) o[g].match(/[^ \t]/) && (y = g);
          let m = "";
          for (let g = 0; g < o.length; g++) {
            const b = o[g], v = g === 0, T = g === o.length - 1, E = g === y;
            let O = b.replace(/\t/g, " ");
            v || (O = O.replace(/^[ ]+/, "")), T || (O = O.replace(/[ ]+$/, "")), O && (E || (O += " "), m += O);
          }
          m && s.push((0, c.inherits)((0, i.stringLiteral)(m), f));
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/builders/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/shallowEqual.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(u, i) {
          const c = Object.keys(i);
          for (const f of c) if (u[f] !== i[f]) return !1;
          return !0;
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          const s = c.split(".");
          return (o) => (0, i.default)(o, s, f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/matchesPattern.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.isAccessor = function(s, o) {
          return !s || s.type !== "ClassAccessorProperty" ? !1 : o == null || (0, i.default)(s, o);
        }, n.isAnyTypeAnnotation = function(s, o) {
          return !!s && s.type === "AnyTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isArgumentPlaceholder = function(s, o) {
          return !!s && s.type === "ArgumentPlaceholder" && (o == null || (0, i.default)(s, o));
        }, n.isArrayExpression = function(s, o) {
          return !!s && s.type === "ArrayExpression" && (o == null || (0, i.default)(s, o));
        }, n.isArrayPattern = function(s, o) {
          return !!s && s.type === "ArrayPattern" && (o == null || (0, i.default)(s, o));
        }, n.isArrayTypeAnnotation = function(s, o) {
          return !!s && s.type === "ArrayTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isArrowFunctionExpression = function(s, o) {
          return !!s && s.type === "ArrowFunctionExpression" && (o == null || (0, i.default)(s, o));
        }, n.isAssignmentExpression = function(s, o) {
          return !!s && s.type === "AssignmentExpression" && (o == null || (0, i.default)(s, o));
        }, n.isAssignmentPattern = function(s, o) {
          return !!s && s.type === "AssignmentPattern" && (o == null || (0, i.default)(s, o));
        }, n.isAwaitExpression = function(s, o) {
          return !!s && s.type === "AwaitExpression" && (o == null || (0, i.default)(s, o));
        }, n.isBigIntLiteral = function(s, o) {
          return !!s && s.type === "BigIntLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isBinary = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BinaryExpression":
            case "LogicalExpression":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isBinaryExpression = function(s, o) {
          return !!s && s.type === "BinaryExpression" && (o == null || (0, i.default)(s, o));
        }, n.isBindExpression = function(s, o) {
          return !!s && s.type === "BindExpression" && (o == null || (0, i.default)(s, o));
        }, n.isBlock = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BlockStatement":
            case "Program":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (s.expectedNode === "BlockStatement") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isBlockParent = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (s.expectedNode === "BlockStatement") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isBlockStatement = function(s, o) {
          return !!s && s.type === "BlockStatement" && (o == null || (0, i.default)(s, o));
        }, n.isBooleanLiteral = function(s, o) {
          return !!s && s.type === "BooleanLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isBooleanLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "BooleanLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isBooleanTypeAnnotation = function(s, o) {
          return !!s && s.type === "BooleanTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isBreakStatement = function(s, o) {
          return !!s && s.type === "BreakStatement" && (o == null || (0, i.default)(s, o));
        }, n.isCallExpression = function(s, o) {
          return !!s && s.type === "CallExpression" && (o == null || (0, i.default)(s, o));
        }, n.isCatchClause = function(s, o) {
          return !!s && s.type === "CatchClause" && (o == null || (0, i.default)(s, o));
        }, n.isClass = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ClassExpression":
            case "ClassDeclaration":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isClassAccessorProperty = function(s, o) {
          return !!s && s.type === "ClassAccessorProperty" && (o == null || (0, i.default)(s, o));
        }, n.isClassBody = function(s, o) {
          return !!s && s.type === "ClassBody" && (o == null || (0, i.default)(s, o));
        }, n.isClassDeclaration = function(s, o) {
          return !!s && s.type === "ClassDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isClassExpression = function(s, o) {
          return !!s && s.type === "ClassExpression" && (o == null || (0, i.default)(s, o));
        }, n.isClassImplements = function(s, o) {
          return !!s && s.type === "ClassImplements" && (o == null || (0, i.default)(s, o));
        }, n.isClassMethod = function(s, o) {
          return !!s && s.type === "ClassMethod" && (o == null || (0, i.default)(s, o));
        }, n.isClassPrivateMethod = function(s, o) {
          return !!s && s.type === "ClassPrivateMethod" && (o == null || (0, i.default)(s, o));
        }, n.isClassPrivateProperty = function(s, o) {
          return !!s && s.type === "ClassPrivateProperty" && (o == null || (0, i.default)(s, o));
        }, n.isClassProperty = function(s, o) {
          return !!s && s.type === "ClassProperty" && (o == null || (0, i.default)(s, o));
        }, n.isCompletionStatement = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isConditional = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ConditionalExpression":
            case "IfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isConditionalExpression = function(s, o) {
          return !!s && s.type === "ConditionalExpression" && (o == null || (0, i.default)(s, o));
        }, n.isContinueStatement = function(s, o) {
          return !!s && s.type === "ContinueStatement" && (o == null || (0, i.default)(s, o));
        }, n.isDebuggerStatement = function(s, o) {
          return !!s && s.type === "DebuggerStatement" && (o == null || (0, i.default)(s, o));
        }, n.isDecimalLiteral = function(s, o) {
          return !!s && s.type === "DecimalLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isDeclaration = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "VariableDeclaration":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
              break;
            case "Placeholder":
              if (s.expectedNode === "Declaration") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isDeclareClass = function(s, o) {
          return !!s && s.type === "DeclareClass" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareExportAllDeclaration = function(s, o) {
          return !!s && s.type === "DeclareExportAllDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareExportDeclaration = function(s, o) {
          return !!s && s.type === "DeclareExportDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareFunction = function(s, o) {
          return !!s && s.type === "DeclareFunction" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareInterface = function(s, o) {
          return !!s && s.type === "DeclareInterface" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareModule = function(s, o) {
          return !!s && s.type === "DeclareModule" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareModuleExports = function(s, o) {
          return !!s && s.type === "DeclareModuleExports" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareOpaqueType = function(s, o) {
          return !!s && s.type === "DeclareOpaqueType" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareTypeAlias = function(s, o) {
          return !!s && s.type === "DeclareTypeAlias" && (o == null || (0, i.default)(s, o));
        }, n.isDeclareVariable = function(s, o) {
          return !!s && s.type === "DeclareVariable" && (o == null || (0, i.default)(s, o));
        }, n.isDeclaredPredicate = function(s, o) {
          return !!s && s.type === "DeclaredPredicate" && (o == null || (0, i.default)(s, o));
        }, n.isDecorator = function(s, o) {
          return !!s && s.type === "Decorator" && (o == null || (0, i.default)(s, o));
        }, n.isDirective = function(s, o) {
          return !!s && s.type === "Directive" && (o == null || (0, i.default)(s, o));
        }, n.isDirectiveLiteral = function(s, o) {
          return !!s && s.type === "DirectiveLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isDoExpression = function(s, o) {
          return !!s && s.type === "DoExpression" && (o == null || (0, i.default)(s, o));
        }, n.isDoWhileStatement = function(s, o) {
          return !!s && s.type === "DoWhileStatement" && (o == null || (0, i.default)(s, o));
        }, n.isEmptyStatement = function(s, o) {
          return !!s && s.type === "EmptyStatement" && (o == null || (0, i.default)(s, o));
        }, n.isEmptyTypeAnnotation = function(s, o) {
          return !!s && s.type === "EmptyTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isEnumBody = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isEnumBooleanBody = function(s, o) {
          return !!s && s.type === "EnumBooleanBody" && (o == null || (0, i.default)(s, o));
        }, n.isEnumBooleanMember = function(s, o) {
          return !!s && s.type === "EnumBooleanMember" && (o == null || (0, i.default)(s, o));
        }, n.isEnumDeclaration = function(s, o) {
          return !!s && s.type === "EnumDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isEnumDefaultedMember = function(s, o) {
          return !!s && s.type === "EnumDefaultedMember" && (o == null || (0, i.default)(s, o));
        }, n.isEnumMember = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isEnumNumberBody = function(s, o) {
          return !!s && s.type === "EnumNumberBody" && (o == null || (0, i.default)(s, o));
        }, n.isEnumNumberMember = function(s, o) {
          return !!s && s.type === "EnumNumberMember" && (o == null || (0, i.default)(s, o));
        }, n.isEnumStringBody = function(s, o) {
          return !!s && s.type === "EnumStringBody" && (o == null || (0, i.default)(s, o));
        }, n.isEnumStringMember = function(s, o) {
          return !!s && s.type === "EnumStringMember" && (o == null || (0, i.default)(s, o));
        }, n.isEnumSymbolBody = function(s, o) {
          return !!s && s.type === "EnumSymbolBody" && (o == null || (0, i.default)(s, o));
        }, n.isExistsTypeAnnotation = function(s, o) {
          return !!s && s.type === "ExistsTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isExportAllDeclaration = function(s, o) {
          return !!s && s.type === "ExportAllDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isExportDeclaration = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isExportDefaultDeclaration = function(s, o) {
          return !!s && s.type === "ExportDefaultDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isExportDefaultSpecifier = function(s, o) {
          return !!s && s.type === "ExportDefaultSpecifier" && (o == null || (0, i.default)(s, o));
        }, n.isExportNamedDeclaration = function(s, o) {
          return !!s && s.type === "ExportNamedDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isExportNamespaceSpecifier = function(s, o) {
          return !!s && s.type === "ExportNamespaceSpecifier" && (o == null || (0, i.default)(s, o));
        }, n.isExportSpecifier = function(s, o) {
          return !!s && s.type === "ExportSpecifier" && (o == null || (0, i.default)(s, o));
        }, n.isExpression = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "CallExpression":
            case "ConditionalExpression":
            case "FunctionExpression":
            case "Identifier":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ObjectExpression":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "ThisExpression":
            case "UnaryExpression":
            case "UpdateExpression":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ImportExpression":
            case "MetaProperty":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "TypeCastExpression":
            case "JSXElement":
            case "JSXFragment":
            case "BindExpression":
            case "DoExpression":
            case "RecordExpression":
            case "TupleExpression":
            case "DecimalLiteral":
            case "ModuleExpression":
            case "TopicReference":
            case "PipelineTopicExpression":
            case "PipelineBareFunction":
            case "PipelinePrimaryTopicReference":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isExpressionStatement = function(s, o) {
          return !!s && s.type === "ExpressionStatement" && (o == null || (0, i.default)(s, o));
        }, n.isExpressionWrapper = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ExpressionStatement":
            case "ParenthesizedExpression":
            case "TypeCastExpression":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFile = function(s, o) {
          return !!s && s.type === "File" && (o == null || (0, i.default)(s, o));
        }, n.isFlow = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ClassImplements":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "DeclaredPredicate":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "FunctionTypeParam":
            case "GenericTypeAnnotation":
            case "InferredPredicate":
            case "InterfaceExtends":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
            case "OpaqueType":
            case "QualifiedTypeIdentifier":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "TypeAlias":
            case "TypeAnnotation":
            case "TypeCastExpression":
            case "TypeParameter":
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation":
            case "UnionTypeAnnotation":
            case "Variance":
            case "VoidTypeAnnotation":
            case "EnumDeclaration":
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFlowBaseAnnotation = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "AnyTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NumberTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "VoidTypeAnnotation":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFlowDeclaration = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFlowPredicate = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "DeclaredPredicate":
            case "InferredPredicate":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFlowType = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "UnionTypeAnnotation":
            case "VoidTypeAnnotation":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFor = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ForInStatement":
            case "ForStatement":
            case "ForOfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isForInStatement = function(s, o) {
          return !!s && s.type === "ForInStatement" && (o == null || (0, i.default)(s, o));
        }, n.isForOfStatement = function(s, o) {
          return !!s && s.type === "ForOfStatement" && (o == null || (0, i.default)(s, o));
        }, n.isForStatement = function(s, o) {
          return !!s && s.type === "ForStatement" && (o == null || (0, i.default)(s, o));
        }, n.isForXStatement = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ForInStatement":
            case "ForOfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFunction = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFunctionDeclaration = function(s, o) {
          return !!s && s.type === "FunctionDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isFunctionExpression = function(s, o) {
          return !!s && s.type === "FunctionExpression" && (o == null || (0, i.default)(s, o));
        }, n.isFunctionParent = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isFunctionTypeAnnotation = function(s, o) {
          return !!s && s.type === "FunctionTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isFunctionTypeParam = function(s, o) {
          return !!s && s.type === "FunctionTypeParam" && (o == null || (0, i.default)(s, o));
        }, n.isGenericTypeAnnotation = function(s, o) {
          return !!s && s.type === "GenericTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isIdentifier = function(s, o) {
          return !!s && s.type === "Identifier" && (o == null || (0, i.default)(s, o));
        }, n.isIfStatement = function(s, o) {
          return !!s && s.type === "IfStatement" && (o == null || (0, i.default)(s, o));
        }, n.isImmutable = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "BigIntLiteral":
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXOpeningElement":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (s.expectedNode === "StringLiteral") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isImport = function(s, o) {
          return !!s && s.type === "Import" && (o == null || (0, i.default)(s, o));
        }, n.isImportAttribute = function(s, o) {
          return !!s && s.type === "ImportAttribute" && (o == null || (0, i.default)(s, o));
        }, n.isImportDeclaration = function(s, o) {
          return !!s && s.type === "ImportDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isImportDefaultSpecifier = function(s, o) {
          return !!s && s.type === "ImportDefaultSpecifier" && (o == null || (0, i.default)(s, o));
        }, n.isImportExpression = function(s, o) {
          return !!s && s.type === "ImportExpression" && (o == null || (0, i.default)(s, o));
        }, n.isImportNamespaceSpecifier = function(s, o) {
          return !!s && s.type === "ImportNamespaceSpecifier" && (o == null || (0, i.default)(s, o));
        }, n.isImportOrExportDeclaration = f, n.isImportSpecifier = function(s, o) {
          return !!s && s.type === "ImportSpecifier" && (o == null || (0, i.default)(s, o));
        }, n.isIndexedAccessType = function(s, o) {
          return !!s && s.type === "IndexedAccessType" && (o == null || (0, i.default)(s, o));
        }, n.isInferredPredicate = function(s, o) {
          return !!s && s.type === "InferredPredicate" && (o == null || (0, i.default)(s, o));
        }, n.isInterfaceDeclaration = function(s, o) {
          return !!s && s.type === "InterfaceDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isInterfaceExtends = function(s, o) {
          return !!s && s.type === "InterfaceExtends" && (o == null || (0, i.default)(s, o));
        }, n.isInterfaceTypeAnnotation = function(s, o) {
          return !!s && s.type === "InterfaceTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isInterpreterDirective = function(s, o) {
          return !!s && s.type === "InterpreterDirective" && (o == null || (0, i.default)(s, o));
        }, n.isIntersectionTypeAnnotation = function(s, o) {
          return !!s && s.type === "IntersectionTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isJSX = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXEmptyExpression":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXIdentifier":
            case "JSXMemberExpression":
            case "JSXNamespacedName":
            case "JSXOpeningElement":
            case "JSXSpreadAttribute":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isJSXAttribute = function(s, o) {
          return !!s && s.type === "JSXAttribute" && (o == null || (0, i.default)(s, o));
        }, n.isJSXClosingElement = function(s, o) {
          return !!s && s.type === "JSXClosingElement" && (o == null || (0, i.default)(s, o));
        }, n.isJSXClosingFragment = function(s, o) {
          return !!s && s.type === "JSXClosingFragment" && (o == null || (0, i.default)(s, o));
        }, n.isJSXElement = function(s, o) {
          return !!s && s.type === "JSXElement" && (o == null || (0, i.default)(s, o));
        }, n.isJSXEmptyExpression = function(s, o) {
          return !!s && s.type === "JSXEmptyExpression" && (o == null || (0, i.default)(s, o));
        }, n.isJSXExpressionContainer = function(s, o) {
          return !!s && s.type === "JSXExpressionContainer" && (o == null || (0, i.default)(s, o));
        }, n.isJSXFragment = function(s, o) {
          return !!s && s.type === "JSXFragment" && (o == null || (0, i.default)(s, o));
        }, n.isJSXIdentifier = function(s, o) {
          return !!s && s.type === "JSXIdentifier" && (o == null || (0, i.default)(s, o));
        }, n.isJSXMemberExpression = function(s, o) {
          return !!s && s.type === "JSXMemberExpression" && (o == null || (0, i.default)(s, o));
        }, n.isJSXNamespacedName = function(s, o) {
          return !!s && s.type === "JSXNamespacedName" && (o == null || (0, i.default)(s, o));
        }, n.isJSXOpeningElement = function(s, o) {
          return !!s && s.type === "JSXOpeningElement" && (o == null || (0, i.default)(s, o));
        }, n.isJSXOpeningFragment = function(s, o) {
          return !!s && s.type === "JSXOpeningFragment" && (o == null || (0, i.default)(s, o));
        }, n.isJSXSpreadAttribute = function(s, o) {
          return !!s && s.type === "JSXSpreadAttribute" && (o == null || (0, i.default)(s, o));
        }, n.isJSXSpreadChild = function(s, o) {
          return !!s && s.type === "JSXSpreadChild" && (o == null || (0, i.default)(s, o));
        }, n.isJSXText = function(s, o) {
          return !!s && s.type === "JSXText" && (o == null || (0, i.default)(s, o));
        }, n.isLVal = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSParameterProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isLabeledStatement = function(s, o) {
          return !!s && s.type === "LabeledStatement" && (o == null || (0, i.default)(s, o));
        }, n.isLiteral = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "TemplateLiteral":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (s.expectedNode === "StringLiteral") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isLogicalExpression = function(s, o) {
          return !!s && s.type === "LogicalExpression" && (o == null || (0, i.default)(s, o));
        }, n.isLoop = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "WhileStatement":
            case "ForOfStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isMemberExpression = function(s, o) {
          return !!s && s.type === "MemberExpression" && (o == null || (0, i.default)(s, o));
        }, n.isMetaProperty = function(s, o) {
          return !!s && s.type === "MetaProperty" && (o == null || (0, i.default)(s, o));
        }, n.isMethod = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isMiscellaneous = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "Noop":
            case "Placeholder":
            case "V8IntrinsicIdentifier":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isMixedTypeAnnotation = function(s, o) {
          return !!s && s.type === "MixedTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isModuleDeclaration = function(s, o) {
          return (0, c.default)("isModuleDeclaration", "isImportOrExportDeclaration"), f(s, o);
        }, n.isModuleExpression = function(s, o) {
          return !!s && s.type === "ModuleExpression" && (o == null || (0, i.default)(s, o));
        }, n.isModuleSpecifier = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ExportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isNewExpression = function(s, o) {
          return !!s && s.type === "NewExpression" && (o == null || (0, i.default)(s, o));
        }, n.isNoop = function(s, o) {
          return !!s && s.type === "Noop" && (o == null || (0, i.default)(s, o));
        }, n.isNullLiteral = function(s, o) {
          return !!s && s.type === "NullLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isNullLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "NullLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isNullableTypeAnnotation = function(s, o) {
          return !!s && s.type === "NullableTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isNumberLiteral = function(s, o) {
          return (0, c.default)("isNumberLiteral", "isNumericLiteral"), !!s && s.type === "NumberLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isNumberLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "NumberLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isNumberTypeAnnotation = function(s, o) {
          return !!s && s.type === "NumberTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isNumericLiteral = function(s, o) {
          return !!s && s.type === "NumericLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isObjectExpression = function(s, o) {
          return !!s && s.type === "ObjectExpression" && (o == null || (0, i.default)(s, o));
        }, n.isObjectMember = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ObjectMethod":
            case "ObjectProperty":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isObjectMethod = function(s, o) {
          return !!s && s.type === "ObjectMethod" && (o == null || (0, i.default)(s, o));
        }, n.isObjectPattern = function(s, o) {
          return !!s && s.type === "ObjectPattern" && (o == null || (0, i.default)(s, o));
        }, n.isObjectProperty = function(s, o) {
          return !!s && s.type === "ObjectProperty" && (o == null || (0, i.default)(s, o));
        }, n.isObjectTypeAnnotation = function(s, o) {
          return !!s && s.type === "ObjectTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isObjectTypeCallProperty = function(s, o) {
          return !!s && s.type === "ObjectTypeCallProperty" && (o == null || (0, i.default)(s, o));
        }, n.isObjectTypeIndexer = function(s, o) {
          return !!s && s.type === "ObjectTypeIndexer" && (o == null || (0, i.default)(s, o));
        }, n.isObjectTypeInternalSlot = function(s, o) {
          return !!s && s.type === "ObjectTypeInternalSlot" && (o == null || (0, i.default)(s, o));
        }, n.isObjectTypeProperty = function(s, o) {
          return !!s && s.type === "ObjectTypeProperty" && (o == null || (0, i.default)(s, o));
        }, n.isObjectTypeSpreadProperty = function(s, o) {
          return !!s && s.type === "ObjectTypeSpreadProperty" && (o == null || (0, i.default)(s, o));
        }, n.isOpaqueType = function(s, o) {
          return !!s && s.type === "OpaqueType" && (o == null || (0, i.default)(s, o));
        }, n.isOptionalCallExpression = function(s, o) {
          return !!s && s.type === "OptionalCallExpression" && (o == null || (0, i.default)(s, o));
        }, n.isOptionalIndexedAccessType = function(s, o) {
          return !!s && s.type === "OptionalIndexedAccessType" && (o == null || (0, i.default)(s, o));
        }, n.isOptionalMemberExpression = function(s, o) {
          return !!s && s.type === "OptionalMemberExpression" && (o == null || (0, i.default)(s, o));
        }, n.isParenthesizedExpression = function(s, o) {
          return !!s && s.type === "ParenthesizedExpression" && (o == null || (0, i.default)(s, o));
        }, n.isPattern = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
              break;
            case "Placeholder":
              if (s.expectedNode === "Pattern") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isPatternLike = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "Identifier":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isPipelineBareFunction = function(s, o) {
          return !!s && s.type === "PipelineBareFunction" && (o == null || (0, i.default)(s, o));
        }, n.isPipelinePrimaryTopicReference = function(s, o) {
          return !!s && s.type === "PipelinePrimaryTopicReference" && (o == null || (0, i.default)(s, o));
        }, n.isPipelineTopicExpression = function(s, o) {
          return !!s && s.type === "PipelineTopicExpression" && (o == null || (0, i.default)(s, o));
        }, n.isPlaceholder = function(s, o) {
          return !!s && s.type === "Placeholder" && (o == null || (0, i.default)(s, o));
        }, n.isPrivate = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isPrivateName = function(s, o) {
          return !!s && s.type === "PrivateName" && (o == null || (0, i.default)(s, o));
        }, n.isProgram = function(s, o) {
          return !!s && s.type === "Program" && (o == null || (0, i.default)(s, o));
        }, n.isProperty = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isPureish = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "ArrowFunctionExpression":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (s.expectedNode === "StringLiteral") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isQualifiedTypeIdentifier = function(s, o) {
          return !!s && s.type === "QualifiedTypeIdentifier" && (o == null || (0, i.default)(s, o));
        }, n.isRecordExpression = function(s, o) {
          return !!s && s.type === "RecordExpression" && (o == null || (0, i.default)(s, o));
        }, n.isRegExpLiteral = function(s, o) {
          return !!s && s.type === "RegExpLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isRegexLiteral = function(s, o) {
          return (0, c.default)("isRegexLiteral", "isRegExpLiteral"), !!s && s.type === "RegexLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isRestElement = function(s, o) {
          return !!s && s.type === "RestElement" && (o == null || (0, i.default)(s, o));
        }, n.isRestProperty = function(s, o) {
          return (0, c.default)("isRestProperty", "isRestElement"), !!s && s.type === "RestProperty" && (o == null || (0, i.default)(s, o));
        }, n.isReturnStatement = function(s, o) {
          return !!s && s.type === "ReturnStatement" && (o == null || (0, i.default)(s, o));
        }, n.isScopable = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (s.expectedNode === "BlockStatement") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isSequenceExpression = function(s, o) {
          return !!s && s.type === "SequenceExpression" && (o == null || (0, i.default)(s, o));
        }, n.isSpreadElement = function(s, o) {
          return !!s && s.type === "SpreadElement" && (o == null || (0, i.default)(s, o));
        }, n.isSpreadProperty = function(s, o) {
          return (0, c.default)("isSpreadProperty", "isSpreadElement"), !!s && s.type === "SpreadProperty" && (o == null || (0, i.default)(s, o));
        }, n.isStandardized = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "InterpreterDirective":
            case "Directive":
            case "DirectiveLiteral":
            case "BlockStatement":
            case "BreakStatement":
            case "CallExpression":
            case "CatchClause":
            case "ConditionalExpression":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "File":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Identifier":
            case "IfStatement":
            case "LabeledStatement":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "Program":
            case "ObjectExpression":
            case "ObjectMethod":
            case "ObjectProperty":
            case "RestElement":
            case "ReturnStatement":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "SwitchCase":
            case "SwitchStatement":
            case "ThisExpression":
            case "ThrowStatement":
            case "TryStatement":
            case "UnaryExpression":
            case "UpdateExpression":
            case "VariableDeclaration":
            case "VariableDeclarator":
            case "WhileStatement":
            case "WithStatement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ArrowFunctionExpression":
            case "ClassBody":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ExportSpecifier":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportExpression":
            case "MetaProperty":
            case "ClassMethod":
            case "ObjectPattern":
            case "SpreadElement":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateElement":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "ExportNamespaceSpecifier":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
            case "StaticBlock":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isStatement = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BlockStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "IfStatement":
            case "LabeledStatement":
            case "ReturnStatement":
            case "SwitchStatement":
            case "ThrowStatement":
            case "TryStatement":
            case "VariableDeclaration":
            case "WhileStatement":
            case "WithStatement":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
              break;
            case "Placeholder":
              switch (s.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                  break;
                default:
                  return !1;
              }
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isStaticBlock = function(s, o) {
          return !!s && s.type === "StaticBlock" && (o == null || (0, i.default)(s, o));
        }, n.isStringLiteral = function(s, o) {
          return !!s && s.type === "StringLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isStringLiteralTypeAnnotation = function(s, o) {
          return !!s && s.type === "StringLiteralTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isStringTypeAnnotation = function(s, o) {
          return !!s && s.type === "StringTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isSuper = function(s, o) {
          return !!s && s.type === "Super" && (o == null || (0, i.default)(s, o));
        }, n.isSwitchCase = function(s, o) {
          return !!s && s.type === "SwitchCase" && (o == null || (0, i.default)(s, o));
        }, n.isSwitchStatement = function(s, o) {
          return !!s && s.type === "SwitchStatement" && (o == null || (0, i.default)(s, o));
        }, n.isSymbolTypeAnnotation = function(s, o) {
          return !!s && s.type === "SymbolTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isTSAnyKeyword = function(s, o) {
          return !!s && s.type === "TSAnyKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSArrayType = function(s, o) {
          return !!s && s.type === "TSArrayType" && (o == null || (0, i.default)(s, o));
        }, n.isTSAsExpression = function(s, o) {
          return !!s && s.type === "TSAsExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTSBaseType = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSLiteralType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isTSBigIntKeyword = function(s, o) {
          return !!s && s.type === "TSBigIntKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSBooleanKeyword = function(s, o) {
          return !!s && s.type === "TSBooleanKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSCallSignatureDeclaration = function(s, o) {
          return !!s && s.type === "TSCallSignatureDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSConditionalType = function(s, o) {
          return !!s && s.type === "TSConditionalType" && (o == null || (0, i.default)(s, o));
        }, n.isTSConstructSignatureDeclaration = function(s, o) {
          return !!s && s.type === "TSConstructSignatureDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSConstructorType = function(s, o) {
          return !!s && s.type === "TSConstructorType" && (o == null || (0, i.default)(s, o));
        }, n.isTSDeclareFunction = function(s, o) {
          return !!s && s.type === "TSDeclareFunction" && (o == null || (0, i.default)(s, o));
        }, n.isTSDeclareMethod = function(s, o) {
          return !!s && s.type === "TSDeclareMethod" && (o == null || (0, i.default)(s, o));
        }, n.isTSEntityName = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "Identifier":
            case "TSQualifiedName":
              break;
            case "Placeholder":
              if (s.expectedNode === "Identifier") break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isTSEnumDeclaration = function(s, o) {
          return !!s && s.type === "TSEnumDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSEnumMember = function(s, o) {
          return !!s && s.type === "TSEnumMember" && (o == null || (0, i.default)(s, o));
        }, n.isTSExportAssignment = function(s, o) {
          return !!s && s.type === "TSExportAssignment" && (o == null || (0, i.default)(s, o));
        }, n.isTSExpressionWithTypeArguments = function(s, o) {
          return !!s && s.type === "TSExpressionWithTypeArguments" && (o == null || (0, i.default)(s, o));
        }, n.isTSExternalModuleReference = function(s, o) {
          return !!s && s.type === "TSExternalModuleReference" && (o == null || (0, i.default)(s, o));
        }, n.isTSFunctionType = function(s, o) {
          return !!s && s.type === "TSFunctionType" && (o == null || (0, i.default)(s, o));
        }, n.isTSImportEqualsDeclaration = function(s, o) {
          return !!s && s.type === "TSImportEqualsDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSImportType = function(s, o) {
          return !!s && s.type === "TSImportType" && (o == null || (0, i.default)(s, o));
        }, n.isTSIndexSignature = function(s, o) {
          return !!s && s.type === "TSIndexSignature" && (o == null || (0, i.default)(s, o));
        }, n.isTSIndexedAccessType = function(s, o) {
          return !!s && s.type === "TSIndexedAccessType" && (o == null || (0, i.default)(s, o));
        }, n.isTSInferType = function(s, o) {
          return !!s && s.type === "TSInferType" && (o == null || (0, i.default)(s, o));
        }, n.isTSInstantiationExpression = function(s, o) {
          return !!s && s.type === "TSInstantiationExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTSInterfaceBody = function(s, o) {
          return !!s && s.type === "TSInterfaceBody" && (o == null || (0, i.default)(s, o));
        }, n.isTSInterfaceDeclaration = function(s, o) {
          return !!s && s.type === "TSInterfaceDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSIntersectionType = function(s, o) {
          return !!s && s.type === "TSIntersectionType" && (o == null || (0, i.default)(s, o));
        }, n.isTSIntrinsicKeyword = function(s, o) {
          return !!s && s.type === "TSIntrinsicKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSLiteralType = function(s, o) {
          return !!s && s.type === "TSLiteralType" && (o == null || (0, i.default)(s, o));
        }, n.isTSMappedType = function(s, o) {
          return !!s && s.type === "TSMappedType" && (o == null || (0, i.default)(s, o));
        }, n.isTSMethodSignature = function(s, o) {
          return !!s && s.type === "TSMethodSignature" && (o == null || (0, i.default)(s, o));
        }, n.isTSModuleBlock = function(s, o) {
          return !!s && s.type === "TSModuleBlock" && (o == null || (0, i.default)(s, o));
        }, n.isTSModuleDeclaration = function(s, o) {
          return !!s && s.type === "TSModuleDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSNamedTupleMember = function(s, o) {
          return !!s && s.type === "TSNamedTupleMember" && (o == null || (0, i.default)(s, o));
        }, n.isTSNamespaceExportDeclaration = function(s, o) {
          return !!s && s.type === "TSNamespaceExportDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSNeverKeyword = function(s, o) {
          return !!s && s.type === "TSNeverKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSNonNullExpression = function(s, o) {
          return !!s && s.type === "TSNonNullExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTSNullKeyword = function(s, o) {
          return !!s && s.type === "TSNullKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSNumberKeyword = function(s, o) {
          return !!s && s.type === "TSNumberKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSObjectKeyword = function(s, o) {
          return !!s && s.type === "TSObjectKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSOptionalType = function(s, o) {
          return !!s && s.type === "TSOptionalType" && (o == null || (0, i.default)(s, o));
        }, n.isTSParameterProperty = function(s, o) {
          return !!s && s.type === "TSParameterProperty" && (o == null || (0, i.default)(s, o));
        }, n.isTSParenthesizedType = function(s, o) {
          return !!s && s.type === "TSParenthesizedType" && (o == null || (0, i.default)(s, o));
        }, n.isTSPropertySignature = function(s, o) {
          return !!s && s.type === "TSPropertySignature" && (o == null || (0, i.default)(s, o));
        }, n.isTSQualifiedName = function(s, o) {
          return !!s && s.type === "TSQualifiedName" && (o == null || (0, i.default)(s, o));
        }, n.isTSRestType = function(s, o) {
          return !!s && s.type === "TSRestType" && (o == null || (0, i.default)(s, o));
        }, n.isTSSatisfiesExpression = function(s, o) {
          return !!s && s.type === "TSSatisfiesExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTSStringKeyword = function(s, o) {
          return !!s && s.type === "TSStringKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSSymbolKeyword = function(s, o) {
          return !!s && s.type === "TSSymbolKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSThisType = function(s, o) {
          return !!s && s.type === "TSThisType" && (o == null || (0, i.default)(s, o));
        }, n.isTSTupleType = function(s, o) {
          return !!s && s.type === "TSTupleType" && (o == null || (0, i.default)(s, o));
        }, n.isTSType = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSImportType":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isTSTypeAliasDeclaration = function(s, o) {
          return !!s && s.type === "TSTypeAliasDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeAnnotation = function(s, o) {
          return !!s && s.type === "TSTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeAssertion = function(s, o) {
          return !!s && s.type === "TSTypeAssertion" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeElement = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isTSTypeLiteral = function(s, o) {
          return !!s && s.type === "TSTypeLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeOperator = function(s, o) {
          return !!s && s.type === "TSTypeOperator" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeParameter = function(s, o) {
          return !!s && s.type === "TSTypeParameter" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeParameterDeclaration = function(s, o) {
          return !!s && s.type === "TSTypeParameterDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeParameterInstantiation = function(s, o) {
          return !!s && s.type === "TSTypeParameterInstantiation" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypePredicate = function(s, o) {
          return !!s && s.type === "TSTypePredicate" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeQuery = function(s, o) {
          return !!s && s.type === "TSTypeQuery" && (o == null || (0, i.default)(s, o));
        }, n.isTSTypeReference = function(s, o) {
          return !!s && s.type === "TSTypeReference" && (o == null || (0, i.default)(s, o));
        }, n.isTSUndefinedKeyword = function(s, o) {
          return !!s && s.type === "TSUndefinedKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSUnionType = function(s, o) {
          return !!s && s.type === "TSUnionType" && (o == null || (0, i.default)(s, o));
        }, n.isTSUnknownKeyword = function(s, o) {
          return !!s && s.type === "TSUnknownKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTSVoidKeyword = function(s, o) {
          return !!s && s.type === "TSVoidKeyword" && (o == null || (0, i.default)(s, o));
        }, n.isTaggedTemplateExpression = function(s, o) {
          return !!s && s.type === "TaggedTemplateExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTemplateElement = function(s, o) {
          return !!s && s.type === "TemplateElement" && (o == null || (0, i.default)(s, o));
        }, n.isTemplateLiteral = function(s, o) {
          return !!s && s.type === "TemplateLiteral" && (o == null || (0, i.default)(s, o));
        }, n.isTerminatorless = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "YieldExpression":
            case "AwaitExpression":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isThisExpression = function(s, o) {
          return !!s && s.type === "ThisExpression" && (o == null || (0, i.default)(s, o));
        }, n.isThisTypeAnnotation = function(s, o) {
          return !!s && s.type === "ThisTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isThrowStatement = function(s, o) {
          return !!s && s.type === "ThrowStatement" && (o == null || (0, i.default)(s, o));
        }, n.isTopicReference = function(s, o) {
          return !!s && s.type === "TopicReference" && (o == null || (0, i.default)(s, o));
        }, n.isTryStatement = function(s, o) {
          return !!s && s.type === "TryStatement" && (o == null || (0, i.default)(s, o));
        }, n.isTupleExpression = function(s, o) {
          return !!s && s.type === "TupleExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTupleTypeAnnotation = function(s, o) {
          return !!s && s.type === "TupleTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isTypeAlias = function(s, o) {
          return !!s && s.type === "TypeAlias" && (o == null || (0, i.default)(s, o));
        }, n.isTypeAnnotation = function(s, o) {
          return !!s && s.type === "TypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isTypeCastExpression = function(s, o) {
          return !!s && s.type === "TypeCastExpression" && (o == null || (0, i.default)(s, o));
        }, n.isTypeParameter = function(s, o) {
          return !!s && s.type === "TypeParameter" && (o == null || (0, i.default)(s, o));
        }, n.isTypeParameterDeclaration = function(s, o) {
          return !!s && s.type === "TypeParameterDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isTypeParameterInstantiation = function(s, o) {
          return !!s && s.type === "TypeParameterInstantiation" && (o == null || (0, i.default)(s, o));
        }, n.isTypeScript = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "TSParameterProperty":
            case "TSDeclareFunction":
            case "TSDeclareMethod":
            case "TSQualifiedName":
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSNamedTupleMember":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSInterfaceDeclaration":
            case "TSInterfaceBody":
            case "TSTypeAliasDeclaration":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSEnumDeclaration":
            case "TSEnumMember":
            case "TSModuleDeclaration":
            case "TSModuleBlock":
            case "TSImportType":
            case "TSImportEqualsDeclaration":
            case "TSExternalModuleReference":
            case "TSNonNullExpression":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
            case "TSTypeAnnotation":
            case "TSTypeParameterInstantiation":
            case "TSTypeParameterDeclaration":
            case "TSTypeParameter":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isTypeofTypeAnnotation = function(s, o) {
          return !!s && s.type === "TypeofTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isUnaryExpression = function(s, o) {
          return !!s && s.type === "UnaryExpression" && (o == null || (0, i.default)(s, o));
        }, n.isUnaryLike = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "UnaryExpression":
            case "SpreadElement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isUnionTypeAnnotation = function(s, o) {
          return !!s && s.type === "UnionTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isUpdateExpression = function(s, o) {
          return !!s && s.type === "UpdateExpression" && (o == null || (0, i.default)(s, o));
        }, n.isUserWhitespacable = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ObjectMethod":
            case "ObjectProperty":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isV8IntrinsicIdentifier = function(s, o) {
          return !!s && s.type === "V8IntrinsicIdentifier" && (o == null || (0, i.default)(s, o));
        }, n.isVariableDeclaration = function(s, o) {
          return !!s && s.type === "VariableDeclaration" && (o == null || (0, i.default)(s, o));
        }, n.isVariableDeclarator = function(s, o) {
          return !!s && s.type === "VariableDeclarator" && (o == null || (0, i.default)(s, o));
        }, n.isVariance = function(s, o) {
          return !!s && s.type === "Variance" && (o == null || (0, i.default)(s, o));
        }, n.isVoidTypeAnnotation = function(s, o) {
          return !!s && s.type === "VoidTypeAnnotation" && (o == null || (0, i.default)(s, o));
        }, n.isWhile = function(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "DoWhileStatement":
            case "WhileStatement":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }, n.isWhileStatement = function(s, o) {
          return !!s && s.type === "WhileStatement" && (o == null || (0, i.default)(s, o));
        }, n.isWithStatement = function(s, o) {
          return !!s && s.type === "WithStatement" && (o == null || (0, i.default)(s, o));
        }, n.isYieldExpression = function(s, o) {
          return !!s && s.type === "YieldExpression" && (o == null || (0, i.default)(s, o));
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/shallowEqual.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function f(s, o) {
          if (!s) return !1;
          switch (s.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              break;
            default:
              return !1;
          }
          return o == null || (0, i.default)(s, o);
        }
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/is.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(o, y, m) {
          return y ? (0, c.default)(y.type, o) ? m === void 0 || (0, i.default)(y, m) : !m && y.type === "Placeholder" && o in s.FLIPPED_ALIAS_KEYS && (0, f.default)(y.expectedNode, o) : !1;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/utils/shallowEqual.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isType.js"), f = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), s = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isBinding.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f, s) {
          if (s && c.type === "Identifier" && f.type === "ObjectProperty" && s.type === "ObjectExpression") return !1;
          const o = i.default.keys[f.type];
          if (o) for (let y = 0; y < o.length; y++) {
            const m = f[o[y]];
            if (Array.isArray(m)) {
              if (m.indexOf(c) >= 0) return !0;
            } else if (m === c) return !0;
          }
          return !1;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isBlockScoped.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          return (0, i.isFunctionDeclaration)(f) || (0, i.isClassDeclaration)(f) || (0, c.default)(f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isLet.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isImmutable.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          return (0, i.default)(f.type, "Immutable") ? !0 : (0, c.isIdentifier)(f) ? f.name === "undefined" : !1;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isType.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isLet.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          return (0, i.isVariableDeclaration)(f) && (f.kind !== "var" || f[c.BLOCK_SCOPED_SYMBOL]);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isNode.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return !(!c || !i.VISITOR_KEYS[c.type]);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isNodesEquivalent.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function c(f, s) {
          if (typeof f != "object" || typeof s != "object" || f == null || s == null) return f === s;
          if (f.type !== s.type) return !1;
          const o = Object.keys(i.NODE_FIELDS[f.type] || f.type), y = i.VISITOR_KEYS[f.type];
          for (const m of o) {
            const g = f[m], b = s[m];
            if (typeof g != typeof b) return !1;
            if (g != null || b != null) {
              if (g == null || b == null) return !1;
              if (Array.isArray(g)) {
                if (!Array.isArray(b) || g.length !== b.length) return !1;
                for (let v = 0; v < g.length; v++) if (!c(g[v], b[v])) return !1;
              } else if (typeof g != "object" || y != null && y.includes(m)) {
                if (!c(g, b)) return !1;
              } else for (const v of Object.keys(g)) if (g[v] !== b[v]) return !1;
            }
          }
          return !0;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isPlaceholderType.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          if (c === f) return !0;
          const s = i.PLACEHOLDERS_ALIAS[c];
          if (s) {
            for (const o of s) if (f === o) return !0;
          }
          return !1;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isReferenced.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(u, i, c) {
          switch (i.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return i.property === u ? !!i.computed : i.object === u;
            case "JSXMemberExpression":
              return i.object === u;
            case "VariableDeclarator":
              return i.init === u;
            case "ArrowFunctionExpression":
              return i.body === u;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return !1;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return i.key === u && !!i.computed;
            case "ObjectProperty":
              return i.key === u ? !!i.computed : !c || c.type !== "ObjectPattern";
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "TSPropertySignature":
              return i.key !== u || !!i.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return i.key !== u;
            case "ClassDeclaration":
            case "ClassExpression":
              return i.superClass === u;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return i.right === u;
            case "ExportSpecifier":
              return (c == null || !c.source) && i.local === u;
            case "TSEnumMember":
              return i.id !== u;
          }
          return !0;
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isScope.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          return (0, i.isBlockStatement)(c) && ((0, i.isFunction)(f) || (0, i.isCatchClause)(f)) ? !1 : (0, i.isPattern)(c) && ((0, i.isFunction)(f) || (0, i.isCatchClause)(f)) ? !0 : (0, i.isScopable)(c);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isSpecifierDefault.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c) {
          return (0, i.isImportDefaultSpecifier)(c) || (0, i.isIdentifier)(c.imported || c.exported, { name: "default" });
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isType.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f) {
          if (c === f) return !0;
          if (c == null || i.ALIAS_KEYS[f]) return !1;
          const s = i.FLIPPED_ALIAS_KEYS[f];
          if (s) {
            if (s[0] === c) return !0;
            for (const o of s) if (c === o) return !0;
          }
          return !1;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidES3Identifier.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          return (0, i.default)(f) && !c.has(f);
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidIdentifier.js");
        const c = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isValidIdentifier.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f = !0) {
          return typeof c != "string" || f && ((0, i.isKeyword)(c) || (0, i.isStrictReservedWord)(c, !0)) ? !1 : (0, i.isIdentifierName)(c);
        };
        var i = u("./node_modules/.pnpm/@babel+helper-validator-identifier@7.24.7/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/isVar.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(f) {
          return (0, i.isVariableDeclaration)(f, { kind: "var" }) && !f[c.BLOCK_SCOPED_SYMBOL];
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js"), c = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/matchesPattern.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(c, f, s) {
          if (!(0, i.isMemberExpression)(c)) return !1;
          const o = Array.isArray(f) ? f : f.split("."), y = [];
          let m;
          for (m = c; (0, i.isMemberExpression)(m); m = m.object) y.push(m.property);
          if (y.push(m), y.length < o.length || !s && y.length > o.length) return !1;
          for (let g = 0, b = y.length - 1; g < o.length; g++, b--) {
            const v = y[b];
            let T;
            if ((0, i.isIdentifier)(v)) T = v.name;
            else if ((0, i.isStringLiteral)(v)) T = v.value;
            else {
              if (!(0, i.isThisExpression)(v)) return !1;
              T = "this";
            }
            if (o[g] !== T) return !1;
          }
          return !0;
        };
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/react/isCompatTag.js": (h, n) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(u) {
          return !!u && /^[a-z]/.test(u);
        };
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/react/isReactComponent.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = void 0;
        const i = (0, u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");
        n.default = i;
      }, "./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/validators/validate.js": (h, n, u) => {
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = function(s, o, y) {
          if (!s) return;
          const m = i.NODE_FIELDS[s.type];
          if (!m) return;
          const g = m[o];
          c(s, o, y, g), f(s, o, y);
        }, n.validateChild = f, n.validateField = c;
        var i = u("./node_modules/.pnpm/@babel+types@7.24.7/node_modules/@babel/types/lib/definitions/index.js");
        function c(s, o, y, m) {
          m != null && m.validate && (m.optional && y == null || m.validate(s, o, y));
        }
        function f(s, o, y) {
          if (y == null) return;
          const m = i.NODE_PARENT_VALIDATIONS[y.type];
          m && m(s, o, y);
        }
      }, "./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs": (h, n, u) => {
        u.r(n), u.d(n, { default: () => G });
        var i = { Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, c = { isSpaceSeparator: (N) => typeof N == "string" && i.Space_Separator.test(N), isIdStartChar: (N) => typeof N == "string" && (N >= "a" && N <= "z" || N >= "A" && N <= "Z" || N === "$" || N === "_" || i.ID_Start.test(N)), isIdContinueChar: (N) => typeof N == "string" && (N >= "a" && N <= "z" || N >= "A" && N <= "Z" || N >= "0" && N <= "9" || N === "$" || N === "_" || N === "‌" || N === "‍" || i.ID_Continue.test(N)), isDigit: (N) => typeof N == "string" && /[0-9]/.test(N), isHexDigit: (N) => typeof N == "string" && /[0-9A-Fa-f]/.test(N) };
        let f, s, o, y, m, g, b, v, T;
        function E(N, V, F) {
          const X = N[V];
          if (X != null && typeof X == "object") if (Array.isArray(X)) for (let K = 0; K < X.length; K++) {
            const ie = String(K), fe = E(X, ie, F);
            fe === void 0 ? delete X[ie] : Object.defineProperty(X, ie, { value: fe, writable: !0, enumerable: !0, configurable: !0 });
          }
          else for (const K in X) {
            const ie = E(X, K, F);
            ie === void 0 ? delete X[K] : Object.defineProperty(X, K, { value: ie, writable: !0, enumerable: !0, configurable: !0 });
          }
          return F.call(N, V, X);
        }
        let O, D, $, I, k;
        function L() {
          for (O = "default", D = "", $ = !1, I = 1; ; ) {
            k = M();
            const N = _[O]();
            if (N) return N;
          }
        }
        function M() {
          if (f[y]) return String.fromCodePoint(f.codePointAt(y));
        }
        function x() {
          const N = M();
          return N === `
` ? (m++, g = 0) : N ? g += N.length : g++, N && (y += N.length), N;
        }
        const _ = { default() {
          switch (k) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case " ":
            case "\uFEFF":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return void x();
            case "/":
              return x(), void (O = "comment");
            case void 0:
              return x(), S("eof");
          }
          if (!c.isSpaceSeparator(k)) return _[s]();
          x();
        }, comment() {
          switch (k) {
            case "*":
              return x(), void (O = "multiLineComment");
            case "/":
              return x(), void (O = "singleLineComment");
          }
          throw P(x());
        }, multiLineComment() {
          switch (k) {
            case "*":
              return x(), void (O = "multiLineCommentAsterisk");
            case void 0:
              throw P(x());
          }
          x();
        }, multiLineCommentAsterisk() {
          switch (k) {
            case "*":
              return void x();
            case "/":
              return x(), void (O = "default");
            case void 0:
              throw P(x());
          }
          x(), O = "multiLineComment";
        }, singleLineComment() {
          switch (k) {
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return x(), void (O = "default");
            case void 0:
              return x(), S("eof");
          }
          x();
        }, value() {
          switch (k) {
            case "{":
            case "[":
              return S("punctuator", x());
            case "n":
              return x(), C("ull"), S("null", null);
            case "t":
              return x(), C("rue"), S("boolean", !0);
            case "f":
              return x(), C("alse"), S("boolean", !1);
            case "-":
            case "+":
              return x() === "-" && (I = -1), void (O = "sign");
            case ".":
              return D = x(), void (O = "decimalPointLeading");
            case "0":
              return D = x(), void (O = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return D = x(), void (O = "decimalInteger");
            case "I":
              return x(), C("nfinity"), S("numeric", 1 / 0);
            case "N":
              return x(), C("aN"), S("numeric", NaN);
            case '"':
            case "'":
              return $ = x() === '"', D = "", void (O = "string");
          }
          throw P(x());
        }, identifierNameStartEscape() {
          if (k !== "u") throw P(x());
          x();
          const N = R();
          switch (N) {
            case "$":
            case "_":
              break;
            default:
              if (!c.isIdStartChar(N)) throw B();
          }
          D += N, O = "identifierName";
        }, identifierName() {
          switch (k) {
            case "$":
            case "_":
            case "‌":
            case "‍":
              return void (D += x());
            case "\\":
              return x(), void (O = "identifierNameEscape");
          }
          if (!c.isIdContinueChar(k)) return S("identifier", D);
          D += x();
        }, identifierNameEscape() {
          if (k !== "u") throw P(x());
          x();
          const N = R();
          switch (N) {
            case "$":
            case "_":
            case "‌":
            case "‍":
              break;
            default:
              if (!c.isIdContinueChar(N)) throw B();
          }
          D += N, O = "identifierName";
        }, sign() {
          switch (k) {
            case ".":
              return D = x(), void (O = "decimalPointLeading");
            case "0":
              return D = x(), void (O = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return D = x(), void (O = "decimalInteger");
            case "I":
              return x(), C("nfinity"), S("numeric", I * (1 / 0));
            case "N":
              return x(), C("aN"), S("numeric", NaN);
          }
          throw P(x());
        }, zero() {
          switch (k) {
            case ".":
              return D += x(), void (O = "decimalPoint");
            case "e":
            case "E":
              return D += x(), void (O = "decimalExponent");
            case "x":
            case "X":
              return D += x(), void (O = "hexadecimal");
          }
          return S("numeric", 0 * I);
        }, decimalInteger() {
          switch (k) {
            case ".":
              return D += x(), void (O = "decimalPoint");
            case "e":
            case "E":
              return D += x(), void (O = "decimalExponent");
          }
          if (!c.isDigit(k)) return S("numeric", I * Number(D));
          D += x();
        }, decimalPointLeading() {
          if (c.isDigit(k)) return D += x(), void (O = "decimalFraction");
          throw P(x());
        }, decimalPoint() {
          switch (k) {
            case "e":
            case "E":
              return D += x(), void (O = "decimalExponent");
          }
          return c.isDigit(k) ? (D += x(), void (O = "decimalFraction")) : S("numeric", I * Number(D));
        }, decimalFraction() {
          switch (k) {
            case "e":
            case "E":
              return D += x(), void (O = "decimalExponent");
          }
          if (!c.isDigit(k)) return S("numeric", I * Number(D));
          D += x();
        }, decimalExponent() {
          switch (k) {
            case "+":
            case "-":
              return D += x(), void (O = "decimalExponentSign");
          }
          if (c.isDigit(k)) return D += x(), void (O = "decimalExponentInteger");
          throw P(x());
        }, decimalExponentSign() {
          if (c.isDigit(k)) return D += x(), void (O = "decimalExponentInteger");
          throw P(x());
        }, decimalExponentInteger() {
          if (!c.isDigit(k)) return S("numeric", I * Number(D));
          D += x();
        }, hexadecimal() {
          if (c.isHexDigit(k)) return D += x(), void (O = "hexadecimalInteger");
          throw P(x());
        }, hexadecimalInteger() {
          if (!c.isHexDigit(k)) return S("numeric", I * Number(D));
          D += x();
        }, string() {
          switch (k) {
            case "\\":
              return x(), void (D += function() {
                switch (M()) {
                  case "b":
                    return x(), "\b";
                  case "f":
                    return x(), "\f";
                  case "n":
                    return x(), `
`;
                  case "r":
                    return x(), "\r";
                  case "t":
                    return x(), "	";
                  case "v":
                    return x(), "\v";
                  case "0":
                    if (x(), c.isDigit(M())) throw P(x());
                    return "\0";
                  case "x":
                    return x(), function() {
                      let N = "", V = M();
                      if (!c.isHexDigit(V) || (N += x(), V = M(), !c.isHexDigit(V))) throw P(x());
                      return N += x(), String.fromCodePoint(parseInt(N, 16));
                    }();
                  case "u":
                    return x(), R();
                  case `
`:
                  case "\u2028":
                  case "\u2029":
                    return x(), "";
                  case "\r":
                    return x(), M() === `
` && x(), "";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case void 0:
                    throw P(x());
                }
                return x();
              }());
            case '"':
              return $ ? (x(), S("string", D)) : void (D += x());
            case "'":
              return $ ? void (D += x()) : (x(), S("string", D));
            case `
`:
            case "\r":
              throw P(x());
            case "\u2028":
            case "\u2029":
              (function(N) {
                console.warn(`JSON5: '${Q(N)}' in strings is not valid ECMAScript; consider escaping`);
              })(k);
              break;
            case void 0:
              throw P(x());
          }
          D += x();
        }, start() {
          switch (k) {
            case "{":
            case "[":
              return S("punctuator", x());
          }
          O = "value";
        }, beforePropertyName() {
          switch (k) {
            case "$":
            case "_":
              return D = x(), void (O = "identifierName");
            case "\\":
              return x(), void (O = "identifierNameStartEscape");
            case "}":
              return S("punctuator", x());
            case '"':
            case "'":
              return $ = x() === '"', void (O = "string");
          }
          if (c.isIdStartChar(k)) return D += x(), void (O = "identifierName");
          throw P(x());
        }, afterPropertyName() {
          if (k === ":") return S("punctuator", x());
          throw P(x());
        }, beforePropertyValue() {
          O = "value";
        }, afterPropertyValue() {
          switch (k) {
            case ",":
            case "}":
              return S("punctuator", x());
          }
          throw P(x());
        }, beforeArrayValue() {
          if (k === "]") return S("punctuator", x());
          O = "value";
        }, afterArrayValue() {
          switch (k) {
            case ",":
            case "]":
              return S("punctuator", x());
          }
          throw P(x());
        }, end() {
          throw P(x());
        } };
        function S(N, V) {
          return { type: N, value: V, line: m, column: g };
        }
        function C(N) {
          for (const V of N) {
            if (M() !== V) throw P(x());
            x();
          }
        }
        function R() {
          let N = "", V = 4;
          for (; V-- > 0; ) {
            const F = M();
            if (!c.isHexDigit(F)) throw P(x());
            N += x();
          }
          return String.fromCodePoint(parseInt(N, 16));
        }
        const H = { start() {
          if (b.type === "eof") throw W();
          z();
        }, beforePropertyName() {
          switch (b.type) {
            case "identifier":
            case "string":
              return v = b.value, void (s = "afterPropertyName");
            case "punctuator":
              return void U();
            case "eof":
              throw W();
          }
        }, afterPropertyName() {
          if (b.type === "eof") throw W();
          s = "beforePropertyValue";
        }, beforePropertyValue() {
          if (b.type === "eof") throw W();
          z();
        }, beforeArrayValue() {
          if (b.type === "eof") throw W();
          b.type !== "punctuator" || b.value !== "]" ? z() : U();
        }, afterPropertyValue() {
          if (b.type === "eof") throw W();
          switch (b.value) {
            case ",":
              return void (s = "beforePropertyName");
            case "}":
              U();
          }
        }, afterArrayValue() {
          if (b.type === "eof") throw W();
          switch (b.value) {
            case ",":
              return void (s = "beforeArrayValue");
            case "]":
              U();
          }
        }, end() {
        } };
        function z() {
          let N;
          switch (b.type) {
            case "punctuator":
              switch (b.value) {
                case "{":
                  N = {};
                  break;
                case "[":
                  N = [];
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              N = b.value;
          }
          if (T === void 0) T = N;
          else {
            const V = o[o.length - 1];
            Array.isArray(V) ? V.push(N) : Object.defineProperty(V, v, { value: N, writable: !0, enumerable: !0, configurable: !0 });
          }
          if (N !== null && typeof N == "object") o.push(N), s = Array.isArray(N) ? "beforeArrayValue" : "beforePropertyName";
          else {
            const V = o[o.length - 1];
            s = V == null ? "end" : Array.isArray(V) ? "afterArrayValue" : "afterPropertyValue";
          }
        }
        function U() {
          o.pop();
          const N = o[o.length - 1];
          s = N == null ? "end" : Array.isArray(N) ? "afterArrayValue" : "afterPropertyValue";
        }
        function P(N) {
          return J(N === void 0 ? `JSON5: invalid end of input at ${m}:${g}` : `JSON5: invalid character '${Q(N)}' at ${m}:${g}`);
        }
        function W() {
          return J(`JSON5: invalid end of input at ${m}:${g}`);
        }
        function B() {
          return g -= 5, J(`JSON5: invalid identifier character at ${m}:${g}`);
        }
        function Q(N) {
          const V = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          if (V[N]) return V[N];
          if (N < " ") {
            const F = N.charCodeAt(0).toString(16);
            return "\\x" + ("00" + F).substring(F.length);
          }
          return N;
        }
        function J(N) {
          const V = new SyntaxError(N);
          return V.lineNumber = m, V.columnNumber = g, V;
        }
        const G = { parse: function(N, V) {
          f = String(N), s = "start", o = [], y = 0, m = 1, g = 0, b = void 0, v = void 0, T = void 0;
          do
            b = L(), H[s]();
          while (b.type !== "eof");
          return typeof V == "function" ? E({ "": T }, "", V) : T;
        }, stringify: function(N, V, F) {
          const X = [];
          let K, ie, fe, _e = "", Ae = "";
          if (V == null || typeof V != "object" || Array.isArray(V) || (F = V.space, fe = V.quote, V = V.replacer), typeof V == "function") ie = V;
          else if (Array.isArray(V)) {
            K = [];
            for (const oe of V) {
              let me;
              typeof oe == "string" ? me = oe : (typeof oe == "number" || oe instanceof String || oe instanceof Number) && (me = String(oe)), me !== void 0 && K.indexOf(me) < 0 && K.push(me);
            }
          }
          return F instanceof Number ? F = Number(F) : F instanceof String && (F = String(F)), typeof F == "number" ? F > 0 && (F = Math.min(10, Math.floor(F)), Ae = "          ".substr(0, F)) : typeof F == "string" && (Ae = F.substr(0, 10)), ce("", { "": N });
          function ce(oe, me) {
            let ye = me[oe];
            switch (ye != null && (typeof ye.toJSON5 == "function" ? ye = ye.toJSON5(oe) : typeof ye.toJSON == "function" && (ye = ye.toJSON(oe))), ie && (ye = ie.call(me, oe, ye)), ye instanceof Number ? ye = Number(ye) : ye instanceof String ? ye = String(ye) : ye instanceof Boolean && (ye = ye.valueOf()), ye) {
              case null:
                return "null";
              case !0:
                return "true";
              case !1:
                return "false";
            }
            return typeof ye == "string" ? ee(ye) : typeof ye == "number" ? String(ye) : typeof ye == "object" ? Array.isArray(ye) ? function(we) {
              if (X.indexOf(we) >= 0) throw TypeError("Converting circular structure to JSON5");
              X.push(we);
              let ge = _e;
              _e += Ae;
              let se, be = [];
              for (let Ie = 0; Ie < we.length; Ie++) {
                const Oe = ce(String(Ie), we);
                be.push(Oe !== void 0 ? Oe : "null");
              }
              if (be.length === 0) se = "[]";
              else if (Ae === "")
                se = "[" + be.join(",") + "]";
              else {
                let Ie = `,
` + _e, Oe = be.join(Ie);
                se = `[
` + _e + Oe + `,
` + ge + "]";
              }
              return X.pop(), _e = ge, se;
            }(ye) : function(we) {
              if (X.indexOf(we) >= 0) throw TypeError("Converting circular structure to JSON5");
              X.push(we);
              let ge = _e;
              _e += Ae;
              let se, be = K || Object.keys(we), Ie = [];
              for (const Oe of be) {
                const Be = ce(Oe, we);
                if (Be !== void 0) {
                  let Fe = ae(Oe) + ":";
                  Ae !== "" && (Fe += " "), Fe += Be, Ie.push(Fe);
                }
              }
              if (Ie.length === 0) se = "{}";
              else {
                let Oe;
                if (Ae === "") Oe = Ie.join(","), se = "{" + Oe + "}";
                else {
                  let Be = `,
` + _e;
                  Oe = Ie.join(Be), se = `{
` + _e + Oe + `,
` + ge + "}";
                }
              }
              return X.pop(), _e = ge, se;
            }(ye) : void 0;
          }
          function ee(oe) {
            const me = { "'": 0.1, '"': 0.2 }, ye = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
            let we = "";
            for (let se = 0; se < oe.length; se++) {
              const be = oe[se];
              switch (be) {
                case "'":
                case '"':
                  me[be]++, we += be;
                  continue;
                case "\0":
                  if (c.isDigit(oe[se + 1])) {
                    we += "\\x00";
                    continue;
                  }
              }
              if (ye[be]) we += ye[be];
              else if (be < " ") {
                let Ie = be.charCodeAt(0).toString(16);
                we += "\\x" + ("00" + Ie).substring(Ie.length);
              } else we += be;
            }
            const ge = fe || Object.keys(me).reduce((se, be) => me[se] < me[be] ? se : be);
            return we = we.replace(new RegExp(ge, "g"), ye[ge]), ge + we + ge;
          }
          function ae(oe) {
            if (oe.length === 0) return ee(oe);
            const me = String.fromCodePoint(oe.codePointAt(0));
            if (!c.isIdStartChar(me)) return ee(oe);
            for (let ye = me.length; ye < oe.length; ye++) if (!c.isIdContinueChar(String.fromCodePoint(oe.codePointAt(ye)))) return ee(oe);
            return oe;
          }
        } };
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/preset-typescript/package.json": (h) => {
        h.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.24.7","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.24.7","@babel/helper-validator-option":"^7.24.7","@babel/plugin-syntax-jsx":"^7.24.7","@babel/plugin-transform-modules-commonjs":"^7.24.7","@babel/plugin-transform-typescript":"^7.24.7"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.24.7","@babel/helper-plugin-test-runner":"^7.24.7"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json": (h) => {
        h.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
      } }, a = {};
      function l(h) {
        var n = a[h];
        if (n !== void 0) return n.exports;
        var u = a[h] = { exports: {} };
        return r[h].call(u.exports, u, u.exports, l), u.exports;
      }
      l.d = (h, n) => {
        for (var u in n) l.o(n, u) && !l.o(h, u) && Object.defineProperty(h, u, { enumerable: !0, get: n[u] });
      }, l.o = (h, n) => Object.prototype.hasOwnProperty.call(h, n), l.r = (h) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(h, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(h, "__esModule", { value: !0 });
      };
      var d = {};
      (() => {
        l.d(d, { default: () => f });
        var h = l("./node_modules/.pnpm/@babel+core@7.24.7/node_modules/@babel/core/lib/index.js"), n = l("url"), u = l("./node_modules/.pnpm/@babel+template@7.24.7/node_modules/@babel/template/lib/index.js");
        function i(s, o) {
          return { name: "transform-import-meta", visitor: { Program(y) {
            const m = [];
            if (y.traverse({ MemberExpression(g) {
              const { node: b } = g;
              b.object.type === "MetaProperty" && b.object.meta.name === "import" && b.object.property.name === "meta" && b.property.type === "Identifier" && b.property.name === "url" && m.push(g);
            } }), m.length !== 0) for (const g of m) g.replaceWith(u.smart.ast`${o.filename ? JSON.stringify((0, n.pathToFileURL)(o.filename)) : "require('url').pathToFileURL(__filename).toString()"}`);
          } } };
        }
        function c({ template: s, types: o }) {
          return { name: "@import-meta-env/babel", visitor: { Identifier(y) {
            if (!o.isIdentifier(y) || !o.isMemberExpression(y.parentPath) && !o.isOptionalMemberExpression(y.parentPath) || !o.isMemberExpression(y.parentPath.node)) return;
            const m = y.parentPath.node;
            if (!o.isMetaProperty(m.object)) return;
            const g = m.object;
            g.meta.name === "import" && g.property.name === "meta" && m.property.name === "env" && y.parentPath.replaceWith(s.expression.ast("process.env"));
          } } };
        }
        function f(s) {
          var o, y, m, g, b, v;
          const T = Object.assign(Object.assign({ babelrc: !1, configFile: !1, compact: !1, retainLines: typeof s.retainLines != "boolean" || s.retainLines, filename: "", cwd: "/" }, s.babel), { plugins: [[l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), { allowTopLevelThis: !0 }], [l("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js"), { noInterop: !0 }], [i, { filename: s.filename }], [l("./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-class-properties/lib/index.js")], [l("./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js")], [c]] });
          s.ts && (T.plugins.push([l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-typescript/lib/index.js"), { allowDeclareFields: !0 }]), T.plugins.unshift([l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.24.7_@babel+traverse@7.24.7/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js")], [l("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-proposal-decorators/lib/index.js"), { legacy: !0 }]), T.plugins.push(l("./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js")), T.plugins.push(l("./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js"))), s.legacy && (T.plugins.push(l("./node_modules/.pnpm/@babel+plugin-transform-nullish-coalescing-operator@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js")), T.plugins.push(l("./node_modules/.pnpm/@babel+plugin-transform-optional-chaining@7.24.7_@babel+core@7.24.7/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js"))), s.babel && Array.isArray(s.babel.plugins) && ((o = T.plugins) === null || o === void 0 || o.push(...s.babel.plugins));
          try {
            return { code: ((y = (0, h.transformSync)(s.source, T)) === null || y === void 0 ? void 0 : y.code) || "" };
          } catch (E) {
            return { error: E, code: "exports.__JITI_ERROR__ = " + JSON.stringify({ filename: s.filename, line: ((m = E.loc) === null || m === void 0 ? void 0 : m.line) || 0, column: ((g = E.loc) === null || g === void 0 ? void 0 : g.column) || 0, code: (b = E.code) === null || b === void 0 ? void 0 : b.replace("BABEL_", "").replace("PARSE_ERROR", "ParseError"), message: (v = E.message) === null || v === void 0 ? void 0 : v.replace("/: ", "").replace(/\(.+\)\s*$/, "") }) };
          }
        }
      })(), t.exports = d.default;
    })();
  }(r0)), r0.exports;
}
function zK(t) {
  throw t;
}
var KK = function(e, r) {
  const a = qK();
  return r = { onError: zK, ...r }, r.transform || (r.transform = GK()), a(e, r);
}, $e;
(function(t) {
  t[t.NONE = 0] = "NONE";
  const r = 1;
  t[t._abstract = r] = "_abstract";
  const a = r + 1;
  t[t._accessor = a] = "_accessor";
  const l = a + 1;
  t[t._as = l] = "_as";
  const d = l + 1;
  t[t._assert = d] = "_assert";
  const h = d + 1;
  t[t._asserts = h] = "_asserts";
  const n = h + 1;
  t[t._async = n] = "_async";
  const u = n + 1;
  t[t._await = u] = "_await";
  const i = u + 1;
  t[t._checks = i] = "_checks";
  const c = i + 1;
  t[t._constructor = c] = "_constructor";
  const f = c + 1;
  t[t._declare = f] = "_declare";
  const s = f + 1;
  t[t._enum = s] = "_enum";
  const o = s + 1;
  t[t._exports = o] = "_exports";
  const y = o + 1;
  t[t._from = y] = "_from";
  const m = y + 1;
  t[t._get = m] = "_get";
  const g = m + 1;
  t[t._global = g] = "_global";
  const b = g + 1;
  t[t._implements = b] = "_implements";
  const v = b + 1;
  t[t._infer = v] = "_infer";
  const T = v + 1;
  t[t._interface = T] = "_interface";
  const E = T + 1;
  t[t._is = E] = "_is";
  const O = E + 1;
  t[t._keyof = O] = "_keyof";
  const D = O + 1;
  t[t._mixins = D] = "_mixins";
  const $ = D + 1;
  t[t._module = $] = "_module";
  const I = $ + 1;
  t[t._namespace = I] = "_namespace";
  const k = I + 1;
  t[t._of = k] = "_of";
  const L = k + 1;
  t[t._opaque = L] = "_opaque";
  const M = L + 1;
  t[t._out = M] = "_out";
  const x = M + 1;
  t[t._override = x] = "_override";
  const _ = x + 1;
  t[t._private = _] = "_private";
  const S = _ + 1;
  t[t._protected = S] = "_protected";
  const C = S + 1;
  t[t._proto = C] = "_proto";
  const R = C + 1;
  t[t._public = R] = "_public";
  const H = R + 1;
  t[t._readonly = H] = "_readonly";
  const z = H + 1;
  t[t._require = z] = "_require";
  const U = z + 1;
  t[t._satisfies = U] = "_satisfies";
  const P = U + 1;
  t[t._set = P] = "_set";
  const W = P + 1;
  t[t._static = W] = "_static";
  const B = W + 1;
  t[t._symbol = B] = "_symbol";
  const Q = B + 1;
  t[t._type = Q] = "_type";
  const J = Q + 1;
  t[t._unique = J] = "_unique";
  const re = J + 1;
  t[t._using = re] = "_using";
})($e || ($e = {}));
var j;
(function(t) {
  t[t.PRECEDENCE_MASK = 15] = "PRECEDENCE_MASK";
  const r = 16;
  t[t.IS_KEYWORD = r] = "IS_KEYWORD";
  const a = 32;
  t[t.IS_ASSIGN = a] = "IS_ASSIGN";
  const l = 64;
  t[t.IS_RIGHT_ASSOCIATIVE = l] = "IS_RIGHT_ASSOCIATIVE";
  const d = 128;
  t[t.IS_PREFIX = d] = "IS_PREFIX";
  const h = 256;
  t[t.IS_POSTFIX = h] = "IS_POSTFIX";
  const n = 512;
  t[t.IS_EXPRESSION_START = n] = "IS_EXPRESSION_START";
  const u = 512;
  t[t.num = u] = "num";
  const i = 1536;
  t[t.bigint = i] = "bigint";
  const c = 2560;
  t[t.decimal = c] = "decimal";
  const f = 3584;
  t[t.regexp = f] = "regexp";
  const s = 4608;
  t[t.string = s] = "string";
  const o = 5632;
  t[t.name = o] = "name";
  const y = 6144;
  t[t.eof = y] = "eof";
  const m = 7680;
  t[t.bracketL = m] = "bracketL";
  const g = 8192;
  t[t.bracketR = g] = "bracketR";
  const b = 9728;
  t[t.braceL = b] = "braceL";
  const v = 10752;
  t[t.braceBarL = v] = "braceBarL";
  const T = 11264;
  t[t.braceR = T] = "braceR";
  const E = 12288;
  t[t.braceBarR = E] = "braceBarR";
  const O = 13824;
  t[t.parenL = O] = "parenL";
  const D = 14336;
  t[t.parenR = D] = "parenR";
  const $ = 15360;
  t[t.comma = $] = "comma";
  const I = 16384;
  t[t.semi = I] = "semi";
  const k = 17408;
  t[t.colon = k] = "colon";
  const L = 18432;
  t[t.doubleColon = L] = "doubleColon";
  const M = 19456;
  t[t.dot = M] = "dot";
  const x = 20480;
  t[t.question = x] = "question";
  const _ = 21504;
  t[t.questionDot = _] = "questionDot";
  const S = 22528;
  t[t.arrow = S] = "arrow";
  const C = 23552;
  t[t.template = C] = "template";
  const R = 24576;
  t[t.ellipsis = R] = "ellipsis";
  const H = 25600;
  t[t.backQuote = H] = "backQuote";
  const z = 27136;
  t[t.dollarBraceL = z] = "dollarBraceL";
  const U = 27648;
  t[t.at = U] = "at";
  const P = 29184;
  t[t.hash = P] = "hash";
  const W = 29728;
  t[t.eq = W] = "eq";
  const B = 30752;
  t[t.assign = B] = "assign";
  const Q = 32640;
  t[t.preIncDec = Q] = "preIncDec";
  const J = 33664;
  t[t.postIncDec = J] = "postIncDec";
  const re = 34432;
  t[t.bang = re] = "bang";
  const G = 35456;
  t[t.tilde = G] = "tilde";
  const N = 35841;
  t[t.pipeline = N] = "pipeline";
  const V = 36866;
  t[t.nullishCoalescing = V] = "nullishCoalescing";
  const F = 37890;
  t[t.logicalOR = F] = "logicalOR";
  const X = 38915;
  t[t.logicalAND = X] = "logicalAND";
  const K = 39940;
  t[t.bitwiseOR = K] = "bitwiseOR";
  const ie = 40965;
  t[t.bitwiseXOR = ie] = "bitwiseXOR";
  const fe = 41990;
  t[t.bitwiseAND = fe] = "bitwiseAND";
  const _e = 43015;
  t[t.equality = _e] = "equality";
  const Ae = 44040;
  t[t.lessThan = Ae] = "lessThan";
  const ce = 45064;
  t[t.greaterThan = ce] = "greaterThan";
  const ee = 46088;
  t[t.relationalOrEqual = ee] = "relationalOrEqual";
  const ae = 47113;
  t[t.bitShiftL = ae] = "bitShiftL";
  const oe = 48137;
  t[t.bitShiftR = oe] = "bitShiftR";
  const me = 49802;
  t[t.plus = me] = "plus";
  const ye = 50826;
  t[t.minus = ye] = "minus";
  const we = 51723;
  t[t.modulo = we] = "modulo";
  const ge = 52235;
  t[t.star = ge] = "star";
  const se = 53259;
  t[t.slash = se] = "slash";
  const be = 54348;
  t[t.exponent = be] = "exponent";
  const Ie = 55296;
  t[t.jsxName = Ie] = "jsxName";
  const Oe = 56320;
  t[t.jsxText = Oe] = "jsxText";
  const Be = 57344;
  t[t.jsxEmptyText = Be] = "jsxEmptyText";
  const Fe = 58880;
  t[t.jsxTagStart = Fe] = "jsxTagStart";
  const ue = 59392;
  t[t.jsxTagEnd = ue] = "jsxTagEnd";
  const te = 60928;
  t[t.typeParameterStart = te] = "typeParameterStart";
  const Y = 61440;
  t[t.nonNullAssertion = Y] = "nonNullAssertion";
  const le = 62480;
  t[t._break = le] = "_break";
  const Ee = 63504;
  t[t._case = Ee] = "_case";
  const Se = 64528;
  t[t._catch = Se] = "_catch";
  const Pe = 65552;
  t[t._continue = Pe] = "_continue";
  const Ve = 66576;
  t[t._debugger = Ve] = "_debugger";
  const Xe = 67600;
  t[t._default = Xe] = "_default";
  const Ye = 68624;
  t[t._do = Ye] = "_do";
  const We = 69648;
  t[t._else = We] = "_else";
  const et = 70672;
  t[t._finally = et] = "_finally";
  const De = 71696;
  t[t._for = De] = "_for";
  const Me = 73232;
  t[t._function = Me] = "_function";
  const Qe = 73744;
  t[t._if = Qe] = "_if";
  const He = 74768;
  t[t._return = He] = "_return";
  const st = 75792;
  t[t._switch = st] = "_switch";
  const it = 77456;
  t[t._throw = it] = "_throw";
  const qe = 77840;
  t[t._try = qe] = "_try";
  const rt = 78864;
  t[t._var = rt] = "_var";
  const bt = 79888;
  t[t._let = bt] = "_let";
  const dt = 80912;
  t[t._const = dt] = "_const";
  const Je = 81936;
  t[t._while = Je] = "_while";
  const mt = 82960;
  t[t._with = mt] = "_with";
  const ut = 84496;
  t[t._new = ut] = "_new";
  const Et = 85520;
  t[t._this = Et] = "_this";
  const Tt = 86544;
  t[t._super = Tt] = "_super";
  const St = 87568;
  t[t._class = St] = "_class";
  const Vt = 88080;
  t[t._extends = Vt] = "_extends";
  const Kt = 89104;
  t[t._export = Kt] = "_export";
  const xt = 90640;
  t[t._import = xt] = "_import";
  const Jt = 91664;
  t[t._yield = Jt] = "_yield";
  const Mt = 92688;
  t[t._null = Mt] = "_null";
  const Bt = 93712;
  t[t._true = Bt] = "_true";
  const It = 94736;
  t[t._false = It] = "_false";
  const jr = 95256;
  t[t._in = jr] = "_in";
  const Cn = 96280;
  t[t._instanceof = Cn] = "_instanceof";
  const an = 97936;
  t[t._typeof = an] = "_typeof";
  const Fr = 98960;
  t[t._void = Fr] = "_void";
  const En = 99984;
  t[t._delete = En] = "_delete";
  const dn = 100880;
  t[t._async = dn] = "_async";
  const on = 101904;
  t[t._get = on] = "_get";
  const vr = 102928;
  t[t._set = vr] = "_set";
  const Vn = 103952;
  t[t._declare = Vn] = "_declare";
  const Cr = 104976;
  t[t._readonly = Cr] = "_readonly";
  const br = 106e3;
  t[t._abstract = br] = "_abstract";
  const _n = 107024;
  t[t._static = _n] = "_static";
  const In = 107536;
  t[t._public = In] = "_public";
  const pn = 108560;
  t[t._private = pn] = "_private";
  const Dr = 109584;
  t[t._protected = Dr] = "_protected";
  const Wn = 110608;
  t[t._override = Wn] = "_override";
  const yi = 112144;
  t[t._as = yi] = "_as";
  const ri = 113168;
  t[t._enum = ri] = "_enum";
  const Nt = 114192;
  t[t._type = Nt] = "_type";
  const Pi = 115216;
  t[t._implements = Pi] = "_implements";
})(j || (j = {}));
function W4(t) {
  switch (t) {
    case j.num:
      return "num";
    case j.bigint:
      return "bigint";
    case j.decimal:
      return "decimal";
    case j.regexp:
      return "regexp";
    case j.string:
      return "string";
    case j.name:
      return "name";
    case j.eof:
      return "eof";
    case j.bracketL:
      return "[";
    case j.bracketR:
      return "]";
    case j.braceL:
      return "{";
    case j.braceBarL:
      return "{|";
    case j.braceR:
      return "}";
    case j.braceBarR:
      return "|}";
    case j.parenL:
      return "(";
    case j.parenR:
      return ")";
    case j.comma:
      return ",";
    case j.semi:
      return ";";
    case j.colon:
      return ":";
    case j.doubleColon:
      return "::";
    case j.dot:
      return ".";
    case j.question:
      return "?";
    case j.questionDot:
      return "?.";
    case j.arrow:
      return "=>";
    case j.template:
      return "template";
    case j.ellipsis:
      return "...";
    case j.backQuote:
      return "`";
    case j.dollarBraceL:
      return "${";
    case j.at:
      return "@";
    case j.hash:
      return "#";
    case j.eq:
      return "=";
    case j.assign:
      return "_=";
    case j.preIncDec:
      return "++/--";
    case j.postIncDec:
      return "++/--";
    case j.bang:
      return "!";
    case j.tilde:
      return "~";
    case j.pipeline:
      return "|>";
    case j.nullishCoalescing:
      return "??";
    case j.logicalOR:
      return "||";
    case j.logicalAND:
      return "&&";
    case j.bitwiseOR:
      return "|";
    case j.bitwiseXOR:
      return "^";
    case j.bitwiseAND:
      return "&";
    case j.equality:
      return "==/!=";
    case j.lessThan:
      return "<";
    case j.greaterThan:
      return ">";
    case j.relationalOrEqual:
      return "<=/>=";
    case j.bitShiftL:
      return "<<";
    case j.bitShiftR:
      return ">>/>>>";
    case j.plus:
      return "+";
    case j.minus:
      return "-";
    case j.modulo:
      return "%";
    case j.star:
      return "*";
    case j.slash:
      return "/";
    case j.exponent:
      return "**";
    case j.jsxName:
      return "jsxName";
    case j.jsxText:
      return "jsxText";
    case j.jsxEmptyText:
      return "jsxEmptyText";
    case j.jsxTagStart:
      return "jsxTagStart";
    case j.jsxTagEnd:
      return "jsxTagEnd";
    case j.typeParameterStart:
      return "typeParameterStart";
    case j.nonNullAssertion:
      return "nonNullAssertion";
    case j._break:
      return "break";
    case j._case:
      return "case";
    case j._catch:
      return "catch";
    case j._continue:
      return "continue";
    case j._debugger:
      return "debugger";
    case j._default:
      return "default";
    case j._do:
      return "do";
    case j._else:
      return "else";
    case j._finally:
      return "finally";
    case j._for:
      return "for";
    case j._function:
      return "function";
    case j._if:
      return "if";
    case j._return:
      return "return";
    case j._switch:
      return "switch";
    case j._throw:
      return "throw";
    case j._try:
      return "try";
    case j._var:
      return "var";
    case j._let:
      return "let";
    case j._const:
      return "const";
    case j._while:
      return "while";
    case j._with:
      return "with";
    case j._new:
      return "new";
    case j._this:
      return "this";
    case j._super:
      return "super";
    case j._class:
      return "class";
    case j._extends:
      return "extends";
    case j._export:
      return "export";
    case j._import:
      return "import";
    case j._yield:
      return "yield";
    case j._null:
      return "null";
    case j._true:
      return "true";
    case j._false:
      return "false";
    case j._in:
      return "in";
    case j._instanceof:
      return "instanceof";
    case j._typeof:
      return "typeof";
    case j._void:
      return "void";
    case j._delete:
      return "delete";
    case j._async:
      return "async";
    case j._get:
      return "get";
    case j._set:
      return "set";
    case j._declare:
      return "declare";
    case j._readonly:
      return "readonly";
    case j._abstract:
      return "abstract";
    case j._static:
      return "static";
    case j._public:
      return "public";
    case j._private:
      return "private";
    case j._protected:
      return "protected";
    case j._override:
      return "override";
    case j._as:
      return "as";
    case j._enum:
      return "enum";
    case j._type:
      return "type";
    case j._implements:
      return "implements";
    default:
      return "";
  }
}
class Bs {
  constructor(e, r, a) {
    this.startTokenIndex = e, this.endTokenIndex = r, this.isFunctionScope = a;
  }
}
class YK {
  constructor(e, r, a, l, d, h, n, u, i, c, f, s, o) {
    this.potentialArrowAt = e, this.noAnonFunctionType = r, this.inDisallowConditionalTypesContext = a, this.tokensLength = l, this.scopesLength = d, this.pos = h, this.type = n, this.contextualKeyword = u, this.start = i, this.end = c, this.isType = f, this.scopeDepth = s, this.error = o;
  }
}
class ai {
  constructor() {
    ai.prototype.__init.call(this), ai.prototype.__init2.call(this), ai.prototype.__init3.call(this), ai.prototype.__init4.call(this), ai.prototype.__init5.call(this), ai.prototype.__init6.call(this), ai.prototype.__init7.call(this), ai.prototype.__init8.call(this), ai.prototype.__init9.call(this), ai.prototype.__init10.call(this), ai.prototype.__init11.call(this), ai.prototype.__init12.call(this), ai.prototype.__init13.call(this);
  }
  // Used to signify the start of a potential arrow function
  __init() {
    this.potentialArrowAt = -1;
  }
  // Used by Flow to handle an edge case involving function type parsing.
  __init2() {
    this.noAnonFunctionType = !1;
  }
  // Used by TypeScript to handle ambiguities when parsing conditional types.
  __init3() {
    this.inDisallowConditionalTypesContext = !1;
  }
  // Token store.
  __init4() {
    this.tokens = [];
  }
  // Array of all observed scopes, ordered by their ending position.
  __init5() {
    this.scopes = [];
  }
  // The current position of the tokenizer in the input.
  __init6() {
    this.pos = 0;
  }
  // Information about the current token.
  __init7() {
    this.type = j.eof;
  }
  __init8() {
    this.contextualKeyword = $e.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = !1;
  }
  __init12() {
    this.scopeDepth = 0;
  }
  /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new YK(
      this.potentialArrowAt,
      this.noAnonFunctionType,
      this.inDisallowConditionalTypesContext,
      this.tokens.length,
      this.scopes.length,
      this.pos,
      this.type,
      this.contextualKeyword,
      this.start,
      this.end,
      this.isType,
      this.scopeDepth,
      this.error
    );
  }
  restoreFromSnapshot(e) {
    this.potentialArrowAt = e.potentialArrowAt, this.noAnonFunctionType = e.noAnonFunctionType, this.inDisallowConditionalTypesContext = e.inDisallowConditionalTypesContext, this.tokens.length = e.tokensLength, this.scopes.length = e.scopesLength, this.pos = e.pos, this.type = e.type, this.contextualKeyword = e.contextualKeyword, this.start = e.start, this.end = e.end, this.isType = e.isType, this.scopeDepth = e.scopeDepth, this.error = e.error;
  }
}
var ze;
(function(t) {
  t[t.backSpace = 8] = "backSpace";
  const r = 10;
  t[t.lineFeed = r] = "lineFeed";
  const a = 9;
  t[t.tab = a] = "tab";
  const l = 13;
  t[t.carriageReturn = l] = "carriageReturn";
  const d = 14;
  t[t.shiftOut = d] = "shiftOut";
  const h = 32;
  t[t.space = h] = "space";
  const n = 33;
  t[t.exclamationMark = n] = "exclamationMark";
  const u = 34;
  t[t.quotationMark = u] = "quotationMark";
  const i = 35;
  t[t.numberSign = i] = "numberSign";
  const c = 36;
  t[t.dollarSign = c] = "dollarSign";
  const f = 37;
  t[t.percentSign = f] = "percentSign";
  const s = 38;
  t[t.ampersand = s] = "ampersand";
  const o = 39;
  t[t.apostrophe = o] = "apostrophe";
  const y = 40;
  t[t.leftParenthesis = y] = "leftParenthesis";
  const m = 41;
  t[t.rightParenthesis = m] = "rightParenthesis";
  const g = 42;
  t[t.asterisk = g] = "asterisk";
  const b = 43;
  t[t.plusSign = b] = "plusSign";
  const v = 44;
  t[t.comma = v] = "comma";
  const T = 45;
  t[t.dash = T] = "dash";
  const E = 46;
  t[t.dot = E] = "dot";
  const O = 47;
  t[t.slash = O] = "slash";
  const D = 48;
  t[t.digit0 = D] = "digit0";
  const $ = 49;
  t[t.digit1 = $] = "digit1";
  const I = 50;
  t[t.digit2 = I] = "digit2";
  const k = 51;
  t[t.digit3 = k] = "digit3";
  const L = 52;
  t[t.digit4 = L] = "digit4";
  const M = 53;
  t[t.digit5 = M] = "digit5";
  const x = 54;
  t[t.digit6 = x] = "digit6";
  const _ = 55;
  t[t.digit7 = _] = "digit7";
  const S = 56;
  t[t.digit8 = S] = "digit8";
  const C = 57;
  t[t.digit9 = C] = "digit9";
  const R = 58;
  t[t.colon = R] = "colon";
  const H = 59;
  t[t.semicolon = H] = "semicolon";
  const z = 60;
  t[t.lessThan = z] = "lessThan";
  const U = 61;
  t[t.equalsTo = U] = "equalsTo";
  const P = 62;
  t[t.greaterThan = P] = "greaterThan";
  const W = 63;
  t[t.questionMark = W] = "questionMark";
  const B = 64;
  t[t.atSign = B] = "atSign";
  const Q = 65;
  t[t.uppercaseA = Q] = "uppercaseA";
  const J = 66;
  t[t.uppercaseB = J] = "uppercaseB";
  const re = 67;
  t[t.uppercaseC = re] = "uppercaseC";
  const G = 68;
  t[t.uppercaseD = G] = "uppercaseD";
  const N = 69;
  t[t.uppercaseE = N] = "uppercaseE";
  const V = 70;
  t[t.uppercaseF = V] = "uppercaseF";
  const F = 71;
  t[t.uppercaseG = F] = "uppercaseG";
  const X = 72;
  t[t.uppercaseH = X] = "uppercaseH";
  const K = 73;
  t[t.uppercaseI = K] = "uppercaseI";
  const ie = 74;
  t[t.uppercaseJ = ie] = "uppercaseJ";
  const fe = 75;
  t[t.uppercaseK = fe] = "uppercaseK";
  const _e = 76;
  t[t.uppercaseL = _e] = "uppercaseL";
  const Ae = 77;
  t[t.uppercaseM = Ae] = "uppercaseM";
  const ce = 78;
  t[t.uppercaseN = ce] = "uppercaseN";
  const ee = 79;
  t[t.uppercaseO = ee] = "uppercaseO";
  const ae = 80;
  t[t.uppercaseP = ae] = "uppercaseP";
  const oe = 81;
  t[t.uppercaseQ = oe] = "uppercaseQ";
  const me = 82;
  t[t.uppercaseR = me] = "uppercaseR";
  const ye = 83;
  t[t.uppercaseS = ye] = "uppercaseS";
  const we = 84;
  t[t.uppercaseT = we] = "uppercaseT";
  const ge = 85;
  t[t.uppercaseU = ge] = "uppercaseU";
  const se = 86;
  t[t.uppercaseV = se] = "uppercaseV";
  const be = 87;
  t[t.uppercaseW = be] = "uppercaseW";
  const Ie = 88;
  t[t.uppercaseX = Ie] = "uppercaseX";
  const Oe = 89;
  t[t.uppercaseY = Oe] = "uppercaseY";
  const Be = 90;
  t[t.uppercaseZ = Be] = "uppercaseZ";
  const Fe = 91;
  t[t.leftSquareBracket = Fe] = "leftSquareBracket";
  const ue = 92;
  t[t.backslash = ue] = "backslash";
  const te = 93;
  t[t.rightSquareBracket = te] = "rightSquareBracket";
  const Y = 94;
  t[t.caret = Y] = "caret";
  const le = 95;
  t[t.underscore = le] = "underscore";
  const Ee = 96;
  t[t.graveAccent = Ee] = "graveAccent";
  const Se = 97;
  t[t.lowercaseA = Se] = "lowercaseA";
  const Pe = 98;
  t[t.lowercaseB = Pe] = "lowercaseB";
  const Ve = 99;
  t[t.lowercaseC = Ve] = "lowercaseC";
  const Xe = 100;
  t[t.lowercaseD = Xe] = "lowercaseD";
  const Ye = 101;
  t[t.lowercaseE = Ye] = "lowercaseE";
  const We = 102;
  t[t.lowercaseF = We] = "lowercaseF";
  const et = 103;
  t[t.lowercaseG = et] = "lowercaseG";
  const De = 104;
  t[t.lowercaseH = De] = "lowercaseH";
  const Me = 105;
  t[t.lowercaseI = Me] = "lowercaseI";
  const Qe = 106;
  t[t.lowercaseJ = Qe] = "lowercaseJ";
  const He = 107;
  t[t.lowercaseK = He] = "lowercaseK";
  const st = 108;
  t[t.lowercaseL = st] = "lowercaseL";
  const it = 109;
  t[t.lowercaseM = it] = "lowercaseM";
  const qe = 110;
  t[t.lowercaseN = qe] = "lowercaseN";
  const rt = 111;
  t[t.lowercaseO = rt] = "lowercaseO";
  const bt = 112;
  t[t.lowercaseP = bt] = "lowercaseP";
  const dt = 113;
  t[t.lowercaseQ = dt] = "lowercaseQ";
  const Je = 114;
  t[t.lowercaseR = Je] = "lowercaseR";
  const mt = 115;
  t[t.lowercaseS = mt] = "lowercaseS";
  const ut = 116;
  t[t.lowercaseT = ut] = "lowercaseT";
  const Et = 117;
  t[t.lowercaseU = Et] = "lowercaseU";
  const Tt = 118;
  t[t.lowercaseV = Tt] = "lowercaseV";
  const St = 119;
  t[t.lowercaseW = St] = "lowercaseW";
  const Vt = 120;
  t[t.lowercaseX = Vt] = "lowercaseX";
  const Kt = 121;
  t[t.lowercaseY = Kt] = "lowercaseY";
  const xt = 122;
  t[t.lowercaseZ = xt] = "lowercaseZ";
  const Jt = 123;
  t[t.leftCurlyBrace = Jt] = "leftCurlyBrace";
  const Mt = 124;
  t[t.verticalBar = Mt] = "verticalBar";
  const Bt = 125;
  t[t.rightCurlyBrace = Bt] = "rightCurlyBrace";
  const It = 126;
  t[t.tilde = It] = "tilde";
  const jr = 160;
  t[t.nonBreakingSpace = jr] = "nonBreakingSpace";
  const Cn = 5760;
  t[t.oghamSpaceMark = Cn] = "oghamSpaceMark";
  const an = 8232;
  t[t.lineSeparator = an] = "lineSeparator";
  const Fr = 8233;
  t[t.paragraphSeparator = Fr] = "paragraphSeparator";
})(ze || (ze = {}));
let Bp, pr, gr, de, _t, q4;
function Ru() {
  return q4++;
}
function XK(t) {
  if ("pos" in t) {
    const e = QK(t.pos);
    t.message += ` (${e.line}:${e.column})`, t.loc = e;
  }
  return t;
}
class JK {
  constructor(e, r) {
    this.line = e, this.column = r;
  }
}
function QK(t) {
  let e = 1, r = 1;
  for (let a = 0; a < t; a++)
    _t.charCodeAt(a) === ze.lineFeed ? (e++, r = 1) : r++;
  return new JK(e, r);
}
function ZK(t, e, r, a) {
  _t = t, de = new ai(), q4 = 1, Bp = e, pr = r, gr = a;
}
function Rt(t) {
  return de.contextualKeyword === t;
}
function xg(t) {
  const e = Ec();
  return e.type === j.name && e.contextualKeyword === t;
}
function gn(t) {
  return de.contextualKeyword === t && at(j.name);
}
function sn(t) {
  gn(t) || er();
}
function Ei() {
  return Ne(j.eof) || Ne(j.braceR) || li();
}
function li() {
  const t = de.tokens[de.tokens.length - 1], e = t ? t.end : 0;
  for (let r = e; r < de.start; r++) {
    const a = _t.charCodeAt(r);
    if (a === ze.lineFeed || a === ze.carriageReturn || a === 8232 || a === 8233)
      return !0;
  }
  return !1;
}
function H4() {
  const t = Tg();
  for (let e = de.end; e < t; e++) {
    const r = _t.charCodeAt(e);
    if (r === ze.lineFeed || r === ze.carriageReturn || r === 8232 || r === 8233)
      return !0;
  }
  return !1;
}
function As() {
  return at(j.semi) || Ei();
}
function Ur() {
  As() || er('Unexpected token, expected ";"');
}
function ct(t) {
  at(t) || er(`Unexpected token, expected "${W4(t)}"`);
}
function er(t = "Unexpected token", e = de.start) {
  if (de.error)
    return;
  const r = new SyntaxError(t);
  r.pos = e, de.error = r, de.pos = _t.length, Zt(j.eof);
}
const G4 = [
  9,
  11,
  12,
  ze.space,
  ze.nonBreakingSpace,
  ze.oghamSpaceMark,
  8192,
  // EN QUAD
  8193,
  // EM QUAD
  8194,
  // EN SPACE
  8195,
  // EM SPACE
  8196,
  // THREE-PER-EM SPACE
  8197,
  // FOUR-PER-EM SPACE
  8198,
  // SIX-PER-EM SPACE
  8199,
  // FIGURE SPACE
  8200,
  // PUNCTUATION SPACE
  8201,
  // THIN SPACE
  8202,
  // HAIR SPACE
  8239,
  // NARROW NO-BREAK SPACE
  8287,
  // MEDIUM MATHEMATICAL SPACE
  12288,
  // IDEOGRAPHIC SPACE
  65279
  // ZERO WIDTH NO-BREAK SPACE
], gw = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, z4 = new Uint8Array(65536);
for (const t of G4)
  z4[t] = 1;
function eY(t) {
  if (t < 48) return t === 36;
  if (t < 58) return !0;
  if (t < 65) return !1;
  if (t < 91) return !0;
  if (t < 97) return t === 95;
  if (t < 123) return !0;
  if (t < 128) return !1;
  throw new Error("Should not be called with non-ASCII char code.");
}
const ss = new Uint8Array(65536);
for (let t = 0; t < 128; t++)
  ss[t] = eY(t) ? 1 : 0;
for (let t = 128; t < 65536; t++)
  ss[t] = 1;
for (const t of G4)
  ss[t] = 0;
ss[8232] = 0;
ss[8233] = 0;
const vc = ss.slice();
for (let t = ze.digit0; t <= ze.digit9; t++)
  vc[t] = 0;
const vw = new Int32Array([
  // ""
  -1,
  27,
  783,
  918,
  1755,
  2376,
  2862,
  3483,
  -1,
  3699,
  -1,
  4617,
  4752,
  4833,
  5130,
  5508,
  5940,
  -1,
  6480,
  6939,
  7749,
  8181,
  8451,
  8613,
  -1,
  8829,
  -1,
  // "a"
  -1,
  -1,
  54,
  243,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  432,
  -1,
  -1,
  -1,
  675,
  -1,
  -1,
  -1,
  // "ab"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  81,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abs"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  108,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abst"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  135,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstr"
  -1,
  162,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstra"
  -1,
  -1,
  -1,
  189,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstrac"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  216,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "abstract"
  $e._abstract << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ac"
  -1,
  -1,
  -1,
  270,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acc"
  -1,
  -1,
  -1,
  -1,
  -1,
  297,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acce"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  324,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "acces"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  351,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "access"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  378,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accesso"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  405,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "accessor"
  $e._accessor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "as"
  $e._as << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  459,
  -1,
  -1,
  -1,
  -1,
  -1,
  594,
  -1,
  // "ass"
  -1,
  -1,
  -1,
  -1,
  -1,
  486,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asse"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  513,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asser"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  540,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "assert"
  $e._assert << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  567,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asserts"
  $e._asserts << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  621,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "asyn"
  -1,
  -1,
  -1,
  648,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "async"
  $e._async << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "aw"
  -1,
  702,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  729,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "awai"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  756,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "await"
  $e._await << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "b"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  810,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "br"
  -1,
  -1,
  -1,
  -1,
  -1,
  837,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "bre"
  -1,
  864,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "brea"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  891,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "break"
  (j._break << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "c"
  -1,
  945,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1107,
  -1,
  -1,
  -1,
  1242,
  -1,
  -1,
  1350,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ca"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  972,
  1026,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cas"
  -1,
  -1,
  -1,
  -1,
  -1,
  999,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "case"
  (j._case << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cat"
  -1,
  -1,
  -1,
  1053,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1080,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "catch"
  (j._catch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ch"
  -1,
  -1,
  -1,
  -1,
  -1,
  1134,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "che"
  -1,
  -1,
  -1,
  1161,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "chec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1188,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "check"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1215,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "checks"
  $e._checks << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cl"
  -1,
  1269,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1296,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "clas"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1323,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "class"
  (j._class << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "co"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1377,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "con"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1404,
  1620,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cons"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1431,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "const"
  (j._const << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1458,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1485,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constru"
  -1,
  -1,
  -1,
  1512,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1539,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "construct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1566,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1593,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "constructor"
  $e._constructor << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "cont"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1647,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "conti"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1674,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "contin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1701,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continu"
  -1,
  -1,
  -1,
  -1,
  -1,
  1728,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "continue"
  (j._continue << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "d"
  -1,
  -1,
  -1,
  -1,
  -1,
  1782,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2349,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "de"
  -1,
  -1,
  1809,
  1971,
  -1,
  -1,
  2106,
  -1,
  -1,
  -1,
  -1,
  -1,
  2241,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "deb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1836,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1863,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debug"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1890,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugg"
  -1,
  -1,
  -1,
  -1,
  -1,
  1917,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1944,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "debugger"
  (j._debugger << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  1998,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decl"
  -1,
  2025,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "decla"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2052,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declar"
  -1,
  -1,
  -1,
  -1,
  -1,
  2079,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "declare"
  $e._declare << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "def"
  -1,
  2133,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2160,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defau"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2187,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "defaul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2214,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "default"
  (j._default << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "del"
  -1,
  -1,
  -1,
  -1,
  -1,
  2268,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "dele"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2295,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delet"
  -1,
  -1,
  -1,
  -1,
  -1,
  2322,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "delete"
  (j._delete << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "do"
  (j._do << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "e"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2403,
  -1,
  2484,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2565,
  -1,
  -1,
  // "el"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2430,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "els"
  -1,
  -1,
  -1,
  -1,
  -1,
  2457,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "else"
  (j._else << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "en"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2511,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2538,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "enum"
  $e._enum << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ex"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2592,
  -1,
  -1,
  -1,
  2727,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2619,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2646,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "expor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2673,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "export"
  (j._export << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2700,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exports"
  $e._exports << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ext"
  -1,
  -1,
  -1,
  -1,
  -1,
  2754,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2781,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "exten"
  -1,
  -1,
  -1,
  -1,
  2808,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extend"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2835,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "extends"
  (j._extends << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "f"
  -1,
  2889,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2997,
  -1,
  -1,
  -1,
  -1,
  -1,
  3159,
  -1,
  -1,
  3213,
  -1,
  -1,
  3294,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2916,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fal"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2943,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fals"
  -1,
  -1,
  -1,
  -1,
  -1,
  2970,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "false"
  (j._false << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3024,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fin"
  -1,
  3051,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fina"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3078,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "final"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3105,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "finall"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3132,
  -1,
  // "finally"
  (j._finally << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3186,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "for"
  (j._for << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3240,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3267,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "from"
  $e._from << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3321,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "fun"
  -1,
  -1,
  -1,
  3348,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "func"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3375,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "funct"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3402,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3429,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "functio"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3456,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "function"
  (j._function << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "g"
  -1,
  -1,
  -1,
  -1,
  -1,
  3510,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3564,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ge"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3537,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "get"
  $e._get << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "gl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3591,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glo"
  -1,
  -1,
  3618,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "glob"
  -1,
  3645,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "globa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3672,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "global"
  $e._global << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "i"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3726,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3753,
  4077,
  -1,
  -1,
  -1,
  -1,
  4590,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "if"
  (j._if << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "im"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3780,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imp"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3807,
  -1,
  -1,
  3996,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impl"
  -1,
  -1,
  -1,
  -1,
  -1,
  3834,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "imple"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3861,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implem"
  -1,
  -1,
  -1,
  -1,
  -1,
  3888,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impleme"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3915,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implemen"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3942,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implement"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  3969,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "implements"
  $e._implements << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4023,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "impor"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4050,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "import"
  (j._import << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "in"
  (j._in << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4104,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4185,
  4401,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inf"
  -1,
  -1,
  -1,
  -1,
  -1,
  4131,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4158,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "infer"
  $e._infer << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ins"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4212,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inst"
  -1,
  4239,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "insta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4266,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instan"
  -1,
  -1,
  -1,
  4293,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanc"
  -1,
  -1,
  -1,
  -1,
  -1,
  4320,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instance"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4347,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4374,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "instanceof"
  (j._instanceof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "int"
  -1,
  -1,
  -1,
  -1,
  -1,
  4428,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inte"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4455,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "inter"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4482,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interf"
  -1,
  4509,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfa"
  -1,
  -1,
  -1,
  4536,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interfac"
  -1,
  -1,
  -1,
  -1,
  -1,
  4563,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "interface"
  $e._interface << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "is"
  $e._is << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "k"
  -1,
  -1,
  -1,
  -1,
  -1,
  4644,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ke"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4671,
  -1,
  // "key"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4698,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4725,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "keyof"
  $e._keyof << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "l"
  -1,
  -1,
  -1,
  -1,
  -1,
  4779,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "le"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4806,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "let"
  (j._let << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "m"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4860,
  -1,
  -1,
  -1,
  -1,
  -1,
  4995,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4887,
  -1,
  -1,
  // "mix"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4914,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4941,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  4968,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mixins"
  $e._mixins << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mo"
  -1,
  -1,
  -1,
  -1,
  5022,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "mod"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5049,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5076,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "modul"
  -1,
  -1,
  -1,
  -1,
  -1,
  5103,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "module"
  $e._module << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "n"
  -1,
  5157,
  -1,
  -1,
  -1,
  5373,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5427,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "na"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5184,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nam"
  -1,
  -1,
  -1,
  -1,
  -1,
  5211,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "name"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5238,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "names"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5265,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namesp"
  -1,
  5292,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespa"
  -1,
  -1,
  -1,
  5319,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespac"
  -1,
  -1,
  -1,
  -1,
  -1,
  5346,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "namespace"
  $e._namespace << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ne"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5400,
  -1,
  -1,
  -1,
  // "new"
  (j._new << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5454,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "nul"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5481,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "null"
  (j._null << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "o"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5535,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5562,
  -1,
  -1,
  -1,
  -1,
  5697,
  5751,
  -1,
  -1,
  -1,
  -1,
  // "of"
  $e._of << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "op"
  -1,
  5589,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5616,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5643,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  5670,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "opaque"
  $e._opaque << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ou"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5724,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "out"
  $e._out << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ov"
  -1,
  -1,
  -1,
  -1,
  -1,
  5778,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ove"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5805,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "over"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5832,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5859,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overri"
  -1,
  -1,
  -1,
  -1,
  5886,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "overrid"
  -1,
  -1,
  -1,
  -1,
  -1,
  5913,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "override"
  $e._override << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "p"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5967,
  -1,
  -1,
  6345,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  5994,
  -1,
  -1,
  -1,
  -1,
  -1,
  6129,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pri"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6021,
  -1,
  -1,
  -1,
  -1,
  // "priv"
  -1,
  6048,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "priva"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6075,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "privat"
  -1,
  -1,
  -1,
  -1,
  -1,
  6102,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "private"
  $e._private << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6156,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prot"
  -1,
  -1,
  -1,
  -1,
  -1,
  6183,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6318,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "prote"
  -1,
  -1,
  -1,
  6210,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protec"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6237,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protect"
  -1,
  -1,
  -1,
  -1,
  -1,
  6264,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protecte"
  -1,
  -1,
  -1,
  -1,
  6291,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "protected"
  $e._protected << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "proto"
  $e._proto << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pu"
  -1,
  -1,
  6372,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "pub"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6399,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6426,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "publi"
  -1,
  -1,
  -1,
  6453,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "public"
  $e._public << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "r"
  -1,
  -1,
  -1,
  -1,
  -1,
  6507,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "re"
  -1,
  6534,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6696,
  -1,
  -1,
  6831,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "rea"
  -1,
  -1,
  -1,
  -1,
  6561,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "read"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6588,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "reado"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6615,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readon"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6642,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "readonl"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6669,
  -1,
  // "readonly"
  $e._readonly << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "req"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6723,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requ"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6750,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6777,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "requir"
  -1,
  -1,
  -1,
  -1,
  -1,
  6804,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "require"
  $e._require << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ret"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6858,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retu"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6885,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "retur"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6912,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "return"
  (j._return << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "s"
  -1,
  6966,
  -1,
  -1,
  -1,
  7182,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7236,
  7371,
  -1,
  7479,
  -1,
  7614,
  -1,
  // "sa"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  6993,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7020,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sati"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7047,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satis"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7074,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisf"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7101,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfi"
  -1,
  -1,
  -1,
  -1,
  -1,
  7128,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7155,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "satisfies"
  $e._satisfies << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "se"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7209,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "set"
  $e._set << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "st"
  -1,
  7263,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sta"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7290,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stat"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7317,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "stati"
  -1,
  -1,
  -1,
  7344,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "static"
  $e._static << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "su"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7398,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sup"
  -1,
  -1,
  -1,
  -1,
  -1,
  7425,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "supe"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7452,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "super"
  (j._super << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sw"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7506,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7533,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "swit"
  -1,
  -1,
  -1,
  7560,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switc"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7587,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "switch"
  (j._switch << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sy"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7641,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "sym"
  -1,
  -1,
  7668,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symb"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7695,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7722,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "symbol"
  $e._symbol << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "t"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7776,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7938,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8046,
  -1,
  // "th"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7803,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7857,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7830,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "this"
  (j._this << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7884,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "thro"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7911,
  -1,
  -1,
  -1,
  // "throw"
  (j._throw << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "tr"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  7965,
  -1,
  -1,
  -1,
  8019,
  -1,
  // "tru"
  -1,
  -1,
  -1,
  -1,
  -1,
  7992,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "true"
  (j._true << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "try"
  (j._try << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "ty"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8073,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typ"
  -1,
  -1,
  -1,
  -1,
  -1,
  8100,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "type"
  $e._type << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8127,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8154,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "typeof"
  (j._typeof << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "u"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8208,
  -1,
  -1,
  -1,
  -1,
  8343,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "un"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8235,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uni"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8262,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniq"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8289,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "uniqu"
  -1,
  -1,
  -1,
  -1,
  -1,
  8316,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "unique"
  $e._unique << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "us"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8370,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8397,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "usin"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8424,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "using"
  $e._using << 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "v"
  -1,
  8478,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8532,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "va"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8505,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "var"
  (j._var << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "vo"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8559,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "voi"
  -1,
  -1,
  -1,
  -1,
  8586,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "void"
  (j._void << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "w"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8640,
  8748,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wh"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8667,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8694,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "whil"
  -1,
  -1,
  -1,
  -1,
  -1,
  8721,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "while"
  (j._while << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wi"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8775,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "wit"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8802,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "with"
  (j._with << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "y"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8856,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yi"
  -1,
  -1,
  -1,
  -1,
  -1,
  8883,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yie"
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  8910,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yiel"
  -1,
  -1,
  -1,
  -1,
  8937,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  // "yield"
  (j._yield << 1) + 1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
]);
function tY() {
  let t = 0, e = 0, r = de.pos;
  for (; r < _t.length && (e = _t.charCodeAt(r), !(e < ze.lowercaseA || e > ze.lowercaseZ)); ) {
    const l = vw[t + (e - ze.lowercaseA) + 1];
    if (l === -1)
      break;
    t = l, r++;
  }
  const a = vw[t];
  if (a > -1 && !ss[e]) {
    de.pos = r, a & 1 ? Zt(a >>> 1) : Zt(j.name, a >>> 1);
    return;
  }
  for (; r < _t.length; ) {
    const l = _t.charCodeAt(r);
    if (ss[l])
      r++;
    else if (l === ze.backslash) {
      if (r += 2, _t.charCodeAt(r) === ze.leftCurlyBrace) {
        for (; r < _t.length && _t.charCodeAt(r) !== ze.rightCurlyBrace; )
          r++;
        r++;
      }
    } else if (l === ze.atSign && _t.charCodeAt(r + 1) === ze.atSign)
      r += 2;
    else
      break;
  }
  de.pos = r, Zt(j.name);
}
var Ut;
(function(t) {
  t[t.Access = 0] = "Access";
  const r = 1;
  t[t.ExportAccess = r] = "ExportAccess";
  const a = r + 1;
  t[t.TopLevelDeclaration = a] = "TopLevelDeclaration";
  const l = a + 1;
  t[t.FunctionScopedDeclaration = l] = "FunctionScopedDeclaration";
  const d = l + 1;
  t[t.BlockScopedDeclaration = d] = "BlockScopedDeclaration";
  const h = d + 1;
  t[t.ObjectShorthandTopLevelDeclaration = h] = "ObjectShorthandTopLevelDeclaration";
  const n = h + 1;
  t[t.ObjectShorthandFunctionScopedDeclaration = n] = "ObjectShorthandFunctionScopedDeclaration";
  const u = n + 1;
  t[t.ObjectShorthandBlockScopedDeclaration = u] = "ObjectShorthandBlockScopedDeclaration";
  const i = u + 1;
  t[t.ObjectShorthand = i] = "ObjectShorthand";
  const c = i + 1;
  t[t.ImportDeclaration = c] = "ImportDeclaration";
  const f = c + 1;
  t[t.ObjectKey = f] = "ObjectKey";
  const s = f + 1;
  t[t.ImportAccess = s] = "ImportAccess";
})(Ut || (Ut = {}));
var ts;
(function(t) {
  t[t.NoChildren = 0] = "NoChildren";
  const r = 1;
  t[t.OneChild = r] = "OneChild";
  const a = r + 1;
  t[t.StaticChildren = a] = "StaticChildren";
  const l = a + 1;
  t[t.KeyAfterPropSpread = l] = "KeyAfterPropSpread";
})(ts || (ts = {}));
function K4(t) {
  const e = t.identifierRole;
  return e === Ut.TopLevelDeclaration || e === Ut.FunctionScopedDeclaration || e === Ut.BlockScopedDeclaration || e === Ut.ObjectShorthandTopLevelDeclaration || e === Ut.ObjectShorthandFunctionScopedDeclaration || e === Ut.ObjectShorthandBlockScopedDeclaration;
}
function rY(t) {
  const e = t.identifierRole;
  return e === Ut.FunctionScopedDeclaration || e === Ut.BlockScopedDeclaration || e === Ut.ObjectShorthandFunctionScopedDeclaration || e === Ut.ObjectShorthandBlockScopedDeclaration;
}
function Y4(t) {
  const e = t.identifierRole;
  return e === Ut.TopLevelDeclaration || e === Ut.ObjectShorthandTopLevelDeclaration || e === Ut.ImportDeclaration;
}
function nY(t) {
  const e = t.identifierRole;
  return e === Ut.TopLevelDeclaration || e === Ut.BlockScopedDeclaration || e === Ut.ObjectShorthandTopLevelDeclaration || e === Ut.ObjectShorthandBlockScopedDeclaration;
}
function iY(t) {
  const e = t.identifierRole;
  return e === Ut.FunctionScopedDeclaration || e === Ut.ObjectShorthandFunctionScopedDeclaration;
}
function sY(t) {
  return t.identifierRole === Ut.ObjectShorthandTopLevelDeclaration || t.identifierRole === Ut.ObjectShorthandBlockScopedDeclaration || t.identifierRole === Ut.ObjectShorthandFunctionScopedDeclaration;
}
class $p {
  constructor() {
    this.type = de.type, this.contextualKeyword = de.contextualKeyword, this.start = de.start, this.end = de.end, this.scopeDepth = de.scopeDepth, this.isType = de.isType, this.identifierRole = null, this.jsxRole = null, this.shadowsGlobal = !1, this.isAsyncOperation = !1, this.contextId = null, this.rhsEndIndex = null, this.isExpression = !1, this.numNullishCoalesceStarts = 0, this.numNullishCoalesceEnds = 0, this.isOptionalChainStart = !1, this.isOptionalChainEnd = !1, this.subscriptStartIndex = null, this.nullishStartIndex = null;
  }
  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.
  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.
  // For assignments, the index of the RHS. For export tokens, the end of the export.
  // For class tokens, records if the class is a class expression or a class statement.
  // Number of times to insert a `nullishCoalesce(` snippet before this token.
  // Number of times to insert a `)` snippet after this token.
  // If true, insert an `optionalChain([` snippet before this token.
  // If true, insert a `])` snippet after this token.
  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.
  // Tag for `??` operators to denote the root token for this nullish coalescing call.
}
function ft() {
  de.tokens.push(new $p()), Z4();
}
function va() {
  de.tokens.push(new $p()), de.start = de.pos, SY();
}
function aY() {
  de.type === j.assign && --de.pos, vY();
}
function nr(t) {
  for (let r = de.tokens.length - t; r < de.tokens.length; r++)
    de.tokens[r].isType = !0;
  const e = de.isType;
  return de.isType = !0, e;
}
function tr(t) {
  de.isType = t;
}
function at(t) {
  return Ne(t) ? (ft(), !0) : !1;
}
function X4(t) {
  const e = de.isType;
  de.isType = !0, at(t), de.isType = e;
}
function Ne(t) {
  return de.type === t;
}
function Yr() {
  const t = de.snapshot();
  ft();
  const e = de.type;
  return de.restoreFromSnapshot(t), e;
}
class oY {
  constructor(e, r) {
    this.type = e, this.contextualKeyword = r;
  }
}
function Ec() {
  const t = de.snapshot();
  ft();
  const e = de.type, r = de.contextualKeyword;
  return de.restoreFromSnapshot(t), new oY(e, r);
}
function Tg() {
  return J4(de.pos);
}
function J4(t) {
  gw.lastIndex = t;
  const e = gw.exec(_t);
  return t + e[0].length;
}
function Q4() {
  return _t.charCodeAt(Tg());
}
function Z4() {
  if (tC(), de.start = de.pos, de.pos >= _t.length) {
    const t = de.tokens;
    t.length >= 2 && t[t.length - 1].start >= _t.length && t[t.length - 2].start >= _t.length && er("Unexpectedly reached the end of input."), Zt(j.eof);
    return;
  }
  lY(_t.charCodeAt(de.pos));
}
function lY(t) {
  vc[t] || t === ze.backslash || t === ze.atSign && _t.charCodeAt(de.pos + 1) === ze.atSign ? tY() : iC(t);
}
function uY() {
  for (; _t.charCodeAt(de.pos) !== ze.asterisk || _t.charCodeAt(de.pos + 1) !== ze.slash; )
    if (de.pos++, de.pos > _t.length) {
      er("Unterminated comment", de.pos - 2);
      return;
    }
  de.pos += 2;
}
function eC(t) {
  let e = _t.charCodeAt(de.pos += t);
  if (de.pos < _t.length)
    for (; e !== ze.lineFeed && e !== ze.carriageReturn && e !== ze.lineSeparator && e !== ze.paragraphSeparator && ++de.pos < _t.length; )
      e = _t.charCodeAt(de.pos);
}
function tC() {
  for (; de.pos < _t.length; ) {
    const t = _t.charCodeAt(de.pos);
    switch (t) {
      case ze.carriageReturn:
        _t.charCodeAt(de.pos + 1) === ze.lineFeed && ++de.pos;
      case ze.lineFeed:
      case ze.lineSeparator:
      case ze.paragraphSeparator:
        ++de.pos;
        break;
      case ze.slash:
        switch (_t.charCodeAt(de.pos + 1)) {
          case ze.asterisk:
            de.pos += 2, uY();
            break;
          case ze.slash:
            eC(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (z4[t])
          ++de.pos;
        else
          return;
    }
  }
}
function Zt(t, e = $e.NONE) {
  de.end = de.pos, de.type = t, de.contextualKeyword = e;
}
function cY() {
  const t = _t.charCodeAt(de.pos + 1);
  if (t >= ze.digit0 && t <= ze.digit9) {
    sC(!0);
    return;
  }
  t === ze.dot && _t.charCodeAt(de.pos + 2) === ze.dot ? (de.pos += 3, Zt(j.ellipsis)) : (++de.pos, Zt(j.dot));
}
function fY() {
  _t.charCodeAt(de.pos + 1) === ze.equalsTo ? Sr(j.assign, 2) : Sr(j.slash, 1);
}
function dY(t) {
  let e = t === ze.asterisk ? j.star : j.modulo, r = 1, a = _t.charCodeAt(de.pos + 1);
  t === ze.asterisk && a === ze.asterisk && (r++, a = _t.charCodeAt(de.pos + 2), e = j.exponent), a === ze.equalsTo && _t.charCodeAt(de.pos + 2) !== ze.greaterThan && (r++, e = j.assign), Sr(e, r);
}
function pY(t) {
  const e = _t.charCodeAt(de.pos + 1);
  if (e === t) {
    _t.charCodeAt(de.pos + 2) === ze.equalsTo ? Sr(j.assign, 3) : Sr(t === ze.verticalBar ? j.logicalOR : j.logicalAND, 2);
    return;
  }
  if (t === ze.verticalBar) {
    if (e === ze.greaterThan) {
      Sr(j.pipeline, 2);
      return;
    } else if (e === ze.rightCurlyBrace && gr) {
      Sr(j.braceBarR, 2);
      return;
    }
  }
  if (e === ze.equalsTo) {
    Sr(j.assign, 2);
    return;
  }
  Sr(t === ze.verticalBar ? j.bitwiseOR : j.bitwiseAND, 1);
}
function hY() {
  _t.charCodeAt(de.pos + 1) === ze.equalsTo ? Sr(j.assign, 2) : Sr(j.bitwiseXOR, 1);
}
function mY(t) {
  const e = _t.charCodeAt(de.pos + 1);
  if (e === t) {
    Sr(j.preIncDec, 2);
    return;
  }
  e === ze.equalsTo ? Sr(j.assign, 2) : t === ze.plusSign ? Sr(j.plus, 1) : Sr(j.minus, 1);
}
function yY() {
  const t = _t.charCodeAt(de.pos + 1);
  if (t === ze.lessThan) {
    if (_t.charCodeAt(de.pos + 2) === ze.equalsTo) {
      Sr(j.assign, 3);
      return;
    }
    de.isType ? Sr(j.lessThan, 1) : Sr(j.bitShiftL, 2);
    return;
  }
  t === ze.equalsTo ? Sr(j.relationalOrEqual, 2) : Sr(j.lessThan, 1);
}
function rC() {
  if (de.isType) {
    Sr(j.greaterThan, 1);
    return;
  }
  const t = _t.charCodeAt(de.pos + 1);
  if (t === ze.greaterThan) {
    const e = _t.charCodeAt(de.pos + 2) === ze.greaterThan ? 3 : 2;
    if (_t.charCodeAt(de.pos + e) === ze.equalsTo) {
      Sr(j.assign, e + 1);
      return;
    }
    Sr(j.bitShiftR, e);
    return;
  }
  t === ze.equalsTo ? Sr(j.relationalOrEqual, 2) : Sr(j.greaterThan, 1);
}
function nC() {
  de.type === j.greaterThan && (de.pos -= 1, rC());
}
function bY(t) {
  const e = _t.charCodeAt(de.pos + 1);
  if (e === ze.equalsTo) {
    Sr(j.equality, _t.charCodeAt(de.pos + 2) === ze.equalsTo ? 3 : 2);
    return;
  }
  if (t === ze.equalsTo && e === ze.greaterThan) {
    de.pos += 2, Zt(j.arrow);
    return;
  }
  Sr(t === ze.equalsTo ? j.eq : j.bang, 1);
}
function gY() {
  const t = _t.charCodeAt(de.pos + 1), e = _t.charCodeAt(de.pos + 2);
  t === ze.questionMark && // In Flow (but not TypeScript), ??string is a valid type that should be
  // tokenized as two individual ? tokens.
  !(gr && de.isType) ? e === ze.equalsTo ? Sr(j.assign, 3) : Sr(j.nullishCoalescing, 2) : t === ze.dot && !(e >= ze.digit0 && e <= ze.digit9) ? (de.pos += 2, Zt(j.questionDot)) : (++de.pos, Zt(j.question));
}
function iC(t) {
  switch (t) {
    case ze.numberSign:
      ++de.pos, Zt(j.hash);
      return;
    case ze.dot:
      cY();
      return;
    case ze.leftParenthesis:
      ++de.pos, Zt(j.parenL);
      return;
    case ze.rightParenthesis:
      ++de.pos, Zt(j.parenR);
      return;
    case ze.semicolon:
      ++de.pos, Zt(j.semi);
      return;
    case ze.comma:
      ++de.pos, Zt(j.comma);
      return;
    case ze.leftSquareBracket:
      ++de.pos, Zt(j.bracketL);
      return;
    case ze.rightSquareBracket:
      ++de.pos, Zt(j.bracketR);
      return;
    case ze.leftCurlyBrace:
      gr && _t.charCodeAt(de.pos + 1) === ze.verticalBar ? Sr(j.braceBarL, 2) : (++de.pos, Zt(j.braceL));
      return;
    case ze.rightCurlyBrace:
      ++de.pos, Zt(j.braceR);
      return;
    case ze.colon:
      _t.charCodeAt(de.pos + 1) === ze.colon ? Sr(j.doubleColon, 2) : (++de.pos, Zt(j.colon));
      return;
    case ze.questionMark:
      gY();
      return;
    case ze.atSign:
      ++de.pos, Zt(j.at);
      return;
    case ze.graveAccent:
      ++de.pos, Zt(j.backQuote);
      return;
    case ze.digit0: {
      const e = _t.charCodeAt(de.pos + 1);
      if (e === ze.lowercaseX || e === ze.uppercaseX || e === ze.lowercaseO || e === ze.uppercaseO || e === ze.lowercaseB || e === ze.uppercaseB) {
        EY();
        return;
      }
    }
    case ze.digit1:
    case ze.digit2:
    case ze.digit3:
    case ze.digit4:
    case ze.digit5:
    case ze.digit6:
    case ze.digit7:
    case ze.digit8:
    case ze.digit9:
      sC(!1);
      return;
    case ze.quotationMark:
    case ze.apostrophe:
      _Y(t);
      return;
    case ze.slash:
      fY();
      return;
    case ze.percentSign:
    case ze.asterisk:
      dY(t);
      return;
    case ze.verticalBar:
    case ze.ampersand:
      pY(t);
      return;
    case ze.caret:
      hY();
      return;
    case ze.plusSign:
    case ze.dash:
      mY(t);
      return;
    case ze.lessThan:
      yY();
      return;
    case ze.greaterThan:
      rC();
      return;
    case ze.equalsTo:
    case ze.exclamationMark:
      bY(t);
      return;
    case ze.tilde:
      Sr(j.tilde, 1);
      return;
  }
  er(`Unexpected character '${String.fromCharCode(t)}'`, de.pos);
}
function Sr(t, e) {
  de.pos += e, Zt(t);
}
function vY() {
  const t = de.pos;
  let e = !1, r = !1;
  for (; ; ) {
    if (de.pos >= _t.length) {
      er("Unterminated regular expression", t);
      return;
    }
    const a = _t.charCodeAt(de.pos);
    if (e)
      e = !1;
    else {
      if (a === ze.leftSquareBracket)
        r = !0;
      else if (a === ze.rightSquareBracket && r)
        r = !1;
      else if (a === ze.slash && !r)
        break;
      e = a === ze.backslash;
    }
    ++de.pos;
  }
  ++de.pos, wY(), Zt(j.regexp);
}
function n0() {
  for (; ; ) {
    const t = _t.charCodeAt(de.pos);
    if (t >= ze.digit0 && t <= ze.digit9 || t === ze.underscore)
      de.pos++;
    else
      break;
  }
}
function EY() {
  for (de.pos += 2; ; ) {
    const e = _t.charCodeAt(de.pos);
    if (e >= ze.digit0 && e <= ze.digit9 || e >= ze.lowercaseA && e <= ze.lowercaseF || e >= ze.uppercaseA && e <= ze.uppercaseF || e === ze.underscore)
      de.pos++;
    else
      break;
  }
  _t.charCodeAt(de.pos) === ze.lowercaseN ? (++de.pos, Zt(j.bigint)) : Zt(j.num);
}
function sC(t) {
  let e = !1, r = !1;
  t || n0();
  let a = _t.charCodeAt(de.pos);
  if (a === ze.dot && (++de.pos, n0(), a = _t.charCodeAt(de.pos)), (a === ze.uppercaseE || a === ze.lowercaseE) && (a = _t.charCodeAt(++de.pos), (a === ze.plusSign || a === ze.dash) && ++de.pos, n0(), a = _t.charCodeAt(de.pos)), a === ze.lowercaseN ? (++de.pos, e = !0) : a === ze.lowercaseM && (++de.pos, r = !0), e) {
    Zt(j.bigint);
    return;
  }
  if (r) {
    Zt(j.decimal);
    return;
  }
  Zt(j.num);
}
function _Y(t) {
  for (de.pos++; ; ) {
    if (de.pos >= _t.length) {
      er("Unterminated string constant");
      return;
    }
    const e = _t.charCodeAt(de.pos);
    if (e === ze.backslash)
      de.pos++;
    else if (e === t)
      break;
    de.pos++;
  }
  de.pos++, Zt(j.string);
}
function SY() {
  for (; ; ) {
    if (de.pos >= _t.length) {
      er("Unterminated template");
      return;
    }
    const t = _t.charCodeAt(de.pos);
    if (t === ze.graveAccent || t === ze.dollarSign && _t.charCodeAt(de.pos + 1) === ze.leftCurlyBrace) {
      if (de.pos === de.start && Ne(j.template))
        if (t === ze.dollarSign) {
          de.pos += 2, Zt(j.dollarBraceL);
          return;
        } else {
          ++de.pos, Zt(j.backQuote);
          return;
        }
      Zt(j.template);
      return;
    }
    t === ze.backslash && de.pos++, de.pos++;
  }
}
function wY() {
  for (; de.pos < _t.length; ) {
    const t = _t.charCodeAt(de.pos);
    if (ss[t])
      de.pos++;
    else if (t === ze.backslash) {
      if (de.pos += 2, _t.charCodeAt(de.pos) === ze.leftCurlyBrace) {
        for (; de.pos < _t.length && _t.charCodeAt(de.pos) !== ze.rightCurlyBrace; )
          de.pos++;
        de.pos++;
      }
    } else
      break;
  }
}
function Mu(t, e = t.currentIndex()) {
  let r = e + 1;
  if (sf(t, r)) {
    const a = t.identifierNameAtIndex(e);
    return {
      isType: !1,
      leftName: a,
      rightName: a,
      endIndex: r
    };
  }
  if (r++, sf(t, r))
    return {
      isType: !0,
      leftName: null,
      rightName: null,
      endIndex: r
    };
  if (r++, sf(t, r))
    return {
      isType: !1,
      leftName: t.identifierNameAtIndex(e),
      rightName: t.identifierNameAtIndex(e + 2),
      endIndex: r
    };
  if (r++, sf(t, r))
    return {
      isType: !0,
      leftName: null,
      rightName: null,
      endIndex: r
    };
  throw new Error(`Unexpected import/export specifier at ${e}`);
}
function sf(t, e) {
  const r = t.tokens[e];
  return r.type === j.braceR || r.type === j.comma;
}
const xY = /* @__PURE__ */ new Map([
  ["quot", '"'],
  ["amp", "&"],
  ["apos", "'"],
  ["lt", "<"],
  ["gt", ">"],
  ["nbsp", " "],
  ["iexcl", "¡"],
  ["cent", "¢"],
  ["pound", "£"],
  ["curren", "¤"],
  ["yen", "¥"],
  ["brvbar", "¦"],
  ["sect", "§"],
  ["uml", "¨"],
  ["copy", "©"],
  ["ordf", "ª"],
  ["laquo", "«"],
  ["not", "¬"],
  ["shy", "­"],
  ["reg", "®"],
  ["macr", "¯"],
  ["deg", "°"],
  ["plusmn", "±"],
  ["sup2", "²"],
  ["sup3", "³"],
  ["acute", "´"],
  ["micro", "µ"],
  ["para", "¶"],
  ["middot", "·"],
  ["cedil", "¸"],
  ["sup1", "¹"],
  ["ordm", "º"],
  ["raquo", "»"],
  ["frac14", "¼"],
  ["frac12", "½"],
  ["frac34", "¾"],
  ["iquest", "¿"],
  ["Agrave", "À"],
  ["Aacute", "Á"],
  ["Acirc", "Â"],
  ["Atilde", "Ã"],
  ["Auml", "Ä"],
  ["Aring", "Å"],
  ["AElig", "Æ"],
  ["Ccedil", "Ç"],
  ["Egrave", "È"],
  ["Eacute", "É"],
  ["Ecirc", "Ê"],
  ["Euml", "Ë"],
  ["Igrave", "Ì"],
  ["Iacute", "Í"],
  ["Icirc", "Î"],
  ["Iuml", "Ï"],
  ["ETH", "Ð"],
  ["Ntilde", "Ñ"],
  ["Ograve", "Ò"],
  ["Oacute", "Ó"],
  ["Ocirc", "Ô"],
  ["Otilde", "Õ"],
  ["Ouml", "Ö"],
  ["times", "×"],
  ["Oslash", "Ø"],
  ["Ugrave", "Ù"],
  ["Uacute", "Ú"],
  ["Ucirc", "Û"],
  ["Uuml", "Ü"],
  ["Yacute", "Ý"],
  ["THORN", "Þ"],
  ["szlig", "ß"],
  ["agrave", "à"],
  ["aacute", "á"],
  ["acirc", "â"],
  ["atilde", "ã"],
  ["auml", "ä"],
  ["aring", "å"],
  ["aelig", "æ"],
  ["ccedil", "ç"],
  ["egrave", "è"],
  ["eacute", "é"],
  ["ecirc", "ê"],
  ["euml", "ë"],
  ["igrave", "ì"],
  ["iacute", "í"],
  ["icirc", "î"],
  ["iuml", "ï"],
  ["eth", "ð"],
  ["ntilde", "ñ"],
  ["ograve", "ò"],
  ["oacute", "ó"],
  ["ocirc", "ô"],
  ["otilde", "õ"],
  ["ouml", "ö"],
  ["divide", "÷"],
  ["oslash", "ø"],
  ["ugrave", "ù"],
  ["uacute", "ú"],
  ["ucirc", "û"],
  ["uuml", "ü"],
  ["yacute", "ý"],
  ["thorn", "þ"],
  ["yuml", "ÿ"],
  ["OElig", "Œ"],
  ["oelig", "œ"],
  ["Scaron", "Š"],
  ["scaron", "š"],
  ["Yuml", "Ÿ"],
  ["fnof", "ƒ"],
  ["circ", "ˆ"],
  ["tilde", "˜"],
  ["Alpha", "Α"],
  ["Beta", "Β"],
  ["Gamma", "Γ"],
  ["Delta", "Δ"],
  ["Epsilon", "Ε"],
  ["Zeta", "Ζ"],
  ["Eta", "Η"],
  ["Theta", "Θ"],
  ["Iota", "Ι"],
  ["Kappa", "Κ"],
  ["Lambda", "Λ"],
  ["Mu", "Μ"],
  ["Nu", "Ν"],
  ["Xi", "Ξ"],
  ["Omicron", "Ο"],
  ["Pi", "Π"],
  ["Rho", "Ρ"],
  ["Sigma", "Σ"],
  ["Tau", "Τ"],
  ["Upsilon", "Υ"],
  ["Phi", "Φ"],
  ["Chi", "Χ"],
  ["Psi", "Ψ"],
  ["Omega", "Ω"],
  ["alpha", "α"],
  ["beta", "β"],
  ["gamma", "γ"],
  ["delta", "δ"],
  ["epsilon", "ε"],
  ["zeta", "ζ"],
  ["eta", "η"],
  ["theta", "θ"],
  ["iota", "ι"],
  ["kappa", "κ"],
  ["lambda", "λ"],
  ["mu", "μ"],
  ["nu", "ν"],
  ["xi", "ξ"],
  ["omicron", "ο"],
  ["pi", "π"],
  ["rho", "ρ"],
  ["sigmaf", "ς"],
  ["sigma", "σ"],
  ["tau", "τ"],
  ["upsilon", "υ"],
  ["phi", "φ"],
  ["chi", "χ"],
  ["psi", "ψ"],
  ["omega", "ω"],
  ["thetasym", "ϑ"],
  ["upsih", "ϒ"],
  ["piv", "ϖ"],
  ["ensp", " "],
  ["emsp", " "],
  ["thinsp", " "],
  ["zwnj", "‌"],
  ["zwj", "‍"],
  ["lrm", "‎"],
  ["rlm", "‏"],
  ["ndash", "–"],
  ["mdash", "—"],
  ["lsquo", "‘"],
  ["rsquo", "’"],
  ["sbquo", "‚"],
  ["ldquo", "“"],
  ["rdquo", "”"],
  ["bdquo", "„"],
  ["dagger", "†"],
  ["Dagger", "‡"],
  ["bull", "•"],
  ["hellip", "…"],
  ["permil", "‰"],
  ["prime", "′"],
  ["Prime", "″"],
  ["lsaquo", "‹"],
  ["rsaquo", "›"],
  ["oline", "‾"],
  ["frasl", "⁄"],
  ["euro", "€"],
  ["image", "ℑ"],
  ["weierp", "℘"],
  ["real", "ℜ"],
  ["trade", "™"],
  ["alefsym", "ℵ"],
  ["larr", "←"],
  ["uarr", "↑"],
  ["rarr", "→"],
  ["darr", "↓"],
  ["harr", "↔"],
  ["crarr", "↵"],
  ["lArr", "⇐"],
  ["uArr", "⇑"],
  ["rArr", "⇒"],
  ["dArr", "⇓"],
  ["hArr", "⇔"],
  ["forall", "∀"],
  ["part", "∂"],
  ["exist", "∃"],
  ["empty", "∅"],
  ["nabla", "∇"],
  ["isin", "∈"],
  ["notin", "∉"],
  ["ni", "∋"],
  ["prod", "∏"],
  ["sum", "∑"],
  ["minus", "−"],
  ["lowast", "∗"],
  ["radic", "√"],
  ["prop", "∝"],
  ["infin", "∞"],
  ["ang", "∠"],
  ["and", "∧"],
  ["or", "∨"],
  ["cap", "∩"],
  ["cup", "∪"],
  ["int", "∫"],
  ["there4", "∴"],
  ["sim", "∼"],
  ["cong", "≅"],
  ["asymp", "≈"],
  ["ne", "≠"],
  ["equiv", "≡"],
  ["le", "≤"],
  ["ge", "≥"],
  ["sub", "⊂"],
  ["sup", "⊃"],
  ["nsub", "⊄"],
  ["sube", "⊆"],
  ["supe", "⊇"],
  ["oplus", "⊕"],
  ["otimes", "⊗"],
  ["perp", "⊥"],
  ["sdot", "⋅"],
  ["lceil", "⌈"],
  ["rceil", "⌉"],
  ["lfloor", "⌊"],
  ["rfloor", "⌋"],
  ["lang", "〈"],
  ["rang", "〉"],
  ["loz", "◊"],
  ["spades", "♠"],
  ["clubs", "♣"],
  ["hearts", "♥"],
  ["diams", "♦"]
]);
function aC(t) {
  const [e, r] = Ew(t.jsxPragma || "React.createElement"), [a, l] = Ew(t.jsxFragmentPragma || "React.Fragment");
  return { base: e, suffix: r, fragmentBase: a, fragmentSuffix: l };
}
function Ew(t) {
  let e = t.indexOf(".");
  return e === -1 && (e = t.length), [t.slice(0, e), t.slice(e)];
}
class fs {
  // Return true if anything was processed, false otherwise.
  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
}
class Ka extends fs {
  // State for calculating the line number of each JSX tag in development.
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }
  // In development, variable name holding the name of the current file.
  __init3() {
    this.filenameVarName = null;
  }
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(e, r, a, l, d) {
    super(), this.rootTransformer = e, this.tokens = r, this.importProcessor = a, this.nameManager = l, this.options = d, Ka.prototype.__init.call(this), Ka.prototype.__init2.call(this), Ka.prototype.__init3.call(this), Ka.prototype.__init4.call(this), Ka.prototype.__init5.call(this), this.jsxPragmaInfo = aC(d), this.isAutomaticRuntime = d.jsxRuntime === "automatic", this.jsxImportSource = d.jsxImportSource || "react";
  }
  process() {
    return this.tokens.matches1(j.jsxTagStart) ? (this.processJSXTag(), !0) : !1;
  }
  getPrefixCode() {
    let e = "";
    if (this.filenameVarName && (e += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`), this.isAutomaticRuntime)
      if (this.importProcessor)
        for (const [r, a] of Object.entries(this.cjsAutomaticModuleNameResolutions))
          e += `var ${a} = require("${r}");`;
      else {
        const { createElement: r, ...a } = this.esmAutomaticImportNameResolutions;
        r && (e += `import {createElement as ${r}} from "${this.jsxImportSource}";`);
        const l = Object.entries(a).map(([d, h]) => `${d} as ${h}`).join(", ");
        if (l) {
          const d = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          e += `import {${l}} from "${d}";`;
        }
      }
    return e;
  }
  processJSXTag() {
    const { jsxRole: e, start: r } = this.tokens.currentToken(), a = this.options.production ? null : this.getElementLocationCode(r);
    this.isAutomaticRuntime && e !== ts.KeyAfterPropSpread ? this.transformTagToJSXFunc(a, e) : this.transformTagToCreateElement(a);
  }
  getElementLocationCode(e) {
    return `lineNumber: ${this.getLineNumberForIndex(e)}`;
  }
  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(e) {
    const r = this.tokens.code;
    for (; this.lastIndex < e && this.lastIndex < r.length; )
      r[this.lastIndex] === `
` && this.lastLineNumber++, this.lastIndex++;
    return this.lastLineNumber;
  }
  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(e, r) {
    const a = r === ts.StaticChildren;
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(a));
    let l = null;
    if (this.tokens.matches1(j.jsxTagEnd))
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`), this.processAutomaticChildrenAndEndProps(r);
    else {
      if (this.processTagIntro(), this.tokens.appendCode(", {"), l = this.processProps(!0), this.tokens.matches2(j.slash, j.jsxTagEnd))
        this.tokens.appendCode("}");
      else if (this.tokens.matches1(j.jsxTagEnd))
        this.tokens.removeToken(), this.processAutomaticChildrenAndEndProps(r);
      else
        throw new Error("Expected either /> or > at the end of the tag.");
      l && this.tokens.appendCode(`, ${l}`);
    }
    for (this.options.production || (l === null && this.tokens.appendCode(", void 0"), this.tokens.appendCode(`, ${a}, ${this.getDevSource(e)}, this`)), this.tokens.removeInitialToken(); !this.tokens.matches1(j.jsxTagEnd); )
      this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(e) {
    if (this.tokens.replaceToken(this.getCreateElementInvocationCode()), this.tokens.matches1(j.jsxTagEnd))
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`), this.processChildren(!0);
    else if (this.processTagIntro(), this.processPropsObjectWithDevInfo(e), !this.tokens.matches2(j.slash, j.jsxTagEnd)) if (this.tokens.matches1(j.jsxTagEnd))
      this.tokens.removeToken(), this.processChildren(!0);
    else
      throw new Error("Expected either /> or > at the end of the tag.");
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(j.jsxTagEnd); )
      this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(e) {
    return this.options.production ? e ? this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
  }
  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime)
      return this.claimAutoImportedFuncInvocation("createElement", "");
    {
      const { jsxPragmaInfo: e } = this;
      return `${this.importProcessor && this.importProcessor.getIdentifierReplacement(e.base) || e.base}${e.suffix}(`;
    }
  }
  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime)
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime"
      );
    {
      const { jsxPragmaInfo: e } = this;
      return (this.importProcessor && this.importProcessor.getIdentifierReplacement(e.fragmentBase) || e.fragmentBase) + e.fragmentSuffix;
    }
  }
  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(e, r) {
    const a = this.claimAutoImportedName(e, r);
    return this.importProcessor ? `${a}.call(void 0, ` : `${a}(`;
  }
  claimAutoImportedName(e, r) {
    if (this.importProcessor) {
      const a = this.jsxImportSource + r;
      return this.cjsAutomaticModuleNameResolutions[a] || (this.cjsAutomaticModuleNameResolutions[a] = this.importProcessor.getFreeIdentifierForPath(a)), `${this.cjsAutomaticModuleNameResolutions[a]}.${e}`;
    } else
      return this.esmAutomaticImportNameResolutions[e] || (this.esmAutomaticImportNameResolutions[e] = this.nameManager.claimFreeName(
        `_${e}`
      )), this.esmAutomaticImportNameResolutions[e];
  }
  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    let e = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[e].isType || !this.tokens.matches2AtIndex(e - 1, j.jsxName, j.jsxName) && !this.tokens.matches2AtIndex(e - 1, j.greaterThan, j.jsxName) && !this.tokens.matches1AtIndex(e, j.braceL) && !this.tokens.matches1AtIndex(e, j.jsxTagEnd) && !this.tokens.matches2AtIndex(e, j.slash, j.jsxTagEnd); )
      e++;
    if (e === this.tokens.currentIndex() + 1) {
      const r = this.tokens.identifierName();
      oC(r) && this.tokens.replaceToken(`'${r}'`);
    }
    for (; this.tokens.currentIndex() < e; )
      this.rootTransformer.processToken();
  }
  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(e) {
    const r = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(e)}`;
    if (!this.tokens.matches1(j.jsxName) && !this.tokens.matches1(j.braceL)) {
      r ? this.tokens.appendCode(`, {${r}}`) : this.tokens.appendCode(", null");
      return;
    }
    this.tokens.appendCode(", {"), this.processProps(!1), r ? this.tokens.appendCode(` ${r}}`) : this.tokens.appendCode("}");
  }
  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(e) {
    let r = null;
    for (; ; ) {
      if (this.tokens.matches2(j.jsxName, j.eq)) {
        const a = this.tokens.identifierName();
        if (e && a === "key") {
          r !== null && this.tokens.appendCode(r.replace(/[^\n]/g, "")), this.tokens.removeToken(), this.tokens.removeToken();
          const l = this.tokens.snapshot();
          this.processPropValue(), r = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(l);
          continue;
        } else
          this.processPropName(a), this.tokens.replaceToken(": "), this.processPropValue();
      } else if (this.tokens.matches1(j.jsxName)) {
        const a = this.tokens.identifierName();
        this.processPropName(a), this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(j.braceL))
        this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("");
      else
        break;
      this.tokens.appendCode(",");
    }
    return r;
  }
  processPropName(e) {
    e.includes("-") ? this.tokens.replaceToken(`'${e}'`) : this.tokens.copyToken();
  }
  processPropValue() {
    this.tokens.matches1(j.braceL) ? (this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("")) : this.tokens.matches1(j.jsxTagStart) ? this.processJSXTag() : this.processStringPropValue();
  }
  processStringPropValue() {
    const e = this.tokens.currentToken(), r = this.tokens.code.slice(e.start + 1, e.end - 1), a = _w(r), l = AY(r);
    this.tokens.replaceToken(l + a);
  }
  /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */
  processAutomaticChildrenAndEndProps(e) {
    e === ts.StaticChildren ? (this.tokens.appendCode(" children: ["), this.processChildren(!1), this.tokens.appendCode("]}")) : (e === ts.OneChild && this.tokens.appendCode(" children: "), this.processChildren(!1), this.tokens.appendCode("}"));
  }
  /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */
  processChildren(e) {
    let r = e;
    for (; ; ) {
      if (this.tokens.matches2(j.jsxTagStart, j.slash))
        return;
      let a = !1;
      if (this.tokens.matches1(j.braceL))
        this.tokens.matches2(j.braceL, j.braceR) ? (this.tokens.replaceToken(""), this.tokens.replaceToken("")) : (this.tokens.replaceToken(r ? ", " : ""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken(""), a = !0);
      else if (this.tokens.matches1(j.jsxTagStart))
        this.tokens.appendCode(r ? ", " : ""), this.processJSXTag(), a = !0;
      else if (this.tokens.matches1(j.jsxText) || this.tokens.matches1(j.jsxEmptyText))
        a = this.processChildTextElement(r);
      else
        throw new Error("Unexpected token when processing JSX children.");
      a && (r = !0);
    }
  }
  /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */
  processChildTextElement(e) {
    const r = this.tokens.currentToken(), a = this.tokens.code.slice(r.start, r.end), l = _w(a), d = TY(a);
    return d === '""' ? (this.tokens.replaceToken(l), !1) : (this.tokens.replaceToken(`${e ? ", " : ""}${d}${l}`), !0);
  }
  getDevSource(e) {
    return `{fileName: ${this.getFilenameVarName()}, ${e}}`;
  }
  getFilenameVarName() {
    return this.filenameVarName || (this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName")), this.filenameVarName;
  }
}
function oC(t) {
  const e = t.charCodeAt(0);
  return e >= ze.lowercaseA && e <= ze.lowercaseZ;
}
function TY(t) {
  let e = "", r = "", a = !1, l = !1;
  for (let d = 0; d < t.length; d++) {
    const h = t[d];
    if (h === " " || h === "	" || h === "\r")
      a || (r += h);
    else if (h === `
`)
      r = "", a = !0;
    else {
      if (l && a && (e += " "), e += r, r = "", h === "&") {
        const { entity: n, newI: u } = lC(t, d + 1);
        d = u - 1, e += n;
      } else
        e += h;
      l = !0, a = !1;
    }
  }
  return a || (e += r), JSON.stringify(e);
}
function _w(t) {
  let e = 0, r = 0;
  for (const a of t)
    a === `
` ? (e++, r = 0) : a === " " && r++;
  return `
`.repeat(e) + " ".repeat(r);
}
function AY(t) {
  let e = "";
  for (let r = 0; r < t.length; r++) {
    const a = t[r];
    if (a === `
`)
      if (/\s/.test(t[r + 1]))
        for (e += " "; r < t.length && /\s/.test(t[r + 1]); )
          r++;
      else
        e += `
`;
    else if (a === "&") {
      const { entity: l, newI: d } = lC(t, r + 1);
      e += l, r = d - 1;
    } else
      e += a;
  }
  return JSON.stringify(e);
}
function lC(t, e) {
  let r = "", a = 0, l, d = e;
  if (t[d] === "#") {
    let h = 10;
    d++;
    let n;
    if (t[d] === "x")
      for (h = 16, d++, n = d; d < t.length && CY(t.charCodeAt(d)); )
        d++;
    else
      for (n = d; d < t.length && PY(t.charCodeAt(d)); )
        d++;
    if (t[d] === ";") {
      const u = t.slice(n, d);
      u && (d++, l = String.fromCodePoint(parseInt(u, h)));
    }
  } else
    for (; d < t.length && a++ < 10; ) {
      const h = t[d];
      if (d++, h === ";") {
        l = xY.get(r);
        break;
      }
      r += h;
    }
  return l ? { entity: l, newI: d } : { entity: "&", newI: e };
}
function PY(t) {
  return t >= ze.digit0 && t <= ze.digit9;
}
function CY(t) {
  return t >= ze.digit0 && t <= ze.digit9 || t >= ze.lowercaseA && t <= ze.lowercaseF || t >= ze.uppercaseA && t <= ze.uppercaseF;
}
function uC(t, e) {
  const r = aC(e), a = /* @__PURE__ */ new Set();
  for (let l = 0; l < t.tokens.length; l++) {
    const d = t.tokens[l];
    if (d.type === j.name && !d.isType && (d.identifierRole === Ut.Access || d.identifierRole === Ut.ObjectShorthand || d.identifierRole === Ut.ExportAccess) && !d.shadowsGlobal && a.add(t.identifierNameForToken(d)), d.type === j.jsxTagStart && a.add(r.base), d.type === j.jsxTagStart && l + 1 < t.tokens.length && t.tokens[l + 1].type === j.jsxTagEnd && (a.add(r.base), a.add(r.fragmentBase)), d.type === j.jsxName && d.identifierRole === Ut.Access) {
      const h = t.identifierNameForToken(d);
      (!oC(h) || t.tokens[l + 1].type === j.dot) && a.add(t.identifierNameForToken(d));
    }
  }
  return a;
}
class Ya {
  __init() {
    this.nonTypeIdentifiers = /* @__PURE__ */ new Set();
  }
  __init2() {
    this.importInfoByPath = /* @__PURE__ */ new Map();
  }
  __init3() {
    this.importsToReplace = /* @__PURE__ */ new Map();
  }
  __init4() {
    this.identifierReplacements = /* @__PURE__ */ new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = /* @__PURE__ */ new Map();
  }
  constructor(e, r, a, l, d, h, n) {
    this.nameManager = e, this.tokens = r, this.enableLegacyTypeScriptModuleInterop = a, this.options = l, this.isTypeScriptTransformEnabled = d, this.keepUnusedImports = h, this.helperManager = n, Ya.prototype.__init.call(this), Ya.prototype.__init2.call(this), Ya.prototype.__init3.call(this), Ya.prototype.__init4.call(this), Ya.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let e = 0; e < this.tokens.tokens.length; e++)
      this.tokens.matches1AtIndex(e, j._import) && !this.tokens.matches3AtIndex(e, j._import, j.name, j.eq) && this.preprocessImportAtIndex(e), this.tokens.matches1AtIndex(e, j._export) && !this.tokens.matches2AtIndex(e, j._export, j.eq) && this.preprocessExportAtIndex(e);
    this.generateImportReplacements();
  }
  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = uC(this.tokens, this.options);
    for (const [e, r] of this.importInfoByPath.entries()) {
      if (r.hasBareImport || r.hasStarExport || r.exportStarNames.length > 0 || r.namedExports.length > 0)
        continue;
      [
        ...r.defaultNames,
        ...r.wildcardNames,
        ...r.namedImports.map(({ localName: l }) => l)
      ].every((l) => this.shouldAutomaticallyElideImportedName(l)) && this.importsToReplace.set(e, "");
    }
  }
  shouldAutomaticallyElideImportedName(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(e);
  }
  generateImportReplacements() {
    for (const [e, r] of this.importInfoByPath.entries()) {
      const {
        defaultNames: a,
        wildcardNames: l,
        namedImports: d,
        namedExports: h,
        exportStarNames: n,
        hasStarExport: u
      } = r;
      if (a.length === 0 && l.length === 0 && d.length === 0 && h.length === 0 && n.length === 0 && !u) {
        this.importsToReplace.set(e, `require('${e}');`);
        continue;
      }
      const i = this.getFreeIdentifierForPath(e);
      let c;
      this.enableLegacyTypeScriptModuleInterop ? c = i : c = l.length > 0 ? l[0] : this.getFreeIdentifierForPath(e);
      let f = `var ${i} = require('${e}');`;
      if (l.length > 0)
        for (const s of l) {
          const o = this.enableLegacyTypeScriptModuleInterop ? i : `${this.helperManager.getHelperName("interopRequireWildcard")}(${i})`;
          f += ` var ${s} = ${o};`;
        }
      else n.length > 0 && c !== i ? f += ` var ${c} = ${this.helperManager.getHelperName(
        "interopRequireWildcard"
      )}(${i});` : a.length > 0 && c !== i && (f += ` var ${c} = ${this.helperManager.getHelperName(
        "interopRequireDefault"
      )}(${i});`);
      for (const { importedName: s, localName: o } of h)
        f += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom"
        )}(${i}, '${o}', '${s}');`;
      for (const s of n)
        f += ` exports.${s} = ${c};`;
      u && (f += ` ${this.helperManager.getHelperName(
        "createStarExport"
      )}(${i});`), this.importsToReplace.set(e, f);
      for (const s of a)
        this.identifierReplacements.set(s, `${c}.default`);
      for (const { importedName: s, localName: o } of d)
        this.identifierReplacements.set(o, `${i}.${s}`);
    }
  }
  getFreeIdentifierForPath(e) {
    const r = e.split("/"), l = r[r.length - 1].replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${l}`);
  }
  preprocessImportAtIndex(e) {
    const r = [], a = [], l = [];
    if (e++, (this.tokens.matchesContextualAtIndex(e, $e._type) || this.tokens.matches1AtIndex(e, j._typeof)) && !this.tokens.matches1AtIndex(e + 1, j.comma) && !this.tokens.matchesContextualAtIndex(e + 1, $e._from) || this.tokens.matches1AtIndex(e, j.parenL))
      return;
    if (this.tokens.matches1AtIndex(e, j.name) && (r.push(this.tokens.identifierNameAtIndex(e)), e++, this.tokens.matches1AtIndex(e, j.comma) && e++), this.tokens.matches1AtIndex(e, j.star) && (e += 2, a.push(this.tokens.identifierNameAtIndex(e)), e++), this.tokens.matches1AtIndex(e, j.braceL)) {
      const n = this.getNamedImports(e + 1);
      e = n.newIndex;
      for (const u of n.namedImports)
        u.importedName === "default" ? r.push(u.localName) : l.push(u);
    }
    if (this.tokens.matchesContextualAtIndex(e, $e._from) && e++, !this.tokens.matches1AtIndex(e, j.string))
      throw new Error("Expected string token at the end of import statement.");
    const d = this.tokens.stringValueAtIndex(e), h = this.getImportInfo(d);
    h.defaultNames.push(...r), h.wildcardNames.push(...a), h.namedImports.push(...l), r.length === 0 && a.length === 0 && l.length === 0 && (h.hasBareImport = !0);
  }
  preprocessExportAtIndex(e) {
    if (this.tokens.matches2AtIndex(e, j._export, j._var) || this.tokens.matches2AtIndex(e, j._export, j._let) || this.tokens.matches2AtIndex(e, j._export, j._const))
      this.preprocessVarExportAtIndex(e);
    else if (this.tokens.matches2AtIndex(e, j._export, j._function) || this.tokens.matches2AtIndex(e, j._export, j._class)) {
      const r = this.tokens.identifierNameAtIndex(e + 2);
      this.addExportBinding(r, r);
    } else if (this.tokens.matches3AtIndex(e, j._export, j.name, j._function)) {
      const r = this.tokens.identifierNameAtIndex(e + 3);
      this.addExportBinding(r, r);
    } else this.tokens.matches2AtIndex(e, j._export, j.braceL) ? this.preprocessNamedExportAtIndex(e) : this.tokens.matches2AtIndex(e, j._export, j.star) && this.preprocessExportStarAtIndex(e);
  }
  preprocessVarExportAtIndex(e) {
    let r = 0;
    for (let a = e + 2; ; a++)
      if (this.tokens.matches1AtIndex(a, j.braceL) || this.tokens.matches1AtIndex(a, j.dollarBraceL) || this.tokens.matches1AtIndex(a, j.bracketL))
        r++;
      else if (this.tokens.matches1AtIndex(a, j.braceR) || this.tokens.matches1AtIndex(a, j.bracketR))
        r--;
      else {
        if (r === 0 && !this.tokens.matches1AtIndex(a, j.name))
          break;
        if (this.tokens.matches1AtIndex(1, j.eq)) {
          const l = this.tokens.currentToken().rhsEndIndex;
          if (l == null)
            throw new Error("Expected = token with an end index.");
          a = l - 1;
        } else {
          const l = this.tokens.tokens[a];
          if (K4(l)) {
            const d = this.tokens.identifierNameAtIndex(a);
            this.identifierReplacements.set(d, `exports.${d}`);
          }
        }
      }
  }
  /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */
  preprocessNamedExportAtIndex(e) {
    e += 2;
    const { newIndex: r, namedImports: a } = this.getNamedImports(e);
    if (e = r, this.tokens.matchesContextualAtIndex(e, $e._from))
      e++;
    else {
      for (const { importedName: h, localName: n } of a)
        this.addExportBinding(h, n);
      return;
    }
    if (!this.tokens.matches1AtIndex(e, j.string))
      throw new Error("Expected string token at the end of import statement.");
    const l = this.tokens.stringValueAtIndex(e);
    this.getImportInfo(l).namedExports.push(...a);
  }
  preprocessExportStarAtIndex(e) {
    let r = null;
    if (this.tokens.matches3AtIndex(e, j._export, j.star, j._as) ? (e += 3, r = this.tokens.identifierNameAtIndex(e), e += 2) : e += 3, !this.tokens.matches1AtIndex(e, j.string))
      throw new Error("Expected string token at the end of star export statement.");
    const a = this.tokens.stringValueAtIndex(e), l = this.getImportInfo(a);
    r !== null ? l.exportStarNames.push(r) : l.hasStarExport = !0;
  }
  getNamedImports(e) {
    const r = [];
    for (; ; ) {
      if (this.tokens.matches1AtIndex(e, j.braceR)) {
        e++;
        break;
      }
      const a = Mu(this.tokens, e);
      if (e = a.endIndex, a.isType || r.push({
        importedName: a.leftName,
        localName: a.rightName
      }), this.tokens.matches2AtIndex(e, j.comma, j.braceR)) {
        e += 2;
        break;
      } else if (this.tokens.matches1AtIndex(e, j.braceR)) {
        e++;
        break;
      } else if (this.tokens.matches1AtIndex(e, j.comma))
        e++;
      else
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[e])}`);
    }
    return { newIndex: e, namedImports: r };
  }
  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
  getImportInfo(e) {
    const r = this.importInfoByPath.get(e);
    if (r)
      return r;
    const a = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: !1,
      exportStarNames: [],
      hasStarExport: !1
    };
    return this.importInfoByPath.set(e, a), a;
  }
  addExportBinding(e, r) {
    this.exportBindingsByLocalName.has(e) || this.exportBindingsByLocalName.set(e, []), this.exportBindingsByLocalName.get(e).push(r);
  }
  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(e) {
    const r = this.importsToReplace.get(e);
    return this.importsToReplace.set(e, ""), r || "";
  }
  getIdentifierReplacement(e) {
    return this.identifierReplacements.get(e) || null;
  }
  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(e) {
    const r = this.exportBindingsByLocalName.get(e);
    return !r || r.length === 0 ? null : r.map((a) => `exports.${a}`).join(" = ");
  }
  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return /* @__PURE__ */ new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys()
    ]);
  }
}
var ny = { exports: {} }, af = { exports: {} }, Sw;
function IY() {
  return Sw || (Sw = 1, function(t, e) {
    (function(r, a) {
      a(e);
    })(jt, function(r) {
      class a {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      function l(i) {
        return i;
      }
      function d(i, c) {
        return i._indexes[c];
      }
      function h(i, c) {
        const f = d(i, c);
        if (f !== void 0)
          return f;
        const { array: s, _indexes: o } = i, y = s.push(c);
        return o[c] = y - 1;
      }
      function n(i) {
        const { array: c, _indexes: f } = i;
        if (c.length === 0)
          return;
        const s = c.pop();
        f[s] = void 0;
      }
      function u(i, c) {
        const f = d(i, c);
        if (f === void 0)
          return;
        const { array: s, _indexes: o } = i;
        for (let y = f + 1; y < s.length; y++) {
          const m = s[y];
          s[y - 1] = m, o[m]--;
        }
        o[c] = void 0, s.pop();
      }
      r.SetArray = a, r.get = d, r.pop = n, r.put = h, r.remove = u, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }(af, af.exports)), af.exports;
}
var of = { exports: {} }, ww;
function cC() {
  return ww || (ww = 1, function(t, e) {
    (function(r, a) {
      a(e);
    })(jt, function(r) {
      const d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = new Uint8Array(64), n = new Uint8Array(128);
      for (let b = 0; b < d.length; b++) {
        const v = d.charCodeAt(b);
        h[b] = v, n[v] = b;
      }
      const u = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Gt < "u" ? {
        decode(b) {
          return Gt.from(b.buffer, b.byteOffset, b.byteLength).toString();
        }
      } : {
        decode(b) {
          let v = "";
          for (let T = 0; T < b.length; T++)
            v += String.fromCharCode(b[T]);
          return v;
        }
      };
      function i(b) {
        const v = new Int32Array(5), T = [];
        let E = 0;
        do {
          const O = c(b, E), D = [];
          let $ = !0, I = 0;
          v[0] = 0;
          for (let k = E; k < O; k++) {
            let L;
            k = f(b, k, v, 0);
            const M = v[0];
            M < I && ($ = !1), I = M, s(b, k, O) ? (k = f(b, k, v, 1), k = f(b, k, v, 2), k = f(b, k, v, 3), s(b, k, O) ? (k = f(b, k, v, 4), L = [M, v[1], v[2], v[3], v[4]]) : L = [M, v[1], v[2], v[3]]) : L = [M], D.push(L);
          }
          $ || o(D), T.push(D), E = O + 1;
        } while (E <= b.length);
        return T;
      }
      function c(b, v) {
        const T = b.indexOf(";", v);
        return T === -1 ? b.length : T;
      }
      function f(b, v, T, E) {
        let O = 0, D = 0, $ = 0;
        do {
          const k = b.charCodeAt(v++);
          $ = n[k], O |= ($ & 31) << D, D += 5;
        } while ($ & 32);
        const I = O & 1;
        return O >>>= 1, I && (O = -2147483648 | -O), T[E] += O, v;
      }
      function s(b, v, T) {
        return v >= T ? !1 : b.charCodeAt(v) !== 44;
      }
      function o(b) {
        b.sort(y);
      }
      function y(b, v) {
        return b[0] - v[0];
      }
      function m(b) {
        const v = new Int32Array(5), T = 1024 * 16, E = T - 36, O = new Uint8Array(T), D = O.subarray(0, E);
        let $ = 0, I = "";
        for (let k = 0; k < b.length; k++) {
          const L = b[k];
          if (k > 0 && ($ === T && (I += u.decode(O), $ = 0), O[$++] = 59), L.length !== 0) {
            v[0] = 0;
            for (let M = 0; M < L.length; M++) {
              const x = L[M];
              $ > E && (I += u.decode(D), O.copyWithin(0, E, $), $ -= E), M > 0 && (O[$++] = 44), $ = g(O, $, v, x, 0), x.length !== 1 && ($ = g(O, $, v, x, 1), $ = g(O, $, v, x, 2), $ = g(O, $, v, x, 3), x.length !== 4 && ($ = g(O, $, v, x, 4)));
            }
          }
        }
        return I + u.decode(O.subarray(0, $));
      }
      function g(b, v, T, E, O) {
        const D = E[O];
        let $ = D - T[O];
        T[O] = D, $ = $ < 0 ? -$ << 1 | 1 : $ << 1;
        do {
          let I = $ & 31;
          $ >>>= 5, $ > 0 && (I |= 32), b[v++] = h[I];
        } while ($ > 0);
        return v;
      }
      r.decode = i, r.encode = m, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }(of, of.exports)), of.exports;
}
var lf = { exports: {} }, i0 = { exports: {} }, xw;
function OY() {
  return xw || (xw = 1, function(t, e) {
    (function(r, a) {
      t.exports = a();
    })(jt, function() {
      const r = /^[\w+.-]+:\/\//, a = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, l = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function d(v) {
        return r.test(v);
      }
      function h(v) {
        return v.startsWith("//");
      }
      function n(v) {
        return v.startsWith("/");
      }
      function u(v) {
        return v.startsWith("file:");
      }
      function i(v) {
        return /^[.?#]/.test(v);
      }
      function c(v) {
        const T = a.exec(v);
        return s(T[1], T[2] || "", T[3], T[4] || "", T[5] || "/", T[6] || "", T[7] || "");
      }
      function f(v) {
        const T = l.exec(v), E = T[2];
        return s("file:", "", T[1] || "", "", n(E) ? E : "/" + E, T[3] || "", T[4] || "");
      }
      function s(v, T, E, O, D, $, I) {
        return {
          scheme: v,
          user: T,
          host: E,
          port: O,
          path: D,
          query: $,
          hash: I,
          type: 7
        };
      }
      function o(v) {
        if (h(v)) {
          const E = c("http:" + v);
          return E.scheme = "", E.type = 6, E;
        }
        if (n(v)) {
          const E = c("http://foo.com" + v);
          return E.scheme = "", E.host = "", E.type = 5, E;
        }
        if (u(v))
          return f(v);
        if (d(v))
          return c(v);
        const T = c("http://foo.com/" + v);
        return T.scheme = "", T.host = "", T.type = v ? v.startsWith("?") ? 3 : v.startsWith("#") ? 2 : 4 : 1, T;
      }
      function y(v) {
        if (v.endsWith("/.."))
          return v;
        const T = v.lastIndexOf("/");
        return v.slice(0, T + 1);
      }
      function m(v, T) {
        g(T, T.type), v.path === "/" ? v.path = T.path : v.path = y(T.path) + v.path;
      }
      function g(v, T) {
        const E = T <= 4, O = v.path.split("/");
        let D = 1, $ = 0, I = !1;
        for (let L = 1; L < O.length; L++) {
          const M = O[L];
          if (!M) {
            I = !0;
            continue;
          }
          if (I = !1, M !== ".") {
            if (M === "..") {
              $ ? (I = !0, $--, D--) : E && (O[D++] = M);
              continue;
            }
            O[D++] = M, $++;
          }
        }
        let k = "";
        for (let L = 1; L < D; L++)
          k += "/" + O[L];
        (!k || I && !k.endsWith("/..")) && (k += "/"), v.path = k;
      }
      function b(v, T) {
        if (!v && !T)
          return "";
        const E = o(v);
        let O = E.type;
        if (T && O !== 7) {
          const $ = o(T), I = $.type;
          switch (O) {
            case 1:
              E.hash = $.hash;
            case 2:
              E.query = $.query;
            case 3:
            case 4:
              m(E, $);
            case 5:
              E.user = $.user, E.host = $.host, E.port = $.port;
            case 6:
              E.scheme = $.scheme;
          }
          I > O && (O = I);
        }
        g(E, O);
        const D = E.query + E.hash;
        switch (O) {
          case 2:
          case 3:
            return D;
          case 4: {
            const $ = E.path.slice(1);
            return $ ? i(T || v) && !i($) ? "./" + $ + D : $ + D : D || ".";
          }
          case 5:
            return E.path + D;
          default:
            return E.scheme + "//" + E.user + E.host + E.port + E.path + D;
        }
      }
      return b;
    });
  }(i0)), i0.exports;
}
var Tw;
function kY() {
  return Tw || (Tw = 1, function(t, e) {
    (function(r, a) {
      a(e, cC(), OY());
    })(jt, function(r, a, l) {
      function d(ge, se) {
        return se && !se.endsWith("/") && (se += "/"), l(ge, se);
      }
      function h(ge) {
        if (!ge)
          return "";
        const se = ge.lastIndexOf("/");
        return ge.slice(0, se + 1);
      }
      const n = 0, u = 1, i = 2, c = 3, f = 4, s = 1, o = 2;
      function y(ge, se) {
        const be = m(ge, 0);
        if (be === ge.length)
          return ge;
        se || (ge = ge.slice());
        for (let Ie = be; Ie < ge.length; Ie = m(ge, Ie + 1))
          ge[Ie] = b(ge[Ie], se);
        return ge;
      }
      function m(ge, se) {
        for (let be = se; be < ge.length; be++)
          if (!g(ge[be]))
            return be;
        return ge.length;
      }
      function g(ge) {
        for (let se = 1; se < ge.length; se++)
          if (ge[se][n] < ge[se - 1][n])
            return !1;
        return !0;
      }
      function b(ge, se) {
        return se || (ge = ge.slice()), ge.sort(v);
      }
      function v(ge, se) {
        return ge[n] - se[n];
      }
      let T = !1;
      function E(ge, se, be, Ie) {
        for (; be <= Ie; ) {
          const Oe = be + (Ie - be >> 1), Be = ge[Oe][n] - se;
          if (Be === 0)
            return T = !0, Oe;
          Be < 0 ? be = Oe + 1 : Ie = Oe - 1;
        }
        return T = !1, be - 1;
      }
      function O(ge, se, be) {
        for (let Ie = be + 1; Ie < ge.length && ge[Ie][n] === se; be = Ie++)
          ;
        return be;
      }
      function D(ge, se, be) {
        for (let Ie = be - 1; Ie >= 0 && ge[Ie][n] === se; be = Ie--)
          ;
        return be;
      }
      function $() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function I(ge, se, be, Ie) {
        const { lastKey: Oe, lastNeedle: Be, lastIndex: Fe } = be;
        let ue = 0, te = ge.length - 1;
        if (Ie === Oe) {
          if (se === Be)
            return T = Fe !== -1 && ge[Fe][n] === se, Fe;
          se >= Be ? ue = Fe === -1 ? 0 : Fe : te = Fe;
        }
        return be.lastKey = Ie, be.lastNeedle = se, be.lastIndex = E(ge, se, ue, te);
      }
      function k(ge, se) {
        const be = se.map(M);
        for (let Ie = 0; Ie < ge.length; Ie++) {
          const Oe = ge[Ie];
          for (let Be = 0; Be < Oe.length; Be++) {
            const Fe = Oe[Be];
            if (Fe.length === 1)
              continue;
            const ue = Fe[u], te = Fe[i], Y = Fe[c], le = be[ue], Ee = le[te] || (le[te] = []), Se = se[ue];
            let Pe = O(Ee, Y, I(Ee, Y, Se, te));
            Se.lastIndex = ++Pe, L(Ee, Pe, [Y, Ie, Fe[n]]);
          }
        }
        return be;
      }
      function L(ge, se, be) {
        for (let Ie = ge.length; Ie > se; Ie--)
          ge[Ie] = ge[Ie - 1];
        ge[se] = be;
      }
      function M() {
        return { __proto__: null };
      }
      const x = function(ge, se) {
        const be = _(ge);
        if (!("sections" in be))
          return new B(be, se);
        const Ie = [], Oe = [], Be = [], Fe = [], ue = [];
        S(be, se, Ie, Oe, Be, Fe, ue, 0, 0, 1 / 0, 1 / 0);
        const te = {
          version: 3,
          file: be.file,
          names: Fe,
          sources: Oe,
          sourcesContent: Be,
          mappings: Ie,
          ignoreList: ue
        };
        return _e(te);
      };
      function _(ge) {
        return typeof ge == "string" ? JSON.parse(ge) : ge;
      }
      function S(ge, se, be, Ie, Oe, Be, Fe, ue, te, Y, le) {
        const { sections: Ee } = ge;
        for (let Se = 0; Se < Ee.length; Se++) {
          const { map: Pe, offset: Ve } = Ee[Se];
          let Xe = Y, Ye = le;
          if (Se + 1 < Ee.length) {
            const We = Ee[Se + 1].offset;
            Xe = Math.min(Y, ue + We.line), Xe === Y ? Ye = Math.min(le, te + We.column) : Xe < Y && (Ye = te + We.column);
          }
          C(Pe, se, be, Ie, Oe, Be, Fe, ue + Ve.line, te + Ve.column, Xe, Ye);
        }
      }
      function C(ge, se, be, Ie, Oe, Be, Fe, ue, te, Y, le) {
        const Ee = _(ge);
        if ("sections" in Ee)
          return S(...arguments);
        const Se = new B(Ee, se), Pe = Ie.length, Ve = Be.length, Xe = re(Se), { resolvedSources: Ye, sourcesContent: We, ignoreList: et } = Se;
        if (R(Ie, Ye), R(Be, Se.names), We)
          R(Oe, We);
        else
          for (let De = 0; De < Ye.length; De++)
            Oe.push(null);
        if (et)
          for (let De = 0; De < et.length; De++)
            Fe.push(et[De] + Pe);
        for (let De = 0; De < Xe.length; De++) {
          const Me = ue + De;
          if (Me > Y)
            return;
          const Qe = H(be, Me), He = De === 0 ? te : 0, st = Xe[De];
          for (let it = 0; it < st.length; it++) {
            const qe = st[it], rt = He + qe[n];
            if (Me === Y && rt >= le)
              return;
            if (qe.length === 1) {
              Qe.push([rt]);
              continue;
            }
            const bt = Pe + qe[u], dt = qe[i], Je = qe[c];
            Qe.push(qe.length === 4 ? [rt, bt, dt, Je] : [rt, bt, dt, Je, Ve + qe[f]]);
          }
        }
      }
      function R(ge, se) {
        for (let be = 0; be < se.length; be++)
          ge.push(se[be]);
      }
      function H(ge, se) {
        for (let be = ge.length; be <= se; be++)
          ge[be] = [];
        return ge[se];
      }
      const z = "`line` must be greater than 0 (lines start at line 1)", U = "`column` must be greater than or equal to 0 (columns start at column 0)", P = -1, W = 1;
      class B {
        constructor(se, be) {
          const Ie = typeof se == "string";
          if (!Ie && se._decodedMemo)
            return se;
          const Oe = Ie ? JSON.parse(se) : se, { version: Be, file: Fe, names: ue, sourceRoot: te, sources: Y, sourcesContent: le } = Oe;
          this.version = Be, this.file = Fe, this.names = ue || [], this.sourceRoot = te, this.sources = Y, this.sourcesContent = le, this.ignoreList = Oe.ignoreList || Oe.x_google_ignoreList || void 0;
          const Ee = d(te || "", h(be));
          this.resolvedSources = Y.map((Pe) => d(Pe || "", Ee));
          const { mappings: Se } = Oe;
          typeof Se == "string" ? (this._encoded = Se, this._decoded = void 0) : (this._encoded = void 0, this._decoded = y(Se, Ie)), this._decodedMemo = $(), this._bySources = void 0, this._bySourceMemos = void 0;
        }
      }
      function Q(ge) {
        return ge;
      }
      function J(ge) {
        var se, be;
        return (se = (be = ge)._encoded) !== null && se !== void 0 ? se : be._encoded = a.encode(ge._decoded);
      }
      function re(ge) {
        var se;
        return (se = ge)._decoded || (se._decoded = a.decode(ge._encoded));
      }
      function G(ge, se, be) {
        const Ie = re(ge);
        if (se >= Ie.length)
          return null;
        const Oe = Ie[se], Be = me(Oe, ge._decodedMemo, se, be, W);
        return Be === -1 ? null : Oe[Be];
      }
      function N(ge, se) {
        let { line: be, column: Ie, bias: Oe } = se;
        if (be--, be < 0)
          throw new Error(z);
        if (Ie < 0)
          throw new Error(U);
        const Be = re(ge);
        if (be >= Be.length)
          return ae(null, null, null, null);
        const Fe = Be[be], ue = me(Fe, ge._decodedMemo, be, Ie, Oe || W);
        if (ue === -1)
          return ae(null, null, null, null);
        const te = Fe[ue];
        if (te.length === 1)
          return ae(null, null, null, null);
        const { names: Y, resolvedSources: le } = ge;
        return ae(le[te[u]], te[i] + 1, te[c], te.length === 5 ? Y[te[f]] : null);
      }
      function V(ge, se) {
        const { source: be, line: Ie, column: Oe, bias: Be } = se;
        return we(ge, be, Ie, Oe, Be || W, !1);
      }
      function F(ge, se) {
        const { source: be, line: Ie, column: Oe, bias: Be } = se;
        return we(ge, be, Ie, Oe, Be || P, !0);
      }
      function X(ge, se) {
        const be = re(ge), { names: Ie, resolvedSources: Oe } = ge;
        for (let Be = 0; Be < be.length; Be++) {
          const Fe = be[Be];
          for (let ue = 0; ue < Fe.length; ue++) {
            const te = Fe[ue], Y = Be + 1, le = te[0];
            let Ee = null, Se = null, Pe = null, Ve = null;
            te.length !== 1 && (Ee = Oe[te[1]], Se = te[2] + 1, Pe = te[3]), te.length === 5 && (Ve = Ie[te[4]]), se({
              generatedLine: Y,
              generatedColumn: le,
              source: Ee,
              originalLine: Se,
              originalColumn: Pe,
              name: Ve
            });
          }
        }
      }
      function K(ge, se) {
        const { sources: be, resolvedSources: Ie } = ge;
        let Oe = be.indexOf(se);
        return Oe === -1 && (Oe = Ie.indexOf(se)), Oe;
      }
      function ie(ge, se) {
        const { sourcesContent: be } = ge;
        if (be == null)
          return null;
        const Ie = K(ge, se);
        return Ie === -1 ? null : be[Ie];
      }
      function fe(ge, se) {
        const { ignoreList: be } = ge;
        if (be == null)
          return !1;
        const Ie = K(ge, se);
        return Ie === -1 ? !1 : be.includes(Ie);
      }
      function _e(ge, se) {
        const be = new B(ee(ge, []), se);
        return be._decoded = ge.mappings, be;
      }
      function Ae(ge) {
        return ee(ge, re(ge));
      }
      function ce(ge) {
        return ee(ge, J(ge));
      }
      function ee(ge, se) {
        return {
          version: ge.version,
          file: ge.file,
          names: ge.names,
          sourceRoot: ge.sourceRoot,
          sources: ge.sources,
          sourcesContent: ge.sourcesContent,
          mappings: se,
          ignoreList: ge.ignoreList || ge.x_google_ignoreList
        };
      }
      function ae(ge, se, be, Ie) {
        return { source: ge, line: se, column: be, name: Ie };
      }
      function oe(ge, se) {
        return { line: ge, column: se };
      }
      function me(ge, se, be, Ie, Oe) {
        let Be = I(ge, Ie, se, be);
        return T ? Be = (Oe === P ? O : D)(ge, Ie, Be) : Oe === P && Be++, Be === -1 || Be === ge.length ? -1 : Be;
      }
      function ye(ge, se, be, Ie, Oe) {
        let Be = me(ge, se, be, Ie, W);
        if (!T && Oe === P && Be++, Be === -1 || Be === ge.length)
          return [];
        const Fe = T ? Ie : ge[Be][n];
        T || (Be = D(ge, Fe, Be));
        const ue = O(ge, Fe, Be), te = [];
        for (; Be <= ue; Be++) {
          const Y = ge[Be];
          te.push(oe(Y[s] + 1, Y[o]));
        }
        return te;
      }
      function we(ge, se, be, Ie, Oe, Be) {
        var Fe;
        if (be--, be < 0)
          throw new Error(z);
        if (Ie < 0)
          throw new Error(U);
        const { sources: ue, resolvedSources: te } = ge;
        let Y = ue.indexOf(se);
        if (Y === -1 && (Y = te.indexOf(se)), Y === -1)
          return Be ? [] : oe(null, null);
        const Ee = ((Fe = ge)._bySources || (Fe._bySources = k(re(ge), ge._bySourceMemos = ue.map($))))[Y][be];
        if (Ee == null)
          return Be ? [] : oe(null, null);
        const Se = ge._bySourceMemos[Y];
        if (Be)
          return ye(Ee, Se, be, Ie, Oe);
        const Pe = me(Ee, Se, be, Ie, Oe);
        if (Pe === -1)
          return oe(null, null);
        const Ve = Ee[Pe];
        return oe(Ve[s] + 1, Ve[o]);
      }
      r.AnyMap = x, r.GREATEST_LOWER_BOUND = W, r.LEAST_UPPER_BOUND = P, r.TraceMap = B, r.allGeneratedPositionsFor = F, r.decodedMap = Ae, r.decodedMappings = re, r.eachMapping = X, r.encodedMap = ce, r.encodedMappings = J, r.generatedPositionFor = V, r.isIgnored = fe, r.originalPositionFor = N, r.presortedDecodedMap = _e, r.sourceContentFor = ie, r.traceSegment = G;
    });
  }(lf, lf.exports)), lf.exports;
}
(function(t, e) {
  (function(r, a) {
    a(e, IY(), cC(), kY());
  })(jt, function(r, a, l, d) {
    class s {
      constructor({ file: z, sourceRoot: U } = {}) {
        this._names = new a.SetArray(), this._sources = new a.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = z, this.sourceRoot = U, this._ignoreList = new a.SetArray();
      }
    }
    function o(H) {
      return H;
    }
    function y(H, z, U, P, W, B, Q, J) {
      return I(!1, H, z, U, P, W, B, Q, J);
    }
    function m(H, z) {
      return R(!1, H, z);
    }
    const g = (H, z, U, P, W, B, Q, J) => I(!0, H, z, U, P, W, B, Q, J), b = (H, z) => R(!0, H, z);
    function v(H, z, U) {
      const { _sources: P, _sourcesContent: W } = H, B = a.put(P, z);
      W[B] = U;
    }
    function T(H, z, U = !0) {
      const { _sources: P, _sourcesContent: W, _ignoreList: B } = H, Q = a.put(P, z);
      Q === W.length && (W[Q] = null), U ? a.put(B, Q) : a.remove(B, Q);
    }
    function E(H) {
      const { _mappings: z, _sources: U, _sourcesContent: P, _names: W, _ignoreList: B } = H;
      return x(z), {
        version: 3,
        file: H.file || void 0,
        names: W.array,
        sourceRoot: H.sourceRoot || void 0,
        sources: U.array,
        sourcesContent: P,
        mappings: z,
        ignoreList: B.array
      };
    }
    function O(H) {
      const z = E(H);
      return Object.assign(Object.assign({}, z), { mappings: l.encode(z.mappings) });
    }
    function D(H) {
      const z = new d.TraceMap(H), U = new s({ file: z.file, sourceRoot: z.sourceRoot });
      return _(U._names, z.names), _(U._sources, z.sources), U._sourcesContent = z.sourcesContent || z.sources.map(() => null), U._mappings = d.decodedMappings(z), z.ignoreList && _(U._ignoreList, z.ignoreList), U;
    }
    function $(H) {
      const z = [], { _mappings: U, _sources: P, _names: W } = H;
      for (let B = 0; B < U.length; B++) {
        const Q = U[B];
        for (let J = 0; J < Q.length; J++) {
          const re = Q[J], G = { line: B + 1, column: re[0] };
          let N, V, F;
          re.length !== 1 && (N = P.array[re[1]], V = { line: re[2] + 1, column: re[3] }, re.length === 5 && (F = W.array[re[4]])), z.push({ generated: G, source: N, original: V, name: F });
        }
      }
      return z;
    }
    function I(H, z, U, P, W, B, Q, J, re) {
      const { _mappings: G, _sources: N, _sourcesContent: V, _names: F } = z, X = k(G, U), K = L(X, P);
      if (!W)
        return H && S(X, K) ? void 0 : M(X, K, [P]);
      const ie = a.put(N, W), fe = J ? a.put(F, J) : -1;
      if (ie === V.length && (V[ie] = re ?? null), !(H && C(X, K, ie, B, Q, fe)))
        return M(X, K, J ? [P, ie, B, Q, fe] : [P, ie, B, Q]);
    }
    function k(H, z) {
      for (let U = H.length; U <= z; U++)
        H[U] = [];
      return H[z];
    }
    function L(H, z) {
      let U = H.length;
      for (let P = U - 1; P >= 0; U = P--) {
        const W = H[P];
        if (z >= W[0])
          break;
      }
      return U;
    }
    function M(H, z, U) {
      for (let P = H.length; P > z; P--)
        H[P] = H[P - 1];
      H[z] = U;
    }
    function x(H) {
      const { length: z } = H;
      let U = z;
      for (let P = U - 1; P >= 0 && !(H[P].length > 0); U = P, P--)
        ;
      U < z && (H.length = U);
    }
    function _(H, z) {
      for (let U = 0; U < z.length; U++)
        a.put(H, z[U]);
    }
    function S(H, z) {
      return z === 0 ? !0 : H[z - 1].length === 1;
    }
    function C(H, z, U, P, W, B) {
      if (z === 0)
        return !1;
      const Q = H[z - 1];
      return Q.length === 1 ? !1 : U === Q[1] && P === Q[2] && W === Q[3] && B === (Q.length === 5 ? Q[4] : -1);
    }
    function R(H, z, U) {
      const { generated: P, source: W, original: B, name: Q, content: J } = U;
      return W ? I(H, z, P.line - 1, P.column, W, B.line - 1, B.column, Q, J) : I(H, z, P.line - 1, P.column, null, null, null, null, null);
    }
    r.GenMapping = s, r.addMapping = m, r.addSegment = y, r.allMappings = $, r.fromMap = D, r.maybeAddMapping = b, r.maybeAddSegment = g, r.setIgnore = T, r.setSourceContent = v, r.toDecodedMap = E, r.toEncodedMap = O, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(ny, ny.exports);
var iu = ny.exports;
function DY({ code: t, mappings: e }, r, a, l, d) {
  const h = NY(l, d), n = new iu.GenMapping({ file: a.compiledFilename });
  let u = 0, i = e[0];
  for (; i === void 0 && u < e.length - 1; )
    u++, i = e[u];
  let c = 0, f = 0;
  i !== f && iu.maybeAddSegment(n, c, 0, r, c, 0);
  for (let m = 0; m < t.length; m++) {
    if (m === i) {
      const g = i - f, b = h[u];
      for (iu.maybeAddSegment(n, c, g, r, c, b); (i === m || i === void 0) && u < e.length - 1; )
        u++, i = e[u];
    }
    t.charCodeAt(m) === ze.lineFeed && (c++, f = m + 1, i !== f && iu.maybeAddSegment(n, c, 0, r, c, 0));
  }
  const { sourceRoot: s, sourcesContent: o, ...y } = iu.toEncodedMap(n);
  return y;
}
function NY(t, e) {
  const r = new Array(e.length);
  let a = 0, l = e[a].start, d = 0;
  for (let h = 0; h < t.length; h++)
    h === l && (r[a] = l - d, a++, l = e[a].start), t.charCodeAt(h) === ze.lineFeed && (d = h + 1);
  return r;
}
const RY = {
  require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
  interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
  interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
  createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
  // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
  // check in the exports object and does a plain assignment, whereas Babel uses
  // defineProperty and builds an object of explicitly-exported names so that star exports can
  // always take lower precedence. For now, we do the easier TypeScript thing.
  createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
  nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
  asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
  optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
  optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
  asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
};
class od {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(e) {
    this.nameManager = e, od.prototype.__init.call(this), od.prototype.__init2.call(this);
  }
  getHelperName(e) {
    let r = this.helperNames[e];
    return r || (r = this.nameManager.claimFreeName(`_${e}`), this.helperNames[e] = r, r);
  }
  emitHelpers() {
    let e = "";
    this.helperNames.optionalChainDelete && this.getHelperName("optionalChain"), this.helperNames.asyncOptionalChainDelete && this.getHelperName("asyncOptionalChain");
    for (const [r, a] of Object.entries(RY)) {
      const l = this.helperNames[r];
      let d = a;
      r === "optionalChainDelete" ? d = d.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain) : r === "asyncOptionalChainDelete" ? d = d.replace(
        "ASYNC_OPTIONAL_CHAIN_NAME",
        this.helperNames.asyncOptionalChain
      ) : r === "require" && (this.createRequireName === null && (this.createRequireName = this.nameManager.claimFreeName("_createRequire")), d = d.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName)), l && (e += " ", e += d.replace(r, l).replace(/\s+/g, " ").trim());
    }
    return e;
  }
}
function Aw(t, e, r) {
  MY(t, r) && LY(t, e, r);
}
function MY(t, e) {
  for (const r of t.tokens)
    if (r.type === j.name && !r.isType && rY(r) && e.has(t.identifierNameForToken(r)))
      return !0;
  return !1;
}
function LY(t, e, r) {
  const a = [];
  let l = e.length - 1;
  for (let d = t.tokens.length - 1; ; d--) {
    for (; a.length > 0 && a[a.length - 1].startTokenIndex === d + 1; )
      a.pop();
    for (; l >= 0 && e[l].endTokenIndex === d + 1; )
      a.push(e[l]), l--;
    if (d < 0)
      break;
    const h = t.tokens[d], n = t.identifierNameForToken(h);
    if (a.length > 1 && !h.isType && h.type === j.name && r.has(n)) {
      if (nY(h))
        Pw(a[a.length - 1], t, n);
      else if (iY(h)) {
        let u = a.length - 1;
        for (; u > 0 && !a[u].isFunctionScope; )
          u--;
        if (u < 0)
          throw new Error("Did not find parent function scope.");
        Pw(a[u], t, n);
      }
    }
  }
  if (a.length > 0)
    throw new Error("Expected empty scope stack after processing file.");
}
function Pw(t, e, r) {
  for (let a = t.startTokenIndex; a < t.endTokenIndex; a++) {
    const l = e.tokens[a];
    (l.type === j.name || l.type === j.jsxName) && e.identifierNameForToken(l) === r && (l.shadowsGlobal = !0);
  }
}
function jY(t, e) {
  const r = [];
  for (const a of e)
    a.type === j.name && r.push(t.slice(a.start, a.end));
  return r;
}
class Ag {
  __init() {
    this.usedNames = /* @__PURE__ */ new Set();
  }
  constructor(e, r) {
    Ag.prototype.__init.call(this), this.usedNames = new Set(jY(e, r));
  }
  claimFreeName(e) {
    const r = this.findFreeName(e);
    return this.usedNames.add(r), r;
  }
  findFreeName(e) {
    if (!this.usedNames.has(e))
      return e;
    let r = 2;
    for (; this.usedNames.has(e + String(r)); )
      r++;
    return e + String(r);
  }
}
var Or = {}, iy = {}, ks = {}, FY = jt && jt.__extends || /* @__PURE__ */ function() {
  var t = function(e, r) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, l) {
      a.__proto__ = l;
    } || function(a, l) {
      for (var d in l) l.hasOwnProperty(d) && (a[d] = l[d]);
    }, t(e, r);
  };
  return function(e, r) {
    t(e, r);
    function a() {
      this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (a.prototype = r.prototype, new a());
  };
}();
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.DetailContext = ks.NoopContext = ks.VError = void 0;
var fC = (
  /** @class */
  function(t) {
    FY(e, t);
    function e(r, a) {
      var l = t.call(this, a) || this;
      return l.path = r, Object.setPrototypeOf(l, e.prototype), l;
    }
    return e;
  }(Error)
);
ks.VError = fC;
var BY = (
  /** @class */
  function() {
    function t() {
    }
    return t.prototype.fail = function(e, r, a) {
      return !1;
    }, t.prototype.unionResolver = function() {
      return this;
    }, t.prototype.createContext = function() {
      return this;
    }, t.prototype.resolveUnion = function(e) {
    }, t;
  }()
);
ks.NoopContext = BY;
var dC = (
  /** @class */
  function() {
    function t() {
      this._propNames = [""], this._messages = [null], this._score = 0;
    }
    return t.prototype.fail = function(e, r, a) {
      return this._propNames.push(e), this._messages.push(r), this._score += a, !1;
    }, t.prototype.unionResolver = function() {
      return new $Y();
    }, t.prototype.resolveUnion = function(e) {
      for (var r, a, l = e, d = null, h = 0, n = l.contexts; h < n.length; h++) {
        var u = n[h];
        (!d || u._score >= d._score) && (d = u);
      }
      d && d._score > 0 && ((r = this._propNames).push.apply(r, d._propNames), (a = this._messages).push.apply(a, d._messages));
    }, t.prototype.getError = function(e) {
      for (var r = [], a = this._propNames.length - 1; a >= 0; a--) {
        var l = this._propNames[a];
        e += typeof l == "number" ? "[" + l + "]" : l ? "." + l : "";
        var d = this._messages[a];
        d && r.push(e + " " + d);
      }
      return new fC(e, r.join("; "));
    }, t.prototype.getErrorDetail = function(e) {
      for (var r = [], a = this._propNames.length - 1; a >= 0; a--) {
        var l = this._propNames[a];
        e += typeof l == "number" ? "[" + l + "]" : l ? "." + l : "";
        var d = this._messages[a];
        d && r.push({ path: e, message: d });
      }
      for (var h = null, a = r.length - 1; a >= 0; a--)
        h && (r[a].nested = [h]), h = r[a];
      return h;
    }, t;
  }()
);
ks.DetailContext = dC;
var $Y = (
  /** @class */
  function() {
    function t() {
      this.contexts = [];
    }
    return t.prototype.createContext = function() {
      var e = new dC();
      return this.contexts.push(e), e;
    }, t;
  }()
);
(function(t) {
  var e = jt && jt.__extends || /* @__PURE__ */ function() {
    var re = function(G, N) {
      return re = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(V, F) {
        V.__proto__ = F;
      } || function(V, F) {
        for (var X in F) F.hasOwnProperty(X) && (V[X] = F[X]);
      }, re(G, N);
    };
    return function(G, N) {
      re(G, N);
      function V() {
        this.constructor = G;
      }
      G.prototype = N === null ? Object.create(N) : (V.prototype = N.prototype, new V());
    };
  }();
  Object.defineProperty(t, "__esModule", { value: !0 }), t.basicTypes = t.BasicType = t.TParamList = t.TParam = t.param = t.TFunc = t.func = t.TProp = t.TOptional = t.opt = t.TIface = t.iface = t.TEnumLiteral = t.enumlit = t.TEnumType = t.enumtype = t.TIntersection = t.intersection = t.TUnion = t.union = t.TTuple = t.tuple = t.TArray = t.array = t.TLiteral = t.lit = t.TName = t.name = t.TType = void 0;
  var r = ks, a = (
    /** @class */
    /* @__PURE__ */ function() {
      function re() {
      }
      return re;
    }()
  );
  t.TType = a;
  function l(re) {
    return typeof re == "string" ? h(re) : re;
  }
  function d(re, G) {
    var N = re[G];
    if (!N)
      throw new Error("Unknown type " + G);
    return N;
  }
  function h(re) {
    return new n(re);
  }
  t.name = h;
  var n = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.name = N, V._failMsg = "is not a " + N, V;
      }
      return G.prototype.getChecker = function(N, V, F) {
        var X = this, K = d(N, this.name), ie = K.getChecker(N, V, F);
        return K instanceof z || K instanceof G ? ie : function(fe, _e) {
          return ie(fe, _e) ? !0 : _e.fail(null, X._failMsg, 0);
        };
      }, G;
    }(a)
  );
  t.TName = n;
  function u(re) {
    return new i(re);
  }
  t.lit = u;
  var i = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.value = N, V.name = JSON.stringify(N), V._failMsg = "is not " + V.name, V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this;
        return function(X, K) {
          return X === F.value ? !0 : K.fail(null, F._failMsg, -1);
        };
      }, G;
    }(a)
  );
  t.TLiteral = i;
  function c(re) {
    return new f(l(re));
  }
  t.array = c;
  var f = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.ttype = N, V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this.ttype.getChecker(N, V);
        return function(X, K) {
          if (!Array.isArray(X))
            return K.fail(null, "is not an array", 0);
          for (var ie = 0; ie < X.length; ie++) {
            var fe = F(X[ie], K);
            if (!fe)
              return K.fail(ie, null, 1);
          }
          return !0;
        };
      }, G;
    }(a)
  );
  t.TArray = f;
  function s() {
    for (var re = [], G = 0; G < arguments.length; G++)
      re[G] = arguments[G];
    return new o(re.map(function(N) {
      return l(N);
    }));
  }
  t.tuple = s;
  var o = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.ttypes = N, V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this.ttypes.map(function(K) {
          return K.getChecker(N, V);
        }), X = function(K, ie) {
          if (!Array.isArray(K))
            return ie.fail(null, "is not an array", 0);
          for (var fe = 0; fe < F.length; fe++) {
            var _e = F[fe](K[fe], ie);
            if (!_e)
              return ie.fail(fe, null, 1);
          }
          return !0;
        };
        return V ? function(K, ie) {
          return X(K, ie) ? K.length <= F.length ? !0 : ie.fail(F.length, "is extraneous", 2) : !1;
        } : X;
      }, G;
    }(a)
  );
  t.TTuple = o;
  function y() {
    for (var re = [], G = 0; G < arguments.length; G++)
      re[G] = arguments[G];
    return new m(re.map(function(N) {
      return l(N);
    }));
  }
  t.union = y;
  var m = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        V.ttypes = N;
        var F = N.map(function(K) {
          return K instanceof n || K instanceof i ? K.name : null;
        }).filter(function(K) {
          return K;
        }), X = N.length - F.length;
        return F.length ? (X > 0 && F.push(X + " more"), V._failMsg = "is none of " + F.join(", ")) : V._failMsg = "is none of " + X + " types", V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this, X = this.ttypes.map(function(K) {
          return K.getChecker(N, V);
        });
        return function(K, ie) {
          for (var fe = ie.unionResolver(), _e = 0; _e < X.length; _e++) {
            var Ae = X[_e](K, fe.createContext());
            if (Ae)
              return !0;
          }
          return ie.resolveUnion(fe), ie.fail(null, F._failMsg, 0);
        };
      }, G;
    }(a)
  );
  t.TUnion = m;
  function g() {
    for (var re = [], G = 0; G < arguments.length; G++)
      re[G] = arguments[G];
    return new b(re.map(function(N) {
      return l(N);
    }));
  }
  t.intersection = g;
  var b = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.ttypes = N, V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = /* @__PURE__ */ new Set(), X = this.ttypes.map(function(K) {
          return K.getChecker(N, V, F);
        });
        return function(K, ie) {
          var fe = X.every(function(_e) {
            return _e(K, ie);
          });
          return fe ? !0 : ie.fail(null, null, 0);
        };
      }, G;
    }(a)
  );
  t.TIntersection = b;
  function v(re) {
    return new T(re);
  }
  t.enumtype = v;
  var T = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.members = N, V.validValues = /* @__PURE__ */ new Set(), V._failMsg = "is not a valid enum value", V.validValues = new Set(Object.keys(N).map(function(F) {
          return N[F];
        })), V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this;
        return function(X, K) {
          return F.validValues.has(X) ? !0 : K.fail(null, F._failMsg, 0);
        };
      }, G;
    }(a)
  );
  t.TEnumType = T;
  function E(re, G) {
    return new O(re, G);
  }
  t.enumlit = E;
  var O = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N, V) {
        var F = re.call(this) || this;
        return F.enumName = N, F.prop = V, F._failMsg = "is not " + N + "." + V, F;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this, X = d(N, this.enumName);
        if (!(X instanceof T))
          throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
        var K = X.members[this.prop];
        if (!X.members.hasOwnProperty(this.prop))
          throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
        return function(ie, fe) {
          return ie === K ? !0 : fe.fail(null, F._failMsg, -1);
        };
      }, G;
    }(a)
  );
  t.TEnumLiteral = O;
  function D(re) {
    return Object.keys(re).map(function(G) {
      return $(G, re[G]);
    });
  }
  function $(re, G) {
    return G instanceof M ? new x(re, G.ttype, !0) : new x(re, l(G), !1);
  }
  function I(re, G) {
    return new k(re, D(G));
  }
  t.iface = I;
  var k = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N, V) {
        var F = re.call(this) || this;
        return F.bases = N, F.props = V, F.propSet = new Set(V.map(function(X) {
          return X.name;
        })), F;
      }
      return G.prototype.getChecker = function(N, V, F) {
        var X = this, K = this.bases.map(function(ee) {
          return d(N, ee).getChecker(N, V);
        }), ie = this.props.map(function(ee) {
          return ee.ttype.getChecker(N, V);
        }), fe = new r.NoopContext(), _e = this.props.map(function(ee, ae) {
          return !ee.isOpt && !ie[ae](void 0, fe);
        }), Ae = function(ee, ae) {
          if (typeof ee != "object" || ee === null)
            return ae.fail(null, "is not an object", 0);
          for (var oe = 0; oe < K.length; oe++)
            if (!K[oe](ee, ae))
              return !1;
          for (var oe = 0; oe < ie.length; oe++) {
            var me = X.props[oe].name, ye = ee[me];
            if (ye === void 0) {
              if (_e[oe])
                return ae.fail(me, "is missing", 1);
            } else {
              var we = ie[oe](ye, ae);
              if (!we)
                return ae.fail(me, null, 1);
            }
          }
          return !0;
        };
        if (!V)
          return Ae;
        var ce = this.propSet;
        return F && (this.propSet.forEach(function(ee) {
          return F.add(ee);
        }), ce = F), function(ee, ae) {
          if (!Ae(ee, ae))
            return !1;
          for (var oe in ee)
            if (!ce.has(oe))
              return ae.fail(oe, "is extraneous", 2);
          return !0;
        };
      }, G;
    }(a)
  );
  t.TIface = k;
  function L(re) {
    return new M(l(re));
  }
  t.opt = L;
  var M = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.ttype = N, V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this.ttype.getChecker(N, V);
        return function(X, K) {
          return X === void 0 || F(X, K);
        };
      }, G;
    }(a)
  );
  t.TOptional = M;
  var x = (
    /** @class */
    /* @__PURE__ */ function() {
      function re(G, N, V) {
        this.name = G, this.ttype = N, this.isOpt = V;
      }
      return re;
    }()
  );
  t.TProp = x;
  function _(re) {
    for (var G = [], N = 1; N < arguments.length; N++)
      G[N - 1] = arguments[N];
    return new S(new H(G), l(re));
  }
  t.func = _;
  var S = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N, V) {
        var F = re.call(this) || this;
        return F.paramList = N, F.result = V, F;
      }
      return G.prototype.getChecker = function(N, V) {
        return function(F, X) {
          return typeof F == "function" ? !0 : X.fail(null, "is not a function", 0);
        };
      }, G;
    }(a)
  );
  t.TFunc = S;
  function C(re, G, N) {
    return new R(re, l(G), !!N);
  }
  t.param = C;
  var R = (
    /** @class */
    /* @__PURE__ */ function() {
      function re(G, N, V) {
        this.name = G, this.ttype = N, this.isOpt = V;
      }
      return re;
    }()
  );
  t.TParam = R;
  var H = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N) {
        var V = re.call(this) || this;
        return V.params = N, V;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this, X = this.params.map(function(_e) {
          return _e.ttype.getChecker(N, V);
        }), K = new r.NoopContext(), ie = this.params.map(function(_e, Ae) {
          return !_e.isOpt && !X[Ae](void 0, K);
        }), fe = function(_e, Ae) {
          if (!Array.isArray(_e))
            return Ae.fail(null, "is not an array", 0);
          for (var ce = 0; ce < X.length; ce++) {
            var ee = F.params[ce];
            if (_e[ce] === void 0) {
              if (ie[ce])
                return Ae.fail(ee.name, "is missing", 1);
            } else {
              var ae = X[ce](_e[ce], Ae);
              if (!ae)
                return Ae.fail(ee.name, null, 1);
            }
          }
          return !0;
        };
        return V ? function(_e, Ae) {
          return fe(_e, Ae) ? _e.length <= X.length ? !0 : Ae.fail(X.length, "is extraneous", 2) : !1;
        } : fe;
      }, G;
    }(a)
  );
  t.TParamList = H;
  var z = (
    /** @class */
    function(re) {
      e(G, re);
      function G(N, V) {
        var F = re.call(this) || this;
        return F.validator = N, F.message = V, F;
      }
      return G.prototype.getChecker = function(N, V) {
        var F = this;
        return function(X, K) {
          return F.validator(X) ? !0 : K.fail(null, F.message, 0);
        };
      }, G;
    }(a)
  );
  t.BasicType = z, t.basicTypes = {
    any: new z(function(re) {
      return !0;
    }, "is invalid"),
    number: new z(function(re) {
      return typeof re == "number";
    }, "is not a number"),
    object: new z(function(re) {
      return typeof re == "object" && re;
    }, "is not an object"),
    boolean: new z(function(re) {
      return typeof re == "boolean";
    }, "is not a boolean"),
    string: new z(function(re) {
      return typeof re == "string";
    }, "is not a string"),
    symbol: new z(function(re) {
      return typeof re == "symbol";
    }, "is not a symbol"),
    void: new z(function(re) {
      return re == null;
    }, "is not void"),
    undefined: new z(function(re) {
      return re === void 0;
    }, "is not undefined"),
    null: new z(function(re) {
      return re === null;
    }, "is not null"),
    never: new z(function(re) {
      return !1;
    }, "is unexpected"),
    Date: new z(P("[object Date]"), "is not a Date"),
    RegExp: new z(P("[object RegExp]"), "is not a RegExp")
  };
  var U = Object.prototype.toString;
  function P(re) {
    return function(G) {
      return typeof G == "object" && G && U.call(G) === re;
    };
  }
  typeof Gt < "u" && (t.basicTypes.Buffer = new z(function(re) {
    return Gt.isBuffer(re);
  }, "is not a Buffer"));
  for (var W = function(re) {
    t.basicTypes[re.name] = new z(function(G) {
      return G instanceof re;
    }, "is not a " + re.name);
  }, B = 0, Q = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    ArrayBuffer
  ]; B < Q.length; B++) {
    var J = Q[B];
    W(J);
  }
})(iy);
(function(t) {
  var e = jt && jt.__spreadArrays || function() {
    for (var u = 0, i = 0, c = arguments.length; i < c; i++) u += arguments[i].length;
    for (var f = Array(u), s = 0, i = 0; i < c; i++)
      for (var o = arguments[i], y = 0, m = o.length; y < m; y++, s++)
        f[s] = o[y];
    return f;
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Checker = t.createCheckers = void 0;
  var r = iy, a = ks, l = iy;
  Object.defineProperty(t, "TArray", { enumerable: !0, get: function() {
    return l.TArray;
  } }), Object.defineProperty(t, "TEnumType", { enumerable: !0, get: function() {
    return l.TEnumType;
  } }), Object.defineProperty(t, "TEnumLiteral", { enumerable: !0, get: function() {
    return l.TEnumLiteral;
  } }), Object.defineProperty(t, "TFunc", { enumerable: !0, get: function() {
    return l.TFunc;
  } }), Object.defineProperty(t, "TIface", { enumerable: !0, get: function() {
    return l.TIface;
  } }), Object.defineProperty(t, "TLiteral", { enumerable: !0, get: function() {
    return l.TLiteral;
  } }), Object.defineProperty(t, "TName", { enumerable: !0, get: function() {
    return l.TName;
  } }), Object.defineProperty(t, "TOptional", { enumerable: !0, get: function() {
    return l.TOptional;
  } }), Object.defineProperty(t, "TParam", { enumerable: !0, get: function() {
    return l.TParam;
  } }), Object.defineProperty(t, "TParamList", { enumerable: !0, get: function() {
    return l.TParamList;
  } }), Object.defineProperty(t, "TProp", { enumerable: !0, get: function() {
    return l.TProp;
  } }), Object.defineProperty(t, "TTuple", { enumerable: !0, get: function() {
    return l.TTuple;
  } }), Object.defineProperty(t, "TType", { enumerable: !0, get: function() {
    return l.TType;
  } }), Object.defineProperty(t, "TUnion", { enumerable: !0, get: function() {
    return l.TUnion;
  } }), Object.defineProperty(t, "TIntersection", { enumerable: !0, get: function() {
    return l.TIntersection;
  } }), Object.defineProperty(t, "array", { enumerable: !0, get: function() {
    return l.array;
  } }), Object.defineProperty(t, "enumlit", { enumerable: !0, get: function() {
    return l.enumlit;
  } }), Object.defineProperty(t, "enumtype", { enumerable: !0, get: function() {
    return l.enumtype;
  } }), Object.defineProperty(t, "func", { enumerable: !0, get: function() {
    return l.func;
  } }), Object.defineProperty(t, "iface", { enumerable: !0, get: function() {
    return l.iface;
  } }), Object.defineProperty(t, "lit", { enumerable: !0, get: function() {
    return l.lit;
  } }), Object.defineProperty(t, "name", { enumerable: !0, get: function() {
    return l.name;
  } }), Object.defineProperty(t, "opt", { enumerable: !0, get: function() {
    return l.opt;
  } }), Object.defineProperty(t, "param", { enumerable: !0, get: function() {
    return l.param;
  } }), Object.defineProperty(t, "tuple", { enumerable: !0, get: function() {
    return l.tuple;
  } }), Object.defineProperty(t, "union", { enumerable: !0, get: function() {
    return l.union;
  } }), Object.defineProperty(t, "intersection", { enumerable: !0, get: function() {
    return l.intersection;
  } }), Object.defineProperty(t, "BasicType", { enumerable: !0, get: function() {
    return l.BasicType;
  } });
  var d = ks;
  Object.defineProperty(t, "VError", { enumerable: !0, get: function() {
    return d.VError;
  } });
  function h() {
    for (var u = [], i = 0; i < arguments.length; i++)
      u[i] = arguments[i];
    for (var c = Object.assign.apply(Object, e([{}, r.basicTypes], u)), f = {}, s = 0, o = u; s < o.length; s++)
      for (var y = o[s], m = 0, g = Object.keys(y); m < g.length; m++) {
        var b = g[m];
        f[b] = new n(c, y[b]);
      }
    return f;
  }
  t.createCheckers = h;
  var n = (
    /** @class */
    function() {
      function u(i, c, f) {
        if (f === void 0 && (f = "value"), this.suite = i, this.ttype = c, this._path = f, this.props = /* @__PURE__ */ new Map(), c instanceof r.TIface)
          for (var s = 0, o = c.props; s < o.length; s++) {
            var y = o[s];
            this.props.set(y.name, y.ttype);
          }
        this.checkerPlain = this.ttype.getChecker(i, !1), this.checkerStrict = this.ttype.getChecker(i, !0);
      }
      return u.prototype.setReportedPath = function(i) {
        this._path = i;
      }, u.prototype.check = function(i) {
        return this._doCheck(this.checkerPlain, i);
      }, u.prototype.test = function(i) {
        return this.checkerPlain(i, new a.NoopContext());
      }, u.prototype.validate = function(i) {
        return this._doValidate(this.checkerPlain, i);
      }, u.prototype.strictCheck = function(i) {
        return this._doCheck(this.checkerStrict, i);
      }, u.prototype.strictTest = function(i) {
        return this.checkerStrict(i, new a.NoopContext());
      }, u.prototype.strictValidate = function(i) {
        return this._doValidate(this.checkerStrict, i);
      }, u.prototype.getProp = function(i) {
        var c = this.props.get(i);
        if (!c)
          throw new Error("Type has no property " + i);
        return new u(this.suite, c, this._path + "." + i);
      }, u.prototype.methodArgs = function(i) {
        var c = this._getMethod(i);
        return new u(this.suite, c.paramList);
      }, u.prototype.methodResult = function(i) {
        var c = this._getMethod(i);
        return new u(this.suite, c.result);
      }, u.prototype.getArgs = function() {
        if (!(this.ttype instanceof r.TFunc))
          throw new Error("getArgs() applied to non-function");
        return new u(this.suite, this.ttype.paramList);
      }, u.prototype.getResult = function() {
        if (!(this.ttype instanceof r.TFunc))
          throw new Error("getResult() applied to non-function");
        return new u(this.suite, this.ttype.result);
      }, u.prototype.getType = function() {
        return this.ttype;
      }, u.prototype._doCheck = function(i, c) {
        var f = new a.NoopContext();
        if (!i(c, f)) {
          var s = new a.DetailContext();
          throw i(c, s), s.getError(this._path);
        }
      }, u.prototype._doValidate = function(i, c) {
        var f = new a.NoopContext();
        if (i(c, f))
          return null;
        var s = new a.DetailContext();
        return i(c, s), s.getErrorDetail(this._path);
      }, u.prototype._getMethod = function(i) {
        var c = this.props.get(i);
        if (!c)
          throw new Error("Type has no property " + i);
        if (!(c instanceof r.TFunc))
          throw new Error("Property " + i + " is not a method");
        return c;
      }, u;
    }()
  );
  t.Checker = n;
})(Or);
const UY = Or.union(
  Or.lit("jsx"),
  Or.lit("typescript"),
  Or.lit("flow"),
  Or.lit("imports"),
  Or.lit("react-hot-loader"),
  Or.lit("jest")
), VY = Or.iface([], {
  compiledFilename: "string"
}), WY = Or.iface([], {
  transforms: Or.array("Transform"),
  disableESTransforms: Or.opt("boolean"),
  jsxRuntime: Or.opt(Or.union(Or.lit("classic"), Or.lit("automatic"), Or.lit("preserve"))),
  production: Or.opt("boolean"),
  jsxImportSource: Or.opt("string"),
  jsxPragma: Or.opt("string"),
  jsxFragmentPragma: Or.opt("string"),
  keepUnusedImports: Or.opt("boolean"),
  preserveDynamicImport: Or.opt("boolean"),
  injectCreateRequireForImportRequire: Or.opt("boolean"),
  enableLegacyTypeScriptModuleInterop: Or.opt("boolean"),
  enableLegacyBabel5ModuleInterop: Or.opt("boolean"),
  sourceMapOptions: Or.opt("SourceMapOptions"),
  filePath: Or.opt("string")
}), qY = {
  Transform: UY,
  SourceMapOptions: VY,
  Options: WY
}, { Options: HY } = Or.createCheckers(qY);
function GY(t) {
  HY.strictCheck(t);
}
function pC() {
  ft(), $n(!1);
}
function hC(t) {
  ft(), Up(t);
}
function Ma(t) {
  zt(), Pg(t);
}
function ld() {
  zt(), de.tokens[de.tokens.length - 1].identifierRole = Ut.ImportDeclaration;
}
function Pg(t) {
  let e;
  de.scopeDepth === 0 ? e = Ut.TopLevelDeclaration : t ? e = Ut.BlockScopedDeclaration : e = Ut.FunctionScopedDeclaration, de.tokens[de.tokens.length - 1].identifierRole = e;
}
function Up(t) {
  switch (de.type) {
    case j._this: {
      const e = nr(0);
      ft(), tr(e);
      return;
    }
    case j._yield:
    case j.name: {
      de.type = j.name, Ma(t);
      return;
    }
    case j.bracketL: {
      ft(), Cg(
        j.bracketR,
        t,
        !0
        /* allowEmpty */
      );
      return;
    }
    case j.braceL:
      Bg(!0, t);
      return;
    default:
      er();
  }
}
function Cg(t, e, r = !1, a = !1, l = 0) {
  let d = !0, h = !1;
  const n = de.tokens.length;
  for (; !at(t) && !de.error; )
    if (d ? d = !1 : (ct(j.comma), de.tokens[de.tokens.length - 1].contextId = l, !h && de.tokens[n].isType && (de.tokens[de.tokens.length - 1].isType = !0, h = !0)), !(r && Ne(j.comma))) {
      if (at(t))
        break;
      if (Ne(j.ellipsis)) {
        hC(e), mC(), at(j.comma), ct(t);
        break;
      } else
        zY(a, e);
    }
}
function zY(t, e) {
  t && Ig([
    $e._public,
    $e._protected,
    $e._private,
    $e._readonly,
    $e._override
  ]), ud(e), mC(), ud(
    e,
    !0
    /* leftAlreadyParsed */
  );
}
function mC() {
  gr ? fQ() : pr && tJ();
}
function ud(t, e = !1) {
  if (e || Up(t), !at(j.eq))
    return;
  const r = de.tokens.length - 1;
  $n(), de.tokens[r].rhsEndIndex = de.tokens.length;
}
function sy() {
  return Ne(j.name);
}
function KY() {
  return Ne(j.name) || !!(de.type & j.IS_KEYWORD) || Ne(j.string) || Ne(j.num) || Ne(j.bigint) || Ne(j.decimal);
}
function yC() {
  const t = de.snapshot();
  return ft(), (Ne(j.bracketL) || Ne(j.braceL) || Ne(j.star) || Ne(j.ellipsis) || Ne(j.hash) || KY()) && !li() ? !0 : (de.restoreFromSnapshot(t), !1);
}
function Ig(t) {
  for (; bC(t) !== null; )
    ;
}
function bC(t) {
  if (!Ne(j.name))
    return null;
  const e = de.contextualKeyword;
  if (t.indexOf(e) !== -1 && yC()) {
    switch (e) {
      case $e._readonly:
        de.tokens[de.tokens.length - 1].type = j._readonly;
        break;
      case $e._abstract:
        de.tokens[de.tokens.length - 1].type = j._abstract;
        break;
      case $e._static:
        de.tokens[de.tokens.length - 1].type = j._static;
        break;
      case $e._public:
        de.tokens[de.tokens.length - 1].type = j._public;
        break;
      case $e._private:
        de.tokens[de.tokens.length - 1].type = j._private;
        break;
      case $e._protected:
        de.tokens[de.tokens.length - 1].type = j._protected;
        break;
      case $e._override:
        de.tokens[de.tokens.length - 1].type = j._override;
        break;
      case $e._declare:
        de.tokens[de.tokens.length - 1].type = j._declare;
        break;
    }
    return e;
  }
  return null;
}
function _c() {
  for (zt(); at(j.dot); )
    zt();
}
function YY() {
  _c(), !li() && Ne(j.lessThan) && Fl();
}
function XY() {
  ft(), Sc();
}
function JY() {
  ft();
}
function QY() {
  ct(j._typeof), Ne(j._import) ? gC() : _c(), !li() && Ne(j.lessThan) && Fl();
}
function gC() {
  ct(j._import), ct(j.parenL), ct(j.string), ct(j.parenR), at(j.dot) && _c(), Ne(j.lessThan) && Fl();
}
function ZY() {
  at(j._const);
  const t = at(j._in), e = gn($e._out);
  at(j._const), (t || e) && !Ne(j.name) ? de.tokens[de.tokens.length - 1].type = j.name : zt(), at(j._extends) && Xr(), at(j.eq) && Xr();
}
function Eo() {
  Ne(j.lessThan) && Vp();
}
function Vp() {
  const t = nr(0);
  for (Ne(j.lessThan) || Ne(j.typeParameterStart) ? ft() : er(); !at(j.greaterThan) && !de.error; )
    ZY(), at(j.comma);
  tr(t);
}
function Og(t) {
  const e = t === j.arrow;
  Eo(), ct(j.parenL), de.scopeDepth++, eX(
    !1
    /* isBlockScope */
  ), de.scopeDepth--, (e || Ne(t)) && Lu(t);
}
function eX(t) {
  Cg(j.parenR, t);
}
function cd() {
  at(j.comma) || Ur();
}
function Cw() {
  Og(j.colon), cd();
}
function tX() {
  const t = de.snapshot();
  ft();
  const e = at(j.name) && Ne(j.colon);
  return de.restoreFromSnapshot(t), e;
}
function vC() {
  if (!(Ne(j.bracketL) && tX()))
    return !1;
  const t = nr(0);
  return ct(j.bracketL), zt(), Sc(), ct(j.bracketR), jl(), cd(), tr(t), !0;
}
function Iw(t) {
  at(j.question), !t && (Ne(j.parenL) || Ne(j.lessThan)) ? (Og(j.colon), cd()) : (jl(), cd());
}
function rX() {
  if (Ne(j.parenL) || Ne(j.lessThan)) {
    Cw();
    return;
  }
  if (Ne(j._new)) {
    ft(), Ne(j.parenL) || Ne(j.lessThan) ? Cw() : Iw(!1);
    return;
  }
  const t = !!bC([$e._readonly]);
  vC() || ((Rt($e._get) || Rt($e._set)) && yC(), ju(
    -1
    /* Types don't need context IDs. */
  ), Iw(t));
}
function nX() {
  EC();
}
function EC() {
  for (ct(j.braceL); !at(j.braceR) && !de.error; )
    rX();
}
function iX() {
  const t = de.snapshot(), e = sX();
  return de.restoreFromSnapshot(t), e;
}
function sX() {
  return ft(), at(j.plus) || at(j.minus) ? Rt($e._readonly) : (Rt($e._readonly) && ft(), !Ne(j.bracketL) || (ft(), !sy()) ? !1 : (ft(), Ne(j._in)));
}
function aX() {
  zt(), ct(j._in), Xr();
}
function oX() {
  ct(j.braceL), Ne(j.plus) || Ne(j.minus) ? (ft(), sn($e._readonly)) : gn($e._readonly), ct(j.bracketL), aX(), gn($e._as) && Xr(), ct(j.bracketR), Ne(j.plus) || Ne(j.minus) ? (ft(), ct(j.question)) : at(j.question), _X(), Ur(), ct(j.braceR);
}
function lX() {
  for (ct(j.bracketL); !at(j.bracketR) && !de.error; )
    uX(), at(j.comma);
}
function uX() {
  at(j.ellipsis) ? Xr() : (Xr(), at(j.question)), at(j.colon) && Xr();
}
function cX() {
  ct(j.parenL), Xr(), ct(j.parenR);
}
function fX() {
  for (va(), va(); !Ne(j.backQuote) && !de.error; )
    ct(j.dollarBraceL), Xr(), va(), va();
  ft();
}
var wa;
(function(t) {
  t[t.TSFunctionType = 0] = "TSFunctionType";
  const r = 1;
  t[t.TSConstructorType = r] = "TSConstructorType";
  const a = r + 1;
  t[t.TSAbstractConstructorType = a] = "TSAbstractConstructorType";
})(wa || (wa = {}));
function s0(t) {
  t === wa.TSAbstractConstructorType && sn($e._abstract), (t === wa.TSConstructorType || t === wa.TSAbstractConstructorType) && ct(j._new);
  const e = de.inDisallowConditionalTypesContext;
  de.inDisallowConditionalTypesContext = !1, Og(j.arrow), de.inDisallowConditionalTypesContext = e;
}
function dX() {
  switch (de.type) {
    case j.name:
      YY();
      return;
    case j._void:
    case j._null:
      ft();
      return;
    case j.string:
    case j.num:
    case j.bigint:
    case j.decimal:
    case j._true:
    case j._false:
      _l();
      return;
    case j.minus:
      ft(), _l();
      return;
    case j._this: {
      JY(), Rt($e._is) && !li() && XY();
      return;
    }
    case j._typeof:
      QY();
      return;
    case j._import:
      gC();
      return;
    case j.braceL:
      iX() ? oX() : nX();
      return;
    case j.bracketL:
      lX();
      return;
    case j.parenL:
      cX();
      return;
    case j.backQuote:
      fX();
      return;
    default:
      if (de.type & j.IS_KEYWORD) {
        ft(), de.tokens[de.tokens.length - 1].type = j.name;
        return;
      }
      break;
  }
  er();
}
function pX() {
  for (dX(); !li() && at(j.bracketL); )
    at(j.bracketR) || (Xr(), ct(j.bracketR));
}
function hX() {
  if (sn($e._infer), zt(), Ne(j._extends)) {
    const t = de.snapshot();
    ct(j._extends);
    const e = de.inDisallowConditionalTypesContext;
    de.inDisallowConditionalTypesContext = !0, Xr(), de.inDisallowConditionalTypesContext = e, (de.error || !de.inDisallowConditionalTypesContext && Ne(j.question)) && de.restoreFromSnapshot(t);
  }
}
function ay() {
  if (Rt($e._keyof) || Rt($e._unique) || Rt($e._readonly))
    ft(), ay();
  else if (Rt($e._infer))
    hX();
  else {
    const t = de.inDisallowConditionalTypesContext;
    de.inDisallowConditionalTypesContext = !1, pX(), de.inDisallowConditionalTypesContext = t;
  }
}
function Ow() {
  if (at(j.bitwiseAND), ay(), Ne(j.bitwiseAND))
    for (; at(j.bitwiseAND); )
      ay();
}
function mX() {
  if (at(j.bitwiseOR), Ow(), Ne(j.bitwiseOR))
    for (; at(j.bitwiseOR); )
      Ow();
}
function yX() {
  return Ne(j.lessThan) ? !0 : Ne(j.parenL) && gX();
}
function bX() {
  if (Ne(j.name) || Ne(j._this))
    return ft(), !0;
  if (Ne(j.braceL) || Ne(j.bracketL)) {
    let t = 1;
    for (ft(); t > 0 && !de.error; )
      Ne(j.braceL) || Ne(j.bracketL) ? t++ : (Ne(j.braceR) || Ne(j.bracketR)) && t--, ft();
    return !0;
  }
  return !1;
}
function gX() {
  const t = de.snapshot(), e = vX();
  return de.restoreFromSnapshot(t), e;
}
function vX() {
  return ft(), !!(Ne(j.parenR) || Ne(j.ellipsis) || bX() && (Ne(j.colon) || Ne(j.comma) || Ne(j.question) || Ne(j.eq) || Ne(j.parenR) && (ft(), Ne(j.arrow))));
}
function Lu(t) {
  const e = nr(0);
  ct(t), SX() || Xr(), tr(e);
}
function EX() {
  Ne(j.colon) && Lu(j.colon);
}
function jl() {
  Ne(j.colon) && Sc();
}
function _X() {
  at(j.colon) && Xr();
}
function SX() {
  const t = de.snapshot();
  return Rt($e._asserts) ? (ft(), gn($e._is) ? (Xr(), !0) : sy() || Ne(j._this) ? (ft(), gn($e._is) && Xr(), !0) : (de.restoreFromSnapshot(t), !1)) : sy() || Ne(j._this) ? (ft(), Rt($e._is) && !li() ? (ft(), Xr(), !0) : (de.restoreFromSnapshot(t), !1)) : !1;
}
function Sc() {
  const t = nr(0);
  ct(j.colon), Xr(), tr(t);
}
function Xr() {
  if (kw(), de.inDisallowConditionalTypesContext || li() || !at(j._extends))
    return;
  const t = de.inDisallowConditionalTypesContext;
  de.inDisallowConditionalTypesContext = !0, kw(), de.inDisallowConditionalTypesContext = t, ct(j.question), Xr(), ct(j.colon), Xr();
}
function wX() {
  return Rt($e._abstract) && Yr() === j._new;
}
function kw() {
  if (yX()) {
    s0(wa.TSFunctionType);
    return;
  }
  if (Ne(j._new)) {
    s0(wa.TSConstructorType);
    return;
  } else if (wX()) {
    s0(wa.TSAbstractConstructorType);
    return;
  }
  mX();
}
function xX() {
  const t = nr(1);
  Xr(), ct(j.greaterThan), tr(t), wc();
}
function TX() {
  if (at(j.jsxTagStart)) {
    de.tokens[de.tokens.length - 1].type = j.typeParameterStart;
    const t = nr(1);
    for (; !Ne(j.greaterThan) && !de.error; )
      Xr(), at(j.comma);
    ji(), tr(t);
  }
}
function _C() {
  for (; !Ne(j.braceL) && !de.error; )
    AX(), at(j.comma);
}
function AX() {
  _c(), Ne(j.lessThan) && Fl();
}
function PX() {
  Ma(!1), Eo(), at(j._extends) && _C(), EC();
}
function CX() {
  Ma(!1), Eo(), ct(j.eq), Xr(), Ur();
}
function IX() {
  if (Ne(j.string) ? _l() : zt(), at(j.eq)) {
    const t = de.tokens.length - 1;
    $n(), de.tokens[t].rhsEndIndex = de.tokens.length;
  }
}
function kg() {
  for (Ma(!1), ct(j.braceL); !at(j.braceR) && !de.error; )
    IX(), at(j.comma);
}
function Dg() {
  ct(j.braceL), Gp(
    /* end */
    j.braceR
  );
}
function oy() {
  Ma(!1), at(j.dot) ? oy() : Dg();
}
function SC() {
  Rt($e._global) ? zt() : Ne(j.string) ? oa() : er(), Ne(j.braceL) ? Dg() : Ur();
}
function ly() {
  ld(), ct(j.eq), kX(), Ur();
}
function OX() {
  return Rt($e._require) && Yr() === j.parenL;
}
function kX() {
  OX() ? DX() : _c();
}
function DX() {
  sn($e._require), ct(j.parenL), Ne(j.string) || er(), _l(), ct(j.parenR);
}
function NX() {
  if (As())
    return !1;
  switch (de.type) {
    case j._function: {
      const t = nr(1);
      ft();
      const e = de.start;
      return uo(
        e,
        /* isStatement */
        !0
      ), tr(t), !0;
    }
    case j._class: {
      const t = nr(1);
      return co(
        /* isStatement */
        !0,
        /* optionalId */
        !1
      ), tr(t), !0;
    }
    case j._const:
      if (Ne(j._const) && xg($e._enum)) {
        const t = nr(1);
        return ct(j._const), sn($e._enum), de.tokens[de.tokens.length - 1].type = j._enum, kg(), tr(t), !0;
      }
    case j._var:
    case j._let: {
      const t = nr(1);
      return Of(de.type !== j._var), tr(t), !0;
    }
    case j.name: {
      const t = nr(1), e = de.contextualKeyword;
      let r = !1;
      return e === $e._global ? (SC(), r = !0) : r = Wp(
        e,
        /* isBeforeToken */
        !0
      ), tr(t), r;
    }
    default:
      return !1;
  }
}
function Dw() {
  return Wp(
    de.contextualKeyword,
    /* isBeforeToken */
    !0
  );
}
function RX(t) {
  switch (t) {
    case $e._declare: {
      const e = de.tokens.length - 1;
      if (NX())
        return de.tokens[e].type = j._declare, !0;
      break;
    }
    case $e._global:
      if (Ne(j.braceL))
        return Dg(), !0;
      break;
    default:
      return Wp(
        t,
        /* isBeforeToken */
        !1
      );
  }
  return !1;
}
function Wp(t, e) {
  switch (t) {
    case $e._abstract:
      if (Uo(e) && Ne(j._class))
        return de.tokens[de.tokens.length - 1].type = j._abstract, co(
          /* isStatement */
          !0,
          /* optionalId */
          !1
        ), !0;
      break;
    case $e._enum:
      if (Uo(e) && Ne(j.name))
        return de.tokens[de.tokens.length - 1].type = j._enum, kg(), !0;
      break;
    case $e._interface:
      if (Uo(e) && Ne(j.name)) {
        const r = nr(e ? 2 : 1);
        return PX(), tr(r), !0;
      }
      break;
    case $e._module:
      if (Uo(e)) {
        if (Ne(j.string)) {
          const r = nr(e ? 2 : 1);
          return SC(), tr(r), !0;
        } else if (Ne(j.name)) {
          const r = nr(e ? 2 : 1);
          return oy(), tr(r), !0;
        }
      }
      break;
    case $e._namespace:
      if (Uo(e) && Ne(j.name)) {
        const r = nr(e ? 2 : 1);
        return oy(), tr(r), !0;
      }
      break;
    case $e._type:
      if (Uo(e) && Ne(j.name)) {
        const r = nr(e ? 2 : 1);
        return CX(), tr(r), !0;
      }
      break;
  }
  return !1;
}
function Uo(t) {
  return t ? (ft(), !0) : !As();
}
function MX() {
  const t = de.snapshot();
  return Vp(), Bl(), EX(), ct(j.arrow), de.error ? (de.restoreFromSnapshot(t), !1) : (xc(!0), !0);
}
function Ng() {
  de.type === j.bitShiftL && (de.pos -= 1, Zt(j.lessThan)), Fl();
}
function Fl() {
  const t = nr(0);
  for (ct(j.lessThan); !Ne(j.greaterThan) && !de.error; )
    Xr(), at(j.comma);
  t ? (ct(j.greaterThan), tr(t)) : (tr(t), nC(), ct(j.greaterThan), de.tokens[de.tokens.length - 1].isType = !0);
}
function wC() {
  if (Ne(j.name))
    switch (de.contextualKeyword) {
      case $e._abstract:
      case $e._declare:
      case $e._enum:
      case $e._interface:
      case $e._module:
      case $e._namespace:
      case $e._type:
        return !0;
    }
  return !1;
}
function LX(t, e) {
  if (Ne(j.colon) && Lu(j.colon), !Ne(j.braceL) && As()) {
    let r = de.tokens.length - 1;
    for (; r >= 0 && (de.tokens[r].start >= t || de.tokens[r].type === j._default || de.tokens[r].type === j._export); )
      de.tokens[r].isType = !0, r--;
    return;
  }
  xc(!1, e);
}
function jX(t, e, r) {
  if (!li() && at(j.bang)) {
    de.tokens[de.tokens.length - 1].type = j.nonNullAssertion;
    return;
  }
  if (Ne(j.lessThan) || Ne(j.bitShiftL)) {
    const a = de.snapshot();
    if (!e && kC() && MX())
      return;
    if (Ng(), !e && at(j.parenL) ? (de.tokens[de.tokens.length - 1].subscriptStartIndex = t, xa()) : Ne(j.backQuote) ? Fg() : (
      // The remaining possible case is an instantiation expression, e.g.
      // Array<number> . Check for a few cases that would disqualify it and
      // cause us to bail out.
      // a<b>>c is not (a<b>)>c, but a<(b>>c)
      (de.type === j.greaterThan || // a<b>c is (a<b)>c
      de.type !== j.parenL && de.type & j.IS_EXPRESSION_START && !li()) && er()
    ), de.error)
      de.restoreFromSnapshot(a);
    else
      return;
  } else !e && Ne(j.questionDot) && Yr() === j.lessThan && (ft(), de.tokens[t].isOptionalChainStart = !0, de.tokens[de.tokens.length - 1].subscriptStartIndex = t, Fl(), ct(j.parenL), xa());
  Mg(t, e, r);
}
function FX() {
  if (at(j._import))
    return Rt($e._type) && Yr() !== j.eq && sn($e._type), ly(), !0;
  if (at(j.eq))
    return Bn(), Ur(), !0;
  if (gn($e._as))
    return sn($e._namespace), zt(), Ur(), !0;
  if (Rt($e._type)) {
    const t = Yr();
    (t === j.braceL || t === j.star) && ft();
  }
  return !1;
}
function BX() {
  if (zt(), Ne(j.comma) || Ne(j.braceR)) {
    de.tokens[de.tokens.length - 1].identifierRole = Ut.ImportDeclaration;
    return;
  }
  if (zt(), Ne(j.comma) || Ne(j.braceR)) {
    de.tokens[de.tokens.length - 1].identifierRole = Ut.ImportDeclaration, de.tokens[de.tokens.length - 2].isType = !0, de.tokens[de.tokens.length - 1].isType = !0;
    return;
  }
  if (zt(), Ne(j.comma) || Ne(j.braceR)) {
    de.tokens[de.tokens.length - 3].identifierRole = Ut.ImportAccess, de.tokens[de.tokens.length - 1].identifierRole = Ut.ImportDeclaration;
    return;
  }
  zt(), de.tokens[de.tokens.length - 3].identifierRole = Ut.ImportAccess, de.tokens[de.tokens.length - 1].identifierRole = Ut.ImportDeclaration, de.tokens[de.tokens.length - 4].isType = !0, de.tokens[de.tokens.length - 3].isType = !0, de.tokens[de.tokens.length - 2].isType = !0, de.tokens[de.tokens.length - 1].isType = !0;
}
function $X() {
  if (zt(), Ne(j.comma) || Ne(j.braceR)) {
    de.tokens[de.tokens.length - 1].identifierRole = Ut.ExportAccess;
    return;
  }
  if (zt(), Ne(j.comma) || Ne(j.braceR)) {
    de.tokens[de.tokens.length - 1].identifierRole = Ut.ExportAccess, de.tokens[de.tokens.length - 2].isType = !0, de.tokens[de.tokens.length - 1].isType = !0;
    return;
  }
  if (zt(), Ne(j.comma) || Ne(j.braceR)) {
    de.tokens[de.tokens.length - 3].identifierRole = Ut.ExportAccess;
    return;
  }
  zt(), de.tokens[de.tokens.length - 3].identifierRole = Ut.ExportAccess, de.tokens[de.tokens.length - 4].isType = !0, de.tokens[de.tokens.length - 3].isType = !0, de.tokens[de.tokens.length - 2].isType = !0, de.tokens[de.tokens.length - 1].isType = !0;
}
function UX() {
  if (Rt($e._abstract) && Yr() === j._class)
    return de.type = j._abstract, ft(), co(!0, !0), !0;
  if (Rt($e._interface)) {
    const t = nr(2);
    return Wp($e._interface, !0), tr(t), !0;
  }
  return !1;
}
function VX() {
  if (de.type === j._const) {
    const t = Ec();
    if (t.type === j.name && t.contextualKeyword === $e._enum)
      return ct(j._const), sn($e._enum), de.tokens[de.tokens.length - 1].type = j._enum, kg(), !0;
  }
  return !1;
}
function WX(t) {
  const e = de.tokens.length;
  Ig([
    $e._abstract,
    $e._readonly,
    $e._declare,
    $e._static,
    $e._override
  ]);
  const r = de.tokens.length;
  if (vC()) {
    const l = t ? e - 1 : e;
    for (let d = l; d < r; d++)
      de.tokens[d].isType = !0;
    return !0;
  }
  return !1;
}
function qX(t) {
  RX(t) || Ur();
}
function HX() {
  const t = gn($e._declare);
  t && (de.tokens[de.tokens.length - 1].type = j._declare);
  let e = !1;
  if (Ne(j.name))
    if (t) {
      const r = nr(2);
      e = Dw(), tr(r);
    } else
      e = Dw();
  if (!e)
    if (t) {
      const r = nr(2);
      xi(!0), tr(r);
    } else
      xi(!0);
}
function GX(t) {
  if (t && (Ne(j.lessThan) || Ne(j.bitShiftL)) && Ng(), gn($e._implements)) {
    de.tokens[de.tokens.length - 1].type = j._implements;
    const e = nr(1);
    _C(), tr(e);
  }
}
function zX() {
  Eo();
}
function KX() {
  Eo();
}
function YX() {
  const t = nr(0);
  li() || at(j.bang), jl(), tr(t);
}
function XX() {
  Ne(j.colon) && Sc();
}
function JX(t, e) {
  return Bp ? QX(t, e) : ZX(t, e);
}
function QX(t, e) {
  if (!Ne(j.lessThan))
    return Ds(t, e);
  const r = de.snapshot();
  let a = Ds(t, e);
  if (de.error)
    de.restoreFromSnapshot(r);
  else
    return a;
  return de.type = j.typeParameterStart, Vp(), a = Ds(t, e), a || er(), a;
}
function ZX(t, e) {
  if (!Ne(j.lessThan))
    return Ds(t, e);
  const r = de.snapshot();
  Vp();
  const a = Ds(t, e);
  if (a || er(), de.error)
    de.restoreFromSnapshot(r);
  else
    return a;
  return Ds(t, e);
}
function eJ() {
  if (Ne(j.colon)) {
    const t = de.snapshot();
    Lu(j.colon), Ei() && er(), Ne(j.arrow) || er(), de.error && de.restoreFromSnapshot(t);
  }
  return at(j.arrow);
}
function tJ() {
  const t = nr(0);
  at(j.question), jl(), tr(t);
}
function rJ() {
  (Ne(j.lessThan) || Ne(j.bitShiftL)) && Ng(), WC();
}
function nJ() {
  let t = !1, e = !1;
  for (; ; ) {
    if (de.pos >= _t.length) {
      er("Unterminated JSX contents");
      return;
    }
    const r = _t.charCodeAt(de.pos);
    if (r === ze.lessThan || r === ze.leftCurlyBrace) {
      if (de.pos === de.start) {
        if (r === ze.lessThan) {
          de.pos++, Zt(j.jsxTagStart);
          return;
        }
        iC(r);
        return;
      }
      Zt(t && !e ? j.jsxEmptyText : j.jsxText);
      return;
    }
    r === ze.lineFeed ? t = !0 : r !== ze.space && r !== ze.carriageReturn && r !== ze.tab && (e = !0), de.pos++;
  }
}
function iJ(t) {
  for (de.pos++; ; ) {
    if (de.pos >= _t.length) {
      er("Unterminated string constant");
      return;
    }
    if (_t.charCodeAt(de.pos) === t) {
      de.pos++;
      break;
    }
    de.pos++;
  }
  Zt(j.string);
}
function sJ() {
  let t;
  do {
    if (de.pos > _t.length) {
      er("Unexpectedly reached the end of input.");
      return;
    }
    t = _t.charCodeAt(++de.pos);
  } while (ss[t] || t === ze.dash);
  Zt(j.jsxName);
}
function uy() {
  ji();
}
function xC(t) {
  if (uy(), !at(j.colon)) {
    de.tokens[de.tokens.length - 1].identifierRole = t;
    return;
  }
  uy();
}
function TC() {
  const t = de.tokens.length;
  xC(Ut.Access);
  let e = !1;
  for (; Ne(j.dot); )
    e = !0, ji(), uy();
  if (!e) {
    const r = de.tokens[t], a = _t.charCodeAt(r.start);
    a >= ze.lowercaseA && a <= ze.lowercaseZ && (r.identifierRole = null);
  }
}
function aJ() {
  switch (de.type) {
    case j.braceL:
      ft(), Bn(), ji();
      return;
    case j.jsxTagStart:
      PC(), ji();
      return;
    case j.string:
      ji();
      return;
    default:
      er("JSX value should be either an expression or a quoted JSX text");
  }
}
function oJ() {
  ct(j.ellipsis), Bn();
}
function lJ(t) {
  if (Ne(j.jsxTagEnd))
    return !1;
  TC(), pr && TX();
  let e = !1;
  for (; !Ne(j.slash) && !Ne(j.jsxTagEnd) && !de.error; ) {
    if (at(j.braceL)) {
      e = !0, ct(j.ellipsis), $n(), ji();
      continue;
    }
    e && de.end - de.start === 3 && _t.charCodeAt(de.start) === ze.lowercaseK && _t.charCodeAt(de.start + 1) === ze.lowercaseE && _t.charCodeAt(de.start + 2) === ze.lowercaseY && (de.tokens[t].jsxRole = ts.KeyAfterPropSpread), xC(Ut.ObjectKey), Ne(j.eq) && (ji(), aJ());
  }
  const r = Ne(j.slash);
  return r && ji(), r;
}
function uJ() {
  Ne(j.jsxTagEnd) || TC();
}
function AC() {
  const t = de.tokens.length - 1;
  de.tokens[t].jsxRole = ts.NoChildren;
  let e = 0;
  if (!lJ(t))
    for (Vo(); ; )
      switch (de.type) {
        case j.jsxTagStart:
          if (ji(), Ne(j.slash)) {
            ji(), uJ(), de.tokens[t].jsxRole !== ts.KeyAfterPropSpread && (e === 1 ? de.tokens[t].jsxRole = ts.OneChild : e > 1 && (de.tokens[t].jsxRole = ts.StaticChildren));
            return;
          }
          e++, AC(), Vo();
          break;
        case j.jsxText:
          e++, Vo();
          break;
        case j.jsxEmptyText:
          Vo();
          break;
        case j.braceL:
          ft(), Ne(j.ellipsis) ? (oJ(), Vo(), e += 2) : (Ne(j.braceR) || (e++, Bn()), Vo());
          break;
        default:
          er();
          return;
      }
}
function PC() {
  ji(), AC();
}
function ji() {
  de.tokens.push(new $p()), tC(), de.start = de.pos;
  const t = _t.charCodeAt(de.pos);
  if (vc[t])
    sJ();
  else if (t === ze.quotationMark || t === ze.apostrophe)
    iJ(t);
  else
    switch (++de.pos, t) {
      case ze.greaterThan:
        Zt(j.jsxTagEnd);
        break;
      case ze.lessThan:
        Zt(j.jsxTagStart);
        break;
      case ze.slash:
        Zt(j.slash);
        break;
      case ze.equalsTo:
        Zt(j.eq);
        break;
      case ze.leftCurlyBrace:
        Zt(j.braceL);
        break;
      case ze.dot:
        Zt(j.dot);
        break;
      case ze.colon:
        Zt(j.colon);
        break;
      default:
        er();
    }
}
function Vo() {
  de.tokens.push(new $p()), de.start = de.pos, nJ();
}
function cJ(t) {
  if (Ne(j.question)) {
    const e = Yr();
    if (e === j.colon || e === j.comma || e === j.parenR)
      return;
  }
  CC(t);
}
function fJ() {
  X4(j.question), Ne(j.colon) && (pr ? Sc() : gr && _o());
}
class dJ {
  constructor(e) {
    this.stop = e;
  }
}
function Bn(t = !1) {
  if ($n(t), Ne(j.comma))
    for (; at(j.comma); )
      $n(t);
}
function $n(t = !1, e = !1) {
  return pr ? JX(t, e) : gr ? bQ(t, e) : Ds(t, e);
}
function Ds(t, e) {
  if (Ne(j._yield))
    return CJ(), !1;
  (Ne(j.parenL) || Ne(j.name) || Ne(j._yield)) && (de.potentialArrowAt = de.start);
  const r = pJ(t);
  return e && jg(), de.type & j.IS_ASSIGN ? (ft(), $n(t), !1) : r;
}
function pJ(t) {
  return mJ(t) ? !0 : (hJ(t), !1);
}
function hJ(t) {
  pr || gr ? cJ(t) : CC(t);
}
function CC(t) {
  at(j.question) && ($n(), ct(j.colon), $n(t));
}
function mJ(t) {
  const e = de.tokens.length;
  return wc() ? !0 : (Cf(e, -1, t), !1);
}
function Cf(t, e, r) {
  if (pr && (j._in & j.PRECEDENCE_MASK) > e && !li() && (gn($e._as) || gn($e._satisfies))) {
    const l = nr(1);
    Xr(), tr(l), nC(), Cf(t, e, r);
    return;
  }
  const a = de.type & j.PRECEDENCE_MASK;
  if (a > 0 && (!r || !Ne(j._in)) && a > e) {
    const l = de.type;
    ft(), l === j.nullishCoalescing && (de.tokens[de.tokens.length - 1].nullishStartIndex = t);
    const d = de.tokens.length;
    wc(), Cf(d, l & j.IS_RIGHT_ASSOCIATIVE ? a - 1 : a, r), l === j.nullishCoalescing && (de.tokens[t].numNullishCoalesceStarts++, de.tokens[de.tokens.length - 1].numNullishCoalesceEnds++), Cf(t, e, r);
  }
}
function wc() {
  if (pr && !Bp && at(j.lessThan))
    return xX(), !1;
  if (Rt($e._module) && Q4() === ze.leftCurlyBrace && !H4())
    return IJ(), !1;
  if (de.type & j.IS_PREFIX)
    return ft(), wc(), !1;
  if (IC())
    return !0;
  for (; de.type & j.IS_POSTFIX && !Ei(); )
    de.type === j.preIncDec && (de.type = j.postIncDec), ft();
  return !1;
}
function IC() {
  const t = de.tokens.length;
  return oa() ? !0 : (Rg(t), de.tokens.length > t && de.tokens[t].isOptionalChainStart && (de.tokens[de.tokens.length - 1].isOptionalChainEnd = !0), !1);
}
function Rg(t, e = !1) {
  gr ? vQ(t, e) : OC(t, e);
}
function OC(t, e = !1) {
  const r = new dJ(!1);
  do
    yJ(t, e, r);
  while (!r.stop && !de.error);
}
function yJ(t, e, r) {
  pr ? jX(t, e, r) : gr ? ZJ(t, e, r) : Mg(t, e, r);
}
function Mg(t, e, r) {
  if (!e && at(j.doubleColon))
    Lg(), r.stop = !0, Rg(t, e);
  else if (Ne(j.questionDot)) {
    if (de.tokens[t].isOptionalChainStart = !0, e && Yr() === j.parenL) {
      r.stop = !0;
      return;
    }
    ft(), de.tokens[de.tokens.length - 1].subscriptStartIndex = t, at(j.bracketL) ? (Bn(), ct(j.bracketR)) : at(j.parenL) ? xa() : fd();
  } else if (at(j.dot))
    de.tokens[de.tokens.length - 1].subscriptStartIndex = t, fd();
  else if (at(j.bracketL))
    de.tokens[de.tokens.length - 1].subscriptStartIndex = t, Bn(), ct(j.bracketR);
  else if (!e && Ne(j.parenL))
    if (kC()) {
      const a = de.snapshot(), l = de.tokens.length;
      ft(), de.tokens[de.tokens.length - 1].subscriptStartIndex = t;
      const d = Ru();
      de.tokens[de.tokens.length - 1].contextId = d, xa(), de.tokens[de.tokens.length - 1].contextId = d, bJ() && (de.restoreFromSnapshot(a), r.stop = !0, de.scopeDepth++, Bl(), gJ(l));
    } else {
      ft(), de.tokens[de.tokens.length - 1].subscriptStartIndex = t;
      const a = Ru();
      de.tokens[de.tokens.length - 1].contextId = a, xa(), de.tokens[de.tokens.length - 1].contextId = a;
    }
  else Ne(j.backQuote) ? Fg() : r.stop = !0;
}
function kC() {
  return de.tokens[de.tokens.length - 1].contextualKeyword === $e._async && !Ei();
}
function xa() {
  let t = !0;
  for (; !at(j.parenR) && !de.error; ) {
    if (t)
      t = !1;
    else if (ct(j.comma), at(j.parenR))
      break;
    MC(!1);
  }
}
function bJ() {
  return Ne(j.colon) || Ne(j.arrow);
}
function gJ(t) {
  pr ? XX() : gr && yQ(), ct(j.arrow), Fu(t);
}
function Lg() {
  const t = de.tokens.length;
  oa(), Rg(t, !0);
}
function oa() {
  if (at(j.modulo))
    return zt(), !1;
  if (Ne(j.jsxText) || Ne(j.jsxEmptyText))
    return _l(), !1;
  if (Ne(j.lessThan) && Bp)
    return de.type = j.jsxTagStart, PC(), ft(), !1;
  const t = de.potentialArrowAt === de.start;
  switch (de.type) {
    case j.slash:
    case j.assign:
      aY();
    case j._super:
    case j._this:
    case j.regexp:
    case j.num:
    case j.bigint:
    case j.decimal:
    case j.string:
    case j._null:
    case j._true:
    case j._false:
      return ft(), !1;
    case j._import:
      return ft(), Ne(j.dot) && (de.tokens[de.tokens.length - 1].type = j.name, ft(), zt()), !1;
    case j.name: {
      const e = de.tokens.length, r = de.start, a = de.contextualKeyword;
      return zt(), a === $e._await ? (PJ(), !1) : a === $e._async && Ne(j._function) && !Ei() ? (ft(), uo(r, !1), !1) : t && a === $e._async && !Ei() && Ne(j.name) ? (de.scopeDepth++, Ma(!1), ct(j.arrow), Fu(e), !0) : Ne(j._do) && !Ei() ? (ft(), Ta(), !1) : t && !Ei() && Ne(j.arrow) ? (de.scopeDepth++, Pg(!1), ct(j.arrow), Fu(e), !0) : (de.tokens[de.tokens.length - 1].identifierRole = Ut.Access, !1);
    }
    case j._do:
      return ft(), Ta(), !1;
    case j.parenL:
      return DC(t);
    case j.bracketL:
      return ft(), RC(j.bracketR, !0), !1;
    case j.braceL:
      return Bg(!1, !1), !1;
    case j._function:
      return vJ(), !1;
    case j.at:
      Kg();
    case j._class:
      return co(!1), !1;
    case j._new:
      return _J(), !1;
    case j.backQuote:
      return Fg(), !1;
    case j.doubleColon:
      return ft(), Lg(), !1;
    case j.hash: {
      const e = Q4();
      return vc[e] || e === ze.backslash ? fd() : ft(), !1;
    }
    default:
      return er(), !1;
  }
}
function fd() {
  at(j.hash), zt();
}
function vJ() {
  const t = de.start;
  zt(), at(j.dot) && zt(), uo(t, !1);
}
function _l() {
  ft();
}
function qp() {
  ct(j.parenL), Bn(), ct(j.parenR);
}
function DC(t) {
  const e = de.snapshot(), r = de.tokens.length;
  ct(j.parenL);
  let a = !0;
  for (; !Ne(j.parenR) && !de.error; ) {
    if (a)
      a = !1;
    else if (ct(j.comma), Ne(j.parenR))
      break;
    if (Ne(j.ellipsis)) {
      hC(
        !1
        /* isBlockScope */
      ), jg();
      break;
    } else
      $n(!1, !0);
  }
  return ct(j.parenR), t && EJ() && cy() ? (de.restoreFromSnapshot(e), de.scopeDepth++, Bl(), cy(), Fu(r), de.error ? (de.restoreFromSnapshot(e), DC(!1), !1) : !0) : !1;
}
function EJ() {
  return Ne(j.colon) || !Ei();
}
function cy() {
  return pr ? eJ() : gr ? gQ() : at(j.arrow);
}
function jg() {
  (pr || gr) && fJ();
}
function _J() {
  if (ct(j._new), at(j.dot)) {
    zt();
    return;
  }
  SJ(), gr && eQ(), at(j.parenL) && RC(j.parenR);
}
function SJ() {
  Lg(), at(j.questionDot);
}
function Fg() {
  for (va(), va(); !Ne(j.backQuote) && !de.error; )
    ct(j.dollarBraceL), Bn(), va(), va();
  ft();
}
function Bg(t, e) {
  const r = Ru();
  let a = !0;
  for (ft(), de.tokens[de.tokens.length - 1].contextId = r; !at(j.braceR) && !de.error; ) {
    if (a)
      a = !1;
    else if (ct(j.comma), at(j.braceR))
      break;
    let l = !1;
    if (Ne(j.ellipsis)) {
      const d = de.tokens.length;
      if (pC(), t && (de.tokens.length === d + 2 && Pg(e), at(j.braceR)))
        break;
      continue;
    }
    t || (l = at(j.star)), !t && Rt($e._async) ? (l && er(), zt(), Ne(j.colon) || Ne(j.parenL) || Ne(j.braceR) || Ne(j.eq) || Ne(j.comma) || (Ne(j.star) && (ft(), l = !0), ju(r))) : ju(r), AJ(t, e, r);
  }
  de.tokens[de.tokens.length - 1].contextId = r;
}
function wJ(t) {
  return !t && (Ne(j.string) || // get "string"() {}
  Ne(j.num) || // get 1() {}
  Ne(j.bracketL) || // get ["string"]() {}
  Ne(j.name) || // get foo() {}
  !!(de.type & j.IS_KEYWORD));
}
function xJ(t, e) {
  const r = de.start;
  return Ne(j.parenL) ? (t && er(), fy(
    r,
    /* isConstructor */
    !1
  ), !0) : wJ(t) ? (ju(e), fy(
    r,
    /* isConstructor */
    !1
  ), !0) : !1;
}
function TJ(t, e) {
  if (at(j.colon)) {
    t ? ud(e) : $n(!1);
    return;
  }
  let r;
  t ? de.scopeDepth === 0 ? r = Ut.ObjectShorthandTopLevelDeclaration : e ? r = Ut.ObjectShorthandBlockScopedDeclaration : r = Ut.ObjectShorthandFunctionScopedDeclaration : r = Ut.ObjectShorthand, de.tokens[de.tokens.length - 1].identifierRole = r, ud(e, !0);
}
function AJ(t, e, r) {
  pr ? zX() : gr && cQ(), xJ(t, r) || TJ(t, e);
}
function ju(t) {
  gr && zg(), at(j.bracketL) ? (de.tokens[de.tokens.length - 1].contextId = t, $n(), ct(j.bracketR), de.tokens[de.tokens.length - 1].contextId = t) : (Ne(j.num) || Ne(j.string) || Ne(j.bigint) || Ne(j.decimal) ? oa() : fd(), de.tokens[de.tokens.length - 1].identifierRole = Ut.ObjectKey, de.tokens[de.tokens.length - 1].contextId = t);
}
function fy(t, e) {
  const r = Ru();
  de.scopeDepth++;
  const a = de.tokens.length;
  Bl(e, r), NC(t, r);
  const d = de.tokens.length;
  de.scopes.push(new Bs(a, d, !0)), de.scopeDepth--;
}
function Fu(t) {
  xc(!0);
  const e = de.tokens.length;
  de.scopes.push(new Bs(t, e, !0)), de.scopeDepth--;
}
function NC(t, e = 0) {
  pr ? LX(t, e) : gr ? QJ(e) : xc(!1, e);
}
function xc(t, e = 0) {
  t && !Ne(j.braceL) ? $n() : Ta(!0, e);
}
function RC(t, e = !1) {
  let r = !0;
  for (; !at(t) && !de.error; ) {
    if (r)
      r = !1;
    else if (ct(j.comma), at(t)) break;
    MC(e);
  }
}
function MC(t) {
  t && Ne(j.comma) || (Ne(j.ellipsis) ? (pC(), jg()) : Ne(j.question) ? ft() : $n(!1, !0));
}
function zt() {
  ft(), de.tokens[de.tokens.length - 1].type = j.name;
}
function PJ() {
  wc();
}
function CJ() {
  ft(), !Ne(j.semi) && !Ei() && (at(j.star), $n());
}
function IJ() {
  sn($e._module), ct(j.braceL), Gp(j.braceR);
}
function OJ(t) {
  return (t.type === j.name || !!(t.type & j.IS_KEYWORD)) && t.contextualKeyword !== $e._from;
}
function $s(t) {
  const e = nr(0);
  ct(t || j.colon), pi(), tr(e);
}
function Nw() {
  ct(j.modulo), sn($e._checks), at(j.parenL) && (Bn(), ct(j.parenR));
}
function $g() {
  const t = nr(0);
  ct(j.colon), Ne(j.modulo) ? Nw() : (pi(), Ne(j.modulo) && Nw()), tr(t);
}
function kJ() {
  ft(), Ug(
    /* isClass */
    !0
  );
}
function DJ() {
  ft(), zt(), Ne(j.lessThan) && ds(), ct(j.parenL), py(), ct(j.parenR), $g(), Ur();
}
function dy() {
  Ne(j._class) ? kJ() : Ne(j._function) ? DJ() : Ne(j._var) ? NJ() : gn($e._module) ? at(j.dot) ? LJ() : RJ() : Rt($e._type) ? jJ() : Rt($e._opaque) ? FJ() : Rt($e._interface) ? BJ() : Ne(j._export) ? MJ() : er();
}
function NJ() {
  ft(), BC(), Ur();
}
function RJ() {
  for (Ne(j.string) ? oa() : zt(), ct(j.braceL); !Ne(j.braceR) && !de.error; )
    Ne(j._import) ? (ft(), YC()) : er();
  ct(j.braceR);
}
function MJ() {
  ct(j._export), at(j._default) ? Ne(j._function) || Ne(j._class) ? dy() : (pi(), Ur()) : Ne(j._var) || // declare export var ...
  Ne(j._function) || // declare export function ...
  Ne(j._class) || // declare export class ...
  Rt($e._opaque) ? dy() : Ne(j.star) || // declare export * from ''
  Ne(j.braceL) || // declare export {} ...
  Rt($e._interface) || // declare export interface ...
  Rt($e._type) || // declare export type ...
  Rt($e._opaque) ? zC() : er();
}
function LJ() {
  sn($e._exports), _o(), Ur();
}
function jJ() {
  ft(), Wg();
}
function FJ() {
  ft(), qg(!0);
}
function BJ() {
  ft(), Ug();
}
function Ug(t = !1) {
  if (Hp(), Ne(j.lessThan) && ds(), at(j._extends))
    do
      If();
    while (!t && at(j.comma));
  if (Rt($e._mixins)) {
    ft();
    do
      If();
    while (at(j.comma));
  }
  if (Rt($e._implements)) {
    ft();
    do
      If();
    while (at(j.comma));
  }
  dd(t, !1, t);
}
function If() {
  LC(!1), Ne(j.lessThan) && lo();
}
function Vg() {
  Ug();
}
function Hp() {
  zt();
}
function Wg() {
  Hp(), Ne(j.lessThan) && ds(), $s(j.eq), Ur();
}
function qg(t) {
  sn($e._type), Hp(), Ne(j.lessThan) && ds(), Ne(j.colon) && $s(j.colon), t || $s(j.eq), Ur();
}
function $J() {
  zg(), BC(), at(j.eq) && pi();
}
function ds() {
  const t = nr(0);
  Ne(j.lessThan) || Ne(j.typeParameterStart) ? ft() : er();
  do
    $J(), Ne(j.greaterThan) || ct(j.comma);
  while (!Ne(j.greaterThan) && !de.error);
  ct(j.greaterThan), tr(t);
}
function lo() {
  const t = nr(0);
  for (ct(j.lessThan); !Ne(j.greaterThan) && !de.error; )
    pi(), Ne(j.greaterThan) || ct(j.comma);
  ct(j.greaterThan), tr(t);
}
function UJ() {
  if (sn($e._interface), at(j._extends))
    do
      If();
    while (at(j.comma));
  dd(!1, !1, !1);
}
function Hg() {
  Ne(j.num) || Ne(j.string) ? oa() : zt();
}
function VJ() {
  Yr() === j.colon ? (Hg(), $s()) : pi(), ct(j.bracketR), $s();
}
function WJ() {
  Hg(), ct(j.bracketR), ct(j.bracketR), Ne(j.lessThan) || Ne(j.parenL) ? Gg() : (at(j.question), $s());
}
function Gg() {
  for (Ne(j.lessThan) && ds(), ct(j.parenL); !Ne(j.parenR) && !Ne(j.ellipsis) && !de.error; )
    pd(), Ne(j.parenR) || ct(j.comma);
  at(j.ellipsis) && pd(), ct(j.parenR), $s();
}
function qJ() {
  Gg();
}
function dd(t, e, r) {
  let a;
  for (e && Ne(j.braceBarL) ? (ct(j.braceBarL), a = j.braceBarR) : (ct(j.braceL), a = j.braceR); !Ne(a) && !de.error; ) {
    if (r && Rt($e._proto)) {
      const l = Yr();
      l !== j.colon && l !== j.question && (ft(), t = !1);
    }
    if (t && Rt($e._static)) {
      const l = Yr();
      l !== j.colon && l !== j.question && ft();
    }
    if (zg(), at(j.bracketL))
      at(j.bracketL) ? WJ() : VJ();
    else if (Ne(j.parenL) || Ne(j.lessThan))
      qJ();
    else {
      if (Rt($e._get) || Rt($e._set)) {
        const l = Yr();
        (l === j.name || l === j.string || l === j.num) && ft();
      }
      HJ();
    }
    GJ();
  }
  ct(a);
}
function HJ() {
  if (Ne(j.ellipsis)) {
    if (ct(j.ellipsis), at(j.comma) || at(j.semi), Ne(j.braceR))
      return;
    pi();
  } else
    Hg(), Ne(j.lessThan) || Ne(j.parenL) ? Gg() : (at(j.question), $s());
}
function GJ() {
  !at(j.semi) && !at(j.comma) && !Ne(j.braceR) && !Ne(j.braceBarR) && er();
}
function LC(t) {
  for (t || zt(); at(j.dot); )
    zt();
}
function zJ() {
  LC(!0), Ne(j.lessThan) && lo();
}
function KJ() {
  ct(j._typeof), jC();
}
function YJ() {
  for (ct(j.bracketL); de.pos < _t.length && !Ne(j.bracketR) && (pi(), !Ne(j.bracketR)); )
    ct(j.comma);
  ct(j.bracketR);
}
function pd() {
  const t = Yr();
  t === j.colon || t === j.question ? (zt(), at(j.question), $s()) : pi();
}
function py() {
  for (; !Ne(j.parenR) && !Ne(j.ellipsis) && !de.error; )
    pd(), Ne(j.parenR) || ct(j.comma);
  at(j.ellipsis) && pd();
}
function jC() {
  let t = !1;
  const e = de.noAnonFunctionType;
  switch (de.type) {
    case j.name: {
      if (Rt($e._interface)) {
        UJ();
        return;
      }
      zt(), zJ();
      return;
    }
    case j.braceL:
      dd(!1, !1, !1);
      return;
    case j.braceBarL:
      dd(!1, !0, !1);
      return;
    case j.bracketL:
      YJ();
      return;
    case j.lessThan:
      ds(), ct(j.parenL), py(), ct(j.parenR), ct(j.arrow), pi();
      return;
    case j.parenL:
      if (ft(), !Ne(j.parenR) && !Ne(j.ellipsis))
        if (Ne(j.name)) {
          const r = Yr();
          t = r !== j.question && r !== j.colon;
        } else
          t = !0;
      if (t)
        if (de.noAnonFunctionType = !1, pi(), de.noAnonFunctionType = e, de.noAnonFunctionType || !(Ne(j.comma) || Ne(j.parenR) && Yr() === j.arrow)) {
          ct(j.parenR);
          return;
        } else
          at(j.comma);
      py(), ct(j.parenR), ct(j.arrow), pi();
      return;
    case j.minus:
      ft(), _l();
      return;
    case j.string:
    case j.num:
    case j._true:
    case j._false:
    case j._null:
    case j._this:
    case j._void:
    case j.star:
      ft();
      return;
    default:
      if (de.type === j._typeof) {
        KJ();
        return;
      } else if (de.type & j.IS_KEYWORD) {
        ft(), de.tokens[de.tokens.length - 1].type = j.name;
        return;
      }
  }
  er();
}
function XJ() {
  for (jC(); !Ei() && (Ne(j.bracketL) || Ne(j.questionDot)); )
    at(j.questionDot), ct(j.bracketL), at(j.bracketR) || (pi(), ct(j.bracketR));
}
function FC() {
  at(j.question) ? FC() : XJ();
}
function Rw() {
  FC(), !de.noAnonFunctionType && at(j.arrow) && pi();
}
function Mw() {
  for (at(j.bitwiseAND), Rw(); at(j.bitwiseAND); )
    Rw();
}
function JJ() {
  for (at(j.bitwiseOR), Mw(); at(j.bitwiseOR); )
    Mw();
}
function pi() {
  JJ();
}
function _o() {
  $s();
}
function BC() {
  zt(), Ne(j.colon) && _o();
}
function zg() {
  (Ne(j.plus) || Ne(j.minus)) && (ft(), de.tokens[de.tokens.length - 1].isType = !0);
}
function QJ(t) {
  Ne(j.colon) && $g(), xc(!1, t);
}
function ZJ(t, e, r) {
  if (Ne(j.questionDot) && Yr() === j.lessThan) {
    if (e) {
      r.stop = !0;
      return;
    }
    ft(), lo(), ct(j.parenL), xa();
    return;
  } else if (!e && Ne(j.lessThan)) {
    const a = de.snapshot();
    if (lo(), ct(j.parenL), xa(), de.error)
      de.restoreFromSnapshot(a);
    else
      return;
  }
  Mg(t, e, r);
}
function eQ() {
  if (Ne(j.lessThan)) {
    const t = de.snapshot();
    lo(), de.error && de.restoreFromSnapshot(t);
  }
}
function tQ() {
  if (Ne(j.name) && de.contextualKeyword === $e._interface) {
    const t = nr(0);
    return ft(), Vg(), tr(t), !0;
  } else if (Rt($e._enum))
    return $C(), !0;
  return !1;
}
function rQ() {
  return Rt($e._enum) ? ($C(), !0) : !1;
}
function nQ(t) {
  if (t === $e._declare) {
    if (Ne(j._class) || Ne(j.name) || Ne(j._function) || Ne(j._var) || Ne(j._export)) {
      const e = nr(1);
      dy(), tr(e);
    }
  } else if (Ne(j.name)) {
    if (t === $e._interface) {
      const e = nr(1);
      Vg(), tr(e);
    } else if (t === $e._type) {
      const e = nr(1);
      Wg(), tr(e);
    } else if (t === $e._opaque) {
      const e = nr(1);
      qg(!1), tr(e);
    }
  }
  Ur();
}
function iQ() {
  return Rt($e._type) || Rt($e._interface) || Rt($e._opaque) || Rt($e._enum);
}
function sQ() {
  return Ne(j.name) && (de.contextualKeyword === $e._type || de.contextualKeyword === $e._interface || de.contextualKeyword === $e._opaque || de.contextualKeyword === $e._enum);
}
function aQ() {
  if (Rt($e._type)) {
    const t = nr(1);
    ft(), Ne(j.braceL) ? (Yg(), Bu()) : Wg(), tr(t);
  } else if (Rt($e._opaque)) {
    const t = nr(1);
    ft(), qg(!1), tr(t);
  } else if (Rt($e._interface)) {
    const t = nr(1);
    ft(), Vg(), tr(t);
  } else
    xi(!0);
}
function oQ() {
  return Ne(j.star) || Rt($e._type) && Yr() === j.star;
}
function lQ() {
  if (gn($e._type)) {
    const t = nr(2);
    hy(), tr(t);
  } else
    hy();
}
function uQ(t) {
  if (t && Ne(j.lessThan) && lo(), Rt($e._implements)) {
    const e = nr(0);
    ft(), de.tokens[de.tokens.length - 1].type = j._implements;
    do
      Hp(), Ne(j.lessThan) && lo();
    while (at(j.comma));
    tr(e);
  }
}
function cQ() {
  Ne(j.lessThan) && (ds(), Ne(j.parenL) || er());
}
function fQ() {
  const t = nr(0);
  at(j.question), Ne(j.colon) && _o(), tr(t);
}
function dQ() {
  if (Ne(j._typeof) || Rt($e._type)) {
    const t = Ec();
    (OJ(t) || t.type === j.braceL || t.type === j.star) && ft();
  }
}
function pQ() {
  const t = de.contextualKeyword === $e._type || de.type === j._typeof;
  t ? ft() : zt(), Rt($e._as) && !xg($e._as) ? (zt(), t && !Ne(j.name) && !(de.type & j.IS_KEYWORD) || zt()) : (t && (Ne(j.name) || de.type & j.IS_KEYWORD) && zt(), gn($e._as) && zt());
}
function hQ() {
  if (Ne(j.lessThan)) {
    const t = nr(0);
    ds(), tr(t);
  }
}
function mQ() {
  Ne(j.colon) && _o();
}
function yQ() {
  if (Ne(j.colon)) {
    const t = de.noAnonFunctionType;
    de.noAnonFunctionType = !0, _o(), de.noAnonFunctionType = t;
  }
}
function bQ(t, e) {
  if (Ne(j.lessThan)) {
    const r = de.snapshot();
    let a = Ds(t, e);
    if (de.error)
      de.restoreFromSnapshot(r), de.type = j.typeParameterStart;
    else
      return a;
    const l = nr(0);
    if (ds(), tr(l), a = Ds(t, e), a)
      return !0;
    er();
  }
  return Ds(t, e);
}
function gQ() {
  if (Ne(j.colon)) {
    const t = nr(0), e = de.snapshot(), r = de.noAnonFunctionType;
    de.noAnonFunctionType = !0, $g(), de.noAnonFunctionType = r, Ei() && er(), Ne(j.arrow) || er(), de.error && de.restoreFromSnapshot(e), tr(t);
  }
  return at(j.arrow);
}
function vQ(t, e = !1) {
  if (de.tokens[de.tokens.length - 1].contextualKeyword === $e._async && Ne(j.lessThan)) {
    const r = de.snapshot();
    if (EQ() && !de.error)
      return;
    de.restoreFromSnapshot(r);
  }
  OC(t, e);
}
function EQ() {
  de.scopeDepth++;
  const t = de.tokens.length;
  return Bl(), cy() ? (Fu(t), !0) : !1;
}
function $C() {
  sn($e._enum), de.tokens[de.tokens.length - 1].type = j._enum, zt(), _Q();
}
function _Q() {
  gn($e._of) && ft(), ct(j.braceL), SQ(), ct(j.braceR);
}
function SQ() {
  for (; !Ne(j.braceR) && !de.error && !at(j.ellipsis); )
    wQ(), Ne(j.braceR) || ct(j.comma);
}
function wQ() {
  zt(), at(j.eq) && ft();
}
function xQ() {
  if (Gp(j.eof), de.scopes.push(new Bs(0, de.tokens.length, !0)), de.scopeDepth !== 0)
    throw new Error(`Invalid scope depth at end of file: ${de.scopeDepth}`);
  return new cZ(de.tokens, de.scopes);
}
function xi(t) {
  gr && tQ() || (Ne(j.at) && Kg(), TQ(t));
}
function TQ(t) {
  if (pr && VX())
    return;
  const e = de.type;
  switch (e) {
    case j._break:
    case j._continue:
      PQ();
      return;
    case j._debugger:
      CQ();
      return;
    case j._do:
      IQ();
      return;
    case j._for:
      OQ();
      return;
    case j._function:
      if (Yr() === j.dot) break;
      t || er(), NQ();
      return;
    case j._class:
      t || er(), co(!0);
      return;
    case j._if:
      RQ();
      return;
    case j._return:
      MQ();
      return;
    case j._switch:
      LQ();
      return;
    case j._throw:
      jQ();
      return;
    case j._try:
      BQ();
      return;
    case j._let:
    case j._const:
      t || er();
    case j._var:
      Of(e !== j._var);
      return;
    case j._while:
      $Q();
      return;
    case j.braceL:
      Ta();
      return;
    case j.semi:
      UQ();
      return;
    case j._export:
    case j._import: {
      const l = Yr();
      if (l === j.parenL || l === j.dot)
        break;
      ft(), e === j._import ? YC() : zC();
      return;
    }
    case j.name:
      if (de.contextualKeyword === $e._async) {
        const l = de.start, d = de.snapshot();
        if (ft(), Ne(j._function) && !Ei()) {
          ct(j._function), uo(l, !0);
          return;
        } else
          de.restoreFromSnapshot(d);
      } else if (de.contextualKeyword === $e._using && !H4() && // Statements like `using[0]` and `using in foo` aren't actual using
      // declarations.
      Yr() === j.name) {
        Of(!0);
        return;
      } else if (UC()) {
        sn($e._await), Of(!0);
        return;
      }
  }
  const r = de.tokens.length;
  Bn();
  let a = null;
  if (de.tokens.length === r + 1) {
    const l = de.tokens[de.tokens.length - 1];
    l.type === j.name && (a = l.contextualKeyword);
  }
  if (a == null) {
    Ur();
    return;
  }
  at(j.colon) ? VQ() : WQ(a);
}
function UC() {
  if (!Rt($e._await))
    return !1;
  const t = de.snapshot();
  return ft(), !Rt($e._using) || li() || (ft(), !Ne(j.name) || li()) ? (de.restoreFromSnapshot(t), !1) : (de.restoreFromSnapshot(t), !0);
}
function Kg() {
  for (; Ne(j.at); )
    VC();
}
function VC() {
  if (ft(), at(j.parenL))
    Bn(), ct(j.parenR);
  else {
    for (zt(); at(j.dot); )
      zt();
    AQ();
  }
}
function AQ() {
  pr ? rJ() : WC();
}
function WC() {
  at(j.parenL) && xa();
}
function PQ() {
  ft(), As() || (zt(), Ur());
}
function CQ() {
  ft(), Ur();
}
function IQ() {
  ft(), xi(!1), ct(j._while), qp(), at(j.semi);
}
function OQ() {
  de.scopeDepth++;
  const t = de.tokens.length;
  DQ();
  const e = de.tokens.length;
  de.scopes.push(new Bs(t, e, !1)), de.scopeDepth--;
}
function kQ() {
  return !(!Rt($e._using) || xg($e._of));
}
function DQ() {
  ft();
  let t = !1;
  if (Rt($e._await) && (t = !0, ft()), ct(j.parenL), Ne(j.semi)) {
    t && er(), a0();
    return;
  }
  const e = UC();
  if (e || Ne(j._var) || Ne(j._let) || Ne(j._const) || kQ()) {
    if (e && sn($e._await), ft(), qC(!0, de.type !== j._var), Ne(j._in) || Rt($e._of)) {
      Lw(t);
      return;
    }
    a0();
    return;
  }
  if (Bn(!0), Ne(j._in) || Rt($e._of)) {
    Lw(t);
    return;
  }
  t && er(), a0();
}
function NQ() {
  const t = de.start;
  ft(), uo(t, !0);
}
function RQ() {
  ft(), qp(), xi(!1), at(j._else) && xi(!1);
}
function MQ() {
  ft(), As() || (Bn(), Ur());
}
function LQ() {
  ft(), qp(), de.scopeDepth++;
  const t = de.tokens.length;
  for (ct(j.braceL); !Ne(j.braceR) && !de.error; )
    if (Ne(j._case) || Ne(j._default)) {
      const r = Ne(j._case);
      ft(), r && Bn(), ct(j.colon);
    } else
      xi(!0);
  ft();
  const e = de.tokens.length;
  de.scopes.push(new Bs(t, e, !1)), de.scopeDepth--;
}
function jQ() {
  ft(), Bn(), Ur();
}
function FQ() {
  Up(
    !0
    /* isBlockScope */
  ), pr && jl();
}
function BQ() {
  if (ft(), Ta(), Ne(j._catch)) {
    ft();
    let t = null;
    if (Ne(j.parenL) && (de.scopeDepth++, t = de.tokens.length, ct(j.parenL), FQ(), ct(j.parenR)), Ta(), t != null) {
      const e = de.tokens.length;
      de.scopes.push(new Bs(t, e, !1)), de.scopeDepth--;
    }
  }
  at(j._finally) && Ta();
}
function Of(t) {
  ft(), qC(!1, t), Ur();
}
function $Q() {
  ft(), qp(), xi(!1);
}
function UQ() {
  ft();
}
function VQ() {
  xi(!0);
}
function WQ(t) {
  pr ? qX(t) : gr ? nQ(t) : Ur();
}
function Ta(t = !1, e = 0) {
  const r = de.tokens.length;
  de.scopeDepth++, ct(j.braceL), e && (de.tokens[de.tokens.length - 1].contextId = e), Gp(j.braceR), e && (de.tokens[de.tokens.length - 1].contextId = e);
  const a = de.tokens.length;
  de.scopes.push(new Bs(r, a, t)), de.scopeDepth--;
}
function Gp(t) {
  for (; !at(t) && !de.error; )
    xi(!0);
}
function a0() {
  ct(j.semi), Ne(j.semi) || Bn(), ct(j.semi), Ne(j.parenR) || Bn(), ct(j.parenR), xi(!1);
}
function Lw(t) {
  t ? gn($e._of) : ft(), Bn(), ct(j.parenR), xi(!1);
}
function qC(t, e) {
  for (; ; ) {
    if (qQ(e), at(j.eq)) {
      const r = de.tokens.length - 1;
      $n(t), de.tokens[r].rhsEndIndex = de.tokens.length;
    }
    if (!at(j.comma))
      break;
  }
}
function qQ(t) {
  Up(t), pr ? YX() : gr && mQ();
}
function uo(t, e, r = !1) {
  Ne(j.star) && ft(), e && !r && !Ne(j.name) && !Ne(j._yield) && er();
  let a = null;
  Ne(j.name) && (e || (a = de.tokens.length, de.scopeDepth++), Ma(!1));
  const l = de.tokens.length;
  de.scopeDepth++, Bl(), NC(t);
  const d = de.tokens.length;
  de.scopes.push(new Bs(l, d, !0)), de.scopeDepth--, a !== null && (de.scopes.push(new Bs(a, d, !0)), de.scopeDepth--);
}
function Bl(t = !1, e = 0) {
  pr ? KX() : gr && hQ(), ct(j.parenL), e && (de.tokens[de.tokens.length - 1].contextId = e), Cg(
    j.parenR,
    !1,
    !1,
    t,
    e
  ), e && (de.tokens[de.tokens.length - 1].contextId = e);
}
function co(t, e = !1) {
  const r = Ru();
  ft(), de.tokens[de.tokens.length - 1].contextId = r, de.tokens[de.tokens.length - 1].isExpression = !t;
  let a = null;
  t || (a = de.tokens.length, de.scopeDepth++), KQ(t, e), YQ();
  const l = de.tokens.length;
  if (HQ(r), !de.error && (de.tokens[l].contextId = r, de.tokens[de.tokens.length - 1].contextId = r, a !== null)) {
    const d = de.tokens.length;
    de.scopes.push(new Bs(a, d, !1)), de.scopeDepth--;
  }
}
function HC() {
  return Ne(j.eq) || Ne(j.semi) || Ne(j.braceR) || Ne(j.bang) || Ne(j.colon);
}
function GC() {
  return Ne(j.parenL) || Ne(j.lessThan);
}
function HQ(t) {
  for (ct(j.braceL); !at(j.braceR) && !de.error; ) {
    if (at(j.semi))
      continue;
    if (Ne(j.at)) {
      VC();
      continue;
    }
    const e = de.start;
    GQ(e, t);
  }
}
function GQ(t, e) {
  pr && Ig([
    $e._declare,
    $e._public,
    $e._protected,
    $e._private,
    $e._override
  ]);
  let r = !1;
  if (Ne(j.name) && de.contextualKeyword === $e._static) {
    if (zt(), GC()) {
      fu(
        t,
        /* isConstructor */
        !1
      );
      return;
    } else if (HC()) {
      kf();
      return;
    }
    if (de.tokens[de.tokens.length - 1].type = j._static, r = !0, Ne(j.braceL)) {
      de.tokens[de.tokens.length - 1].contextId = e, Ta();
      return;
    }
  }
  zQ(t, r, e);
}
function zQ(t, e, r) {
  if (pr && WX(e))
    return;
  if (at(j.star)) {
    su(r), fu(
      t,
      /* isConstructor */
      !1
    );
    return;
  }
  su(r);
  let a = !1;
  const l = de.tokens[de.tokens.length - 1];
  l.contextualKeyword === $e._constructor && (a = !0), jw(), GC() ? fu(t, a) : HC() ? kf() : l.contextualKeyword === $e._async && !As() ? (de.tokens[de.tokens.length - 1].type = j._async, Ne(j.star) && ft(), su(r), jw(), fu(
    t,
    !1
    /* isConstructor */
  )) : (l.contextualKeyword === $e._get || l.contextualKeyword === $e._set) && !(As() && Ne(j.star)) ? (l.contextualKeyword === $e._get ? de.tokens[de.tokens.length - 1].type = j._get : de.tokens[de.tokens.length - 1].type = j._set, su(r), fu(
    t,
    /* isConstructor */
    !1
  )) : l.contextualKeyword === $e._accessor && !As() ? (su(r), kf()) : As() ? kf() : er();
}
function fu(t, e) {
  pr ? Eo() : gr && Ne(j.lessThan) && ds(), fy(t, e);
}
function su(t) {
  ju(t);
}
function jw() {
  if (pr) {
    const t = nr(0);
    at(j.question), tr(t);
  }
}
function kf() {
  if (pr ? (X4(j.bang), jl()) : gr && Ne(j.colon) && _o(), Ne(j.eq)) {
    const t = de.tokens.length;
    ft(), $n(), de.tokens[t].rhsEndIndex = de.tokens.length;
  }
  Ur();
}
function KQ(t, e = !1) {
  pr && (!t || e) && Rt($e._implements) || (Ne(j.name) && Ma(!0), pr ? Eo() : gr && Ne(j.lessThan) && ds());
}
function YQ() {
  let t = !1;
  at(j._extends) ? (IC(), t = !0) : t = !1, pr ? GX(t) : gr && uQ(t);
}
function zC() {
  const t = de.tokens.length - 1;
  pr && FX() || (ZQ() ? eZ() : QQ() ? (zt(), Ne(j.comma) && Yr() === j.star ? (ct(j.comma), ct(j.star), sn($e._as), zt()) : KC(), Bu()) : at(j._default) ? XQ() : rZ() ? JQ() : (Yg(), Bu()), de.tokens[t].rhsEndIndex = de.tokens.length);
}
function XQ() {
  if (pr && UX() || gr && rQ())
    return;
  const t = de.start;
  at(j._function) ? uo(t, !0, !0) : Rt($e._async) && Yr() === j._function ? (gn($e._async), at(j._function), uo(t, !0, !0)) : Ne(j._class) ? co(!0, !0) : Ne(j.at) ? (Kg(), co(!0, !0)) : ($n(), Ur());
}
function JQ() {
  pr ? HX() : gr ? aQ() : xi(!0);
}
function QQ() {
  if (pr && wC())
    return !1;
  if (gr && sQ())
    return !1;
  if (Ne(j.name))
    return de.contextualKeyword !== $e._async;
  if (!Ne(j._default))
    return !1;
  const t = Tg(), e = Ec(), r = e.type === j.name && e.contextualKeyword === $e._from;
  if (e.type === j.comma)
    return !0;
  if (r) {
    const a = _t.charCodeAt(J4(t + 4));
    return a === ze.quotationMark || a === ze.apostrophe;
  }
  return !1;
}
function KC() {
  at(j.comma) && Yg();
}
function Bu() {
  gn($e._from) && (oa(), XC()), Ur();
}
function ZQ() {
  return gr ? oQ() : Ne(j.star);
}
function eZ() {
  gr ? lQ() : hy();
}
function hy() {
  ct(j.star), Rt($e._as) ? tZ() : Bu();
}
function tZ() {
  ft(), de.tokens[de.tokens.length - 1].type = j._as, zt(), KC(), Bu();
}
function rZ() {
  return pr && wC() || gr && iQ() || de.type === j._var || de.type === j._const || de.type === j._let || de.type === j._function || de.type === j._class || Rt($e._async) || Ne(j.at);
}
function Yg() {
  let t = !0;
  for (ct(j.braceL); !at(j.braceR) && !de.error; ) {
    if (t)
      t = !1;
    else if (ct(j.comma), at(j.braceR))
      break;
    nZ();
  }
}
function nZ() {
  if (pr) {
    $X();
    return;
  }
  zt(), de.tokens[de.tokens.length - 1].identifierRole = Ut.ExportAccess, gn($e._as) && zt();
}
function iZ() {
  const t = de.snapshot();
  return sn($e._module), gn($e._from) ? Rt($e._from) ? (de.restoreFromSnapshot(t), !0) : (de.restoreFromSnapshot(t), !1) : Ne(j.comma) ? (de.restoreFromSnapshot(t), !1) : (de.restoreFromSnapshot(t), !0);
}
function sZ() {
  Rt($e._module) && iZ() && ft();
}
function YC() {
  if (pr && Ne(j.name) && Yr() === j.eq) {
    ly();
    return;
  }
  if (pr && Rt($e._type)) {
    const t = Ec();
    if (t.type === j.name && t.contextualKeyword !== $e._from) {
      if (sn($e._type), Yr() === j.eq) {
        ly();
        return;
      }
    } else (t.type === j.star || t.type === j.braceL) && sn($e._type);
  }
  Ne(j.string) || (sZ(), oZ(), sn($e._from)), oa(), XC(), Ur();
}
function aZ() {
  return Ne(j.name);
}
function Fw() {
  ld();
}
function oZ() {
  gr && dQ();
  let t = !0;
  if (!(aZ() && (Fw(), !at(j.comma)))) {
    if (Ne(j.star)) {
      ft(), sn($e._as), Fw();
      return;
    }
    for (ct(j.braceL); !at(j.braceR) && !de.error; ) {
      if (t)
        t = !1;
      else if (at(j.colon) && er(
        "ES2015 named imports do not destructure. Use another statement for destructuring after the import."
      ), ct(j.comma), at(j.braceR))
        break;
      lZ();
    }
  }
}
function lZ() {
  if (pr) {
    BX();
    return;
  }
  if (gr) {
    pQ();
    return;
  }
  ld(), Rt($e._as) && (de.tokens[de.tokens.length - 1].identifierRole = Ut.ImportAccess, ft(), ld());
}
function XC() {
  (Ne(j._with) || Rt($e._assert) && !li()) && (ft(), Bg(!1, !1));
}
function uZ() {
  return de.pos === 0 && _t.charCodeAt(0) === ze.numberSign && _t.charCodeAt(1) === ze.exclamationMark && eC(2), Z4(), xQ();
}
class cZ {
  constructor(e, r) {
    this.tokens = e, this.scopes = r;
  }
}
function fZ(t, e, r, a) {
  if (a && r)
    throw new Error("Cannot combine flow and typescript plugins.");
  ZK(t, e, r, a);
  const l = uZ();
  if (de.error)
    throw XK(de.error);
  return l;
}
function dZ(t) {
  let e = t.currentIndex(), r = 0;
  const a = t.currentToken();
  do {
    const l = t.tokens[e];
    if (l.isOptionalChainStart && r++, l.isOptionalChainEnd && r--, r += l.numNullishCoalesceStarts, r -= l.numNullishCoalesceEnds, l.contextualKeyword === $e._await && l.identifierRole == null && l.scopeDepth === a.scopeDepth)
      return !0;
    e += 1;
  } while (r > 0 && e < t.tokens.length);
  return !1;
}
class Eu {
  __init() {
    this.resultCode = "";
  }
  // Array mapping input token index to optional string index position in the
  // output code.
  __init2() {
    this.resultMappings = new Array(this.tokens.length);
  }
  __init3() {
    this.tokenIndex = 0;
  }
  constructor(e, r, a, l, d) {
    this.code = e, this.tokens = r, this.isFlowEnabled = a, this.disableESTransforms = l, this.helperManager = d, Eu.prototype.__init.call(this), Eu.prototype.__init2.call(this), Eu.prototype.__init3.call(this);
  }
  /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */
  snapshot() {
    return {
      resultCode: this.resultCode,
      tokenIndex: this.tokenIndex
    };
  }
  restoreToSnapshot(e) {
    this.resultCode = e.resultCode, this.tokenIndex = e.tokenIndex;
  }
  /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */
  dangerouslyGetAndRemoveCodeSinceSnapshot(e) {
    const r = this.resultCode.slice(e.resultCode.length);
    return this.resultCode = e.resultCode, r;
  }
  reset() {
    this.resultCode = "", this.resultMappings = new Array(this.tokens.length), this.tokenIndex = 0;
  }
  matchesContextualAtIndex(e, r) {
    return this.matches1AtIndex(e, j.name) && this.tokens[e].contextualKeyword === r;
  }
  identifierNameAtIndex(e) {
    return this.identifierNameForToken(this.tokens[e]);
  }
  identifierNameAtRelativeIndex(e) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(e));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(e) {
    return this.code.slice(e.start, e.end);
  }
  rawCodeForToken(e) {
    return this.code.slice(e.start, e.end);
  }
  stringValueAtIndex(e) {
    return this.stringValueForToken(this.tokens[e]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(e) {
    return this.code.slice(e.start + 1, e.end - 1);
  }
  matches1AtIndex(e, r) {
    return this.tokens[e].type === r;
  }
  matches2AtIndex(e, r, a) {
    return this.tokens[e].type === r && this.tokens[e + 1].type === a;
  }
  matches3AtIndex(e, r, a, l) {
    return this.tokens[e].type === r && this.tokens[e + 1].type === a && this.tokens[e + 2].type === l;
  }
  matches1(e) {
    return this.tokens[this.tokenIndex].type === e;
  }
  matches2(e, r) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === r;
  }
  matches3(e, r, a) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === r && this.tokens[this.tokenIndex + 2].type === a;
  }
  matches4(e, r, a, l) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === r && this.tokens[this.tokenIndex + 2].type === a && this.tokens[this.tokenIndex + 3].type === l;
  }
  matches5(e, r, a, l, d) {
    return this.tokens[this.tokenIndex].type === e && this.tokens[this.tokenIndex + 1].type === r && this.tokens[this.tokenIndex + 2].type === a && this.tokens[this.tokenIndex + 3].type === l && this.tokens[this.tokenIndex + 4].type === d;
  }
  matchesContextual(e) {
    return this.matchesContextualAtIndex(this.tokenIndex, e);
  }
  matchesContextIdAndLabel(e, r) {
    return this.matches1(e) && this.currentToken().contextId === r;
  }
  previousWhitespaceAndComments() {
    let e = this.code.slice(
      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length
    );
    return this.isFlowEnabled && (e = e.replace(/@flow/g, "")), e;
  }
  replaceToken(e) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += e, this.appendTokenSuffix(), this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(e) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, ""), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += e, this.appendTokenSuffix(), this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }
  /**
   * Remove all code until the next }, accounting for balanced braces.
   */
  removeBalancedCode() {
    let e = 0;
    for (; !this.isAtEnd(); ) {
      if (this.matches1(j.braceL))
        e++;
      else if (this.matches1(j.braceR)) {
        if (e === 0)
          return;
        e--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(e) {
    if (this.tokens[this.tokenIndex].type !== e)
      throw new Error(`Expected token ${e}`);
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    ), this.appendTokenSuffix(), this.tokenIndex++;
  }
  copyTokenWithPrefix(e) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultCode += e, this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end
    ), this.appendTokenSuffix(), this.tokenIndex++;
  }
  appendTokenPrefix() {
    const e = this.currentToken();
    if ((e.numNullishCoalesceStarts || e.isOptionalChainStart) && (e.isAsyncOperation = dZ(this)), !this.disableESTransforms) {
      if (e.numNullishCoalesceStarts)
        for (let r = 0; r < e.numNullishCoalesceStarts; r++)
          e.isAsyncOperation ? (this.resultCode += "await ", this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce")) : this.resultCode += this.helperManager.getHelperName("nullishCoalesce"), this.resultCode += "(";
      e.isOptionalChainStart && (e.isAsyncOperation && (this.resultCode += "await "), this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === j._delete ? e.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete") : this.resultCode += this.helperManager.getHelperName("optionalChainDelete") : e.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChain") : this.resultCode += this.helperManager.getHelperName("optionalChain"), this.resultCode += "([");
    }
  }
  appendTokenSuffix() {
    const e = this.currentToken();
    if (e.isOptionalChainEnd && !this.disableESTransforms && (this.resultCode += "])"), e.numNullishCoalesceEnds && !this.disableESTransforms)
      for (let r = 0; r < e.numNullishCoalesceEnds; r++)
        this.resultCode += "))";
  }
  appendCode(e) {
    this.resultCode += e;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const e = this.currentToken();
    return this.code.slice(e.start, e.end);
  }
  tokenAtRelativeIndex(e) {
    return this.tokens[this.tokenIndex + e];
  }
  currentIndex() {
    return this.tokenIndex;
  }
  /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */
  nextToken() {
    if (this.tokenIndex === this.tokens.length)
      throw new Error("Unexpectedly reached end of input.");
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length)
      throw new Error("Tried to finish processing tokens before reaching the end.");
    return this.resultCode += this.previousWhitespaceAndComments(), { code: this.resultCode, mappings: this.resultMappings };
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
}
function pZ(t, e, r, a) {
  const l = e.snapshot(), d = hZ(e);
  let h = [];
  const n = [], u = [];
  let i = null;
  const c = [], f = [], s = e.currentToken().contextId;
  if (s == null)
    throw new Error("Expected non-null class context ID on class open-brace.");
  for (e.nextToken(); !e.matchesContextIdAndLabel(j.braceR, s); )
    if (e.matchesContextual($e._constructor) && !e.currentToken().isType)
      ({ constructorInitializerStatements: h, constructorInsertPos: i } = Bw(e));
    else if (e.matches1(j.semi))
      a || f.push({ start: e.currentIndex(), end: e.currentIndex() + 1 }), e.nextToken();
    else if (e.currentToken().isType)
      e.nextToken();
    else {
      const o = e.currentIndex();
      let y = !1, m = !1, g = !1;
      for (; hd(e.currentToken()); )
        e.matches1(j._static) && (y = !0), e.matches1(j.hash) && (m = !0), (e.matches1(j._declare) || e.matches1(j._abstract)) && (g = !0), e.nextToken();
      if (y && e.matches1(j.braceL)) {
        o0(e, s);
        continue;
      }
      if (m) {
        o0(e, s);
        continue;
      }
      if (e.matchesContextual($e._constructor) && !e.currentToken().isType) {
        ({ constructorInitializerStatements: h, constructorInsertPos: i } = Bw(e));
        continue;
      }
      const b = e.currentIndex();
      if (mZ(e), e.matches1(j.lessThan) || e.matches1(j.parenL)) {
        o0(e, s);
        continue;
      }
      for (; e.currentToken().isType; )
        e.nextToken();
      if (e.matches1(j.eq)) {
        const v = e.currentIndex(), T = e.currentToken().rhsEndIndex;
        if (T == null)
          throw new Error("Expected rhsEndIndex on class field assignment.");
        for (e.nextToken(); e.currentIndex() < T; )
          t.processToken();
        let E;
        y ? (E = r.claimFreeName("__initStatic"), u.push(E)) : (E = r.claimFreeName("__init"), n.push(E)), c.push({
          initializerName: E,
          equalsIndex: v,
          start: b,
          end: e.currentIndex()
        });
      } else (!a || g) && f.push({ start: o, end: e.currentIndex() });
    }
  return e.restoreToSnapshot(l), a ? {
    headerInfo: d,
    constructorInitializerStatements: h,
    instanceInitializerNames: [],
    staticInitializerNames: [],
    constructorInsertPos: i,
    fields: [],
    rangesToRemove: f
  } : {
    headerInfo: d,
    constructorInitializerStatements: h,
    instanceInitializerNames: n,
    staticInitializerNames: u,
    constructorInsertPos: i,
    fields: c,
    rangesToRemove: f
  };
}
function o0(t, e) {
  for (t.nextToken(); t.currentToken().contextId !== e; )
    t.nextToken();
  for (; hd(t.tokenAtRelativeIndex(-1)); )
    t.previousToken();
}
function hZ(t) {
  const e = t.currentToken(), r = e.contextId;
  if (r == null)
    throw new Error("Expected context ID on class token.");
  const a = e.isExpression;
  if (a == null)
    throw new Error("Expected isExpression on class token.");
  let l = null, d = !1;
  for (t.nextToken(), t.matches1(j.name) && (l = t.identifierName()); !t.matchesContextIdAndLabel(j.braceL, r); )
    t.matches1(j._extends) && !t.currentToken().isType && (d = !0), t.nextToken();
  return { isExpression: a, className: l, hasSuperclass: d };
}
function Bw(t) {
  const e = [];
  t.nextToken();
  const r = t.currentToken().contextId;
  if (r == null)
    throw new Error("Expected context ID on open-paren starting constructor params.");
  for (; !t.matchesContextIdAndLabel(j.parenR, r); )
    if (t.currentToken().contextId === r) {
      if (t.nextToken(), hd(t.currentToken())) {
        for (t.nextToken(); hd(t.currentToken()); )
          t.nextToken();
        const d = t.currentToken();
        if (d.type !== j.name)
          throw new Error("Expected identifier after access modifiers in constructor arg.");
        const h = t.identifierNameForToken(d);
        e.push(`this.${h} = ${h}`);
      }
    } else
      t.nextToken();
  for (t.nextToken(); t.currentToken().isType; )
    t.nextToken();
  let a = t.currentIndex(), l = !1;
  for (; !t.matchesContextIdAndLabel(j.braceR, r); ) {
    if (!l && t.matches2(j._super, j.parenL)) {
      t.nextToken();
      const d = t.currentToken().contextId;
      if (d == null)
        throw new Error("Expected a context ID on the super call");
      for (; !t.matchesContextIdAndLabel(j.parenR, d); )
        t.nextToken();
      a = t.currentIndex(), l = !0;
    }
    t.nextToken();
  }
  return t.nextToken(), { constructorInitializerStatements: e, constructorInsertPos: a };
}
function hd(t) {
  return [
    j._async,
    j._get,
    j._set,
    j.plus,
    j.minus,
    j._readonly,
    j._static,
    j._public,
    j._private,
    j._protected,
    j._override,
    j._abstract,
    j.star,
    j._declare,
    j.hash
  ].includes(t.type);
}
function mZ(t) {
  if (t.matches1(j.bracketL)) {
    const r = t.currentToken().contextId;
    if (r == null)
      throw new Error("Expected class context ID on computed name open bracket.");
    for (; !t.matchesContextIdAndLabel(j.bracketR, r); )
      t.nextToken();
    t.nextToken();
  } else
    t.nextToken();
}
function JC(t) {
  if (t.removeInitialToken(), t.removeToken(), t.removeToken(), t.removeToken(), t.matches1(j.parenL))
    t.removeToken(), t.removeToken(), t.removeToken();
  else
    for (; t.matches1(j.dot); )
      t.removeToken(), t.removeToken();
}
const QC = {
  typeDeclarations: /* @__PURE__ */ new Set(),
  valueDeclarations: /* @__PURE__ */ new Set()
};
function ZC(t) {
  const e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  for (let a = 0; a < t.tokens.length; a++) {
    const l = t.tokens[a];
    l.type === j.name && Y4(l) && (l.isType ? e.add(t.identifierNameForToken(l)) : r.add(t.identifierNameForToken(l)));
  }
  return { typeDeclarations: e, valueDeclarations: r };
}
function eI(t) {
  let e = t.currentIndex();
  for (; !t.matches1AtIndex(e, j.braceR); )
    e++;
  return t.matchesContextualAtIndex(e + 1, $e._from) && t.matches1AtIndex(e + 2, j.string);
}
function Za(t) {
  (t.matches2(j._with, j.braceL) || t.matches2(j.name, j.braceL) && t.matchesContextual($e._assert)) && (t.removeToken(), t.removeToken(), t.removeBalancedCode(), t.removeToken());
}
function tI(t, e, r, a) {
  if (!t || e)
    return !1;
  const l = r.currentToken();
  if (l.rhsEndIndex == null)
    throw new Error("Expected non-null rhsEndIndex on export token.");
  const d = l.rhsEndIndex - r.currentIndex();
  if (d !== 3 && !(d === 4 && r.matches1AtIndex(l.rhsEndIndex - 1, j.semi)))
    return !1;
  const h = r.tokenAtRelativeIndex(2);
  if (h.type !== j.name)
    return !1;
  const n = r.identifierNameForToken(h);
  return a.typeDeclarations.has(n) && !a.valueDeclarations.has(n);
}
class _u extends fs {
  __init() {
    this.hadExport = !1;
  }
  __init2() {
    this.hadNamedExport = !1;
  }
  __init3() {
    this.hadDefaultExport = !1;
  }
  constructor(e, r, a, l, d, h, n, u, i, c, f, s) {
    super(), this.rootTransformer = e, this.tokens = r, this.importProcessor = a, this.nameManager = l, this.helperManager = d, this.reactHotLoaderTransformer = h, this.enableLegacyBabel5ModuleInterop = n, this.enableLegacyTypeScriptModuleInterop = u, this.isTypeScriptTransformEnabled = i, this.isFlowTransformEnabled = c, this.preserveDynamicImport = f, this.keepUnusedImports = s, _u.prototype.__init.call(this), _u.prototype.__init2.call(this), _u.prototype.__init3.call(this), this.declarationInfo = i ? ZC(r) : QC;
  }
  getPrefixCode() {
    let e = "";
    return this.hadExport && (e += 'Object.defineProperty(exports, "__esModule", {value: true});'), e;
  }
  getSuffixCode() {
    return this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport ? `
module.exports = exports.default;
` : "";
  }
  process() {
    return this.tokens.matches3(j._import, j.name, j.eq) ? this.processImportEquals() : this.tokens.matches1(j._import) ? (this.processImport(), !0) : this.tokens.matches2(j._export, j.eq) ? (this.tokens.replaceToken("module.exports"), !0) : this.tokens.matches1(j._export) && !this.tokens.currentToken().isType ? (this.hadExport = !0, this.processExport()) : this.tokens.matches2(j.name, j.postIncDec) && this.processPostIncDec() ? !0 : this.tokens.matches1(j.name) || this.tokens.matches1(j.jsxName) ? this.processIdentifier() : this.tokens.matches1(j.eq) ? this.processAssignment() : this.tokens.matches1(j.assign) ? this.processComplexAssignment() : this.tokens.matches1(j.preIncDec) ? this.processPreIncDec() : !1;
  }
  processImportEquals() {
    const e = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.importProcessor.shouldAutomaticallyElideImportedName(e) ? JC(this.tokens) : this.tokens.replaceToken("const"), !0;
  }
  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
  processImport() {
    if (this.tokens.matches2(j._import, j.parenL)) {
      if (this.preserveDynamicImport) {
        this.tokens.copyToken();
        return;
      }
      const r = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${r}require`);
      const a = this.tokens.currentToken().contextId;
      if (a == null)
        throw new Error("Expected context ID on dynamic import invocation.");
      for (this.tokens.copyToken(); !this.tokens.matchesContextIdAndLabel(j.parenR, a); )
        this.rootTransformer.processToken();
      this.tokens.replaceToken(r ? ")))" : "))");
      return;
    }
    if (this.removeImportAndDetectIfShouldElide())
      this.tokens.removeToken();
    else {
      const r = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(r)), this.tokens.appendCode(this.importProcessor.claimImportCode(r));
    }
    Za(this.tokens), this.tokens.matches1(j.semi) && this.tokens.removeToken();
  }
  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
  removeImportAndDetectIfShouldElide() {
    if (this.tokens.removeInitialToken(), this.tokens.matchesContextual($e._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, j.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, $e._from))
      return this.removeRemainingImport(), !0;
    if (this.tokens.matches1(j.name) || this.tokens.matches1(j.star))
      return this.removeRemainingImport(), !1;
    if (this.tokens.matches1(j.string))
      return !1;
    let e = !1, r = !1;
    for (; !this.tokens.matches1(j.string); )
      (!e && this.tokens.matches1(j.braceL) || this.tokens.matches1(j.comma)) && (this.tokens.removeToken(), this.tokens.matches1(j.braceR) || (r = !0), (this.tokens.matches2(j.name, j.comma) || this.tokens.matches2(j.name, j.braceR) || this.tokens.matches4(j.name, j.name, j.name, j.comma) || this.tokens.matches4(j.name, j.name, j.name, j.braceR)) && (e = !0)), this.tokens.removeToken();
    return this.keepUnusedImports ? !1 : this.isTypeScriptTransformEnabled ? !e : this.isFlowTransformEnabled ? r && !e : !1;
  }
  removeRemainingImport() {
    for (; !this.tokens.matches1(j.string); )
      this.tokens.removeToken();
  }
  processIdentifier() {
    const e = this.tokens.currentToken();
    if (e.shadowsGlobal)
      return !1;
    if (e.identifierRole === Ut.ObjectShorthand)
      return this.processObjectShorthand();
    if (e.identifierRole !== Ut.Access)
      return !1;
    const r = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(e)
    );
    if (!r)
      return !1;
    let a = this.tokens.currentIndex() + 1;
    for (; a < this.tokens.tokens.length && this.tokens.tokens[a].type === j.parenR; )
      a++;
    return this.tokens.tokens[a].type === j.parenL ? this.tokens.tokenAtRelativeIndex(1).type === j.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== j._new ? (this.tokens.replaceToken(`${r}.call(void 0, `), this.tokens.removeToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.parenR)) : this.tokens.replaceToken(`(0, ${r})`) : this.tokens.replaceToken(r), !0;
  }
  processObjectShorthand() {
    const e = this.tokens.identifierName(), r = this.importProcessor.getIdentifierReplacement(e);
    return r ? (this.tokens.replaceToken(`${e}: ${r}`), !0) : !1;
  }
  processExport() {
    if (this.tokens.matches2(j._export, j._enum) || this.tokens.matches3(j._export, j._const, j._enum))
      return this.hadNamedExport = !0, !1;
    if (this.tokens.matches2(j._export, j._default))
      return this.tokens.matches3(j._export, j._default, j._enum) ? (this.hadDefaultExport = !0, !1) : (this.processExportDefault(), !0);
    if (this.tokens.matches2(j._export, j.braceL))
      return this.processExportBindings(), !0;
    if (this.tokens.matches2(j._export, j.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, $e._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(j.braceL)) {
        for (; !this.tokens.matches1(j.braceR); )
          this.tokens.removeToken();
        this.tokens.removeToken();
      } else
        this.tokens.removeToken(), this.tokens.matches1(j._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual($e._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, j.string) && (this.tokens.removeToken(), this.tokens.removeToken(), Za(this.tokens)), !0;
    }
    if (this.hadNamedExport = !0, this.tokens.matches2(j._export, j._var) || this.tokens.matches2(j._export, j._let) || this.tokens.matches2(j._export, j._const))
      return this.processExportVar(), !0;
    if (this.tokens.matches2(j._export, j._function) || // export async function
    this.tokens.matches3(j._export, j.name, j._function))
      return this.processExportFunction(), !0;
    if (this.tokens.matches2(j._export, j._class) || this.tokens.matches3(j._export, j._abstract, j._class) || this.tokens.matches2(j._export, j.at))
      return this.processExportClass(), !0;
    if (this.tokens.matches2(j._export, j.star))
      return this.processExportStar(), !0;
    throw new Error("Unrecognized export syntax.");
  }
  processAssignment() {
    const e = this.tokens.currentIndex(), r = this.tokens.tokens[e - 1];
    if (r.isType || r.type !== j.name || r.shadowsGlobal || e >= 2 && this.tokens.matches1AtIndex(e - 2, j.dot) || e >= 2 && [j._var, j._let, j._const].includes(this.tokens.tokens[e - 2].type))
      return !1;
    const a = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(r)
    );
    return a ? (this.tokens.copyToken(), this.tokens.appendCode(` ${a} =`), !0) : !1;
  }
  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
  processComplexAssignment() {
    const e = this.tokens.currentIndex(), r = this.tokens.tokens[e - 1];
    if (r.type !== j.name || r.shadowsGlobal || e >= 2 && this.tokens.matches1AtIndex(e - 2, j.dot))
      return !1;
    const a = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(r)
    );
    return a ? (this.tokens.appendCode(` = ${a}`), this.tokens.copyToken(), !0) : !1;
  }
  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
  processPreIncDec() {
    const e = this.tokens.currentIndex(), r = this.tokens.tokens[e + 1];
    if (r.type !== j.name || r.shadowsGlobal || e + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(e + 2, j.dot) || this.tokens.matches1AtIndex(e + 2, j.bracketL) || this.tokens.matches1AtIndex(e + 2, j.parenL)))
      return !1;
    const a = this.tokens.identifierNameForToken(r), l = this.importProcessor.resolveExportBinding(a);
    return l ? (this.tokens.appendCode(`${l} = `), this.tokens.copyToken(), !0) : !1;
  }
  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
  processPostIncDec() {
    const e = this.tokens.currentIndex(), r = this.tokens.tokens[e], a = this.tokens.tokens[e + 1];
    if (r.type !== j.name || r.shadowsGlobal || e >= 1 && this.tokens.matches1AtIndex(e - 1, j.dot))
      return !1;
    const l = this.tokens.identifierNameForToken(r), d = this.importProcessor.resolveExportBinding(l);
    if (!d)
      return !1;
    const h = this.tokens.rawCodeForToken(a), n = this.importProcessor.getIdentifierReplacement(l) || l;
    if (h === "++")
      this.tokens.replaceToken(`(${n} = ${d} = ${n} + 1, ${n} - 1)`);
    else if (h === "--")
      this.tokens.replaceToken(`(${n} = ${d} = ${n} - 1, ${n} + 1)`);
    else
      throw new Error(`Unexpected operator: ${h}`);
    return this.tokens.removeToken(), !0;
  }
  processExportDefault() {
    let e = !0;
    if (this.tokens.matches4(j._export, j._default, j._function, j.name) || // export default async function
    this.tokens.matches5(j._export, j._default, j.name, j._function, j.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      $e._async
    )) {
      this.tokens.removeInitialToken(), this.tokens.removeToken();
      const r = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${r};`);
    } else if (this.tokens.matches4(j._export, j._default, j._class, j.name) || this.tokens.matches5(j._export, j._default, j._abstract, j._class, j.name) || this.tokens.matches3(j._export, j._default, j.at)) {
      this.tokens.removeInitialToken(), this.tokens.removeToken(), this.copyDecorators(), this.tokens.matches1(j._abstract) && this.tokens.removeToken();
      const r = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${r};`);
    } else if (tI(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    ))
      e = !1, this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken();
    else if (this.reactHotLoaderTransformer) {
      const r = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${r}; exports.`), this.tokens.copyToken(), this.tokens.appendCode(` = ${r} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(r);
    } else
      this.tokens.replaceToken("exports."), this.tokens.copyToken(), this.tokens.appendCode(" =");
    e && (this.hadDefaultExport = !0);
  }
  copyDecorators() {
    for (; this.tokens.matches1(j.at); )
      if (this.tokens.copyToken(), this.tokens.matches1(j.parenL))
        this.tokens.copyExpectedToken(j.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.parenR);
      else {
        for (this.tokens.copyExpectedToken(j.name); this.tokens.matches1(j.dot); )
          this.tokens.copyExpectedToken(j.dot), this.tokens.copyExpectedToken(j.name);
        this.tokens.matches1(j.parenL) && (this.tokens.copyExpectedToken(j.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.parenR));
      }
  }
  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
  processExportVar() {
    this.isSimpleExportVar() ? this.processSimpleExportVar() : this.processComplexExportVar();
  }
  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
  isSimpleExportVar() {
    let e = this.tokens.currentIndex();
    if (e++, e++, !this.tokens.matches1AtIndex(e, j.name))
      return !1;
    for (e++; e < this.tokens.tokens.length && this.tokens.tokens[e].isType; )
      e++;
    return !!this.tokens.matches1AtIndex(e, j.eq);
  }
  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
  processSimpleExportVar() {
    this.tokens.removeInitialToken(), this.tokens.copyToken();
    const e = this.tokens.identifierName();
    for (; !this.tokens.matches1(j.eq); )
      this.rootTransformer.processToken();
    const r = this.tokens.currentToken().rhsEndIndex;
    if (r == null)
      throw new Error("Expected = token with an end index.");
    for (; this.tokens.currentIndex() < r; )
      this.rootTransformer.processToken();
    this.tokens.appendCode(`; exports.${e} = ${e}`);
  }
  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
  processComplexExportVar() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const e = this.tokens.matches1(j.braceL);
    e && this.tokens.appendCode("(");
    let r = 0;
    for (; ; )
      if (this.tokens.matches1(j.braceL) || this.tokens.matches1(j.dollarBraceL) || this.tokens.matches1(j.bracketL))
        r++, this.tokens.copyToken();
      else if (this.tokens.matches1(j.braceR) || this.tokens.matches1(j.bracketR))
        r--, this.tokens.copyToken();
      else {
        if (r === 0 && !this.tokens.matches1(j.name) && !this.tokens.currentToken().isType)
          break;
        if (this.tokens.matches1(j.eq)) {
          const a = this.tokens.currentToken().rhsEndIndex;
          if (a == null)
            throw new Error("Expected = token with an end index.");
          for (; this.tokens.currentIndex() < a; )
            this.rootTransformer.processToken();
        } else {
          const a = this.tokens.currentToken();
          if (K4(a)) {
            const l = this.tokens.identifierName();
            let d = this.importProcessor.getIdentifierReplacement(l);
            if (d === null)
              throw new Error(`Expected a replacement for ${l} in \`export var\` syntax.`);
            sY(a) && (d = `${l}: ${d}`), this.tokens.replaceToken(d);
          } else
            this.rootTransformer.processToken();
        }
      }
    if (e) {
      const a = this.tokens.currentToken().rhsEndIndex;
      if (a == null)
        throw new Error("Expected = token with an end index.");
      for (; this.tokens.currentIndex() < a; )
        this.rootTransformer.processToken();
      this.tokens.appendCode(")");
    }
  }
  /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */
  processExportFunction() {
    this.tokens.replaceToken("");
    const e = this.processNamedFunction();
    this.tokens.appendCode(` exports.${e} = ${e};`);
  }
  /**
   * Skip past a function with a name and return that name.
   */
  processNamedFunction() {
    if (this.tokens.matches1(j._function))
      this.tokens.copyToken();
    else if (this.tokens.matches2(j.name, j._function)) {
      if (!this.tokens.matchesContextual($e._async))
        throw new Error("Expected async keyword in function export.");
      this.tokens.copyToken(), this.tokens.copyToken();
    }
    if (this.tokens.matches1(j.star) && this.tokens.copyToken(), !this.tokens.matches1(j.name))
      throw new Error("Expected identifier for exported function name.");
    const e = this.tokens.identifierName();
    if (this.tokens.copyToken(), this.tokens.currentToken().isType)
      for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; )
        this.tokens.removeToken();
    return this.tokens.copyExpectedToken(j.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.parenR), this.rootTransformer.processPossibleTypeRange(), this.tokens.copyExpectedToken(j.braceL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.braceR), e;
  }
  /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */
  processExportClass() {
    this.tokens.removeInitialToken(), this.copyDecorators(), this.tokens.matches1(j._abstract) && this.tokens.removeToken();
    const e = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${e} = ${e};`);
  }
  /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */
  processExportBindings() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const e = eI(this.tokens), r = [];
    for (; ; ) {
      if (this.tokens.matches1(j.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const a = Mu(this.tokens);
      for (; this.tokens.currentIndex() < a.endIndex; )
        this.tokens.removeToken();
      if (!(a.isType || !e && this.shouldElideExportedIdentifier(a.leftName))) {
        const d = a.rightName;
        d === "default" ? this.hadDefaultExport = !0 : this.hadNamedExport = !0;
        const h = a.leftName, n = this.importProcessor.getIdentifierReplacement(h);
        r.push(`exports.${d} = ${n || h};`);
      }
      if (this.tokens.matches1(j.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(j.comma, j.braceR)) {
        this.tokens.removeToken(), this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(j.comma))
        this.tokens.removeToken();
      else
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
    }
    if (this.tokens.matchesContextual($e._from)) {
      this.tokens.removeToken();
      const a = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(a)), Za(this.tokens);
    } else
      this.tokens.appendCode(r.join(" "));
    this.tokens.matches1(j.semi) && this.tokens.removeToken();
  }
  processExportStar() {
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(j.string); )
      this.tokens.removeToken();
    const e = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(e)), Za(this.tokens), this.tokens.matches1(j.semi) && this.tokens.removeToken();
  }
  shouldElideExportedIdentifier(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(e);
  }
}
class yZ extends fs {
  constructor(e, r, a, l, d, h, n, u) {
    super(), this.tokens = e, this.nameManager = r, this.helperManager = a, this.reactHotLoaderTransformer = l, this.isTypeScriptTransformEnabled = d, this.isFlowTransformEnabled = h, this.keepUnusedImports = n, this.nonTypeIdentifiers = d && !n ? uC(e, u) : /* @__PURE__ */ new Set(), this.declarationInfo = d && !n ? ZC(e) : QC, this.injectCreateRequireForImportRequire = !!u.injectCreateRequireForImportRequire;
  }
  process() {
    if (this.tokens.matches3(j._import, j.name, j.eq))
      return this.processImportEquals();
    if (this.tokens.matches4(j._import, j.name, j.name, j.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, $e._type)) {
      this.tokens.removeInitialToken();
      for (let e = 0; e < 7; e++)
        this.tokens.removeToken();
      return !0;
    }
    if (this.tokens.matches2(j._export, j.eq))
      return this.tokens.replaceToken("module.exports"), !0;
    if (this.tokens.matches5(j._export, j._import, j.name, j.name, j.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, $e._type)) {
      this.tokens.removeInitialToken();
      for (let e = 0; e < 8; e++)
        this.tokens.removeToken();
      return !0;
    }
    if (this.tokens.matches1(j._import))
      return this.processImport();
    if (this.tokens.matches2(j._export, j._default))
      return this.processExportDefault();
    if (this.tokens.matches2(j._export, j.braceL))
      return this.processNamedExports();
    if (this.tokens.matches2(j._export, j.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, $e._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(j.braceL)) {
        for (; !this.tokens.matches1(j.braceR); )
          this.tokens.removeToken();
        this.tokens.removeToken();
      } else
        this.tokens.removeToken(), this.tokens.matches1(j._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual($e._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, j.string) && (this.tokens.removeToken(), this.tokens.removeToken(), Za(this.tokens)), !0;
    }
    return !1;
  }
  processImportEquals() {
    const e = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.shouldAutomaticallyElideImportedName(e) ? JC(this.tokens) : this.injectCreateRequireForImportRequire ? (this.tokens.replaceToken("const"), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.replaceToken(this.helperManager.getHelperName("require"))) : this.tokens.replaceToken("const"), !0;
  }
  processImport() {
    if (this.tokens.matches2(j._import, j.parenL))
      return !1;
    const e = this.tokens.snapshot();
    if (this.removeImportTypeBindings()) {
      for (this.tokens.restoreToSnapshot(e); !this.tokens.matches1(j.string); )
        this.tokens.removeToken();
      this.tokens.removeToken(), Za(this.tokens), this.tokens.matches1(j.semi) && this.tokens.removeToken();
    }
    return !0;
  }
  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
  removeImportTypeBindings() {
    if (this.tokens.copyExpectedToken(j._import), this.tokens.matchesContextual($e._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, j.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, $e._from))
      return !0;
    if (this.tokens.matches1(j.string))
      return this.tokens.copyToken(), !1;
    this.tokens.matchesContextual($e._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, $e._from) && this.tokens.copyToken();
    let e = !1, r = !1, a = !1;
    if (this.tokens.matches1(j.name) && (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName()) ? (this.tokens.removeToken(), this.tokens.matches1(j.comma) && this.tokens.removeToken()) : (e = !0, this.tokens.copyToken(), this.tokens.matches1(j.comma) && (a = !0, this.tokens.removeToken()))), this.tokens.matches1(j.star))
      this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2)) ? (this.tokens.removeToken(), this.tokens.removeToken(), this.tokens.removeToken()) : (a && this.tokens.appendCode(","), e = !0, this.tokens.copyExpectedToken(j.star), this.tokens.copyExpectedToken(j.name), this.tokens.copyExpectedToken(j.name));
    else if (this.tokens.matches1(j.braceL)) {
      for (a && this.tokens.appendCode(","), this.tokens.copyToken(); !this.tokens.matches1(j.braceR); ) {
        r = !0;
        const l = Mu(this.tokens);
        if (l.isType || this.shouldAutomaticallyElideImportedName(l.rightName)) {
          for (; this.tokens.currentIndex() < l.endIndex; )
            this.tokens.removeToken();
          this.tokens.matches1(j.comma) && this.tokens.removeToken();
        } else {
          for (e = !0; this.tokens.currentIndex() < l.endIndex; )
            this.tokens.copyToken();
          this.tokens.matches1(j.comma) && this.tokens.copyToken();
        }
      }
      this.tokens.copyExpectedToken(j.braceR);
    }
    return this.keepUnusedImports ? !1 : this.isTypeScriptTransformEnabled ? !e : this.isFlowTransformEnabled ? r && !e : !1;
  }
  shouldAutomaticallyElideImportedName(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(e);
  }
  processExportDefault() {
    if (tI(
      this.isTypeScriptTransformEnabled,
      this.keepUnusedImports,
      this.tokens,
      this.declarationInfo
    ))
      return this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken(), !0;
    if (!(this.tokens.matches4(j._export, j._default, j._function, j.name) || // export default async function
    this.tokens.matches5(j._export, j._default, j.name, j._function, j.name) && this.tokens.matchesContextualAtIndex(
      this.tokens.currentIndex() + 2,
      $e._async
    ) || this.tokens.matches4(j._export, j._default, j._class, j.name) || this.tokens.matches5(j._export, j._default, j._abstract, j._class, j.name)) && this.reactHotLoaderTransformer) {
      const r = this.nameManager.claimFreeName("_default");
      return this.tokens.replaceToken(`let ${r}; export`), this.tokens.copyToken(), this.tokens.appendCode(` ${r} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(r), !0;
    }
    return !1;
  }
  /**
   * Handle a statement with one of these forms:
   * export {a, type b};
   * export {c, type d} from 'foo';
   *
   * In both cases, any explicit type exports should be removed. In the first
   * case, we also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled)
      return !1;
    this.tokens.copyExpectedToken(j._export), this.tokens.copyExpectedToken(j.braceL);
    const e = eI(this.tokens);
    let r = !1;
    for (; !this.tokens.matches1(j.braceR); ) {
      const a = Mu(this.tokens);
      if (a.isType || !e && this.shouldElideExportedName(a.leftName)) {
        for (; this.tokens.currentIndex() < a.endIndex; )
          this.tokens.removeToken();
        this.tokens.matches1(j.comma) && this.tokens.removeToken();
      } else {
        for (r = !0; this.tokens.currentIndex() < a.endIndex; )
          this.tokens.copyToken();
        this.tokens.matches1(j.comma) && this.tokens.copyToken();
      }
    }
    return this.tokens.copyExpectedToken(j.braceR), !this.keepUnusedImports && e && !r && (this.tokens.removeToken(), this.tokens.removeToken(), Za(this.tokens)), !0;
  }
  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
  shouldElideExportedName(e) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(e) && !this.declarationInfo.valueDeclarations.has(e);
  }
}
class bZ extends fs {
  constructor(e, r, a) {
    super(), this.rootTransformer = e, this.tokens = r, this.isImportsTransformEnabled = a;
  }
  process() {
    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange() ? !0 : this.tokens.matches1(j._enum) ? (this.processEnum(), !0) : this.tokens.matches2(j._export, j._enum) ? (this.processNamedExportEnum(), !0) : this.tokens.matches3(j._export, j._default, j._enum) ? (this.processDefaultExportEnum(), !0) : !1;
  }
  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      this.tokens.removeInitialToken();
      const e = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum(), this.tokens.appendCode(` exports.${e} = ${e};`);
    } else
      this.tokens.copyToken(), this.processEnum();
  }
  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const e = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum(), this.isImportsTransformEnabled ? this.tokens.appendCode(` exports.default = ${e};`) : this.tokens.appendCode(` export default ${e};`);
  }
  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    this.tokens.replaceToken("const"), this.tokens.copyExpectedToken(j.name);
    let e = !1;
    this.tokens.matchesContextual($e._of) && (this.tokens.removeToken(), e = this.tokens.matchesContextual($e._symbol), this.tokens.removeToken());
    const r = this.tokens.matches3(j.braceL, j.name, j.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const a = !e && !r;
    for (this.tokens.replaceTokenTrimmingLeftWhitespace(a ? ".Mirrored([" : "({"); !this.tokens.matches1(j.braceR); ) {
      if (this.tokens.matches1(j.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(e, r), this.tokens.matches1(j.comma) && this.tokens.copyToken();
    }
    this.tokens.replaceToken(a ? "]);" : "});");
  }
  /**
   * Process an individual enum element, producing either an array element or an
   * object element based on what type of enum this is.
   */
  processEnumElement(e, r) {
    if (e) {
      const a = this.tokens.identifierName();
      this.tokens.copyToken(), this.tokens.appendCode(`: Symbol("${a}")`);
    } else r ? (this.tokens.copyToken(), this.tokens.replaceTokenTrimmingLeftWhitespace(":"), this.tokens.copyToken()) : this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
  }
}
function gZ(t) {
  let e, r = t[0], a = 1;
  for (; a < t.length; ) {
    const l = t[a], d = t[a + 1];
    if (a += 2, (l === "optionalAccess" || l === "optionalCall") && r == null)
      return;
    l === "access" || l === "optionalAccess" ? (e = r, r = d(r)) : (l === "call" || l === "optionalCall") && (r = d((...h) => r.call(e, ...h)), e = void 0);
  }
  return r;
}
const uf = "jest", vZ = ["mock", "unmock", "enableAutomock", "disableAutomock"];
class Xg extends fs {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(e, r, a, l) {
    super(), this.rootTransformer = e, this.tokens = r, this.nameManager = a, this.importProcessor = l, Xg.prototype.__init.call(this);
  }
  process() {
    return this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(j.name, j.dot, j.name, j.parenL) && this.tokens.identifierName() === uf ? gZ([this, "access", (e) => e.importProcessor, "optionalAccess", (e) => e.getGlobalNames, "call", (e) => e(), "optionalAccess", (e) => e.has, "call", (e) => e(uf)]) ? !1 : this.extractHoistedCalls() : !1;
  }
  getHoistedCode() {
    return this.hoistedFunctionNames.length > 0 ? this.hoistedFunctionNames.map((e) => `${e}();`).join("") : "";
  }
  /**
   * Extracts any methods calls on the jest-object that should be hoisted.
   *
   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
   *
   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
   */
  extractHoistedCalls() {
    this.tokens.removeToken();
    let e = !1;
    for (; this.tokens.matches3(j.dot, j.name, j.parenL); ) {
      const r = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      if (vZ.includes(r)) {
        const l = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(l), this.tokens.replaceToken(`function ${l}(){${uf}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.parenR), this.tokens.appendCode(";}"), e = !1;
      } else
        e ? this.tokens.copyToken() : this.tokens.replaceToken(`${uf}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.parenR), e = !0;
    }
    return !0;
  }
}
class EZ extends fs {
  constructor(e) {
    super(), this.tokens = e;
  }
  process() {
    if (this.tokens.matches1(j.num)) {
      const e = this.tokens.currentTokenCode();
      if (e.includes("_"))
        return this.tokens.replaceToken(e.replace(/_/g, "")), !0;
    }
    return !1;
  }
}
class _Z extends fs {
  constructor(e, r) {
    super(), this.tokens = e, this.nameManager = r;
  }
  process() {
    return this.tokens.matches2(j._catch, j.braceL) ? (this.tokens.copyToken(), this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`), !0) : !1;
  }
}
class SZ extends fs {
  constructor(e, r) {
    super(), this.tokens = e, this.nameManager = r;
  }
  process() {
    if (this.tokens.matches1(j.nullishCoalescing)) {
      const a = this.tokens.currentToken();
      return this.tokens.tokens[a.nullishStartIndex].isAsyncOperation ? this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (") : this.tokens.replaceTokenTrimmingLeftWhitespace(", () => ("), !0;
    }
    if (this.tokens.matches1(j._delete) && this.tokens.tokenAtRelativeIndex(1).isOptionalChainStart)
      return this.tokens.removeInitialToken(), !0;
    const r = this.tokens.currentToken().subscriptStartIndex;
    if (r != null && this.tokens.tokens[r].isOptionalChainStart && // Super subscripts can't be optional (since super is never null/undefined), and the syntax
    // relies on the subscript being intact, so leave this token alone.
    this.tokens.tokenAtRelativeIndex(-1).type !== j._super) {
      const a = this.nameManager.claimFreeName("_");
      let l;
      if (r > 0 && this.tokens.matches1AtIndex(r - 1, j._delete) && this.isLastSubscriptInChain() ? l = `${a} => delete ${a}` : l = `${a} => ${a}`, this.tokens.tokens[r].isAsyncOperation && (l = `async ${l}`), this.tokens.matches2(j.questionDot, j.parenL) || this.tokens.matches2(j.questionDot, j.lessThan))
        this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${l}`);
      else if (this.tokens.matches2(j.questionDot, j.bracketL))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${l}`);
      else if (this.tokens.matches1(j.questionDot))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${l}.`);
      else if (this.tokens.matches1(j.dot))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${l}.`);
      else if (this.tokens.matches1(j.bracketL))
        this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${l}[`);
      else if (this.tokens.matches1(j.parenL))
        this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${l}(`);
      else
        throw new Error("Unexpected subscript operator in optional chain.");
      return !0;
    }
    return !1;
  }
  /**
   * Determine if the current token is the last of its chain, so that we know whether it's eligible
   * to have a delete op inserted.
   *
   * We can do this by walking forward until we determine one way or another. Each
   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
   * depth goes negative) and see if any other subscript token is after us in the chain.
   */
  isLastSubscriptInChain() {
    let e = 0;
    for (let r = this.tokens.currentIndex() + 1; ; r++) {
      if (r >= this.tokens.tokens.length)
        throw new Error("Reached the end of the code while finding the end of the access chain.");
      if (this.tokens.tokens[r].isOptionalChainStart ? e++ : this.tokens.tokens[r].isOptionalChainEnd && e--, e < 0)
        return !0;
      if (e === 0 && this.tokens.tokens[r].subscriptStartIndex != null)
        return !1;
    }
  }
  /**
   * Determine if we are the open-paren in an expression like super.a()?.b.
   *
   * We can do this by walking backward to find the previous subscript. If that subscript was
   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
   * we'll need to attach the right context.
   */
  justSkippedSuper() {
    let e = 0, r = this.tokens.currentIndex() - 1;
    for (; ; ) {
      if (r < 0)
        throw new Error(
          "Reached the start of the code while finding the start of the access chain."
        );
      if (this.tokens.tokens[r].isOptionalChainStart ? e-- : this.tokens.tokens[r].isOptionalChainEnd && e++, e < 0)
        return !1;
      if (e === 0 && this.tokens.tokens[r].subscriptStartIndex != null)
        return this.tokens.tokens[r - 1].type === j._super;
      r--;
    }
  }
}
class wZ extends fs {
  constructor(e, r, a, l) {
    super(), this.rootTransformer = e, this.tokens = r, this.importProcessor = a, this.options = l;
  }
  process() {
    const e = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const r = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      return r ? this.tokens.replaceToken(`(0, ${r})`) : this.tokens.copyToken(), this.tryProcessCreateClassCall(e), !0;
    }
    if (this.tokens.matches3(j.name, j.dot, j.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const r = this.importProcessor && this.importProcessor.getIdentifierReplacement("React") || "React";
      return r ? (this.tokens.replaceToken(r), this.tokens.copyToken(), this.tokens.copyToken()) : (this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.copyToken()), this.tryProcessCreateClassCall(e), !0;
    }
    return !1;
  }
  /**
   * This is called with the token position at the open-paren.
   */
  tryProcessCreateClassCall(e) {
    const r = this.findDisplayName(e);
    r && this.classNeedsDisplayName() && (this.tokens.copyExpectedToken(j.parenL), this.tokens.copyExpectedToken(j.braceL), this.tokens.appendCode(`displayName: '${r}',`), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(j.braceR), this.tokens.copyExpectedToken(j.parenR));
  }
  findDisplayName(e) {
    return e < 2 ? null : this.tokens.matches2AtIndex(e - 2, j.name, j.eq) ? this.tokens.identifierNameAtIndex(e - 2) : e >= 2 && this.tokens.tokens[e - 2].identifierRole === Ut.ObjectKey ? this.tokens.identifierNameAtIndex(e - 2) : this.tokens.matches2AtIndex(e - 2, j._export, j._default) ? this.getDisplayNameFromFilename() : null;
  }
  getDisplayNameFromFilename() {
    const r = (this.options.filePath || "unknown").split("/"), a = r[r.length - 1], l = a.lastIndexOf("."), d = l === -1 ? a : a.slice(0, l);
    return d === "index" && r[r.length - 2] ? r[r.length - 2] : d;
  }
  /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */
  classNeedsDisplayName() {
    let e = this.tokens.currentIndex();
    if (!this.tokens.matches2(j.parenL, j.braceL))
      return !1;
    const r = e + 1, a = this.tokens.tokens[r].contextId;
    if (a == null)
      throw new Error("Expected non-null context ID on object open-brace.");
    for (; e < this.tokens.tokens.length; e++) {
      const l = this.tokens.tokens[e];
      if (l.type === j.braceR && l.contextId === a) {
        e++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(e) === "displayName" && this.tokens.tokens[e].identifierRole === Ut.ObjectKey && l.contextId === a)
        return !1;
    }
    if (e === this.tokens.tokens.length)
      throw new Error("Unexpected end of input when processing React class.");
    return this.tokens.matches1AtIndex(e, j.parenR) || this.tokens.matches2AtIndex(e, j.comma, j.parenR);
  }
}
class Jg extends fs {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(e, r) {
    super(), this.tokens = e, this.filePath = r, Jg.prototype.__init.call(this);
  }
  setExtractedDefaultExportName(e) {
    this.extractedDefaultExportName = e;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const e = /* @__PURE__ */ new Set();
    for (const a of this.tokens.tokens)
      !a.isType && Y4(a) && a.identifierRole !== Ut.ImportDeclaration && e.add(this.tokens.identifierNameForToken(a));
    const r = Array.from(e).map((a) => ({
      variableName: a,
      uniqueLocalName: a
    }));
    return this.extractedDefaultExportName && r.push({
      variableName: this.extractedDefaultExportName,
      uniqueLocalName: "default"
    }), `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${r.map(
      ({ variableName: a, uniqueLocalName: l }) => `  reactHotLoader.register(${a}, "${l}", ${JSON.stringify(
        this.filePath || ""
      )});`
    ).join(`
`)}
  leaveModule(module);
})();`;
  }
  process() {
    return !1;
  }
}
const xZ = /* @__PURE__ */ new Set([
  // Reserved keywords as of ECMAScript 2015
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  // Future reserved keywords
  "enum",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "await",
  // Literals that cannot be used as identifiers
  "false",
  "null",
  "true"
]);
function $w(t) {
  if (t.length === 0 || !vc[t.charCodeAt(0)])
    return !1;
  for (let e = 1; e < t.length; e++)
    if (!ss[t.charCodeAt(e)])
      return !1;
  return !xZ.has(t);
}
class TZ extends fs {
  constructor(e, r, a) {
    super(), this.rootTransformer = e, this.tokens = r, this.isImportsTransformEnabled = a;
  }
  process() {
    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange() ? !0 : this.tokens.matches1(j._public) || this.tokens.matches1(j._protected) || this.tokens.matches1(j._private) || this.tokens.matches1(j._abstract) || this.tokens.matches1(j._readonly) || this.tokens.matches1(j._override) || this.tokens.matches1(j.nonNullAssertion) ? (this.tokens.removeInitialToken(), !0) : this.tokens.matches1(j._enum) || this.tokens.matches2(j._const, j._enum) ? (this.processEnum(), !0) : this.tokens.matches2(j._export, j._enum) || this.tokens.matches3(j._export, j._const, j._enum) ? (this.processEnum(!0), !0) : !1;
  }
  processEnum(e = !1) {
    for (this.tokens.removeInitialToken(); this.tokens.matches1(j._const) || this.tokens.matches1(j._enum); )
      this.tokens.removeToken();
    const r = this.tokens.identifierName();
    this.tokens.removeToken(), e && !this.isImportsTransformEnabled && this.tokens.appendCode("export "), this.tokens.appendCode(`var ${r}; (function (${r})`), this.tokens.copyExpectedToken(j.braceL), this.processEnumBody(r), this.tokens.copyExpectedToken(j.braceR), e && this.isImportsTransformEnabled ? this.tokens.appendCode(`)(${r} || (exports.${r} = ${r} = {}));`) : this.tokens.appendCode(`)(${r} || (${r} = {}));`);
  }
  /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */
  processEnumBody(e) {
    let r = null;
    for (; !this.tokens.matches1(j.braceR); ) {
      const { nameStringCode: a, variableName: l } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken(), this.tokens.matches3(j.eq, j.string, j.comma) || this.tokens.matches3(j.eq, j.string, j.braceR) ? this.processStringLiteralEnumMember(e, a, l) : this.tokens.matches1(j.eq) ? this.processExplicitValueEnumMember(e, a, l) : this.processImplicitValueEnumMember(
        e,
        a,
        l,
        r
      ), this.tokens.matches1(j.comma) && this.tokens.removeToken(), l != null ? r = l : r = `${e}[${a}]`;
    }
  }
  /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */
  extractEnumKeyInfo(e) {
    if (e.type === j.name) {
      const r = this.tokens.identifierNameForToken(e);
      return {
        nameStringCode: `"${r}"`,
        variableName: $w(r) ? r : null
      };
    } else if (e.type === j.string) {
      const r = this.tokens.stringValueForToken(e);
      return {
        nameStringCode: this.tokens.code.slice(e.start, e.end),
        variableName: $w(r) ? r : null
      };
    } else
      throw new Error("Expected name or string at beginning of enum element.");
  }
  /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */
  processStringLiteralEnumMember(e, r, a) {
    a != null ? (this.tokens.appendCode(`const ${a}`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(`; ${e}[${r}] = ${a};`)) : (this.tokens.appendCode(`${e}[${r}]`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(";"));
  }
  /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
   * auto-incrementing.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = 1 + 1
   * ->
   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
   *
   * Example 2:
   * "some key" = 1 + 1
   * ->
   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
   */
  processExplicitValueEnumMember(e, r, a) {
    const l = this.tokens.currentToken().rhsEndIndex;
    if (l == null)
      throw new Error("Expected rhsEndIndex on enum assign.");
    if (a != null) {
      for (this.tokens.appendCode(`const ${a}`), this.tokens.copyToken(); this.tokens.currentIndex() < l; )
        this.rootTransformer.processToken();
      this.tokens.appendCode(
        `; ${e}[${e}[${r}] = ${a}] = ${r};`
      );
    } else {
      for (this.tokens.appendCode(`${e}[${e}[${r}]`), this.tokens.copyToken(); this.tokens.currentIndex() < l; )
        this.rootTransformer.processToken();
      this.tokens.appendCode(`] = ${r};`);
    }
  }
  /**
   * Handle an enum member with no right-hand side expression. In this case, the value is the
   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
   * reverse mapping.
   *
   * Example 1:
   * someKey2
   * ->
   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
   *
   * Example 2:
   * "some key 2"
   * ->
   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
   */
  processImplicitValueEnumMember(e, r, a, l) {
    let d = l != null ? `${l} + 1` : "0";
    a != null && (this.tokens.appendCode(`const ${a} = ${d}; `), d = a), this.tokens.appendCode(
      `${e}[${e}[${r}] = ${d}] = ${r};`
    );
  }
}
class md {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(e, r, a, l) {
    md.prototype.__init.call(this), md.prototype.__init2.call(this), this.nameManager = e.nameManager, this.helperManager = e.helperManager;
    const { tokenProcessor: d, importProcessor: h } = e;
    this.tokens = d, this.isImportsTransformEnabled = r.includes("imports"), this.isReactHotLoaderTransformEnabled = r.includes("react-hot-loader"), this.disableESTransforms = !!l.disableESTransforms, l.disableESTransforms || (this.transformers.push(
      new SZ(d, this.nameManager)
    ), this.transformers.push(new EZ(d)), this.transformers.push(new _Z(d, this.nameManager))), r.includes("jsx") && (l.jsxRuntime !== "preserve" && this.transformers.push(
      new Ka(this, d, h, this.nameManager, l)
    ), this.transformers.push(
      new wZ(this, d, h, l)
    ));
    let n = null;
    if (r.includes("react-hot-loader")) {
      if (!l.filePath)
        throw new Error("filePath is required when using the react-hot-loader transform.");
      n = new Jg(d, l.filePath), this.transformers.push(n);
    }
    if (r.includes("imports")) {
      if (h === null)
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      this.transformers.push(
        new _u(
          this,
          d,
          h,
          this.nameManager,
          this.helperManager,
          n,
          a,
          !!l.enableLegacyTypeScriptModuleInterop,
          r.includes("typescript"),
          r.includes("flow"),
          !!l.preserveDynamicImport,
          !!l.keepUnusedImports
        )
      );
    } else
      this.transformers.push(
        new yZ(
          d,
          this.nameManager,
          this.helperManager,
          n,
          r.includes("typescript"),
          r.includes("flow"),
          !!l.keepUnusedImports,
          l
        )
      );
    r.includes("flow") && this.transformers.push(
      new bZ(this, d, r.includes("imports"))
    ), r.includes("typescript") && this.transformers.push(
      new TZ(this, d, r.includes("imports"))
    ), r.includes("jest") && this.transformers.push(
      new Xg(this, d, this.nameManager, h)
    );
  }
  transform() {
    this.tokens.reset(), this.processBalancedCode();
    let r = this.isImportsTransformEnabled ? '"use strict";' : "";
    for (const h of this.transformers)
      r += h.getPrefixCode();
    r += this.helperManager.emitHelpers(), r += this.generatedVariables.map((h) => ` var ${h};`).join("");
    for (const h of this.transformers)
      r += h.getHoistedCode();
    let a = "";
    for (const h of this.transformers)
      a += h.getSuffixCode();
    const l = this.tokens.finish();
    let { code: d } = l;
    if (d.startsWith("#!")) {
      let h = d.indexOf(`
`);
      return h === -1 && (h = d.length, d += `
`), {
        code: d.slice(0, h + 1) + r + d.slice(h + 1) + a,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(l.mappings, r.length)
      };
    } else
      return {
        code: r + d + a,
        mappings: this.shiftMappings(l.mappings, r.length)
      };
  }
  processBalancedCode() {
    let e = 0, r = 0;
    for (; !this.tokens.isAtEnd(); ) {
      if (this.tokens.matches1(j.braceL) || this.tokens.matches1(j.dollarBraceL))
        e++;
      else if (this.tokens.matches1(j.braceR)) {
        if (e === 0)
          return;
        e--;
      }
      if (this.tokens.matches1(j.parenL))
        r++;
      else if (this.tokens.matches1(j.parenR)) {
        if (r === 0)
          return;
        r--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(j._class)) {
      this.processClass();
      return;
    }
    for (const e of this.transformers)
      if (e.process())
        return;
    this.tokens.copyToken();
  }
  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(j._class, j.name))
      throw new Error("Expected identifier for exported class name.");
    const e = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.processClass(), e;
  }
  processClass() {
    const e = pZ(this, this.tokens, this.nameManager, this.disableESTransforms), r = (e.headerInfo.isExpression || !e.headerInfo.className) && e.staticInitializerNames.length + e.instanceInitializerNames.length > 0;
    let a = e.headerInfo.className;
    r && (a = this.nameManager.claimFreeName("_class"), this.generatedVariables.push(a), this.tokens.appendCode(` (${a} =`));
    const d = this.tokens.currentToken().contextId;
    if (d == null)
      throw new Error("Expected class to have a context ID.");
    for (this.tokens.copyExpectedToken(j._class); !this.tokens.matchesContextIdAndLabel(j.braceL, d); )
      this.processToken();
    this.processClassBody(e, a);
    const h = e.staticInitializerNames.map(
      (n) => `${a}.${n}()`
    );
    r ? this.tokens.appendCode(
      `, ${h.map((n) => `${n}, `).join("")}${a})`
    ) : e.staticInitializerNames.length > 0 && this.tokens.appendCode(` ${h.map((n) => `${n};`).join(" ")}`);
  }
  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(e, r) {
    const {
      headerInfo: a,
      constructorInsertPos: l,
      constructorInitializerStatements: d,
      fields: h,
      instanceInitializerNames: n,
      rangesToRemove: u
    } = e;
    let i = 0, c = 0;
    const f = this.tokens.currentToken().contextId;
    if (f == null)
      throw new Error("Expected non-null context ID on class.");
    this.tokens.copyExpectedToken(j.braceL), this.isReactHotLoaderTransformEnabled && this.tokens.appendCode(
      "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}"
    );
    const s = d.length + n.length > 0;
    if (l === null && s) {
      const o = this.makeConstructorInitCode(
        d,
        n,
        r
      );
      if (a.hasSuperclass) {
        const y = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${y}) { super(...${y}); ${o}; }`
        );
      } else
        this.tokens.appendCode(`constructor() { ${o}; }`);
    }
    for (; !this.tokens.matchesContextIdAndLabel(j.braceR, f); )
      if (i < h.length && this.tokens.currentIndex() === h[i].start) {
        let o = !1;
        for (this.tokens.matches1(j.bracketL) ? this.tokens.copyTokenWithPrefix(`${h[i].initializerName}() {this`) : this.tokens.matches1(j.string) || this.tokens.matches1(j.num) ? (this.tokens.copyTokenWithPrefix(`${h[i].initializerName}() {this[`), o = !0) : this.tokens.copyTokenWithPrefix(`${h[i].initializerName}() {this.`); this.tokens.currentIndex() < h[i].end; )
          o && this.tokens.currentIndex() === h[i].equalsIndex && this.tokens.appendCode("]"), this.processToken();
        this.tokens.appendCode("}"), i++;
      } else if (c < u.length && this.tokens.currentIndex() >= u[c].start) {
        for (this.tokens.currentIndex() < u[c].end && this.tokens.removeInitialToken(); this.tokens.currentIndex() < u[c].end; )
          this.tokens.removeToken();
        c++;
      } else this.tokens.currentIndex() === l ? (this.tokens.copyToken(), s && this.tokens.appendCode(
        `;${this.makeConstructorInitCode(
          d,
          n,
          r
        )};`
      ), this.processToken()) : this.processToken();
    this.tokens.copyExpectedToken(j.braceR);
  }
  makeConstructorInitCode(e, r, a) {
    return [
      ...e,
      ...r.map((l) => `${a}.prototype.${l}.call(this)`)
    ].join(";");
  }
  /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(j.parenR, j.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let e = this.tokens.currentIndex() + 1;
      for (; this.tokens.tokens[e].isType; )
        e++;
      if (this.tokens.matches1AtIndex(e, j.arrow)) {
        for (this.tokens.removeInitialToken(); this.tokens.currentIndex() < e; )
          this.tokens.removeToken();
        return this.tokens.replaceTokenTrimmingLeftWhitespace(") =>"), !0;
      }
    }
    return !1;
  }
  /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual($e._async) && !this.tokens.matches1(j._async))
      return !1;
    const e = this.tokens.tokenAtRelativeIndex(1);
    if (e.type !== j.lessThan || !e.isType)
      return !1;
    let r = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[r].isType; )
      r++;
    if (this.tokens.matches1AtIndex(r, j.parenL)) {
      for (this.tokens.replaceToken("async ("), this.tokens.removeInitialToken(); this.tokens.currentIndex() < r; )
        this.tokens.removeToken();
      return this.tokens.removeToken(), this.processBalancedCode(), this.processToken(), !0;
    }
    return !1;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; )
        this.tokens.removeToken();
      return !0;
    }
    return !1;
  }
  shiftMappings(e, r) {
    for (let a = 0; a < e.length; a++) {
      const l = e[a];
      l !== void 0 && (e[a] = l + r);
    }
    return e;
  }
}
var rI = {};
(function(t) {
  t.__esModule = !0, t.LinesAndColumns = void 0;
  var e = `
`, r = "\r", a = (
    /** @class */
    function() {
      function l(d) {
        this.string = d;
        for (var h = [0], n = 0; n < d.length; )
          switch (d[n]) {
            case e:
              n += e.length, h.push(n);
              break;
            case r:
              n += r.length, d[n] === e && (n += e.length), h.push(n);
              break;
            default:
              n++;
              break;
          }
        this.offsets = h;
      }
      return l.prototype.locationForIndex = function(d) {
        if (d < 0 || d > this.string.length)
          return null;
        for (var h = 0, n = this.offsets; n[h + 1] <= d; )
          h++;
        var u = d - n[h];
        return { line: h, column: u };
      }, l.prototype.indexForLocation = function(d) {
        var h = d.line, n = d.column;
        return h < 0 || h >= this.offsets.length || n < 0 || n > this.lengthOfLine(h) ? null : this.offsets[h] + n;
      }, l.prototype.lengthOfLine = function(d) {
        var h = this.offsets[d], n = d === this.offsets.length - 1 ? this.string.length : this.offsets[d + 1];
        return n - h;
      }, l;
    }()
  );
  t.LinesAndColumns = a, t.default = a;
})(rI);
const AZ = /* @__PURE__ */ gd(rI);
function PZ(t, e) {
  if (e.length === 0)
    return "";
  const r = Object.keys(e[0]).filter(
    (s) => s !== "type" && s !== "value" && s !== "start" && s !== "end" && s !== "loc"
  ), a = Object.keys(e[0].type).filter((s) => s !== "label" && s !== "keyword"), l = ["Location", "Label", "Raw", ...r, ...a], d = new AZ(t), h = [l, ...e.map(u)], n = l.map(() => 0);
  for (const s of h)
    for (let o = 0; o < s.length; o++)
      n[o] = Math.max(n[o], s[o].length);
  return h.map((s) => s.map((o, y) => o.padEnd(n[y])).join(" ")).join(`
`);
  function u(s) {
    const o = t.slice(s.start, s.end);
    return [
      c(s.start, s.end),
      W4(s.type),
      CZ(String(o), 14),
      // @ts-ignore: Intentional dynamic access by key.
      ...r.map((y) => i(s[y], y)),
      // @ts-ignore: Intentional dynamic access by key.
      ...a.map((y) => i(s.type[y], y))
    ];
  }
  function i(s, o) {
    return s === !0 ? o : s === !1 || s === null ? "" : String(s);
  }
  function c(s, o) {
    return `${f(s)}-${f(o)}`;
  }
  function f(s) {
    const o = d.locationForIndex(s);
    return o ? `${o.line + 1}:${o.column + 1}` : "Unknown";
  }
}
function CZ(t, e) {
  return t.length > e ? `${t.slice(0, e - 3)}...` : t;
}
function IZ(t) {
  const e = /* @__PURE__ */ new Set();
  for (let r = 0; r < t.tokens.length; r++)
    t.matches1AtIndex(r, j._import) && !t.matches3AtIndex(r, j._import, j.name, j.eq) && OZ(t, r, e);
  return e;
}
function OZ(t, e, r) {
  e++, !t.matches1AtIndex(e, j.parenL) && (t.matches1AtIndex(e, j.name) && (r.add(t.identifierNameAtIndex(e)), e++, t.matches1AtIndex(e, j.comma) && e++), t.matches1AtIndex(e, j.star) && (e += 2, r.add(t.identifierNameAtIndex(e)), e++), t.matches1AtIndex(e, j.braceL) && (e++, kZ(t, e, r)));
}
function kZ(t, e, r) {
  for (; ; ) {
    if (t.matches1AtIndex(e, j.braceR))
      return;
    const a = Mu(t, e);
    if (e = a.endIndex, a.isType || r.add(a.rightName), t.matches2AtIndex(e, j.comma, j.braceR))
      return;
    if (t.matches1AtIndex(e, j.braceR))
      return;
    if (t.matches1AtIndex(e, j.comma))
      e++;
    else
      throw new Error(`Unexpected token: ${JSON.stringify(t.tokens[e])}`);
  }
}
function DZ() {
  return "3.35.0";
}
function NZ(t, e) {
  GY(e);
  try {
    const r = nI(t, e), l = new md(
      r,
      e.transforms,
      !!e.enableLegacyBabel5ModuleInterop,
      e
    ).transform();
    let d = { code: l.code };
    if (e.sourceMapOptions) {
      if (!e.filePath)
        throw new Error("filePath must be specified when generating a source map.");
      d = {
        ...d,
        sourceMap: DY(
          l,
          e.filePath,
          e.sourceMapOptions,
          t,
          r.tokenProcessor.tokens
        )
      };
    }
    return d;
  } catch (r) {
    throw e.filePath && (r.message = `Error transforming ${e.filePath}: ${r.message}`), r;
  }
}
function RZ(t, e) {
  const r = nI(t, e).tokenProcessor.tokens;
  return PZ(t, r);
}
function nI(t, e) {
  const r = e.transforms.includes("jsx"), a = e.transforms.includes("typescript"), l = e.transforms.includes("flow"), d = e.disableESTransforms === !0, h = fZ(t, r, a, l), n = h.tokens, u = h.scopes, i = new Ag(t, n), c = new od(i), f = new Eu(
    t,
    n,
    l,
    d,
    c
  ), s = !!e.enableLegacyTypeScriptModuleInterop;
  let o = null;
  return e.transforms.includes("imports") ? (o = new Ya(
    i,
    f,
    s,
    e,
    e.transforms.includes("typescript"),
    !!e.keepUnusedImports,
    c
  ), o.preprocessTokens(), Aw(f, u, o.getGlobalNames()), e.transforms.includes("typescript") && !e.keepUnusedImports && o.pruneTypeOnlyImports()) : e.transforms.includes("typescript") && !e.keepUnusedImports && Aw(f, u, IZ(f)), { tokenProcessor: f, scopes: u, nameManager: i, importProcessor: o, helperManager: c };
}
const MZ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getFormattedTokens: RZ,
  getVersion: DZ,
  transform: NZ
}, Symbol.toStringTag, { value: "Module" })), LZ = /* @__PURE__ */ vd(MZ);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "loadConfig", {
    enumerable: !0,
    get: function() {
      return h;
    }
  });
  const e = /* @__PURE__ */ a(KK), r = LZ;
  function a(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  let l = null;
  function d() {
    return l ?? (l = (0, e.default)(__filename, {
      interopDefault: !0,
      transform: (n) => (0, r.transform)(n.source, {
        transforms: [
          "typescript",
          "imports"
        ]
      })
    }));
  }
  function h(n) {
    let u = function() {
      try {
        return n ? au(n) : {};
      } catch {
        return d()(n);
      }
    }();
    var i;
    return (i = u.default) !== null && i !== void 0 ? i : u;
  }
})(U4);
var iI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return i;
    }
  });
  const e = /* @__PURE__ */ a(oi), r = /* @__PURE__ */ a(Qr);
  function a(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  let l = [
    ".js",
    ".cjs",
    ".mjs"
  ], d = [
    "",
    ".js",
    ".cjs",
    ".mjs",
    ".ts",
    ".cts",
    ".mts",
    ".jsx",
    ".tsx"
  ], h = [
    "",
    ".ts",
    ".cts",
    ".mts",
    ".tsx",
    ".js",
    ".cjs",
    ".mjs",
    ".jsx"
  ];
  function n(c, f) {
    for (let s of f) {
      let o = `${c}${s}`;
      if (e.default.existsSync(o) && e.default.statSync(o).isFile())
        return o;
    }
    for (let s of f) {
      let o = `${c}/index${s}`;
      if (e.default.existsSync(o))
        return o;
    }
    return null;
  }
  function* u(c, f, s, o = r.default.extname(c)) {
    let y = n(r.default.resolve(f, c), l.includes(o) ? d : h);
    if (y === null || s.has(y)) return;
    s.add(y), yield y, f = r.default.dirname(y), o = r.default.extname(y);
    let m = e.default.readFileSync(y, "utf-8");
    for (let g of [
      ...m.matchAll(/import[\s\S]*?['"](.{3,}?)['"]/gi),
      ...m.matchAll(/import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi),
      ...m.matchAll(/require\(['"`](.+)['"`]\)/gi)
    ])
      g[1].startsWith(".") && (yield* u(g[1], f, s, o));
  }
  function i(c) {
    return c === null ? /* @__PURE__ */ new Set() : new Set(u(c, r.default.dirname(c), /* @__PURE__ */ new Set()));
  }
})(iI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(
    t,
    // DISABLE_TOUCH = TRUE
    // Retrieve an existing context from cache if possible (since contexts are unique per
    // source path), or set up a new one (including setting up watchers and registering
    // plugins) then return it
    "default",
    {
      enumerable: !0,
      get: function() {
        return b;
      }
    }
  );
  const e = /* @__PURE__ */ s(oi), r = /* @__PURE__ */ s(Xx), a = /* @__PURE__ */ s(Jx), l = /* @__PURE__ */ s(Zx), d = /* @__PURE__ */ s(fT), h = zb(), n = /* @__PURE__ */ s(G3), u = z3, i = K3, c = U4, f = /* @__PURE__ */ s(iI);
  function s(v) {
    return v && v.__esModule ? v : {
      default: v
    };
  }
  let o = new r.default({
    maxSize: 100
  }), y = /* @__PURE__ */ new WeakMap();
  function m(v, T) {
    if (y.has(v))
      return y.get(v);
    let E = (0, i.parseCandidateFiles)(v, T);
    return y.set(v, E).get(v);
  }
  function g(v) {
    let T = (0, d.default)(v);
    if (T !== null) {
      let [O, D, $, I] = o.get(T) || [], k = (0, f.default)(T), L = !1, M = /* @__PURE__ */ new Map();
      for (let S of k) {
        let C = e.default.statSync(S).mtimeMs;
        M.set(S, C), (!I || !I.has(S) || C > I.get(S)) && (L = !0);
      }
      if (!L)
        return [
          O,
          T,
          D,
          $
        ];
      for (let S of k)
        delete require.cache[S];
      let x = (0, u.validateConfig)((0, l.default)((0, c.loadConfig)(T))), _ = (0, a.default)(x);
      return o.set(T, [
        x,
        _,
        k,
        M
      ]), [
        x,
        T,
        _,
        k
      ];
    }
    let E = (0, l.default)(v.config === void 0 ? v : v.config);
    return E = (0, u.validateConfig)(E), [
      E,
      null,
      (0, a.default)(E),
      []
    ];
  }
  function b(v) {
    return ({ tailwindDirectives: T, registerDependency: E }) => (O, D) => {
      let [$, I, k, L] = g(v), M = new Set(L);
      if (T.size > 0) {
        M.add(D.opts.from);
        for (let R of D.messages)
          R.type === "dependency" && M.add(R.file);
      }
      let [x, , _] = (0, h.getContext)(O, D, $, I, k, M), S = (0, h.getFileModifiedMap)(x), C = m(x, $);
      if (T.size > 0) {
        for (let z of C)
          for (let U of (0, n.default)(z))
            E(U);
        let [R, H] = (0, i.resolvedChangedContent)(x, C, S);
        for (let z of R)
          x.changedContent.push(z);
        for (let [z, U] of H.entries())
          _.set(z, U);
      }
      for (let R of L)
        E({
          type: "dependency",
          file: R
        });
      for (let [R, H] of _.entries())
        S.set(R, H);
      return x;
    };
  }
})(P2);
var sI = {}, aI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  const e = /* @__PURE__ */ r(as);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function a(l) {
    let d = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set();
    if (l.walkAtRules((u) => {
      u.name === "apply" && n.add(u), u.name === "import" && (u.params === '"tailwindcss/base"' || u.params === "'tailwindcss/base'" ? (u.name = "tailwind", u.params = "base") : u.params === '"tailwindcss/components"' || u.params === "'tailwindcss/components'" ? (u.name = "tailwind", u.params = "components") : u.params === '"tailwindcss/utilities"' || u.params === "'tailwindcss/utilities'" ? (u.name = "tailwind", u.params = "utilities") : (u.params === '"tailwindcss/screens"' || u.params === "'tailwindcss/screens'" || u.params === '"tailwindcss/variants"' || u.params === "'tailwindcss/variants'") && (u.name = "tailwind", u.params = "variants")), u.name === "tailwind" && (u.params === "screens" && (u.params = "variants"), d.add(u.params)), [
        "layer",
        "responsive",
        "variants"
      ].includes(u.name) && ([
        "responsive",
        "variants"
      ].includes(u.name) && e.default.warn(`${u.name}-at-rule-deprecated`, [
        `The \`@${u.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
        "Use `@layer utilities` or `@layer components` instead.",
        "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
      ]), h.add(u));
    }), !d.has("base") || !d.has("components") || !d.has("utilities")) {
      for (let u of h)
        if (u.name === "layer" && [
          "base",
          "components",
          "utilities"
        ].includes(u.params)) {
          if (!d.has(u.params))
            throw u.error(`\`@layer ${u.params}\` is used but no matching \`@tailwind ${u.params}\` directive is present.`);
        } else if (u.name === "responsive") {
          if (!d.has("utilities"))
            throw u.error("`@responsive` is used but `@tailwind utilities` is missing.");
        } else if (u.name === "variants" && !d.has("utilities"))
          throw u.error("`@variants` is used but `@tailwind utilities` is missing.");
    }
    return {
      tailwindDirectives: d,
      applyDirectives: n
    };
  }
})(aI);
var oI = {}, lI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, a = void 0, l = void 0) {
    return r.map((d) => {
      var h;
      let n = d.clone(), u = ((h = d.raws.tailwind) === null || h === void 0 ? void 0 : h.preserveSource) !== !0 || !n.source;
      return a !== void 0 && u && (n.source = a, "walk" in n && n.walk((i) => {
        i.source = a;
      })), l !== void 0 && (n.raws.tailwind = {
        ...n.raws.tailwind,
        ...l
      }), n;
    });
  }
})(lI);
var uI = {}, cI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(s, o) {
    for (var y in o) Object.defineProperty(s, y, {
      enumerable: !0,
      get: o[y]
    });
  }
  e(t, {
    pattern: function() {
      return d;
    },
    withoutCapturing: function() {
      return h;
    },
    any: function() {
      return n;
    },
    optional: function() {
      return u;
    },
    zeroOrMore: function() {
      return i;
    },
    nestedBrackets: function() {
      return c;
    },
    escape: function() {
      return f;
    }
  });
  const r = /[\\^$.*+?()[\]{}|]/g, a = RegExp(r.source);
  function l(s) {
    return s = Array.isArray(s) ? s : [
      s
    ], s = s.map((o) => o instanceof RegExp ? o.source : o), s.join("");
  }
  function d(s) {
    return new RegExp(l(s), "g");
  }
  function h(s) {
    return new RegExp(`(?:${l(s)})`, "g");
  }
  function n(s) {
    return `(?:${s.map(l).join("|")})`;
  }
  function u(s) {
    return `(?:${l(s)})?`;
  }
  function i(s) {
    return `(?:${l(s)})*`;
  }
  function c(s, o, y = 1) {
    return h([
      f(s),
      /[^\s]*/,
      y === 1 ? `[^${f(s)}${f(o)}s]*` : n([
        `[^${f(s)}${f(o)}s]*`,
        c(s, o, y - 1)
      ]),
      /[^\s]*/,
      f(o)
    ]);
  }
  function f(s) {
    return s && a.test(s) ? s.replace(r, "\\$&") : s || "";
  }
})(cI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "defaultExtractor", {
    enumerable: !0,
    get: function() {
      return d;
    }
  });
  const e = Vs, r = /* @__PURE__ */ l(cI);
  function a(c) {
    if (typeof WeakMap != "function") return null;
    var f = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
    return (a = function(o) {
      return o ? s : f;
    })(c);
  }
  function l(c, f) {
    if (c && c.__esModule)
      return c;
    if (c === null || typeof c != "object" && typeof c != "function")
      return {
        default: c
      };
    var s = a(f);
    if (s && s.has(c))
      return s.get(c);
    var o = {}, y = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var m in c)
      if (m !== "default" && Object.prototype.hasOwnProperty.call(c, m)) {
        var g = y ? Object.getOwnPropertyDescriptor(c, m) : null;
        g && (g.get || g.set) ? Object.defineProperty(o, m, g) : o[m] = c[m];
      }
    return o.default = c, s && s.set(c, o), o;
  }
  function d(c) {
    let f = Array.from(h(c));
    return (s) => {
      let o = [];
      for (let m of f) {
        var y;
        o = [
          ...o,
          ...(y = s.match(m)) !== null && y !== void 0 ? y : []
        ];
      }
      return o.filter((m) => m !== void 0).map(i);
    };
  }
  function* h(c) {
    let f = c.tailwindConfig.separator, s = (0, e.flagEnabled)(c.tailwindConfig, "variantGrouping"), o = c.tailwindConfig.prefix !== "" ? r.optional(r.pattern([
      /-?/,
      r.escape(c.tailwindConfig.prefix)
    ])) : "", y = r.any([
      // Arbitrary properties (without square brackets)
      /\[[^\s:'"`]+:[^\s\[\]]+\]/,
      // Arbitrary properties with balanced square brackets
      // This is a targeted fix to continue to allow theme()
      // with square brackets to work in arbitrary properties
      // while fixing a problem with the regex matching too much
      /\[[^\s:'"`]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
      // Utilities
      r.pattern([
        // Utility Name / Group Name
        /-?(?:\w+)/,
        // Normal/Arbitrary values
        r.optional(r.any([
          r.pattern([
            // Arbitrary values
            /-(?:\w+-)*\[[^\s:]+\]/,
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\><$]*)?/
          ]),
          r.pattern([
            // Arbitrary values
            /-(?:\w+-)*\[[^\s]+\]/,
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\$]*)?/
          ]),
          // Normal values w/o quotes — may include an opacity modifier
          /[-\/][^\s'"`\\$={><]*/
        ]))
      ])
    ]), m = [
      // Without quotes
      r.any([
        // This is here to provide special support for the `@` variant
        r.pattern([
          /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
          f
        ]),
        r.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
          f
        ]),
        r.pattern([
          /[^\s"'`\[\\]+/,
          f
        ])
      ]),
      // With quotes allowed
      r.any([
        r.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
          f
        ]),
        r.pattern([
          /[^\s`\[\\]+/,
          f
        ])
      ])
    ];
    for (const g of m)
      yield r.pattern([
        // Variants
        "((?=((",
        g,
        ")+))\\2)?",
        // Important (optional)
        /!?/,
        o,
        s ? r.any([
          // Or any of those things but grouped separated by commas
          r.pattern([
            /\(/,
            y,
            r.zeroOrMore([
              /,/,
              y
            ]),
            /\)/
          ]),
          // Arbitrary properties, constrained utilities, arbitrary values, etc…
          y
        ]) : y
      ]);
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  let n = /([\[\]'"`])([^\[\]'"`])?/g, u = /[^"'`\s<>\]]+/;
  function i(c) {
    if (!c.includes("-["))
      return c;
    let f = 0, s = [], o = c.matchAll(n);
    o = Array.from(o).flatMap((y) => {
      const [, ...m] = y;
      return m.map((g, b) => Object.assign([], y, {
        index: y.index + b,
        0: g
      }));
    });
    for (let y of o) {
      let m = y[0], g = s[s.length - 1];
      if (m === g ? s.pop() : (m === "'" || m === '"' || m === "`") && s.push(m), !g) {
        if (m === "[") {
          f++;
          continue;
        } else if (m === "]") {
          f--;
          continue;
        }
        if (f < 0)
          return c.substring(0, y.index - 1);
        if (f === 0 && !u.test(m))
          return c.substring(0, y.index);
      }
    }
    return c;
  }
})(uI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return T;
    }
  });
  const e = /* @__PURE__ */ u(oi), r = /* @__PURE__ */ u(Xx), a = /* @__PURE__ */ c(mo), l = Eb(), d = /* @__PURE__ */ u(as), h = /* @__PURE__ */ u(lI), n = uI;
  function u(E) {
    return E && E.__esModule ? E : {
      default: E
    };
  }
  function i(E) {
    if (typeof WeakMap != "function") return null;
    var O = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
    return (i = function($) {
      return $ ? D : O;
    })(E);
  }
  function c(E, O) {
    if (E && E.__esModule)
      return E;
    if (E === null || typeof E != "object" && typeof E != "function")
      return {
        default: E
      };
    var D = i(O);
    if (D && D.has(E))
      return D.get(E);
    var $ = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var k in E)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(E, k)) {
        var L = I ? Object.getOwnPropertyDescriptor(E, k) : null;
        L && (L.get || L.set) ? Object.defineProperty($, k, L) : $[k] = E[k];
      }
    return $.default = E, D && D.set(E, $), $;
  }
  let f = a.env;
  const s = {
    DEFAULT: n.defaultExtractor
  }, o = {
    DEFAULT: (E) => E,
    svelte: (E) => E.replace(/(?:^|\s)class:/g, " ")
  };
  function y(E, O) {
    let D = E.tailwindConfig.content.extract;
    return D[O] || D.DEFAULT || s[O] || s.DEFAULT(E);
  }
  function m(E, O) {
    let D = E.content.transform;
    return D[O] || D.DEFAULT || o[O] || o.DEFAULT;
  }
  let g = /* @__PURE__ */ new WeakMap();
  function b(E, O, D, $) {
    g.has(O) || g.set(O, new r.default({
      maxSize: 25e3
    }));
    for (let I of E.split(`
`))
      if (I = I.trim(), !$.has(I))
        if ($.add(I), g.get(O).has(I))
          for (let k of g.get(O).get(I))
            D.add(k);
        else {
          let k = O(I).filter((M) => M !== "!*"), L = new Set(k);
          for (let M of L)
            D.add(M);
          g.get(O).set(I, L);
        }
  }
  function v(E, O) {
    let D = O.offsets.sort(E), $ = {
      base: /* @__PURE__ */ new Set(),
      defaults: /* @__PURE__ */ new Set(),
      components: /* @__PURE__ */ new Set(),
      utilities: /* @__PURE__ */ new Set(),
      variants: /* @__PURE__ */ new Set()
    };
    for (let [I, k] of D)
      $[I.layer].add(k);
    return $;
  }
  function T(E) {
    return (O) => {
      let D = {
        base: null,
        components: null,
        utilities: null,
        variants: null
      };
      if (O.walkAtRules((U) => {
        U.name === "tailwind" && Object.keys(D).includes(U.params) && (D[U.params] = U);
      }), Object.values(D).every((U) => U === null))
        return O;
      var $;
      let I = /* @__PURE__ */ new Set([
        ...($ = E.candidates) !== null && $ !== void 0 ? $ : [],
        a.NOT_ON_DEMAND
      ]), k = /* @__PURE__ */ new Set();
      f.DEBUG && console.time("Reading changed files");
      for (let { file: U, content: P, extension: W } of E.changedContent) {
        let B = m(E.tailwindConfig, W), Q = y(E, W);
        P = U ? e.default.readFileSync(U, "utf8") : P, b(B(P), Q, I, k);
      }
      f.DEBUG && console.timeEnd("Reading changed files");
      let L = E.classCache.size;
      f.DEBUG && console.time("Generate rules"), f.DEBUG && console.time("Sorting candidates");
      let M = new Set([
        ...I
      ].sort((U, P) => U === P ? 0 : U < P ? -1 : 1));
      f.DEBUG && console.timeEnd("Sorting candidates"), (0, l.generateRules)(M, E), f.DEBUG && console.timeEnd("Generate rules"), f.DEBUG && console.time("Build stylesheet"), (E.stylesheetCache === null || E.classCache.size !== L) && (E.stylesheetCache = v([
        ...E.ruleCache
      ], E)), f.DEBUG && console.timeEnd("Build stylesheet");
      let { defaults: x, base: _, components: S, utilities: C, variants: R } = E.stylesheetCache;
      D.base && (D.base.before((0, h.default)([
        ..._,
        ...x
      ], D.base.source, {
        layer: "base"
      })), D.base.remove()), D.components && (D.components.before((0, h.default)([
        ...S
      ], D.components.source, {
        layer: "components"
      })), D.components.remove()), D.utilities && (D.utilities.before((0, h.default)([
        ...C
      ], D.utilities.source, {
        layer: "utilities"
      })), D.utilities.remove());
      const H = Array.from(R).filter((U) => {
        var P;
        const W = (P = U.raws.tailwind) === null || P === void 0 ? void 0 : P.parentLayer;
        return W === "components" ? D.components !== null : W === "utilities" ? D.utilities !== null : !0;
      });
      D.variants ? (D.variants.before((0, h.default)(H, D.variants.source, {
        layer: "variants"
      })), D.variants.remove()) : H.length > 0 && O.append((0, h.default)(H, O.source, {
        layer: "variants"
      }));
      const z = H.some((U) => {
        var P;
        return ((P = U.raws.tailwind) === null || P === void 0 ? void 0 : P.parentLayer) === "utilities";
      });
      D.utilities && C.size === 0 && !z && d.default.warn("content-problems", [
        "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
        "https://tailwindcss.com/docs/content-configuration"
      ]), f.DEBUG && (console.log("Potential classes: ", I.size), console.log("Active contexts: ", a.contextSourcesMap.size)), E.changedContent = [], O.walkAtRules("layer", (U) => {
        Object.keys(D).includes(U.params) && U.remove();
      });
    };
  }
})(oI);
var fI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return D;
    }
  });
  const e = /* @__PURE__ */ n(Vi), r = /* @__PURE__ */ n(ua), a = Eb(), l = /* @__PURE__ */ n(Pl), d = vb, h = Yd;
  function n($) {
    return $ && $.__esModule ? $ : {
      default: $
    };
  }
  function u($) {
    let I = /* @__PURE__ */ new Map();
    e.default.root({
      nodes: [
        $.clone()
      ]
    }).walkRules((x) => {
      (0, r.default)((_) => {
        _.walkClasses((S) => {
          let C = S.parent.toString(), R = I.get(C);
          R || I.set(C, R = /* @__PURE__ */ new Set()), R.add(S.value);
        });
      }).processSync(x.selector);
    });
    let L = Array.from(I.values(), (x) => Array.from(x)), M = L.flat();
    return Object.assign(M, {
      groups: L
    });
  }
  let i = (0, r.default)();
  function c($) {
    return i.astSync($);
  }
  function f($, I) {
    let k = /* @__PURE__ */ new Set();
    for (let L of $)
      k.add(L.split(I).pop());
    return Array.from(k);
  }
  function s($, I) {
    let k = $.tailwindConfig.prefix;
    return typeof k == "function" ? k(I) : k + I;
  }
  function* o($) {
    for (yield $; $.parent; )
      yield $.parent, $ = $.parent;
  }
  function y($, I = {}) {
    let k = $.nodes;
    $.nodes = [];
    let L = $.clone(I);
    return $.nodes = k, L;
  }
  function m($) {
    for (let I of o($))
      if ($ !== I) {
        if (I.type === "root")
          break;
        $ = y(I, {
          nodes: [
            $
          ]
        });
      }
    return $;
  }
  function g($, I) {
    let k = /* @__PURE__ */ new Map();
    return $.walkRules((L) => {
      for (let S of o(L)) {
        var M;
        if (((M = S.raws.tailwind) === null || M === void 0 ? void 0 : M.layer) !== void 0)
          return;
      }
      let x = m(L), _ = I.offsets.create("user");
      for (let S of u(L)) {
        let C = k.get(S) || [];
        k.set(S, C), C.push([
          {
            layer: "user",
            sort: _,
            important: !1
          },
          x
        ]);
      }
    }), k;
  }
  function b($, I) {
    for (let k of $) {
      if (I.notClassCache.has(k) || I.applyClassCache.has(k))
        continue;
      if (I.classCache.has(k)) {
        I.applyClassCache.set(k, I.classCache.get(k).map(([M, x]) => [
          M,
          x.clone()
        ]));
        continue;
      }
      let L = Array.from((0, a.resolveMatches)(k, I));
      if (L.length === 0) {
        I.notClassCache.add(k);
        continue;
      }
      I.applyClassCache.set(k, L);
    }
    return I.applyClassCache;
  }
  function v($) {
    let I = null;
    return {
      get: (k) => (I = I || $(), I.get(k)),
      has: (k) => (I = I || $(), I.has(k))
    };
  }
  function T($) {
    return {
      get: (I) => $.flatMap((k) => k.get(I) || []),
      has: (I) => $.some((k) => k.has(I))
    };
  }
  function E($) {
    let I = $.split(/[\s\t\n]+/g);
    return I[I.length - 1] === "!important" ? [
      I.slice(0, -1),
      !0
    ] : [
      I,
      !1
    ];
  }
  function O($, I, k) {
    let L = /* @__PURE__ */ new Set(), M = [];
    if ($.walkAtRules("apply", (C) => {
      let [R] = E(C.params);
      for (let H of R)
        L.add(H);
      M.push(C);
    }), M.length === 0)
      return;
    let x = T([
      k,
      b(L, I)
    ]);
    function _(C, R, H) {
      let z = c(C), U = c(R), W = c(`.${(0, l.default)(H)}`).nodes[0].nodes[0];
      return z.each((B) => {
        let Q = /* @__PURE__ */ new Set();
        U.each((J) => {
          let re = !1;
          J = J.clone(), J.walkClasses((G) => {
            G.value === W.value && (re || (G.replaceWith(...B.nodes.map((N) => N.clone())), Q.add(J), re = !0));
          });
        });
        for (let J of Q) {
          let re = [
            []
          ];
          for (let G of J.nodes)
            G.type === "combinator" ? (re.push(G), re.push([])) : re[re.length - 1].push(G);
          J.nodes = [];
          for (let G of re)
            Array.isArray(G) && G.sort((N, V) => N.type === "tag" && V.type === "class" ? -1 : N.type === "class" && V.type === "tag" ? 1 : N.type === "class" && V.type === "pseudo" && V.value.startsWith("::") ? -1 : N.type === "pseudo" && N.value.startsWith("::") && V.type === "class" ? 1 : 0), J.nodes = J.nodes.concat(G);
        }
        B.replaceWith(...Q);
      }), z.toString();
    }
    let S = /* @__PURE__ */ new Map();
    for (let C of M) {
      let [R] = S.get(C.parent) || [
        [],
        C.source
      ];
      S.set(C.parent, [
        R,
        C.source
      ]);
      let [H, z] = E(C.params);
      if (C.parent.type === "atrule") {
        if (C.parent.name === "screen") {
          let U = C.parent.params;
          throw C.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${H.map((P) => `${U}:${P}`).join(" ")} instead.`);
        }
        throw C.error(`@apply is not supported within nested at-rules like @${C.parent.name}. You can fix this by un-nesting @${C.parent.name}.`);
      }
      for (let U of H) {
        if ([
          s(I, "group"),
          s(I, "peer")
        ].includes(U))
          throw C.error(`@apply should not be used with the '${U}' utility`);
        if (!x.has(U))
          throw C.error(`The \`${U}\` class does not exist. If \`${U}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
        let P = x.get(U);
        R.push([
          U,
          z,
          P
        ]);
      }
    }
    for (let [C, [R, H]] of S) {
      let z = [];
      for (let [P, W, B] of R) {
        let Q = [
          P,
          ...f([
            P
          ], I.tailwindConfig.separator)
        ];
        for (let [J, re] of B) {
          let G = u(C), N = u(re);
          if (N = N.groups.filter((K) => K.some((ie) => Q.includes(ie))).flat(), N = N.concat(f(N, I.tailwindConfig.separator)), G.some((K) => N.includes(K)))
            throw re.error(`You cannot \`@apply\` the \`${P}\` utility here because it creates a circular dependency.`);
          let F = e.default.root({
            nodes: [
              re.clone()
            ]
          });
          F.walk((K) => {
            K.source = H;
          }), (re.type !== "atrule" || re.type === "atrule" && re.name !== "keyframes") && F.walkRules((K) => {
            if (!u(K).some((ce) => ce === P)) {
              K.remove();
              return;
            }
            let ie = typeof I.tailwindConfig.important == "string" ? I.tailwindConfig.important : null, _e = C.raws.tailwind !== void 0 && ie && C.selector.indexOf(ie) === 0 ? C.selector.slice(ie.length) : C.selector;
            K.selector = _(_e, K.selector, P), ie && _e !== C.selector && (K.selector = (0, d.applyImportantSelector)(K.selector, ie)), K.walkDecls((ce) => {
              ce.important = J.important || W;
            });
            let Ae = (0, r.default)().astSync(K.selector);
            Ae.each((ce) => (0, h.movePseudos)(ce)), K.selector = Ae.toString();
          }), F.nodes[0] && z.push([
            J.sort,
            F.nodes[0]
          ]);
        }
      }
      let U = I.offsets.sort(z).map((P) => P[1]);
      C.after(U);
    }
    for (let C of M)
      C.parent.nodes.length > 1 ? C.remove() : C.parent.remove();
    O($, I, k);
  }
  function D($) {
    return (I) => {
      let k = v(() => g(I, $));
      O(I, $, k);
    };
  }
})(fI);
var dI = {}, pI = { exports: {} };
(function(t) {
  (function() {
    function e(l, d, h) {
      if (!l) return null;
      e.caseSensitive || (l = l.toLowerCase());
      var n = e.threshold === null ? null : e.threshold * l.length, u = e.thresholdAbsolute, i;
      n !== null && u !== null ? i = Math.min(n, u) : n !== null ? i = n : u !== null ? i = u : i = null;
      var c, f, s, o, y, m = d.length;
      for (y = 0; y < m; y++)
        if (f = d[y], h && (f = f[h]), !!f && (e.caseSensitive ? s = f : s = f.toLowerCase(), o = a(l, s, i), (i === null || o < i) && (i = o, h && e.returnWinningObject ? c = d[y] : c = f, e.returnFirstMatch)))
          return c;
      return c || e.nullResultValue;
    }
    e.threshold = 0.4, e.thresholdAbsolute = 20, e.caseSensitive = !1, e.nullResultValue = null, e.returnWinningObject = null, e.returnFirstMatch = !1, t.exports ? t.exports = e : window.didYouMean = e;
    var r = Math.pow(2, 32) - 1;
    function a(l, d, h) {
      h = h || h === 0 ? h : r;
      var n = l.length, u = d.length;
      if (n === 0) return Math.min(h + 1, u);
      if (u === 0) return Math.min(h + 1, n);
      if (Math.abs(n - u) > h) return h + 1;
      var i = [], c, f, s, o, y;
      for (c = 0; c <= u; c++)
        i[c] = [c];
      for (f = 0; f <= n; f++)
        i[0][f] = f;
      for (c = 1; c <= u; c++) {
        for (s = r, o = 1, c > h && (o = c - h), y = u + 1, y > h + c && (y = h + c), f = 1; f <= n; f++)
          f < o || f > y ? i[c][f] = h + 1 : d.charAt(c - 1) === l.charAt(f - 1) ? i[c][f] = i[c - 1][f - 1] : i[c][f] = Math.min(
            i[c - 1][f - 1] + 1,
            // Substitute
            Math.min(
              i[c][f - 1] + 1,
              // Insert
              i[c - 1][f] + 1
            )
          ), i[c][f] < s && (s = i[c][f]);
        if (s > h) return h + 1;
      }
      return i[u][n];
    }
  })();
})(pI);
var jZ = pI.exports, l0 = 40, u0 = 41, cf = 39, c0 = 34, f0 = 92, Wo = 47, d0 = 44, p0 = 58, ff = 42, FZ = 117, BZ = 85, $Z = 43, UZ = /^[a-f0-9?-]+$/i, VZ = function(t) {
  for (var e = [], r = t, a, l, d, h, n, u, i, c, f = 0, s = r.charCodeAt(f), o = r.length, y = [{ nodes: e }], m = 0, g, b = "", v = "", T = ""; f < o; )
    if (s <= 32) {
      a = f;
      do
        a += 1, s = r.charCodeAt(a);
      while (s <= 32);
      h = r.slice(f, a), d = e[e.length - 1], s === u0 && m ? T = h : d && d.type === "div" ? (d.after = h, d.sourceEndIndex += h.length) : s === d0 || s === p0 || s === Wo && r.charCodeAt(a + 1) !== ff && (!g || g && g.type === "function" && g.value !== "calc") ? v = h : e.push({
        type: "space",
        sourceIndex: f,
        sourceEndIndex: a,
        value: h
      }), f = a;
    } else if (s === cf || s === c0) {
      a = f, l = s === cf ? "'" : '"', h = {
        type: "string",
        sourceIndex: f,
        quote: l
      };
      do
        if (n = !1, a = r.indexOf(l, a + 1), ~a)
          for (u = a; r.charCodeAt(u - 1) === f0; )
            u -= 1, n = !n;
        else
          r += l, a = r.length - 1, h.unclosed = !0;
      while (n);
      h.value = r.slice(f + 1, a), h.sourceEndIndex = h.unclosed ? a : a + 1, e.push(h), f = a + 1, s = r.charCodeAt(f);
    } else if (s === Wo && r.charCodeAt(f + 1) === ff)
      a = r.indexOf("*/", f), h = {
        type: "comment",
        sourceIndex: f,
        sourceEndIndex: a + 2
      }, a === -1 && (h.unclosed = !0, a = r.length, h.sourceEndIndex = a), h.value = r.slice(f + 2, a), e.push(h), f = a + 2, s = r.charCodeAt(f);
    else if ((s === Wo || s === ff) && g && g.type === "function" && g.value === "calc")
      h = r[f], e.push({
        type: "word",
        sourceIndex: f - v.length,
        sourceEndIndex: f + h.length,
        value: h
      }), f += 1, s = r.charCodeAt(f);
    else if (s === Wo || s === d0 || s === p0)
      h = r[f], e.push({
        type: "div",
        sourceIndex: f - v.length,
        sourceEndIndex: f + h.length,
        value: h,
        before: v,
        after: ""
      }), v = "", f += 1, s = r.charCodeAt(f);
    else if (l0 === s) {
      a = f;
      do
        a += 1, s = r.charCodeAt(a);
      while (s <= 32);
      if (c = f, h = {
        type: "function",
        sourceIndex: f - b.length,
        value: b,
        before: r.slice(c + 1, a)
      }, f = a, b === "url" && s !== cf && s !== c0) {
        a -= 1;
        do
          if (n = !1, a = r.indexOf(")", a + 1), ~a)
            for (u = a; r.charCodeAt(u - 1) === f0; )
              u -= 1, n = !n;
          else
            r += ")", a = r.length - 1, h.unclosed = !0;
        while (n);
        i = a;
        do
          i -= 1, s = r.charCodeAt(i);
        while (s <= 32);
        c < i ? (f !== i + 1 ? h.nodes = [
          {
            type: "word",
            sourceIndex: f,
            sourceEndIndex: i + 1,
            value: r.slice(f, i + 1)
          }
        ] : h.nodes = [], h.unclosed && i + 1 !== a ? (h.after = "", h.nodes.push({
          type: "space",
          sourceIndex: i + 1,
          sourceEndIndex: a,
          value: r.slice(i + 1, a)
        })) : (h.after = r.slice(i + 1, a), h.sourceEndIndex = a)) : (h.after = "", h.nodes = []), f = a + 1, h.sourceEndIndex = h.unclosed ? a : f, s = r.charCodeAt(f), e.push(h);
      } else
        m += 1, h.after = "", h.sourceEndIndex = f + 1, e.push(h), y.push(h), e = h.nodes = [], g = h;
      b = "";
    } else if (u0 === s && m)
      f += 1, s = r.charCodeAt(f), g.after = T, g.sourceEndIndex += T.length, T = "", m -= 1, y[y.length - 1].sourceEndIndex = f, y.pop(), g = y[m], e = g.nodes;
    else {
      a = f;
      do
        s === f0 && (a += 1), a += 1, s = r.charCodeAt(a);
      while (a < o && !(s <= 32 || s === cf || s === c0 || s === d0 || s === p0 || s === Wo || s === l0 || s === ff && g && g.type === "function" && g.value === "calc" || s === Wo && g.type === "function" && g.value === "calc" || s === u0 && m));
      h = r.slice(f, a), l0 === s ? b = h : (FZ === h.charCodeAt(0) || BZ === h.charCodeAt(0)) && $Z === h.charCodeAt(1) && UZ.test(h.slice(2)) ? e.push({
        type: "unicode-range",
        sourceIndex: f,
        sourceEndIndex: a,
        value: h
      }) : e.push({
        type: "word",
        sourceIndex: f,
        sourceEndIndex: a,
        value: h
      }), f = a;
    }
  for (f = y.length - 1; f; f -= 1)
    y[f].unclosed = !0, y[f].sourceEndIndex = r.length;
  return y[0].nodes;
}, WZ = function t(e, r, a) {
  var l, d, h, n;
  for (l = 0, d = e.length; l < d; l += 1)
    h = e[l], a || (n = r(h, l, e)), n !== !1 && h.type === "function" && Array.isArray(h.nodes) && t(h.nodes, r, a), a && r(h, l, e);
};
function Uw(t, e) {
  var r = t.type, a = t.value, l, d;
  return e && (d = e(t)) !== void 0 ? d : r === "word" || r === "space" ? a : r === "string" ? (l = t.quote || "", l + a + (t.unclosed ? "" : l)) : r === "comment" ? "/*" + a + (t.unclosed ? "" : "*/") : r === "div" ? (t.before || "") + a + (t.after || "") : Array.isArray(t.nodes) ? (l = hI(t.nodes, e), r !== "function" ? l : a + "(" + (t.before || "") + l + (t.after || "") + (t.unclosed ? "" : ")")) : a;
}
function hI(t, e) {
  var r, a;
  if (Array.isArray(t)) {
    for (r = "", a = t.length - 1; ~a; a -= 1)
      r = Uw(t[a], e) + r;
    return r;
  }
  return Uw(t, e);
}
var qZ = hI, h0, Vw;
function HZ() {
  if (Vw) return h0;
  Vw = 1;
  var t = 45, e = 43, r = 46, a = 101, l = 69;
  function d(h) {
    var n = h.charCodeAt(0), u;
    if (n === e || n === t) {
      if (u = h.charCodeAt(1), u >= 48 && u <= 57)
        return !0;
      var i = h.charCodeAt(2);
      return u === r && i >= 48 && i <= 57;
    }
    return n === r ? (u = h.charCodeAt(1), u >= 48 && u <= 57) : n >= 48 && n <= 57;
  }
  return h0 = function(h) {
    var n = 0, u = h.length, i, c, f;
    if (u === 0 || !d(h))
      return !1;
    for (i = h.charCodeAt(n), (i === e || i === t) && n++; n < u && (i = h.charCodeAt(n), !(i < 48 || i > 57)); )
      n += 1;
    if (i = h.charCodeAt(n), c = h.charCodeAt(n + 1), i === r && c >= 48 && c <= 57)
      for (n += 2; n < u && (i = h.charCodeAt(n), !(i < 48 || i > 57)); )
        n += 1;
    if (i = h.charCodeAt(n), c = h.charCodeAt(n + 1), f = h.charCodeAt(n + 2), (i === a || i === l) && (c >= 48 && c <= 57 || (c === e || c === t) && f >= 48 && f <= 57))
      for (n += c === e || c === t ? 3 : 2; n < u && (i = h.charCodeAt(n), !(i < 48 || i > 57)); )
        n += 1;
    return {
      number: h.slice(0, n),
      unit: h.slice(n)
    };
  }, h0;
}
var GZ = VZ, mI = WZ, yI = qZ;
function Ia(t) {
  return this instanceof Ia ? (this.nodes = GZ(t), this) : new Ia(t);
}
Ia.prototype.toString = function() {
  return Array.isArray(this.nodes) ? yI(this.nodes) : "";
};
Ia.prototype.walk = function(t, e) {
  return mI(this.nodes, t, e), this;
};
Ia.unit = HZ();
Ia.walk = mI;
Ia.stringify = yI;
var zZ = Ia;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return I;
    }
  });
  const e = /* @__PURE__ */ f(YT), r = /* @__PURE__ */ f(jZ), a = /* @__PURE__ */ f(Qu), l = /* @__PURE__ */ f(zZ), d = Kd, h = /* @__PURE__ */ f(zd), n = Fd, u = zu, i = Gu, c = /* @__PURE__ */ f(as);
  function f(k) {
    return k && k.__esModule ? k : {
      default: k
    };
  }
  function s(k) {
    return typeof k == "object" && k !== null;
  }
  function o(k, L) {
    let M = (0, n.toPath)(L);
    do
      if (M.pop(), (0, e.default)(k, M) !== void 0) break;
    while (M.length);
    return M.length ? M : void 0;
  }
  function y(k) {
    return typeof k == "string" ? k : k.reduce((L, M, x) => M.includes(".") ? `${L}[${M}]` : x === 0 ? M : `${L}.${M}`, "");
  }
  function m(k) {
    return k.map((L) => `'${L}'`).join(", ");
  }
  function g(k) {
    return m(Object.keys(k));
  }
  function b(k, L, M, x = {}) {
    const _ = Array.isArray(L) ? y(L) : L.replace(/^['"]+|['"]+$/g, ""), S = Array.isArray(L) ? L : (0, n.toPath)(_), C = (0, e.default)(k.theme, S, M);
    if (C === void 0) {
      let H = `'${_}' does not exist in your theme config.`;
      const z = S.slice(0, -1), U = (0, e.default)(k.theme, z);
      if (s(U)) {
        const P = Object.keys(U).filter((B) => b(k, [
          ...z,
          B
        ]).isValid), W = (0, r.default)(S[S.length - 1], P);
        W ? H += ` Did you mean '${y([
          ...z,
          W
        ])}'?` : P.length > 0 && (H += ` '${y(z)}' has the following valid keys: ${m(P)}`);
      } else {
        const P = o(k.theme, _);
        if (P) {
          const W = (0, e.default)(k.theme, P);
          s(W) ? H += ` '${y(P)}' has the following keys: ${g(W)}` : H += ` '${y(P)}' is not an object.`;
        } else
          H += ` Your theme has the following top-level keys: ${g(k.theme)}`;
      }
      return {
        isValid: !1,
        error: H
      };
    }
    if (!(typeof C == "string" || typeof C == "number" || typeof C == "function" || C instanceof String || C instanceof Number || Array.isArray(C))) {
      let H = `'${_}' was found but does not resolve to a string.`;
      if (s(C)) {
        let z = Object.keys(C).filter((U) => b(k, [
          ...S,
          U
        ]).isValid);
        z.length && (H += ` Did you mean something like '${y([
          ...S,
          z[0]
        ])}'?`);
      }
      return {
        isValid: !1,
        error: H
      };
    }
    const [R] = S;
    return {
      isValid: !0,
      value: (0, a.default)(R)(C, x)
    };
  }
  function v(k, L, M) {
    L = L.map((_) => T(k, _, M));
    let x = [
      ""
    ];
    for (let _ of L)
      _.type === "div" && _.value === "," ? x.push("") : x[x.length - 1] += l.default.stringify(_);
    return x;
  }
  function T(k, L, M) {
    if (L.type === "function" && M[L.value] !== void 0) {
      let x = v(k, L.nodes, M);
      L.type = "word", L.value = M[L.value](k, ...x);
    }
    return L;
  }
  function E(k, L, M) {
    return (0, l.default)(L).walk((x) => {
      T(k, x, M);
    }).toString();
  }
  let O = {
    atrule: "params",
    decl: "value"
  };
  function* D(k) {
    k = k.replace(/^['"]+|['"]+$/g, "");
    let L = k.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), M;
    yield [
      k,
      void 0
    ], L && (k = L[1], M = L[2], yield [
      k,
      M
    ]);
  }
  function $(k, L, M) {
    const x = Array.from(D(L)).map(([S, C]) => Object.assign(b(k, S, M, {
      opacityValue: C
    }), {
      resolvedPath: S,
      alpha: C
    }));
    var _;
    return (_ = x.find((S) => S.isValid)) !== null && _ !== void 0 ? _ : x[0];
  }
  function I(k) {
    let L = k.tailwindConfig, M = {
      theme: (x, _, ...S) => {
        let { isValid: C, value: R, error: H, alpha: z } = $(L, _, S.length ? S : void 0);
        if (!C) {
          var U;
          let B = x.parent, Q = (U = B == null ? void 0 : B.raws.tailwind) === null || U === void 0 ? void 0 : U.candidate;
          if (B && Q !== void 0) {
            k.markInvalidUtilityNode(B), B.remove(), c.default.warn("invalid-theme-key-in-class", [
              `The utility \`${Q}\` contains an invalid theme value and was not generated.`
            ]);
            return;
          }
          throw x.error(H);
        }
        let P = (0, i.parseColorFormat)(R);
        return (z !== void 0 || P !== void 0 && typeof P == "function") && (z === void 0 && (z = 1), R = (0, u.withAlphaValue)(P, z, P)), R;
      },
      screen: (x, _) => {
        _ = _.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
        let C = (0, d.normalizeScreens)(L.theme.screens).find(({ name: R }) => R === _);
        if (!C)
          throw x.error(`The '${_}' screen does not exist in your theme.`);
        return (0, h.default)(C);
      }
    };
    return (x) => {
      x.walk((_) => {
        let S = O[_.type];
        S !== void 0 && (_[S] = E(_, _[S], M));
      });
    };
  }
})(dI);
var bI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = Kd, r = /* @__PURE__ */ a(zd);
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l({ tailwindConfig: { theme: d } }) {
    return function(h) {
      h.walkAtRules("screen", (n) => {
        let u = n.params, c = (0, e.normalizeScreens)(d.screens).find(({ name: f }) => f === u);
        if (!c)
          throw n.error(`No \`${u}\` screen found.`);
        n.name = "media", n.params = (0, r.default)(c);
      });
    };
  }
})(bI);
var gI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  function e(s, o) {
    for (var y in o) Object.defineProperty(s, y, {
      enumerable: !0,
      get: o[y]
    });
  }
  e(t, {
    elementSelectorParser: function() {
      return u;
    },
    default: function() {
      return f;
    }
  });
  const r = /* @__PURE__ */ d(Vi), a = /* @__PURE__ */ d(ua), l = Vs;
  function d(s) {
    return s && s.__esModule ? s : {
      default: s
    };
  }
  let h = {
    id(s) {
      return a.default.attribute({
        attribute: "id",
        operator: "=",
        value: s.value,
        quoteMark: '"'
      });
    }
  };
  function n(s) {
    let o = s.filter((T) => T.type !== "pseudo" || T.nodes.length > 0 ? !0 : T.value.startsWith("::") || [
      ":before",
      ":after",
      ":first-line",
      ":first-letter"
    ].includes(T.value)).reverse(), y = /* @__PURE__ */ new Set([
      "tag",
      "class",
      "id",
      "attribute"
    ]), m = o.findIndex((T) => y.has(T.type));
    if (m === -1) return o.reverse().join("").trim();
    let g = o[m], b = h[g.type] ? h[g.type](g) : g;
    o = o.slice(0, m);
    let v = o.findIndex((T) => T.type === "combinator" && T.value === ">");
    return v !== -1 && (o.splice(0, v), o.unshift(a.default.universal())), [
      b,
      ...o.reverse()
    ].join("").trim();
  }
  let u = (0, a.default)((s) => s.map((o) => {
    let y = o.split((m) => m.type === "combinator" && m.value === " ").pop();
    return n(y);
  })), i = /* @__PURE__ */ new Map();
  function c(s) {
    return i.has(s) || i.set(s, u.transformSync(s)), i.get(s);
  }
  function f({ tailwindConfig: s }) {
    return (o) => {
      let y = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Set();
      if (o.walkAtRules("defaults", (v) => {
        if (v.nodes && v.nodes.length > 0) {
          m.add(v);
          return;
        }
        let T = v.params;
        y.has(T) || y.set(T, /* @__PURE__ */ new Set()), y.get(T).add(v.parent), v.remove();
      }), (0, l.flagEnabled)(s, "optimizeUniversalDefaults"))
        for (let v of m) {
          let T = /* @__PURE__ */ new Map();
          var g;
          let E = (g = y.get(v.params)) !== null && g !== void 0 ? g : [];
          for (let O of E)
            for (let D of c(O.selector)) {
              let $ = D.includes(":-") || D.includes("::-") ? D : "__DEFAULT__";
              var b;
              let I = (b = T.get($)) !== null && b !== void 0 ? b : /* @__PURE__ */ new Set();
              T.set($, I), I.add(D);
            }
          if ((0, l.flagEnabled)(s, "optimizeUniversalDefaults")) {
            if (T.size === 0) {
              v.remove();
              continue;
            }
            for (let [, O] of T) {
              let D = r.default.rule({
                source: v.source
              });
              D.selectors = [
                ...O
              ], D.append(v.nodes.map(($) => $.clone())), v.before(D);
            }
          }
          v.remove();
        }
      else if (m.size) {
        let v = r.default.rule({
          selectors: [
            "*",
            "::before",
            "::after"
          ]
        });
        for (let E of m)
          v.append(E.nodes), v.parent || E.before(v), v.source || (v.source = E.source), E.remove();
        let T = v.clone({
          selectors: [
            "::backdrop"
          ]
        });
        v.after(T);
      }
    };
  }
})(gI);
var vI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  let e = {
    atrule: [
      "name",
      "params"
    ],
    rule: [
      "selector"
    ]
  }, r = new Set(Object.keys(e));
  function a() {
    function l(d) {
      let h = null;
      d.each((n) => {
        if (!r.has(n.type)) {
          h = null;
          return;
        }
        if (h === null) {
          h = n;
          return;
        }
        let u = e[n.type];
        var i, c;
        n.type === "atrule" && n.name === "font-face" ? h = n : u.every((f) => ((i = n[f]) !== null && i !== void 0 ? i : "").replace(/\s+/g, " ") === ((c = h[f]) !== null && c !== void 0 ? c : "").replace(/\s+/g, " ")) ? (n.nodes && h.append(n.nodes), n.remove()) : h = n;
      }), d.each((n) => {
        n.type === "atrule" && l(n);
      });
    }
    return (d) => {
      l(d);
    };
  }
})(vI);
var EI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e() {
    return (l) => {
      l.walkRules((d) => {
        let h = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set([]), u = /* @__PURE__ */ new Map();
        d.walkDecls((i) => {
          if (i.parent === d) {
            if (h.has(i.prop)) {
              if (h.get(i.prop).value === i.value) {
                n.add(h.get(i.prop)), h.set(i.prop, i);
                return;
              }
              u.has(i.prop) || u.set(i.prop, /* @__PURE__ */ new Set()), u.get(i.prop).add(h.get(i.prop)), u.get(i.prop).add(i);
            }
            h.set(i.prop, i);
          }
        });
        for (let i of n)
          i.remove();
        for (let i of u.values()) {
          let c = /* @__PURE__ */ new Map();
          for (let f of i) {
            let s = a(f.value);
            s !== null && (c.has(s) || c.set(s, /* @__PURE__ */ new Set()), c.get(s).add(f));
          }
          for (let f of c.values()) {
            let s = Array.from(f).slice(0, -1);
            for (let o of s)
              o.remove();
          }
        }
      });
    };
  }
  let r = Symbol("unitless-number");
  function a(l) {
    let d = /^-?\d*.?\d+([\w%]+)?$/g.exec(l);
    if (d) {
      var h;
      return (h = d[1]) !== null && h !== void 0 ? h : r;
    }
    return null;
  }
})(EI);
var _I = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  function e(a) {
    if (!a.walkAtRules) return;
    let l = /* @__PURE__ */ new Set();
    if (a.walkAtRules("apply", (d) => {
      l.add(d.parent);
    }), l.size !== 0)
      for (let d of l) {
        let h = [], n = [];
        for (let u of d.nodes)
          u.type === "atrule" && u.name === "apply" ? (n.length > 0 && (h.push(n), n = []), h.push([
            u
          ])) : n.push(u);
        if (n.length > 0 && h.push(n), h.length !== 1) {
          for (let u of [
            ...h
          ].reverse()) {
            let i = d.clone({
              nodes: []
            });
            i.append(u), d.after(i);
          }
          d.remove();
        }
      }
  }
  function r() {
    return (a) => {
      e(a);
    };
  }
})(_I);
var SI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return a;
    }
  });
  function e(l) {
    return l.type === "root";
  }
  function r(l) {
    return l.type === "atrule" && l.name === "layer";
  }
  function a(l) {
    return (d, h) => {
      let n = !1;
      d.walkAtRules("tailwind", (u) => {
        if (n) return !1;
        if (u.parent && !(e(u.parent) || r(u.parent)))
          return n = !0, u.warn(h, [
            "Nested @tailwind rules were detected, but are not supported.",
            "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
            "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
          ].join(`
`)), !1;
      }), d.walkRules((u) => {
        if (n) return !1;
        u.walkRules((i) => (n = !0, i.warn(h, [
          "Nested CSS was detected, but CSS nesting has not been configured correctly.",
          "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
          "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
        ].join(`
`)), !1));
      });
    };
  }
})(SI);
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "default", {
    enumerable: !0,
    get: function() {
      return y;
    }
  });
  const e = /* @__PURE__ */ o(aI), r = /* @__PURE__ */ o(oI), a = /* @__PURE__ */ o(fI), l = /* @__PURE__ */ o(dI), d = /* @__PURE__ */ o(bI), h = /* @__PURE__ */ o(gI), n = /* @__PURE__ */ o(vI), u = /* @__PURE__ */ o(EI), i = /* @__PURE__ */ o(_I), c = /* @__PURE__ */ o(SI), f = zb(), s = Vs;
  function o(m) {
    return m && m.__esModule ? m : {
      default: m
    };
  }
  function y(m) {
    return function(g, b) {
      let { tailwindDirectives: v, applyDirectives: T } = (0, e.default)(g);
      (0, c.default)()(g, b), (0, i.default)()(g, b);
      let E = m({
        tailwindDirectives: v,
        applyDirectives: T,
        registerDependency(O) {
          b.messages.push({
            plugin: "tailwindcss",
            parent: b.opts.from,
            ...O
          });
        },
        createContext(O, D) {
          return (0, f.createContext)(O, D, g);
        }
      })(g, b);
      if (E.tailwindConfig.separator === "-")
        throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
      (0, s.issueFlagNotices)(E.tailwindConfig), (0, r.default)(E)(g, b), (0, i.default)()(g, b), (0, a.default)(E)(g, b), (0, l.default)(E)(g, b), (0, d.default)(E)(g, b), (0, h.default)(E)(g, b), (0, n.default)(E)(g, b), (0, u.default)(E)(g, b);
    };
  }
})(sI);
var wI = {};
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "findAtConfigPath", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ a(oi), r = /* @__PURE__ */ a(Qr);
  function a(d) {
    return d && d.__esModule ? d : {
      default: d
    };
  }
  function l(d, h) {
    let n = null, u = null;
    return d.walkAtRules("config", (i) => {
      var c, f, s;
      if (u = (s = (f = (c = i.source) === null || c === void 0 ? void 0 : c.input.file) !== null && f !== void 0 ? f : h.opts.from) !== null && s !== void 0 ? s : null, u === null)
        throw i.error("The `@config` directive cannot be used without setting `from` in your PostCSS config.");
      if (n)
        throw i.error("Only one `@config` directive is allowed per file.");
      let o = i.params.match(/(['"])(.*?)\1/);
      if (!o)
        throw i.error("A path is required when using the `@config` directive.");
      let y = o[2];
      if (r.default.isAbsolute(y))
        throw i.error("The `@config` directive cannot be used with an absolute path.");
      if (n = r.default.resolve(r.default.dirname(u), y), !e.default.existsSync(n))
        throw i.error(`The config file at "${y}" does not exist. Make sure the path is correct and the file exists.`);
      i.remove();
    }), n || null;
  }
})(wI);
var KZ = _d.exports;
Object.defineProperty(KZ, "__esModule", {
  value: !0
});
const YZ = /* @__PURE__ */ xI(P2), Ww = /* @__PURE__ */ xI(sI), qw = mo, XZ = wI;
function xI(t) {
  return t && t.__esModule ? t : {
    default: t
  };
}
_d.exports = function(e) {
  return {
    postcssPlugin: "tailwindcss",
    plugins: [
      qw.env.DEBUG && function(r) {
        return console.log(`
`), console.time("JIT TOTAL"), r;
      },
      function(r, a) {
        var l;
        e = (l = (0, XZ.findAtConfigPath)(r, a)) !== null && l !== void 0 ? l : e;
        let d = (0, YZ.default)(e);
        if (r.type === "document") {
          let h = r.nodes.filter((n) => n.type === "root");
          for (const n of h)
            n.type === "root" && (0, Ww.default)(d)(n, a);
          return;
        }
        (0, Ww.default)(d)(r, a);
      },
      !1,
      qw.env.DEBUG && function(r) {
        return console.timeEnd("JIT TOTAL"), console.log(`
`), r;
      }
    ].filter(Boolean)
  };
};
_d.exports.postcss = !0;
var JZ = _d.exports, QZ = JZ;
const ZZ = /* @__PURE__ */ gd(QZ);
var Qg = { exports: {} }, Df = Object.prototype.hasOwnProperty, TI = Object.prototype.toString, Hw = Object.defineProperty, Gw = Object.getOwnPropertyDescriptor, zw = function(e) {
  return typeof Array.isArray == "function" ? Array.isArray(e) : TI.call(e) === "[object Array]";
}, Kw = function(e) {
  if (!e || TI.call(e) !== "[object Object]")
    return !1;
  var r = Df.call(e, "constructor"), a = e.constructor && e.constructor.prototype && Df.call(e.constructor.prototype, "isPrototypeOf");
  if (e.constructor && !r && !a)
    return !1;
  var l;
  for (l in e)
    ;
  return typeof l > "u" || Df.call(e, l);
}, Yw = function(e, r) {
  Hw && r.name === "__proto__" ? Hw(e, r.name, {
    enumerable: !0,
    configurable: !0,
    value: r.newValue,
    writable: !0
  }) : e[r.name] = r.newValue;
}, Xw = function(e, r) {
  if (r === "__proto__")
    if (Df.call(e, r)) {
      if (Gw)
        return Gw(e, r).value;
    } else return;
  return e[r];
}, eee = function t() {
  var e, r, a, l, d, h, n = arguments[0], u = 1, i = arguments.length, c = !1;
  for (typeof n == "boolean" && (c = n, n = arguments[1] || {}, u = 2), (n == null || typeof n != "object" && typeof n != "function") && (n = {}); u < i; ++u)
    if (e = arguments[u], e != null)
      for (r in e)
        a = Xw(n, r), l = Xw(e, r), n !== l && (c && l && (Kw(l) || (d = zw(l))) ? (d ? (d = !1, h = a && zw(a) ? a : []) : h = a && Kw(a) ? a : {}, Yw(n, { name: r, newValue: t(c, h, l) })) : typeof l < "u" && Yw(n, { name: r, newValue: l }));
  return n;
}, my = function(t, e) {
  var r = new t.constructor();
  return Object.keys(t).forEach(function(a) {
    if (t.hasOwnProperty(a)) {
      var l = t[a], d = typeof l;
      a === "parent" && d === "object" ? e && (r[a] = e) : a === "source" ? r[a] = l : l instanceof Array ? a === "nodes" ? r[a] = [] : r[a] = l.map(function(h) {
        my(h, r);
      }) : a !== "before" && a !== "after" && a !== "between" && a !== "semicolon" && (d === "object" && (l = my(l)), r[a] = l);
    }
  }), r;
}, Zg = my, tee = AI;
function AI(t, e, r) {
  t instanceof RegExp && (t = Jw(t, r)), e instanceof RegExp && (e = Jw(e, r));
  var a = PI(t, e, r);
  return a && {
    start: a[0],
    end: a[1],
    pre: r.slice(0, a[0]),
    body: r.slice(a[0] + t.length, a[1]),
    post: r.slice(a[1] + e.length)
  };
}
function Jw(t, e) {
  var r = e.match(t);
  return r ? r[0] : null;
}
AI.range = PI;
function PI(t, e, r) {
  var a, l, d, h, n, u = r.indexOf(t), i = r.indexOf(e, u + 1), c = u;
  if (u >= 0 && i > 0) {
    if (t === e)
      return [u, i];
    for (a = [], d = r.length; c >= 0 && !n; )
      c == u ? (a.push(c), u = r.indexOf(t, c + 1)) : a.length == 1 ? n = [a.pop(), i] : (l = a.pop(), l < d && (d = l, h = i), i = r.indexOf(e, c + 1)), c = u < i && u >= 0 ? u : i;
    a.length && (n = [d, h]);
  }
  return n;
}
var ree = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, nee = function(t) {
  return t.split(ree).filter(function(e) {
    return e.length > 0;
  }).map(function(e) {
    return e.trim().replace(/\s*?>>\s*?/g, "");
  });
}, iee = nee, see = iee, aee = function(t, e) {
  e = e || !1;
  for (var r = [
    // Start off with one branch
    []
  ], a = e ? t : t.parent; a; ) {
    var l = (a.selectors || []).map(function(h) {
      return {
        value: h,
        type: "selector"
      };
    });
    a.type === "atrule" && (l = [].concat(a.params).map(function(h) {
      return {
        value: "@" + a.name + " " + h,
        type: "atrule"
      };
    }));
    var d = (l.length > 0 ? l : [1]).map(function() {
      return r.map(function(h) {
        return h.slice(0);
      });
    });
    l.forEach(function(h, n) {
      d[n] = d[n].map(function(u) {
        var i = [h.value];
        return h.type === "selector" && (i = see(h.value)), u.unshift.apply(u, i), u;
      });
    }), r = [], d.forEach(function(h) {
      r = r.concat(h);
    }), a = a.parent;
  }
  return r;
}, zp = aee, oee = /[|\\{}()[\]^$+*?.]/g, lee = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(oee, "\\$&");
}, uee = {
  "*": !0,
  ":root": !0,
  html: !0
}, cee = function(t) {
  return !!uee[t];
}, fee = cee, dee = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, pee = function(t) {
  return t.split(dee).filter(function(e) {
    return e.length > 0;
  }).map(function(e) {
    return e.trim().replace(/\s*?>\s*?/g, "");
  });
}, hee = pee, mee = lee, Qw = fee, Zw = hee, yee = /^@.*/, CI = new RegExp("([^\\s:]+)(?<!\\\\)((?::|::)[^\\s]*?)(\\s+|$)");
function II(t, e) {
  var r, a, l = e.some(function(d) {
    return t.some(function(h) {
      r = null;
      var n = !0;
      for (a = 0; a < d.length; a++) {
        for (var u = d[a], i = r || 0, c = -1, f = h.slice(i), s = 0; s < f.length; s++) {
          var o = f[s], y = i + s;
          if (
            // If the part on the end of the piece itself matches:
            //		scopePiece `.bar` matches node `.bar`
            //		scopePiece `.bar` matches node `.foo + .bar`
            new RegExp(mee(u) + "$").test(o)
          ) {
            c = y;
            break;
          }
          if (Qw(u) || Qw(o)) {
            c = y;
            break;
          }
          var m = Zw(o);
          if (m.length > 1) {
            var g = [].concat([m]), b = [].concat([
              d.slice(a).reduce(function(E, O) {
                return E.concat(Zw(O));
              }, [])
            ]), v = II(g, b);
            (v.doesMatchScope || a + 1 < d.length) && (c = y, a += v.scopePieceIndex - 1);
            break;
          }
        }
        var T = c >= i;
        if (r = c + 1, n = n && T, !n)
          break;
      }
      return n;
    });
  });
  return {
    doesMatchScope: l,
    nodeScopePieceIndex: r - 1,
    scopePieceIndex: a
  };
}
var e2 = function(t) {
  return t.map(function(e) {
    return e.map(function(r) {
      return yee.test(r) ? r : r.replace(new RegExp(CI.source, "g"), function(a, l, d, h) {
        return l + h;
      });
    });
  });
}, OI = function(t, e, r) {
  return t = e2(t), r && (e = e2(e)), II(t, e).doesMatchScope;
};
OI.RE_PSEUDO_SELECTOR = CI;
var kI = OI, bee = kI, t2 = zp, gee = function(t, e, r) {
  var a = t2(t, !0), l = t2(e, !0);
  return bee(a, l, r);
}, DI = gee, NI = function(t, e, r) {
  r = r || [];
  var a = !1;
  return t && (r = t.reduce(function(l, d) {
    var h = !!e[d], n = h ? l.some(function(u) {
      return e[d].some(function(i) {
        return u === i;
      });
    }) : !1;
    return a = a || n, h && !a && (l = l.concat(e[d]), (e[d] || []).forEach(function(u) {
      var i = NI(u.variablesUsed, e, l);
      l = i.deps, a = a || i.hasCircularOrSelfReference;
    })), l;
  }, r)), {
    deps: r,
    hasCircularOrSelfReference: a
  };
}, RI = NI, vee = zp, Eee = function(t, e) {
  for (var r, a = e; a.parent && !r; ) {
    var l = vee(a.clone(), !0);
    l.some(function(d) {
      return d.some(function(h) {
        return h === t ? (r = a, !0) : !1;
      });
    }), a = a.parent;
  }
  return r;
}, MI = Eee, r2 = Zg, _ee = function(t, e, r) {
  r = r || function() {
    return !0;
  };
  for (var a = [], l = t, d = !1; l && !d; )
    l.type === "decl" ? a.push(l.clone()) : a.push(r2(l)), d = r(l), l = l.parent;
  for (var h = [], n = e; n; )
    h.push(r2(n)), n = n.parent;
  return h.forEach(function(u, i, c) {
    i + 1 < c.length && (u.parent = c[i + 1]);
  }), a.forEach(function(u, i, c) {
    i + 1 < c.length ? u.parent = c[i + 1] : (h.slice(-1)[0].parent = l, u.parent = h[0]);
  }), a[0];
}, LI = _ee, See = tee, wee = zp, n2 = DI, xee = RI, Tee = MI, Aee = LI, Pee = /var\(\s*(--[^,\s)]+)/;
function Cee(t) {
  return String(t);
}
function yd(t) {
  var e = See("(", ")", t);
  if (e) {
    if (/(?:^|[^\w-])var$/.test(e.pre))
      return {
        pre: e.pre.slice(0, -3),
        body: e.body,
        post: e.post
      };
    var r = yd(e.body);
    if (r)
      return {
        pre: e.pre + "(" + r.pre,
        body: r.body,
        post: r.post + ")" + e.post
      };
    var a = yd(e.post);
    if (a)
      return {
        pre: e.pre + "(" + e.body + ")" + a.pre,
        body: a.body,
        post: a.post
      };
  }
}
var bd = function(t, e, r, a) {
  for (var l = void 0, d = Cee(t.value), h = [], n = {}, u = d; l = yd(u); ) {
    var i = l.body.split(","), c = i[0].trim();
    n[c] = !0, u = (l.pre || "") + l.body.replace(c, "") + (l.post || "");
  }
  u = void 0;
  for (var f = Object.keys(n), s = !1; l = yd(d); ) {
    var o = void 0, i = l.body.split(","), c = i[0].trim(), y = i.length > 1 ? i.slice(1).join(",").trim() : void 0;
    (e[c] || []).forEach(function(D) {
      D.parent.type === "root" || D.parent.selectors[0], n2(t.parent, D.parent);
      var $ = n2(t.parent, D.parent, r);
      $ && // And if the currently matched declaration is `!important`, it will take another `!important` to override it
      (!(o || {}).isImportant || D.isImportant) && (o = D);
    });
    var m = (o || {}).calculatedInPlaceValue || function() {
      var D = y;
      if (y) {
        var $ = t.clone({ parent: t.parent, value: y });
        D = bd($, e, !1).value;
      }
      return D;
    }();
    if (o !== void 0 && !xee(f, e).hasCircularOrSelfReference) {
      var g = wee(t.parent.parent, !0), b = g[0].slice(-1)[0], v = Tee(b, o.decl.parent), T = Aee(o.decl, t.parent.parent, function(D) {
        return D === v;
      });
      m = bd(T, e, !1).value;
    }
    s = m === void 0, s && h.push(["variable " + c + " is undefined and used without a fallback", { node: t }]), d = (l.pre || "") + m + (l.post || "");
  }
  return {
    // The resolved value
    value: s ? void 0 : d,
    // Array of variable names used in resolving this value
    variablesUsed: f,
    // Any warnings generated from parsing this value
    warnings: h
  };
};
bd.RE_VAR_FUNC = Pee;
var jI = bd, i2 = jI, Iee = zp, Oee = RI, s2 = kI, kee = DI, Nf = Zg, Dee = MI, Nee = LI;
function Ree(t, e, r, a) {
  t.forEach(function(l) {
    Oee(t, e).deps.forEach(function(d) {
      var h;
      if (d.isUnderAtRule) {
        var n = Iee(d.parent, !0), u = n[0].slice(-1)[0], i = Dee(u, r.parent), c = d.parent.parent;
        h = Nee(r, c, function(y) {
          return y === i;
        });
      } else if (s2.RE_PSEUDO_SELECTOR.test(d.parent.selector)) {
        var f = Nf(r.parent);
        f.parent = r.parent.parent, h = r.clone(), f.append(h);
        var s = d.parent.selector.match(new RegExp(s2.RE_PSEUDO_SELECTOR.source + "$")), o = s ? s[2] : "";
        f.selector += o;
      }
      h && kee(h, d.parent, !0) && a(h, d);
    });
  });
}
function Mee(t, e, r, a, l) {
  r = (typeof r == "function" ? r(t) : r) || !1, a = a || !1;
  var d = function(u) {
    return l && l(u), u;
  }, h = d(i2(t, e)), n;
  Ree(h.variablesUsed, e, t, function(u, i) {
    var c = Nf(t.parent), f = t.clone();
    c.append(f);
    let s;
    if (typeof r == "function" ? s = r(t) : s = r, s === !0 && f.cloneAfter(), f.value = d(i2(u, e, !0)).value, i.isUnderAtRule) {
      var o = Nf(i.parent.parent);
      o.append(c);
      for (var y = o, m = i.parent.parent; m.parent.type === "atrule"; ) {
        var g = Nf(m.parent);
        g.append(y), y = g, m = m.parent;
      }
      o !== y && (t.parent.parent.insertAfter(a && n || t.parent, y), n = y);
    } else
      c.selector = u.parent.selector, t.parent.parent.insertAfter(a && n || t.parent, c);
  }), r === !0 && t.value !== h.value && t.cloneAfter(), h.value === void 0 && (h.value = "undefined"), t.value = h.value;
}
var Lee = Mee, a2 = eee, jee = Zg, o2 = jI, Fee = Lee, FI = /(--(.+))/;
function Bee(t, e) {
  t.walkDecls(function(r) {
    FI.test(r.prop) && e(r);
  });
}
function $ee(t) {
  for (var e = t; e && e.nodes.length <= 0; ) {
    var r = e.type !== "root" ? e : null;
    r ? (e = r.parent, r.remove()) : e = null;
  }
}
var Uee = {
  // Allows you to preserve custom properties & var() usage in output.
  // `true`, `false`, or `'computed'`
  preserve: !1,
  // Define variables via JS
  // Simple key-value pair
  // or an object with a `value` property and an optional `isImportant` bool property
  variables: {},
  // Preserve variables injected via JS with the `variables` option above
  // before serializing to CSS (`false` will remove these variables from output)
  preserveInjectedVariables: !0,
  // Will write media queries in the same order as in the original file.
  // Currently defaulted to false for legacy behavior. We can update to `true` in a major version
  preserveAtRulesOrder: !1
};
Qg.exports = (t = {}) => {
  var e = a2({}, Uee, t);
  return {
    postcssPlugin: "postcss-css-variables",
    Once(r, { decl: a, result: l, rule: d }) {
      var h = [], n = [], u = {};
      u = a2(
        u,
        Object.keys(e.variables).reduce(
          function(f, s) {
            var o = e.variables[s];
            s = s.slice(0, 2) === "--" ? s : "--" + s;
            var y = (o || {}).value || o, m = (o || {}).isImportant || !1, g = d({ selector: ":root" });
            r.root().prepend(g);
            var b = a({
              prop: s,
              value: y,
              important: m
            });
            return g.append(b), e.preserveInjectedVariables || n.push(b), f[s] = (f[s] || []).concat({
              decl: b,
              prop: s,
              calculatedInPlaceValue: y,
              isImportant: m,
              variablesUsed: [],
              parent: g,
              isUnderAtRule: !1
            }), f;
          },
          {}
        )
      );
      var i = function(f) {
        var s = [].concat(f.warnings);
        return s.forEach(function(o) {
          o = [].concat(o), l.warn.apply(l, o);
        }), f;
      };
      Bee(r, function(f) {
        var s = f.parent, o = i(o2(f, u));
        f.parent.selectors.forEach(function(m) {
          var g = jee(f.parent);
          g.selector = m, g.parent = f.parent.parent;
          var b = f.clone();
          g.append(b);
          var v = f.prop;
          u[v] = (u[v] || []).concat({
            decl: b,
            prop: v,
            calculatedInPlaceValue: o.value,
            isImportant: f.important || !1,
            variablesUsed: o.variablesUsed,
            parent: g,
            // variables inside root or at-rules (eg. @media, @support)
            isUnderAtRule: g.parent.type === "atrule"
          });
        });
        let y;
        typeof e.preserve == "function" ? y = e.preserve(f) : y = e.preserve, y ? y === "computed" && (f.value = o.value) : f.remove(), s.nodes.length <= 0 && h.push(s);
      });
      var c = [];
      r.walk(function(f) {
        if (f.nodes !== void 0) {
          var s = f.nodes.some(function(o) {
            if (o.type === "decl") {
              var y = o;
              if (o2.RE_VAR_FUNC.test(y.value) && !FI.test(y.prop))
                return !0;
            }
            return !1;
          });
          s && (f.type === "rule" && f.selectors.length > 1 ? (f.selectors.reverse().forEach(function(o) {
            var y = f.cloneAfter();
            return y.selector = o, y;
          }), f.remove()) : c.push(f));
        }
      }), c.forEach(function(f) {
        f.nodes.slice(0).forEach(function(s) {
          if (s.type === "decl") {
            var o = s;
            Fee(
              o,
              u,
              e.preserve,
              e.preserveAtRulesOrder,
              i
            );
          }
        });
      }), h.forEach($ee), n.forEach(function(f) {
        f.remove();
      });
    }
  };
};
Qg.exports.postcss = !0;
var Vee = Qg.exports;
const Wee = /* @__PURE__ */ gd(Vee);
Hr.stringify;
Hr.fromJSON;
Hr.plugin;
Hr.parse;
Hr.list;
Hr.document;
Hr.comment;
Hr.atRule;
Hr.rule;
Hr.decl;
Hr.root;
Hr.CssSyntaxError;
Hr.Declaration;
Hr.Container;
Hr.Processor;
Hr.Document;
Hr.Comment;
Hr.Warning;
Hr.AtRule;
Hr.Result;
Hr.Input;
Hr.Rule;
Hr.Root;
Hr.Node;
E7.__OXIDE__ = void 0;
function qee(t, e) {
  const r = e == null ? void 0 : e.corePlugins, a = {
    ...e,
    corePlugins: {
      preflight: !1,
      ...r
    }
  };
  return Hr([
    ZZ({
      ...a,
      content: [{ raw: t, extension: "html" }]
    }),
    Wee()
  ]).process(
    String.raw`
        @tailwind base;
        @tailwind components;
        @tailwind utilities;
      `,
    { from: void 0 }
    // no need to use from since the `content` context is sent into tailwind
  ).css;
}
function Hee(t) {
  return t.replace(
    /*      we need this look ahead capturing group to avoid using negative look behinds */
    /([^\\]|^)(?=([^\w\-]))/g,
    (e, r, a) => r === "" && a === "\\" ? e : `${r}\\`
  );
}
function Gee(t) {
  const e = {};
  for (const [r, a, l] of t.matchAll(
    /\s*\.([\S]+)\s*{([^}]*)}/gm
  ))
    e[a.trim()] = l.replace(/^\n+/, "").replace(/\n+$/, "").trim();
  return e;
}
const _te = _6({
  name: "Tailwind",
  props: {
    config: {
      type: Object,
      default: {},
      required: !1
    }
  },
  async setup(t, { slots: e }) {
    if (!e.default || !e.default())
      throw new Error("Tailwind component must have a default slot");
    const r = e.default();
    let a = [];
    const l = await S6(_v("div", r)).then((g) => g.replace(/^<div[^>]*>|<\/div>$/g, "")), h = v7(
      await qee(l, t.config || {})
    ).replaceAll(
      /@media\s*\(.*\)\s*{\s*\.(.*)\s*{[\s\S]*}\s*}/gm,
      (g, b) => (a.push(
        g.replace(/[\r\n|\r|\n]+/g, "").replace(/\s+/g, " ").replaceAll(/\s*\.[\S]+\s*{([^}]*)}/gm, (v, T) => v.replace(
          T,
          T.split(";").map(
            (E) => E.endsWith("!important") ? E.trim() : `${E.trim()}!important`
          ).join(";")
        ))
      ), "")
    ), n = Gee(h);
    a = a.filter((g) => g.trim().length > 0);
    const u = /<html[^>]*>/gm.test(l), i = /<head[^>]*>/gm.test(l);
    if (a.length > 0 && (!u || !i))
      throw new Error("Tailwind: To use responsive styles you must have a <Html> and <Head> element in your template.");
    const c = new J6(), f = new M6(c);
    f.write(l), f.end();
    const s = c.dom, o = E2((g) => g.name === "head", s);
    a.length > 0 && i && o && y7(o, {
      type: "tag",
      name: "style",
      children: [
        {
          type: "text",
          data: g7(a.join(""))
        }
      ]
    });
    const y = (g) => g.attribs && g.attribs.class;
    b7((g) => y(g), s).forEach((g) => {
      const b = g.attribs.style || "";
      if (g.attribs.class) {
        const T = g.attribs.class.split(" "), E = [], O = [];
        T.forEach((D) => {
          const $ = Hee(D);
          typeof n[$] > "u" ? E.push(D) : O.push(
            `${n[$]};`
          );
        }), E.length > 0 && (g.attribs.class = E.join(" ").trim()), O.length > 0 && (g.attribs.style = `${b} ${O.join(" ")}`.trim()), g.attribs.style === "" && delete g.attribs.style;
      }
    });
    const m = vy(s, {
      decodeEntities: !1,
      xmlMode: !0
    });
    return () => _v("tailwind-clean-component", { innerHTML: m });
  }
});
export {
  _te as Tailwind
};
