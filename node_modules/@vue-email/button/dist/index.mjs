// src/index.ts
import { computed, defineComponent, h } from "vue";

// src/utils/px-to-pt.ts
var pxToPt = (px) => typeof px === "number" && !isNaN(Number(px)) ? px * 3 / 4 : null;

// src/utils/parse-padding.ts
function convertToPx(value) {
  let px = 0;
  if (!value) {
    return px;
  }
  if (typeof value === "number") {
    return value;
  }
  const matches = /^([\d.]+)(px|em|rem|%)$/.exec(value);
  if (matches && matches.length === 3) {
    const numValue = parseFloat(matches[1]);
    const unit = matches[2];
    switch (unit) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  } else {
    return 0;
  }
}
function parsePadding({
  padding = "",
  paddingTop,
  paddingRight,
  paddingBottom,
  paddingLeft
}) {
  let pt = 0;
  let pr = 0;
  let pb = 0;
  let pl = 0;
  if (typeof padding === "number") {
    pt = padding;
    pr = padding;
    pb = padding;
    pl = padding;
  } else {
    const values = padding.split(/\s+/);
    switch (values.length) {
      case 1:
        pt = convertToPx(values[0]);
        pr = convertToPx(values[0]);
        pb = convertToPx(values[0]);
        pl = convertToPx(values[0]);
        break;
      case 2:
        pt = convertToPx(values[0]);
        pb = convertToPx(values[0]);
        pr = convertToPx(values[1]);
        pl = convertToPx(values[1]);
        break;
      case 3:
        pt = convertToPx(values[0]);
        pr = convertToPx(values[1]);
        pl = convertToPx(values[1]);
        pb = convertToPx(values[2]);
        break;
      case 4:
        pt = convertToPx(values[0]);
        pr = convertToPx(values[1]);
        pb = convertToPx(values[2]);
        pl = convertToPx(values[3]);
        break;
      default:
        break;
    }
  }
  return {
    pt: paddingTop ? convertToPx(paddingTop) : pt,
    pr: paddingRight ? convertToPx(paddingRight) : pr,
    pb: paddingBottom ? convertToPx(paddingBottom) : pb,
    pl: paddingLeft ? convertToPx(paddingLeft) : pl
  };
}

// src/index.ts
var buttonStyle = (style) => {
  const { pt, pr, pb, pl, ...rest } = style || {};
  return {
    lineHeight: "100%",
    textDecoration: "none",
    display: "inline-block",
    maxWidth: "100%",
    ...rest,
    padding: `${pt}px ${pr}px ${pb}px ${pl}px`
  };
};
var buttonTextStyle = (pb) => {
  return {
    maxWidth: "100%",
    display: "inline-block",
    lineHeight: "120%",
    msoPaddingAlt: "0px",
    msoTextRaise: pxToPt(pb || 0)
  };
};
var Button = defineComponent({
  name: "Button",
  setup(props, { slots }) {
    var _a, _b, _c, _d, _e;
    const styleObject = computed(() => {
      if (typeof props.style === "string" || Array.isArray(props.style)) {
        return {};
      }
      return props.style;
    });
    const { pt, pr, pb, pl } = parsePadding({
      padding: (_a = styleObject.value) == null ? void 0 : _a.padding,
      paddingLeft: (_b = styleObject.value) == null ? void 0 : _b.paddingLeft,
      paddingRight: (_c = styleObject.value) == null ? void 0 : _c.paddingRight,
      paddingTop: (_d = styleObject.value) == null ? void 0 : _d.paddingTop,
      paddingBottom: (_e = styleObject.value) == null ? void 0 : _e.paddingBottom
    });
    const y = pt + pb;
    const textRaise = pxToPt(y);
    const firstSpan = `<!--[if mso]><i style="letter-spacing: ${pl}px;mso-font-width:-100%;mso-text-raise:${textRaise}" hidden>&nbsp;</i><![endif]-->`;
    const secondSpan = `<!--[if mso]><i style="letter-spacing: ${pr}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`;
    return () => {
      var _a2;
      return h(
        "a",
        {
          "style": buttonStyle({
            ...props.style,
            pt,
            pr,
            pb,
            pl
          }),
          "href": props.href,
          "target": props.target
        },
        [
          h("span", { innerHTML: firstSpan }),
          h(
            "span",
            {
              style: buttonTextStyle(pb)
            },
            (_a2 = slots.default) == null ? void 0 : _a2.call(slots)
          ),
          h("span", { innerHTML: secondSpan })
        ]
      );
    };
  }
});
export {
  Button
};
