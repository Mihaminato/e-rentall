// src/shared/render.ts
import { renderToString } from "vue/server-renderer";
import { createSSRApp } from "vue";
import { convert } from "html-to-text";

// src/shared/utils/pretty.ts
import jsBeautify from "js-beautify";
var defaults = {
  unformatted: ["code", "pre", "em", "strong", "span"],
  indent_inner_html: true,
  indent_char: " ",
  indent_size: 2,
  sep: "\n"
};
var pretty = (str, options = {}) => {
  return jsBeautify.html(str, { ...defaults, ...options });
};

// src/shared/plain-text-selectors.ts
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "#__vue-email-preview", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];

// src/shared/utils/cleanup.ts
function cleanup(str) {
  if (!str || typeof str !== "string")
    return str;
  return str.replace(/ data-v-inspector="[^"]*"/g, "").replace(/<!--\[-->/g, "").replace(/<!--\]-->/g, "").replace(/<!--[\s\S]*?-->/g, "").replace(/<style>[\s\S]*?<\/style>/g, "").replace(/<script>[\s\S]*?<\/script>/g, "").replace(/<script[^>]*>[\s\S]*?<\/script>/g, "").replace(/<template>/g, "").replace(/<template[^>]*>/g, "").replace(/<\/template>/g, "").replace(/<tailwind-clean-component>/g, "").replace(/<tailwind-clean-component[^>]*>/g, "").replace(/<\/tailwind-clean-component>/g, "");
}

// src/shared/render.ts
async function render(component, props, options) {
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const App = createSSRApp(component, props || {});
  const markup = await renderToString(App);
  if (options == null ? void 0 : options.plainText) {
    return convert(markup, {
      selectors: plainTextSelectors,
      ...(options == null ? void 0 : options.plainText) === true ? options.htmlToTextOptions : {}
    });
  }
  const doc = `${doctype}${cleanup(markup)}`;
  if (options && options.pretty) {
    return pretty(doc);
  }
  return doc;
}
export {
  cleanup,
  plainTextSelectors,
  render
};
